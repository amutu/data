# 1 "<built-in>"
# 1 "./include/autoconf.h" 1
/*
 * Automatically generated C config: don't edit
 * Busybox version: 1.26.2
 */
#define AUTOCONF_TIMESTAMP "2017-07-16 16:15:57 CST"

#define CONFIG_HAVE_DOT_CONFIG 1
#define ENABLE_HAVE_DOT_CONFIG 1
#ifdef MAKE_SUID
# define IF_HAVE_DOT_CONFIG(...) __VA_ARGS__ "CONFIG_HAVE_DOT_CONFIG"
#else
# 12 "./include/autoconf.h"
# define IF_HAVE_DOT_CONFIG(...) __VA_ARGS__
#endif
# 14 "./include/autoconf.h"
#define IF_NOT_HAVE_DOT_CONFIG(...)

/*
 * Busybox Settings
 */
#undef CONFIG_DESKTOP
#define ENABLE_DESKTOP 0
#define IF_DESKTOP(...)
#define IF_NOT_DESKTOP(...) __VA_ARGS__
#undef CONFIG_EXTRA_COMPAT
#define ENABLE_EXTRA_COMPAT 0
#define IF_EXTRA_COMPAT(...)
#define IF_NOT_EXTRA_COMPAT(...) __VA_ARGS__
#define CONFIG_INCLUDE_SUSv2 1
#define ENABLE_INCLUDE_SUSv2 1
#ifdef MAKE_SUID
# define IF_INCLUDE_SUSv2(...) __VA_ARGS__ "CONFIG_INCLUDE_SUSv2"
#else
# 32 "./include/autoconf.h"
# define IF_INCLUDE_SUSv2(...) __VA_ARGS__
#endif
# 34 "./include/autoconf.h"
#define IF_NOT_INCLUDE_SUSv2(...)
#define CONFIG_USE_PORTABLE_CODE 1
#define ENABLE_USE_PORTABLE_CODE 1
#ifdef MAKE_SUID
# define IF_USE_PORTABLE_CODE(...) __VA_ARGS__ "CONFIG_USE_PORTABLE_CODE"
#else
# 40 "./include/autoconf.h"
# define IF_USE_PORTABLE_CODE(...) __VA_ARGS__
#endif
# 42 "./include/autoconf.h"
#define IF_NOT_USE_PORTABLE_CODE(...)
#define CONFIG_PLATFORM_LINUX 1
#define ENABLE_PLATFORM_LINUX 1
#ifdef MAKE_SUID
# define IF_PLATFORM_LINUX(...) __VA_ARGS__ "CONFIG_PLATFORM_LINUX"
#else
# 48 "./include/autoconf.h"
# define IF_PLATFORM_LINUX(...) __VA_ARGS__
#endif
# 50 "./include/autoconf.h"
#define IF_NOT_PLATFORM_LINUX(...)
#define CONFIG_SHOW_USAGE 1
#define ENABLE_SHOW_USAGE 1
#ifdef MAKE_SUID
# define IF_SHOW_USAGE(...) __VA_ARGS__ "CONFIG_SHOW_USAGE"
#else
# 56 "./include/autoconf.h"
# define IF_SHOW_USAGE(...) __VA_ARGS__
#endif
# 58 "./include/autoconf.h"
#define IF_NOT_SHOW_USAGE(...)
#define CONFIG_FEATURE_VERBOSE_USAGE 1
#define ENABLE_FEATURE_VERBOSE_USAGE 1
#ifdef MAKE_SUID
# define IF_FEATURE_VERBOSE_USAGE(...) __VA_ARGS__ "CONFIG_FEATURE_VERBOSE_USAGE"
#else
# 64 "./include/autoconf.h"
# define IF_FEATURE_VERBOSE_USAGE(...) __VA_ARGS__
#endif
# 66 "./include/autoconf.h"
#define IF_NOT_FEATURE_VERBOSE_USAGE(...)
#define CONFIG_FEATURE_COMPRESS_USAGE 1
#define ENABLE_FEATURE_COMPRESS_USAGE 1
#ifdef MAKE_SUID
# define IF_FEATURE_COMPRESS_USAGE(...) __VA_ARGS__ "CONFIG_FEATURE_COMPRESS_USAGE"
#else
# 72 "./include/autoconf.h"
# define IF_FEATURE_COMPRESS_USAGE(...) __VA_ARGS__
#endif
# 74 "./include/autoconf.h"
#define IF_NOT_FEATURE_COMPRESS_USAGE(...)
#undef CONFIG_BUSYBOX
#define ENABLE_BUSYBOX 0
#define IF_BUSYBOX(...)
#define IF_NOT_BUSYBOX(...) __VA_ARGS__
#undef CONFIG_FEATURE_INSTALLER
#define ENABLE_FEATURE_INSTALLER 0
#define IF_FEATURE_INSTALLER(...)
#define IF_NOT_FEATURE_INSTALLER(...) __VA_ARGS__
#undef CONFIG_INSTALL_NO_USR
#define ENABLE_INSTALL_NO_USR 0
#define IF_INSTALL_NO_USR(...)
#define IF_NOT_INSTALL_NO_USR(...) __VA_ARGS__
#undef CONFIG_PAM
#define ENABLE_PAM 0
#define IF_PAM(...)
#define IF_NOT_PAM(...) __VA_ARGS__
#define CONFIG_LONG_OPTS 1
#define ENABLE_LONG_OPTS 1
#ifdef MAKE_SUID
# define IF_LONG_OPTS(...) __VA_ARGS__ "CONFIG_LONG_OPTS"
#else
# 96 "./include/autoconf.h"
# define IF_LONG_OPTS(...) __VA_ARGS__
#endif
# 98 "./include/autoconf.h"
#define IF_NOT_LONG_OPTS(...)
#define CONFIG_FEATURE_DEVPTS 1
#define ENABLE_FEATURE_DEVPTS 1
#ifdef MAKE_SUID
# define IF_FEATURE_DEVPTS(...) __VA_ARGS__ "CONFIG_FEATURE_DEVPTS"
#else
# 104 "./include/autoconf.h"
# define IF_FEATURE_DEVPTS(...) __VA_ARGS__
#endif
# 106 "./include/autoconf.h"
#define IF_NOT_FEATURE_DEVPTS(...)
#undef CONFIG_FEATURE_CLEAN_UP
#define ENABLE_FEATURE_CLEAN_UP 0
#define IF_FEATURE_CLEAN_UP(...)
#define IF_NOT_FEATURE_CLEAN_UP(...) __VA_ARGS__
#undef CONFIG_FEATURE_UTMP
#define ENABLE_FEATURE_UTMP 0
#define IF_FEATURE_UTMP(...)
#define IF_NOT_FEATURE_UTMP(...) __VA_ARGS__
#undef CONFIG_FEATURE_WTMP
#define ENABLE_FEATURE_WTMP 0
#define IF_FEATURE_WTMP(...)
#define IF_NOT_FEATURE_WTMP(...) __VA_ARGS__
#define CONFIG_FEATURE_PIDFILE 1
#define ENABLE_FEATURE_PIDFILE 1
#ifdef MAKE_SUID
# define IF_FEATURE_PIDFILE(...) __VA_ARGS__ "CONFIG_FEATURE_PIDFILE"
#else
# 124 "./include/autoconf.h"
# define IF_FEATURE_PIDFILE(...) __VA_ARGS__
#endif
# 126 "./include/autoconf.h"
#define IF_NOT_FEATURE_PIDFILE(...)
#define CONFIG_PID_FILE_PATH "/var/run"
#define ENABLE_PID_FILE_PATH 1
#ifdef MAKE_SUID
# define IF_PID_FILE_PATH(...) __VA_ARGS__ "CONFIG_PID_FILE_PATH"
#else
# 132 "./include/autoconf.h"
# define IF_PID_FILE_PATH(...) __VA_ARGS__
#endif
# 134 "./include/autoconf.h"
#define IF_NOT_PID_FILE_PATH(...)
#define CONFIG_FEATURE_SUID 1
#define ENABLE_FEATURE_SUID 1
#ifdef MAKE_SUID
# define IF_FEATURE_SUID(...) __VA_ARGS__ "CONFIG_FEATURE_SUID"
#else
# 140 "./include/autoconf.h"
# define IF_FEATURE_SUID(...) __VA_ARGS__
#endif
# 142 "./include/autoconf.h"
#define IF_NOT_FEATURE_SUID(...)
#define CONFIG_FEATURE_SUID_CONFIG 1
#define ENABLE_FEATURE_SUID_CONFIG 1
#ifdef MAKE_SUID
# define IF_FEATURE_SUID_CONFIG(...) __VA_ARGS__ "CONFIG_FEATURE_SUID_CONFIG"
#else
# 148 "./include/autoconf.h"
# define IF_FEATURE_SUID_CONFIG(...) __VA_ARGS__
#endif
# 150 "./include/autoconf.h"
#define IF_NOT_FEATURE_SUID_CONFIG(...)
#define CONFIG_FEATURE_SUID_CONFIG_QUIET 1
#define ENABLE_FEATURE_SUID_CONFIG_QUIET 1
#ifdef MAKE_SUID
# define IF_FEATURE_SUID_CONFIG_QUIET(...) __VA_ARGS__ "CONFIG_FEATURE_SUID_CONFIG_QUIET"
#else
# 156 "./include/autoconf.h"
# define IF_FEATURE_SUID_CONFIG_QUIET(...) __VA_ARGS__
#endif
# 158 "./include/autoconf.h"
#define IF_NOT_FEATURE_SUID_CONFIG_QUIET(...)
#undef CONFIG_SELINUX
#define ENABLE_SELINUX 0
#define IF_SELINUX(...)
#define IF_NOT_SELINUX(...) __VA_ARGS__
#undef CONFIG_FEATURE_PREFER_APPLETS
#define ENABLE_FEATURE_PREFER_APPLETS 0
#define IF_FEATURE_PREFER_APPLETS(...)
#define IF_NOT_FEATURE_PREFER_APPLETS(...) __VA_ARGS__
#define CONFIG_BUSYBOX_EXEC_PATH "/proc/self/exe"
#define ENABLE_BUSYBOX_EXEC_PATH 1
#ifdef MAKE_SUID
# define IF_BUSYBOX_EXEC_PATH(...) __VA_ARGS__ "CONFIG_BUSYBOX_EXEC_PATH"
#else
# 172 "./include/autoconf.h"
# define IF_BUSYBOX_EXEC_PATH(...) __VA_ARGS__
#endif
# 174 "./include/autoconf.h"
#define IF_NOT_BUSYBOX_EXEC_PATH(...)
#define CONFIG_FEATURE_SYSLOG 1
#define ENABLE_FEATURE_SYSLOG 1
#ifdef MAKE_SUID
# define IF_FEATURE_SYSLOG(...) __VA_ARGS__ "CONFIG_FEATURE_SYSLOG"
#else
# 180 "./include/autoconf.h"
# define IF_FEATURE_SYSLOG(...) __VA_ARGS__
#endif
# 182 "./include/autoconf.h"
#define IF_NOT_FEATURE_SYSLOG(...)
#undef CONFIG_FEATURE_HAVE_RPC
#define ENABLE_FEATURE_HAVE_RPC 0
#define IF_FEATURE_HAVE_RPC(...)
#define IF_NOT_FEATURE_HAVE_RPC(...) __VA_ARGS__

/*
 * Build Options
 */
#undef CONFIG_STATIC
#define ENABLE_STATIC 0
#define IF_STATIC(...)
#define IF_NOT_STATIC(...) __VA_ARGS__
#undef CONFIG_PIE
#define ENABLE_PIE 0
#define IF_PIE(...)
#define IF_NOT_PIE(...) __VA_ARGS__
#undef CONFIG_NOMMU
#define ENABLE_NOMMU 0
#define IF_NOMMU(...)
#define IF_NOT_NOMMU(...) __VA_ARGS__
#undef CONFIG_BUILD_LIBBUSYBOX
#define ENABLE_BUILD_LIBBUSYBOX 0
#define IF_BUILD_LIBBUSYBOX(...)
#define IF_NOT_BUILD_LIBBUSYBOX(...) __VA_ARGS__
#undef CONFIG_FEATURE_INDIVIDUAL
#define ENABLE_FEATURE_INDIVIDUAL 0
#define IF_FEATURE_INDIVIDUAL(...)
#define IF_NOT_FEATURE_INDIVIDUAL(...) __VA_ARGS__
#undef CONFIG_FEATURE_SHARED_BUSYBOX
#define ENABLE_FEATURE_SHARED_BUSYBOX 0
#define IF_FEATURE_SHARED_BUSYBOX(...)
#define IF_NOT_FEATURE_SHARED_BUSYBOX(...) __VA_ARGS__
#define CONFIG_LFS 1
#define ENABLE_LFS 1
#ifdef MAKE_SUID
# define IF_LFS(...) __VA_ARGS__ "CONFIG_LFS"
#else
# 220 "./include/autoconf.h"
# define IF_LFS(...) __VA_ARGS__
#endif
# 222 "./include/autoconf.h"
#define IF_NOT_LFS(...)
#define CONFIG_CROSS_COMPILER_PREFIX ""
#define ENABLE_CROSS_COMPILER_PREFIX 1
#ifdef MAKE_SUID
# define IF_CROSS_COMPILER_PREFIX(...) __VA_ARGS__ "CONFIG_CROSS_COMPILER_PREFIX"
#else
# 228 "./include/autoconf.h"
# define IF_CROSS_COMPILER_PREFIX(...) __VA_ARGS__
#endif
# 230 "./include/autoconf.h"
#define IF_NOT_CROSS_COMPILER_PREFIX(...)
#define CONFIG_SYSROOT ""
#define ENABLE_SYSROOT 1
#ifdef MAKE_SUID
# define IF_SYSROOT(...) __VA_ARGS__ "CONFIG_SYSROOT"
#else
# 236 "./include/autoconf.h"
# define IF_SYSROOT(...) __VA_ARGS__
#endif
# 238 "./include/autoconf.h"
#define IF_NOT_SYSROOT(...)
#define CONFIG_EXTRA_CFLAGS ""
#define ENABLE_EXTRA_CFLAGS 1
#ifdef MAKE_SUID
# define IF_EXTRA_CFLAGS(...) __VA_ARGS__ "CONFIG_EXTRA_CFLAGS"
#else
# 244 "./include/autoconf.h"
# define IF_EXTRA_CFLAGS(...) __VA_ARGS__
#endif
# 246 "./include/autoconf.h"
#define IF_NOT_EXTRA_CFLAGS(...)
#define CONFIG_EXTRA_LDFLAGS ""
#define ENABLE_EXTRA_LDFLAGS 1
#ifdef MAKE_SUID
# define IF_EXTRA_LDFLAGS(...) __VA_ARGS__ "CONFIG_EXTRA_LDFLAGS"
#else
# 252 "./include/autoconf.h"
# define IF_EXTRA_LDFLAGS(...) __VA_ARGS__
#endif
# 254 "./include/autoconf.h"
#define IF_NOT_EXTRA_LDFLAGS(...)
#define CONFIG_EXTRA_LDLIBS ""
#define ENABLE_EXTRA_LDLIBS 1
#ifdef MAKE_SUID
# define IF_EXTRA_LDLIBS(...) __VA_ARGS__ "CONFIG_EXTRA_LDLIBS"
#else
# 260 "./include/autoconf.h"
# define IF_EXTRA_LDLIBS(...) __VA_ARGS__
#endif
# 262 "./include/autoconf.h"
#define IF_NOT_EXTRA_LDLIBS(...)

/*
 * Installation Options ("make install" behavior)
 */
#define CONFIG_INSTALL_APPLET_SYMLINKS 1
#define ENABLE_INSTALL_APPLET_SYMLINKS 1
#ifdef MAKE_SUID
# define IF_INSTALL_APPLET_SYMLINKS(...) __VA_ARGS__ "CONFIG_INSTALL_APPLET_SYMLINKS"
#else
# 272 "./include/autoconf.h"
# define IF_INSTALL_APPLET_SYMLINKS(...) __VA_ARGS__
#endif
# 274 "./include/autoconf.h"
#define IF_NOT_INSTALL_APPLET_SYMLINKS(...)
#undef CONFIG_INSTALL_APPLET_HARDLINKS
#define ENABLE_INSTALL_APPLET_HARDLINKS 0
#define IF_INSTALL_APPLET_HARDLINKS(...)
#define IF_NOT_INSTALL_APPLET_HARDLINKS(...) __VA_ARGS__
#undef CONFIG_INSTALL_APPLET_SCRIPT_WRAPPERS
#define ENABLE_INSTALL_APPLET_SCRIPT_WRAPPERS 0
#define IF_INSTALL_APPLET_SCRIPT_WRAPPERS(...)
#define IF_NOT_INSTALL_APPLET_SCRIPT_WRAPPERS(...) __VA_ARGS__
#undef CONFIG_INSTALL_APPLET_DONT
#define ENABLE_INSTALL_APPLET_DONT 0
#define IF_INSTALL_APPLET_DONT(...)
#define IF_NOT_INSTALL_APPLET_DONT(...) __VA_ARGS__
#undef CONFIG_INSTALL_SH_APPLET_SYMLINK
#define ENABLE_INSTALL_SH_APPLET_SYMLINK 0
#define IF_INSTALL_SH_APPLET_SYMLINK(...)
#define IF_NOT_INSTALL_SH_APPLET_SYMLINK(...) __VA_ARGS__
#undef CONFIG_INSTALL_SH_APPLET_HARDLINK
#define ENABLE_INSTALL_SH_APPLET_HARDLINK 0
#define IF_INSTALL_SH_APPLET_HARDLINK(...)
#define IF_NOT_INSTALL_SH_APPLET_HARDLINK(...) __VA_ARGS__
#undef CONFIG_INSTALL_SH_APPLET_SCRIPT_WRAPPER
#define ENABLE_INSTALL_SH_APPLET_SCRIPT_WRAPPER 0
#define IF_INSTALL_SH_APPLET_SCRIPT_WRAPPER(...)
#define IF_NOT_INSTALL_SH_APPLET_SCRIPT_WRAPPER(...) __VA_ARGS__
#define CONFIG_PREFIX "./_install"
#define ENABLE_PREFIX 1
#ifdef MAKE_SUID
# define IF_PREFIX(...) __VA_ARGS__ "CONFIG_PREFIX"
#else
# 304 "./include/autoconf.h"
# define IF_PREFIX(...) __VA_ARGS__
#endif
# 306 "./include/autoconf.h"
#define IF_NOT_PREFIX(...)

/*
 * Debugging Options
 */
#undef CONFIG_DEBUG
#define ENABLE_DEBUG 0
#define IF_DEBUG(...)
#define IF_NOT_DEBUG(...) __VA_ARGS__
#undef CONFIG_DEBUG_PESSIMIZE
#define ENABLE_DEBUG_PESSIMIZE 0
#define IF_DEBUG_PESSIMIZE(...)
#define IF_NOT_DEBUG_PESSIMIZE(...) __VA_ARGS__
#undef CONFIG_DEBUG_SANITIZE
#define ENABLE_DEBUG_SANITIZE 0
#define IF_DEBUG_SANITIZE(...)
#define IF_NOT_DEBUG_SANITIZE(...) __VA_ARGS__
#undef CONFIG_UNIT_TEST
#define ENABLE_UNIT_TEST 0
#define IF_UNIT_TEST(...)
#define IF_NOT_UNIT_TEST(...) __VA_ARGS__
#undef CONFIG_WERROR
#define ENABLE_WERROR 0
#define IF_WERROR(...)
#define IF_NOT_WERROR(...) __VA_ARGS__
#define CONFIG_NO_DEBUG_LIB 1
#define ENABLE_NO_DEBUG_LIB 1
#ifdef MAKE_SUID
# define IF_NO_DEBUG_LIB(...) __VA_ARGS__ "CONFIG_NO_DEBUG_LIB"
#else
# 336 "./include/autoconf.h"
# define IF_NO_DEBUG_LIB(...) __VA_ARGS__
#endif
# 338 "./include/autoconf.h"
#define IF_NOT_NO_DEBUG_LIB(...)
#undef CONFIG_DMALLOC
#define ENABLE_DMALLOC 0
#define IF_DMALLOC(...)
#define IF_NOT_DMALLOC(...) __VA_ARGS__
#undef CONFIG_EFENCE
#define ENABLE_EFENCE 0
#define IF_EFENCE(...)
#define IF_NOT_EFENCE(...) __VA_ARGS__

/*
 * Busybox Library Tuning
 */
#undef CONFIG_FEATURE_USE_BSS_TAIL
#define ENABLE_FEATURE_USE_BSS_TAIL 0
#define IF_FEATURE_USE_BSS_TAIL(...)
#define IF_NOT_FEATURE_USE_BSS_TAIL(...) __VA_ARGS__
#define CONFIG_FEATURE_RTMINMAX 1
#define ENABLE_FEATURE_RTMINMAX 1
#ifdef MAKE_SUID
# define IF_FEATURE_RTMINMAX(...) __VA_ARGS__ "CONFIG_FEATURE_RTMINMAX"
#else
# 360 "./include/autoconf.h"
# define IF_FEATURE_RTMINMAX(...) __VA_ARGS__
#endif
# 362 "./include/autoconf.h"
#define IF_NOT_FEATURE_RTMINMAX(...)
#define CONFIG_FEATURE_BUFFERS_USE_MALLOC 1
#define ENABLE_FEATURE_BUFFERS_USE_MALLOC 1
#ifdef MAKE_SUID
# define IF_FEATURE_BUFFERS_USE_MALLOC(...) __VA_ARGS__ "CONFIG_FEATURE_BUFFERS_USE_MALLOC"
#else
# 368 "./include/autoconf.h"
# define IF_FEATURE_BUFFERS_USE_MALLOC(...) __VA_ARGS__
#endif
# 370 "./include/autoconf.h"
#define IF_NOT_FEATURE_BUFFERS_USE_MALLOC(...)
#undef CONFIG_FEATURE_BUFFERS_GO_ON_STACK
#define ENABLE_FEATURE_BUFFERS_GO_ON_STACK 0
#define IF_FEATURE_BUFFERS_GO_ON_STACK(...)
#define IF_NOT_FEATURE_BUFFERS_GO_ON_STACK(...) __VA_ARGS__
#undef CONFIG_FEATURE_BUFFERS_GO_IN_BSS
#define ENABLE_FEATURE_BUFFERS_GO_IN_BSS 0
#define IF_FEATURE_BUFFERS_GO_IN_BSS(...)
#define IF_NOT_FEATURE_BUFFERS_GO_IN_BSS(...) __VA_ARGS__
#define CONFIG_PASSWORD_MINLEN 6
#define ENABLE_PASSWORD_MINLEN 1
#ifdef MAKE_SUID
# define IF_PASSWORD_MINLEN(...) __VA_ARGS__ "CONFIG_PASSWORD_MINLEN"
#else
# 384 "./include/autoconf.h"
# define IF_PASSWORD_MINLEN(...) __VA_ARGS__
#endif
# 386 "./include/autoconf.h"
#define IF_NOT_PASSWORD_MINLEN(...)
#define CONFIG_MD5_SMALL 1
#define ENABLE_MD5_SMALL 1
#ifdef MAKE_SUID
# define IF_MD5_SMALL(...) __VA_ARGS__ "CONFIG_MD5_SMALL"
#else
# 392 "./include/autoconf.h"
# define IF_MD5_SMALL(...) __VA_ARGS__
#endif
# 394 "./include/autoconf.h"
#define IF_NOT_MD5_SMALL(...)
#define CONFIG_SHA3_SMALL 1
#define ENABLE_SHA3_SMALL 1
#ifdef MAKE_SUID
# define IF_SHA3_SMALL(...) __VA_ARGS__ "CONFIG_SHA3_SMALL"
#else
# 400 "./include/autoconf.h"
# define IF_SHA3_SMALL(...) __VA_ARGS__
#endif
# 402 "./include/autoconf.h"
#define IF_NOT_SHA3_SMALL(...)
#define CONFIG_FEATURE_FAST_TOP 1
#define ENABLE_FEATURE_FAST_TOP 1
#ifdef MAKE_SUID
# define IF_FEATURE_FAST_TOP(...) __VA_ARGS__ "CONFIG_FEATURE_FAST_TOP"
#else
# 408 "./include/autoconf.h"
# define IF_FEATURE_FAST_TOP(...) __VA_ARGS__
#endif
# 410 "./include/autoconf.h"
#define IF_NOT_FEATURE_FAST_TOP(...)
#undef CONFIG_FEATURE_ETC_NETWORKS
#define ENABLE_FEATURE_ETC_NETWORKS 0
#define IF_FEATURE_ETC_NETWORKS(...)
#define IF_NOT_FEATURE_ETC_NETWORKS(...) __VA_ARGS__
#define CONFIG_FEATURE_USE_TERMIOS 1
#define ENABLE_FEATURE_USE_TERMIOS 1
#ifdef MAKE_SUID
# define IF_FEATURE_USE_TERMIOS(...) __VA_ARGS__ "CONFIG_FEATURE_USE_TERMIOS"
#else
# 420 "./include/autoconf.h"
# define IF_FEATURE_USE_TERMIOS(...) __VA_ARGS__
#endif
# 422 "./include/autoconf.h"
#define IF_NOT_FEATURE_USE_TERMIOS(...)
#define CONFIG_FEATURE_EDITING 1
#define ENABLE_FEATURE_EDITING 1
#ifdef MAKE_SUID
# define IF_FEATURE_EDITING(...) __VA_ARGS__ "CONFIG_FEATURE_EDITING"
#else
# 428 "./include/autoconf.h"
# define IF_FEATURE_EDITING(...) __VA_ARGS__
#endif
# 430 "./include/autoconf.h"
#define IF_NOT_FEATURE_EDITING(...)
#define CONFIG_FEATURE_EDITING_MAX_LEN 1024
#define ENABLE_FEATURE_EDITING_MAX_LEN 1
#ifdef MAKE_SUID
# define IF_FEATURE_EDITING_MAX_LEN(...) __VA_ARGS__ "CONFIG_FEATURE_EDITING_MAX_LEN"
#else
# 436 "./include/autoconf.h"
# define IF_FEATURE_EDITING_MAX_LEN(...) __VA_ARGS__
#endif
# 438 "./include/autoconf.h"
#define IF_NOT_FEATURE_EDITING_MAX_LEN(...)
#undef CONFIG_FEATURE_EDITING_VI
#define ENABLE_FEATURE_EDITING_VI 0
#define IF_FEATURE_EDITING_VI(...)
#define IF_NOT_FEATURE_EDITING_VI(...) __VA_ARGS__
#define CONFIG_FEATURE_EDITING_HISTORY 30
#define ENABLE_FEATURE_EDITING_HISTORY 1
#ifdef MAKE_SUID
# define IF_FEATURE_EDITING_HISTORY(...) __VA_ARGS__ "CONFIG_FEATURE_EDITING_HISTORY"
#else
# 448 "./include/autoconf.h"
# define IF_FEATURE_EDITING_HISTORY(...) __VA_ARGS__
#endif
# 450 "./include/autoconf.h"
#define IF_NOT_FEATURE_EDITING_HISTORY(...)
#undef CONFIG_FEATURE_EDITING_SAVEHISTORY
#define ENABLE_FEATURE_EDITING_SAVEHISTORY 0
#define IF_FEATURE_EDITING_SAVEHISTORY(...)
#define IF_NOT_FEATURE_EDITING_SAVEHISTORY(...) __VA_ARGS__
#undef CONFIG_FEATURE_EDITING_SAVE_ON_EXIT
#define ENABLE_FEATURE_EDITING_SAVE_ON_EXIT 0
#define IF_FEATURE_EDITING_SAVE_ON_EXIT(...)
#define IF_NOT_FEATURE_EDITING_SAVE_ON_EXIT(...) __VA_ARGS__
#undef CONFIG_FEATURE_REVERSE_SEARCH
#define ENABLE_FEATURE_REVERSE_SEARCH 0
#define IF_FEATURE_REVERSE_SEARCH(...)
#define IF_NOT_FEATURE_REVERSE_SEARCH(...) __VA_ARGS__
#define CONFIG_FEATURE_TAB_COMPLETION 1
#define ENABLE_FEATURE_TAB_COMPLETION 1
#ifdef MAKE_SUID
# define IF_FEATURE_TAB_COMPLETION(...) __VA_ARGS__ "CONFIG_FEATURE_TAB_COMPLETION"
#else
# 468 "./include/autoconf.h"
# define IF_FEATURE_TAB_COMPLETION(...) __VA_ARGS__
#endif
# 470 "./include/autoconf.h"
#define IF_NOT_FEATURE_TAB_COMPLETION(...)
#undef CONFIG_FEATURE_USERNAME_COMPLETION
#define ENABLE_FEATURE_USERNAME_COMPLETION 0
#define IF_FEATURE_USERNAME_COMPLETION(...)
#define IF_NOT_FEATURE_USERNAME_COMPLETION(...) __VA_ARGS__
#undef CONFIG_FEATURE_EDITING_FANCY_PROMPT
#define ENABLE_FEATURE_EDITING_FANCY_PROMPT 0
#define IF_FEATURE_EDITING_FANCY_PROMPT(...)
#define IF_NOT_FEATURE_EDITING_FANCY_PROMPT(...) __VA_ARGS__
#undef CONFIG_FEATURE_EDITING_ASK_TERMINAL
#define ENABLE_FEATURE_EDITING_ASK_TERMINAL 0
#define IF_FEATURE_EDITING_ASK_TERMINAL(...)
#define IF_NOT_FEATURE_EDITING_ASK_TERMINAL(...) __VA_ARGS__
#define CONFIG_LOCALE_SUPPORT 1
#define ENABLE_LOCALE_SUPPORT 1
#ifdef MAKE_SUID
# define IF_LOCALE_SUPPORT(...) __VA_ARGS__ "CONFIG_LOCALE_SUPPORT"
#else
# 488 "./include/autoconf.h"
# define IF_LOCALE_SUPPORT(...) __VA_ARGS__
#endif
# 490 "./include/autoconf.h"
#define IF_NOT_LOCALE_SUPPORT(...)
#define CONFIG_UNICODE_SUPPORT 1
#define ENABLE_UNICODE_SUPPORT 1
#ifdef MAKE_SUID
# define IF_UNICODE_SUPPORT(...) __VA_ARGS__ "CONFIG_UNICODE_SUPPORT"
#else
# 496 "./include/autoconf.h"
# define IF_UNICODE_SUPPORT(...) __VA_ARGS__
#endif
# 498 "./include/autoconf.h"
#define IF_NOT_UNICODE_SUPPORT(...)
#undef CONFIG_UNICODE_USING_LOCALE
#define ENABLE_UNICODE_USING_LOCALE 0
#define IF_UNICODE_USING_LOCALE(...)
#define IF_NOT_UNICODE_USING_LOCALE(...) __VA_ARGS__
#undef CONFIG_FEATURE_CHECK_UNICODE_IN_ENV
#define ENABLE_FEATURE_CHECK_UNICODE_IN_ENV 0
#define IF_FEATURE_CHECK_UNICODE_IN_ENV(...)
#define IF_NOT_FEATURE_CHECK_UNICODE_IN_ENV(...) __VA_ARGS__
#define CONFIG_SUBST_WCHAR 63
#define ENABLE_SUBST_WCHAR 1
#ifdef MAKE_SUID
# define IF_SUBST_WCHAR(...) __VA_ARGS__ "CONFIG_SUBST_WCHAR"
#else
# 512 "./include/autoconf.h"
# define IF_SUBST_WCHAR(...) __VA_ARGS__
#endif
# 514 "./include/autoconf.h"
#define IF_NOT_SUBST_WCHAR(...)
#define CONFIG_LAST_SUPPORTED_WCHAR 767
#define ENABLE_LAST_SUPPORTED_WCHAR 1
#ifdef MAKE_SUID
# define IF_LAST_SUPPORTED_WCHAR(...) __VA_ARGS__ "CONFIG_LAST_SUPPORTED_WCHAR"
#else
# 520 "./include/autoconf.h"
# define IF_LAST_SUPPORTED_WCHAR(...) __VA_ARGS__
#endif
# 522 "./include/autoconf.h"
#define IF_NOT_LAST_SUPPORTED_WCHAR(...)
#undef CONFIG_UNICODE_COMBINING_WCHARS
#define ENABLE_UNICODE_COMBINING_WCHARS 0
#define IF_UNICODE_COMBINING_WCHARS(...)
#define IF_NOT_UNICODE_COMBINING_WCHARS(...) __VA_ARGS__
#undef CONFIG_UNICODE_WIDE_WCHARS
#define ENABLE_UNICODE_WIDE_WCHARS 0
#define IF_UNICODE_WIDE_WCHARS(...)
#define IF_NOT_UNICODE_WIDE_WCHARS(...) __VA_ARGS__
#undef CONFIG_UNICODE_BIDI_SUPPORT
#define ENABLE_UNICODE_BIDI_SUPPORT 0
#define IF_UNICODE_BIDI_SUPPORT(...)
#define IF_NOT_UNICODE_BIDI_SUPPORT(...) __VA_ARGS__
#undef CONFIG_UNICODE_NEUTRAL_TABLE
#define ENABLE_UNICODE_NEUTRAL_TABLE 0
#define IF_UNICODE_NEUTRAL_TABLE(...)
#define IF_NOT_UNICODE_NEUTRAL_TABLE(...) __VA_ARGS__
#undef CONFIG_UNICODE_PRESERVE_BROKEN
#define ENABLE_UNICODE_PRESERVE_BROKEN 0
#define IF_UNICODE_PRESERVE_BROKEN(...)
#define IF_NOT_UNICODE_PRESERVE_BROKEN(...) __VA_ARGS__
#define CONFIG_FEATURE_NON_POSIX_CP 1
#define ENABLE_FEATURE_NON_POSIX_CP 1
#ifdef MAKE_SUID
# define IF_FEATURE_NON_POSIX_CP(...) __VA_ARGS__ "CONFIG_FEATURE_NON_POSIX_CP"
#else
# 548 "./include/autoconf.h"
# define IF_FEATURE_NON_POSIX_CP(...) __VA_ARGS__
#endif
# 550 "./include/autoconf.h"
#define IF_NOT_FEATURE_NON_POSIX_CP(...)
#undef CONFIG_FEATURE_VERBOSE_CP_MESSAGE
#define ENABLE_FEATURE_VERBOSE_CP_MESSAGE 0
#define IF_FEATURE_VERBOSE_CP_MESSAGE(...)
#define IF_NOT_FEATURE_VERBOSE_CP_MESSAGE(...) __VA_ARGS__
#undef CONFIG_FEATURE_USE_SENDFILE
#define ENABLE_FEATURE_USE_SENDFILE 0
#define IF_FEATURE_USE_SENDFILE(...)
#define IF_NOT_FEATURE_USE_SENDFILE(...) __VA_ARGS__
#define CONFIG_FEATURE_COPYBUF_KB 4
#define ENABLE_FEATURE_COPYBUF_KB 1
#ifdef MAKE_SUID
# define IF_FEATURE_COPYBUF_KB(...) __VA_ARGS__ "CONFIG_FEATURE_COPYBUF_KB"
#else
# 564 "./include/autoconf.h"
# define IF_FEATURE_COPYBUF_KB(...) __VA_ARGS__
#endif
# 566 "./include/autoconf.h"
#define IF_NOT_FEATURE_COPYBUF_KB(...)
#undef CONFIG_FEATURE_SKIP_ROOTFS
#define ENABLE_FEATURE_SKIP_ROOTFS 0
#define IF_FEATURE_SKIP_ROOTFS(...)
#define IF_NOT_FEATURE_SKIP_ROOTFS(...) __VA_ARGS__
#undef CONFIG_MONOTONIC_SYSCALL
#define ENABLE_MONOTONIC_SYSCALL 0
#define IF_MONOTONIC_SYSCALL(...)
#define IF_NOT_MONOTONIC_SYSCALL(...) __VA_ARGS__
#define CONFIG_IOCTL_HEX2STR_ERROR 1
#define ENABLE_IOCTL_HEX2STR_ERROR 1
#ifdef MAKE_SUID
# define IF_IOCTL_HEX2STR_ERROR(...) __VA_ARGS__ "CONFIG_IOCTL_HEX2STR_ERROR"
#else
# 580 "./include/autoconf.h"
# define IF_IOCTL_HEX2STR_ERROR(...) __VA_ARGS__
#endif
# 582 "./include/autoconf.h"
#define IF_NOT_IOCTL_HEX2STR_ERROR(...)
#define CONFIG_FEATURE_HWIB 1
#define ENABLE_FEATURE_HWIB 1
#ifdef MAKE_SUID
# define IF_FEATURE_HWIB(...) __VA_ARGS__ "CONFIG_FEATURE_HWIB"
#else
# 588 "./include/autoconf.h"
# define IF_FEATURE_HWIB(...) __VA_ARGS__
#endif
# 590 "./include/autoconf.h"
#define IF_NOT_FEATURE_HWIB(...)

/*
 * Applets
 */

/*
 * Archival Utilities
 */
#define CONFIG_FEATURE_SEAMLESS_XZ 1
#define ENABLE_FEATURE_SEAMLESS_XZ 1
#ifdef MAKE_SUID
# define IF_FEATURE_SEAMLESS_XZ(...) __VA_ARGS__ "CONFIG_FEATURE_SEAMLESS_XZ"
#else
# 604 "./include/autoconf.h"
# define IF_FEATURE_SEAMLESS_XZ(...) __VA_ARGS__
#endif
# 606 "./include/autoconf.h"
#define IF_NOT_FEATURE_SEAMLESS_XZ(...)
#define CONFIG_FEATURE_SEAMLESS_LZMA 1
#define ENABLE_FEATURE_SEAMLESS_LZMA 1
#ifdef MAKE_SUID
# define IF_FEATURE_SEAMLESS_LZMA(...) __VA_ARGS__ "CONFIG_FEATURE_SEAMLESS_LZMA"
#else
# 612 "./include/autoconf.h"
# define IF_FEATURE_SEAMLESS_LZMA(...) __VA_ARGS__
#endif
# 614 "./include/autoconf.h"
#define IF_NOT_FEATURE_SEAMLESS_LZMA(...)
#define CONFIG_FEATURE_SEAMLESS_BZ2 1
#define ENABLE_FEATURE_SEAMLESS_BZ2 1
#ifdef MAKE_SUID
# define IF_FEATURE_SEAMLESS_BZ2(...) __VA_ARGS__ "CONFIG_FEATURE_SEAMLESS_BZ2"
#else
# 620 "./include/autoconf.h"
# define IF_FEATURE_SEAMLESS_BZ2(...) __VA_ARGS__
#endif
# 622 "./include/autoconf.h"
#define IF_NOT_FEATURE_SEAMLESS_BZ2(...)
#define CONFIG_FEATURE_SEAMLESS_GZ 1
#define ENABLE_FEATURE_SEAMLESS_GZ 1
#ifdef MAKE_SUID
# define IF_FEATURE_SEAMLESS_GZ(...) __VA_ARGS__ "CONFIG_FEATURE_SEAMLESS_GZ"
#else
# 628 "./include/autoconf.h"
# define IF_FEATURE_SEAMLESS_GZ(...) __VA_ARGS__
#endif
# 630 "./include/autoconf.h"
#define IF_NOT_FEATURE_SEAMLESS_GZ(...)
#define CONFIG_FEATURE_SEAMLESS_Z 1
#define ENABLE_FEATURE_SEAMLESS_Z 1
#ifdef MAKE_SUID
# define IF_FEATURE_SEAMLESS_Z(...) __VA_ARGS__ "CONFIG_FEATURE_SEAMLESS_Z"
#else
# 636 "./include/autoconf.h"
# define IF_FEATURE_SEAMLESS_Z(...) __VA_ARGS__
#endif
# 638 "./include/autoconf.h"
#define IF_NOT_FEATURE_SEAMLESS_Z(...)
#define CONFIG_AR 1
#define ENABLE_AR 1
#ifdef MAKE_SUID
# define IF_AR(...) __VA_ARGS__ "CONFIG_AR"
#else
# 644 "./include/autoconf.h"
# define IF_AR(...) __VA_ARGS__
#endif
# 646 "./include/autoconf.h"
#define IF_NOT_AR(...)
#define CONFIG_FEATURE_AR_LONG_FILENAMES 1
#define ENABLE_FEATURE_AR_LONG_FILENAMES 1
#ifdef MAKE_SUID
# define IF_FEATURE_AR_LONG_FILENAMES(...) __VA_ARGS__ "CONFIG_FEATURE_AR_LONG_FILENAMES"
#else
# 652 "./include/autoconf.h"
# define IF_FEATURE_AR_LONG_FILENAMES(...) __VA_ARGS__
#endif
# 654 "./include/autoconf.h"
#define IF_NOT_FEATURE_AR_LONG_FILENAMES(...)
#define CONFIG_FEATURE_AR_CREATE 1
#define ENABLE_FEATURE_AR_CREATE 1
#ifdef MAKE_SUID
# define IF_FEATURE_AR_CREATE(...) __VA_ARGS__ "CONFIG_FEATURE_AR_CREATE"
#else
# 660 "./include/autoconf.h"
# define IF_FEATURE_AR_CREATE(...) __VA_ARGS__
#endif
# 662 "./include/autoconf.h"
#define IF_NOT_FEATURE_AR_CREATE(...)
#define CONFIG_UNCOMPRESS 1
#define ENABLE_UNCOMPRESS 1
#ifdef MAKE_SUID
# define IF_UNCOMPRESS(...) __VA_ARGS__ "CONFIG_UNCOMPRESS"
#else
# 668 "./include/autoconf.h"
# define IF_UNCOMPRESS(...) __VA_ARGS__
#endif
# 670 "./include/autoconf.h"
#define IF_NOT_UNCOMPRESS(...)
#define CONFIG_GUNZIP 1
#define ENABLE_GUNZIP 1
#ifdef MAKE_SUID
# define IF_GUNZIP(...) __VA_ARGS__ "CONFIG_GUNZIP"
#else
# 676 "./include/autoconf.h"
# define IF_GUNZIP(...) __VA_ARGS__
#endif
# 678 "./include/autoconf.h"
#define IF_NOT_GUNZIP(...)
#undef CONFIG_ZCAT
#define ENABLE_ZCAT 0
#define IF_ZCAT(...)
#define IF_NOT_ZCAT(...) __VA_ARGS__
#undef CONFIG_FEATURE_GUNZIP_LONG_OPTIONS
#define ENABLE_FEATURE_GUNZIP_LONG_OPTIONS 0
#define IF_FEATURE_GUNZIP_LONG_OPTIONS(...)
#define IF_NOT_FEATURE_GUNZIP_LONG_OPTIONS(...) __VA_ARGS__
#define CONFIG_BUNZIP2 1
#define ENABLE_BUNZIP2 1
#ifdef MAKE_SUID
# define IF_BUNZIP2(...) __VA_ARGS__ "CONFIG_BUNZIP2"
#else
# 692 "./include/autoconf.h"
# define IF_BUNZIP2(...) __VA_ARGS__
#endif
# 694 "./include/autoconf.h"
#define IF_NOT_BUNZIP2(...)
#undef CONFIG_BZCAT
#define ENABLE_BZCAT 0
#define IF_BZCAT(...)
#define IF_NOT_BZCAT(...) __VA_ARGS__
#define CONFIG_UNLZMA 1
#define ENABLE_UNLZMA 1
#ifdef MAKE_SUID
# define IF_UNLZMA(...) __VA_ARGS__ "CONFIG_UNLZMA"
#else
# 704 "./include/autoconf.h"
# define IF_UNLZMA(...) __VA_ARGS__
#endif
# 706 "./include/autoconf.h"
#define IF_NOT_UNLZMA(...)
#undef CONFIG_LZCAT
#define ENABLE_LZCAT 0
#define IF_LZCAT(...)
#define IF_NOT_LZCAT(...) __VA_ARGS__
#define CONFIG_LZMA 1
#define ENABLE_LZMA 1
#ifdef MAKE_SUID
# define IF_LZMA(...) __VA_ARGS__ "CONFIG_LZMA"
#else
# 716 "./include/autoconf.h"
# define IF_LZMA(...) __VA_ARGS__
#endif
# 718 "./include/autoconf.h"
#define IF_NOT_LZMA(...)
#define CONFIG_FEATURE_LZMA_FAST 1
#define ENABLE_FEATURE_LZMA_FAST 1
#ifdef MAKE_SUID
# define IF_FEATURE_LZMA_FAST(...) __VA_ARGS__ "CONFIG_FEATURE_LZMA_FAST"
#else
# 724 "./include/autoconf.h"
# define IF_FEATURE_LZMA_FAST(...) __VA_ARGS__
#endif
# 726 "./include/autoconf.h"
#define IF_NOT_FEATURE_LZMA_FAST(...)
#define CONFIG_UNXZ 1
#define ENABLE_UNXZ 1
#ifdef MAKE_SUID
# define IF_UNXZ(...) __VA_ARGS__ "CONFIG_UNXZ"
#else
# 732 "./include/autoconf.h"
# define IF_UNXZ(...) __VA_ARGS__
#endif
# 734 "./include/autoconf.h"
#define IF_NOT_UNXZ(...)
#undef CONFIG_XZCAT
#define ENABLE_XZCAT 0
#define IF_XZCAT(...)
#define IF_NOT_XZCAT(...) __VA_ARGS__
#define CONFIG_XZ 1
#define ENABLE_XZ 1
#ifdef MAKE_SUID
# define IF_XZ(...) __VA_ARGS__ "CONFIG_XZ"
#else
# 744 "./include/autoconf.h"
# define IF_XZ(...) __VA_ARGS__
#endif
# 746 "./include/autoconf.h"
#define IF_NOT_XZ(...)
#define CONFIG_BZIP2 1
#define ENABLE_BZIP2 1
#ifdef MAKE_SUID
# define IF_BZIP2(...) __VA_ARGS__ "CONFIG_BZIP2"
#else
# 752 "./include/autoconf.h"
# define IF_BZIP2(...) __VA_ARGS__
#endif
# 754 "./include/autoconf.h"
#define IF_NOT_BZIP2(...)
#define CONFIG_CPIO 1
#define ENABLE_CPIO 1
#ifdef MAKE_SUID
# define IF_CPIO(...) __VA_ARGS__ "CONFIG_CPIO"
#else
# 760 "./include/autoconf.h"
# define IF_CPIO(...) __VA_ARGS__
#endif
# 762 "./include/autoconf.h"
#define IF_NOT_CPIO(...)
#undef CONFIG_FEATURE_CPIO_O
#define ENABLE_FEATURE_CPIO_O 0
#define IF_FEATURE_CPIO_O(...)
#define IF_NOT_FEATURE_CPIO_O(...) __VA_ARGS__
#undef CONFIG_FEATURE_CPIO_P
#define ENABLE_FEATURE_CPIO_P 0
#define IF_FEATURE_CPIO_P(...)
#define IF_NOT_FEATURE_CPIO_P(...) __VA_ARGS__
#undef CONFIG_DPKG
#define ENABLE_DPKG 0
#define IF_DPKG(...)
#define IF_NOT_DPKG(...) __VA_ARGS__
#undef CONFIG_DPKG_DEB
#define ENABLE_DPKG_DEB 0
#define IF_DPKG_DEB(...)
#define IF_NOT_DPKG_DEB(...) __VA_ARGS__
#define CONFIG_GZIP 1
#define ENABLE_GZIP 1
#ifdef MAKE_SUID
# define IF_GZIP(...) __VA_ARGS__ "CONFIG_GZIP"
#else
# 784 "./include/autoconf.h"
# define IF_GZIP(...) __VA_ARGS__
#endif
# 786 "./include/autoconf.h"
#define IF_NOT_GZIP(...)
#define CONFIG_FEATURE_GZIP_LONG_OPTIONS 1
#define ENABLE_FEATURE_GZIP_LONG_OPTIONS 1
#ifdef MAKE_SUID
# define IF_FEATURE_GZIP_LONG_OPTIONS(...) __VA_ARGS__ "CONFIG_FEATURE_GZIP_LONG_OPTIONS"
#else
# 792 "./include/autoconf.h"
# define IF_FEATURE_GZIP_LONG_OPTIONS(...) __VA_ARGS__
#endif
# 794 "./include/autoconf.h"
#define IF_NOT_FEATURE_GZIP_LONG_OPTIONS(...)
#define CONFIG_GZIP_FAST 0
#define ENABLE_GZIP_FAST 1
#ifdef MAKE_SUID
# define IF_GZIP_FAST(...) __VA_ARGS__ "CONFIG_GZIP_FAST"
#else
# 800 "./include/autoconf.h"
# define IF_GZIP_FAST(...) __VA_ARGS__
#endif
# 802 "./include/autoconf.h"
#define IF_NOT_GZIP_FAST(...)
#undef CONFIG_FEATURE_GZIP_LEVELS
#define ENABLE_FEATURE_GZIP_LEVELS 0
#define IF_FEATURE_GZIP_LEVELS(...)
#define IF_NOT_FEATURE_GZIP_LEVELS(...) __VA_ARGS__
#define CONFIG_LZOP 1
#define ENABLE_LZOP 1
#ifdef MAKE_SUID
# define IF_LZOP(...) __VA_ARGS__ "CONFIG_LZOP"
#else
# 812 "./include/autoconf.h"
# define IF_LZOP(...) __VA_ARGS__
#endif
# 814 "./include/autoconf.h"
#define IF_NOT_LZOP(...)
#undef CONFIG_UNLZOP
#define ENABLE_UNLZOP 0
#define IF_UNLZOP(...)
#define IF_NOT_UNLZOP(...) __VA_ARGS__
#undef CONFIG_LZOPCAT
#define ENABLE_LZOPCAT 0
#define IF_LZOPCAT(...)
#define IF_NOT_LZOPCAT(...) __VA_ARGS__
#undef CONFIG_LZOP_COMPR_HIGH
#define ENABLE_LZOP_COMPR_HIGH 0
#define IF_LZOP_COMPR_HIGH(...)
#define IF_NOT_LZOP_COMPR_HIGH(...) __VA_ARGS__
#define CONFIG_RPM 1
#define ENABLE_RPM 1
#ifdef MAKE_SUID
# define IF_RPM(...) __VA_ARGS__ "CONFIG_RPM"
#else
# 832 "./include/autoconf.h"
# define IF_RPM(...) __VA_ARGS__
#endif
# 834 "./include/autoconf.h"
#define IF_NOT_RPM(...)
#define CONFIG_RPM2CPIO 1
#define ENABLE_RPM2CPIO 1
#ifdef MAKE_SUID
# define IF_RPM2CPIO(...) __VA_ARGS__ "CONFIG_RPM2CPIO"
#else
# 840 "./include/autoconf.h"
# define IF_RPM2CPIO(...) __VA_ARGS__
#endif
# 842 "./include/autoconf.h"
#define IF_NOT_RPM2CPIO(...)
#define CONFIG_TAR 1
#define ENABLE_TAR 1
#ifdef MAKE_SUID
# define IF_TAR(...) __VA_ARGS__ "CONFIG_TAR"
#else
# 848 "./include/autoconf.h"
# define IF_TAR(...) __VA_ARGS__
#endif
# 850 "./include/autoconf.h"
#define IF_NOT_TAR(...)
#define CONFIG_FEATURE_TAR_CREATE 1
#define ENABLE_FEATURE_TAR_CREATE 1
#ifdef MAKE_SUID
# define IF_FEATURE_TAR_CREATE(...) __VA_ARGS__ "CONFIG_FEATURE_TAR_CREATE"
#else
# 856 "./include/autoconf.h"
# define IF_FEATURE_TAR_CREATE(...) __VA_ARGS__
#endif
# 858 "./include/autoconf.h"
#define IF_NOT_FEATURE_TAR_CREATE(...)
#define CONFIG_FEATURE_TAR_AUTODETECT 1
#define ENABLE_FEATURE_TAR_AUTODETECT 1
#ifdef MAKE_SUID
# define IF_FEATURE_TAR_AUTODETECT(...) __VA_ARGS__ "CONFIG_FEATURE_TAR_AUTODETECT"
#else
# 864 "./include/autoconf.h"
# define IF_FEATURE_TAR_AUTODETECT(...) __VA_ARGS__
#endif
# 866 "./include/autoconf.h"
#define IF_NOT_FEATURE_TAR_AUTODETECT(...)
#define CONFIG_FEATURE_TAR_FROM 1
#define ENABLE_FEATURE_TAR_FROM 1
#ifdef MAKE_SUID
# define IF_FEATURE_TAR_FROM(...) __VA_ARGS__ "CONFIG_FEATURE_TAR_FROM"
#else
# 872 "./include/autoconf.h"
# define IF_FEATURE_TAR_FROM(...) __VA_ARGS__
#endif
# 874 "./include/autoconf.h"
#define IF_NOT_FEATURE_TAR_FROM(...)
#define CONFIG_FEATURE_TAR_OLDGNU_COMPATIBILITY 1
#define ENABLE_FEATURE_TAR_OLDGNU_COMPATIBILITY 1
#ifdef MAKE_SUID
# define IF_FEATURE_TAR_OLDGNU_COMPATIBILITY(...) __VA_ARGS__ "CONFIG_FEATURE_TAR_OLDGNU_COMPATIBILITY"
#else
# 880 "./include/autoconf.h"
# define IF_FEATURE_TAR_OLDGNU_COMPATIBILITY(...) __VA_ARGS__
#endif
# 882 "./include/autoconf.h"
#define IF_NOT_FEATURE_TAR_OLDGNU_COMPATIBILITY(...)
#define CONFIG_FEATURE_TAR_OLDSUN_COMPATIBILITY 1
#define ENABLE_FEATURE_TAR_OLDSUN_COMPATIBILITY 1
#ifdef MAKE_SUID
# define IF_FEATURE_TAR_OLDSUN_COMPATIBILITY(...) __VA_ARGS__ "CONFIG_FEATURE_TAR_OLDSUN_COMPATIBILITY"
#else
# 888 "./include/autoconf.h"
# define IF_FEATURE_TAR_OLDSUN_COMPATIBILITY(...) __VA_ARGS__
#endif
# 890 "./include/autoconf.h"
#define IF_NOT_FEATURE_TAR_OLDSUN_COMPATIBILITY(...)
#define CONFIG_FEATURE_TAR_GNU_EXTENSIONS 1
#define ENABLE_FEATURE_TAR_GNU_EXTENSIONS 1
#ifdef MAKE_SUID
# define IF_FEATURE_TAR_GNU_EXTENSIONS(...) __VA_ARGS__ "CONFIG_FEATURE_TAR_GNU_EXTENSIONS"
#else
# 896 "./include/autoconf.h"
# define IF_FEATURE_TAR_GNU_EXTENSIONS(...) __VA_ARGS__
#endif
# 898 "./include/autoconf.h"
#define IF_NOT_FEATURE_TAR_GNU_EXTENSIONS(...)
#define CONFIG_FEATURE_TAR_LONG_OPTIONS 1
#define ENABLE_FEATURE_TAR_LONG_OPTIONS 1
#ifdef MAKE_SUID
# define IF_FEATURE_TAR_LONG_OPTIONS(...) __VA_ARGS__ "CONFIG_FEATURE_TAR_LONG_OPTIONS"
#else
# 904 "./include/autoconf.h"
# define IF_FEATURE_TAR_LONG_OPTIONS(...) __VA_ARGS__
#endif
# 906 "./include/autoconf.h"
#define IF_NOT_FEATURE_TAR_LONG_OPTIONS(...)
#define CONFIG_FEATURE_TAR_TO_COMMAND 1
#define ENABLE_FEATURE_TAR_TO_COMMAND 1
#ifdef MAKE_SUID
# define IF_FEATURE_TAR_TO_COMMAND(...) __VA_ARGS__ "CONFIG_FEATURE_TAR_TO_COMMAND"
#else
# 912 "./include/autoconf.h"
# define IF_FEATURE_TAR_TO_COMMAND(...) __VA_ARGS__
#endif
# 914 "./include/autoconf.h"
#define IF_NOT_FEATURE_TAR_TO_COMMAND(...)
#undef CONFIG_FEATURE_TAR_UNAME_GNAME
#define ENABLE_FEATURE_TAR_UNAME_GNAME 0
#define IF_FEATURE_TAR_UNAME_GNAME(...)
#define IF_NOT_FEATURE_TAR_UNAME_GNAME(...) __VA_ARGS__
#define CONFIG_FEATURE_TAR_NOPRESERVE_TIME 1
#define ENABLE_FEATURE_TAR_NOPRESERVE_TIME 1
#ifdef MAKE_SUID
# define IF_FEATURE_TAR_NOPRESERVE_TIME(...) __VA_ARGS__ "CONFIG_FEATURE_TAR_NOPRESERVE_TIME"
#else
# 924 "./include/autoconf.h"
# define IF_FEATURE_TAR_NOPRESERVE_TIME(...) __VA_ARGS__
#endif
# 926 "./include/autoconf.h"
#define IF_NOT_FEATURE_TAR_NOPRESERVE_TIME(...)
#undef CONFIG_FEATURE_TAR_SELINUX
#define ENABLE_FEATURE_TAR_SELINUX 0
#define IF_FEATURE_TAR_SELINUX(...)
#define IF_NOT_FEATURE_TAR_SELINUX(...) __VA_ARGS__
#define CONFIG_UNZIP 1
#define ENABLE_UNZIP 1
#ifdef MAKE_SUID
# define IF_UNZIP(...) __VA_ARGS__ "CONFIG_UNZIP"
#else
# 936 "./include/autoconf.h"
# define IF_UNZIP(...) __VA_ARGS__
#endif
# 938 "./include/autoconf.h"
#define IF_NOT_UNZIP(...)

/*
 * Coreutils
 */
#define CONFIG_BASENAME 1
#define ENABLE_BASENAME 1
#ifdef MAKE_SUID
# define IF_BASENAME(...) __VA_ARGS__ "CONFIG_BASENAME"
#else
# 948 "./include/autoconf.h"
# define IF_BASENAME(...) __VA_ARGS__
#endif
# 950 "./include/autoconf.h"
#define IF_NOT_BASENAME(...)
#define CONFIG_CAL 1
#define ENABLE_CAL 1
#ifdef MAKE_SUID
# define IF_CAL(...) __VA_ARGS__ "CONFIG_CAL"
#else
# 956 "./include/autoconf.h"
# define IF_CAL(...) __VA_ARGS__
#endif
# 958 "./include/autoconf.h"
#define IF_NOT_CAL(...)
#define CONFIG_CAT 1
#define ENABLE_CAT 1
#ifdef MAKE_SUID
# define IF_CAT(...) __VA_ARGS__ "CONFIG_CAT"
#else
# 964 "./include/autoconf.h"
# define IF_CAT(...) __VA_ARGS__
#endif
# 966 "./include/autoconf.h"
#define IF_NOT_CAT(...)
#define CONFIG_CATV 1
#define ENABLE_CATV 1
#ifdef MAKE_SUID
# define IF_CATV(...) __VA_ARGS__ "CONFIG_CATV"
#else
# 972 "./include/autoconf.h"
# define IF_CATV(...) __VA_ARGS__
#endif
# 974 "./include/autoconf.h"
#define IF_NOT_CATV(...)
#define CONFIG_CHGRP 1
#define ENABLE_CHGRP 1
#ifdef MAKE_SUID
# define IF_CHGRP(...) __VA_ARGS__ "CONFIG_CHGRP"
#else
# 980 "./include/autoconf.h"
# define IF_CHGRP(...) __VA_ARGS__
#endif
# 982 "./include/autoconf.h"
#define IF_NOT_CHGRP(...)
#define CONFIG_CHMOD 1
#define ENABLE_CHMOD 1
#ifdef MAKE_SUID
# define IF_CHMOD(...) __VA_ARGS__ "CONFIG_CHMOD"
#else
# 988 "./include/autoconf.h"
# define IF_CHMOD(...) __VA_ARGS__
#endif
# 990 "./include/autoconf.h"
#define IF_NOT_CHMOD(...)
#define CONFIG_CHOWN 1
#define ENABLE_CHOWN 1
#ifdef MAKE_SUID
# define IF_CHOWN(...) __VA_ARGS__ "CONFIG_CHOWN"
#else
# 996 "./include/autoconf.h"
# define IF_CHOWN(...) __VA_ARGS__
#endif
# 998 "./include/autoconf.h"
#define IF_NOT_CHOWN(...)
#define CONFIG_FEATURE_CHOWN_LONG_OPTIONS 1
#define ENABLE_FEATURE_CHOWN_LONG_OPTIONS 1
#ifdef MAKE_SUID
# define IF_FEATURE_CHOWN_LONG_OPTIONS(...) __VA_ARGS__ "CONFIG_FEATURE_CHOWN_LONG_OPTIONS"
#else
# 1004 "./include/autoconf.h"
# define IF_FEATURE_CHOWN_LONG_OPTIONS(...) __VA_ARGS__
#endif
# 1006 "./include/autoconf.h"
#define IF_NOT_FEATURE_CHOWN_LONG_OPTIONS(...)
#define CONFIG_CHROOT 1
#define ENABLE_CHROOT 1
#ifdef MAKE_SUID
# define IF_CHROOT(...) __VA_ARGS__ "CONFIG_CHROOT"
#else
# 1012 "./include/autoconf.h"
# define IF_CHROOT(...) __VA_ARGS__
#endif
# 1014 "./include/autoconf.h"
#define IF_NOT_CHROOT(...)
#define CONFIG_CKSUM 1
#define ENABLE_CKSUM 1
#ifdef MAKE_SUID
# define IF_CKSUM(...) __VA_ARGS__ "CONFIG_CKSUM"
#else
# 1020 "./include/autoconf.h"
# define IF_CKSUM(...) __VA_ARGS__
#endif
# 1022 "./include/autoconf.h"
#define IF_NOT_CKSUM(...)
#define CONFIG_COMM 1
#define ENABLE_COMM 1
#ifdef MAKE_SUID
# define IF_COMM(...) __VA_ARGS__ "CONFIG_COMM"
#else
# 1028 "./include/autoconf.h"
# define IF_COMM(...) __VA_ARGS__
#endif
# 1030 "./include/autoconf.h"
#define IF_NOT_COMM(...)
#define CONFIG_CP 1
#define ENABLE_CP 1
#ifdef MAKE_SUID
# define IF_CP(...) __VA_ARGS__ "CONFIG_CP"
#else
# 1036 "./include/autoconf.h"
# define IF_CP(...) __VA_ARGS__
#endif
# 1038 "./include/autoconf.h"
#define IF_NOT_CP(...)
#define CONFIG_FEATURE_CP_LONG_OPTIONS 1
#define ENABLE_FEATURE_CP_LONG_OPTIONS 1
#ifdef MAKE_SUID
# define IF_FEATURE_CP_LONG_OPTIONS(...) __VA_ARGS__ "CONFIG_FEATURE_CP_LONG_OPTIONS"
#else
# 1044 "./include/autoconf.h"
# define IF_FEATURE_CP_LONG_OPTIONS(...) __VA_ARGS__
#endif
# 1046 "./include/autoconf.h"
#define IF_NOT_FEATURE_CP_LONG_OPTIONS(...)
#define CONFIG_CUT 1
#define ENABLE_CUT 1
#ifdef MAKE_SUID
# define IF_CUT(...) __VA_ARGS__ "CONFIG_CUT"
#else
# 1052 "./include/autoconf.h"
# define IF_CUT(...) __VA_ARGS__
#endif
# 1054 "./include/autoconf.h"
#define IF_NOT_CUT(...)
#undef CONFIG_DATE
#define ENABLE_DATE 0
#define IF_DATE(...)
#define IF_NOT_DATE(...) __VA_ARGS__
#undef CONFIG_FEATURE_DATE_ISOFMT
#define ENABLE_FEATURE_DATE_ISOFMT 0
#define IF_FEATURE_DATE_ISOFMT(...)
#define IF_NOT_FEATURE_DATE_ISOFMT(...) __VA_ARGS__
#undef CONFIG_FEATURE_DATE_NANO
#define ENABLE_FEATURE_DATE_NANO 0
#define IF_FEATURE_DATE_NANO(...)
#define IF_NOT_FEATURE_DATE_NANO(...) __VA_ARGS__
#undef CONFIG_FEATURE_DATE_COMPAT
#define ENABLE_FEATURE_DATE_COMPAT 0
#define IF_FEATURE_DATE_COMPAT(...)
#define IF_NOT_FEATURE_DATE_COMPAT(...) __VA_ARGS__
#define CONFIG_DD 1
#define ENABLE_DD 1
#ifdef MAKE_SUID
# define IF_DD(...) __VA_ARGS__ "CONFIG_DD"
#else
# 1076 "./include/autoconf.h"
# define IF_DD(...) __VA_ARGS__
#endif
# 1078 "./include/autoconf.h"
#define IF_NOT_DD(...)
#define CONFIG_FEATURE_DD_SIGNAL_HANDLING 1
#define ENABLE_FEATURE_DD_SIGNAL_HANDLING 1
#ifdef MAKE_SUID
# define IF_FEATURE_DD_SIGNAL_HANDLING(...) __VA_ARGS__ "CONFIG_FEATURE_DD_SIGNAL_HANDLING"
#else
# 1084 "./include/autoconf.h"
# define IF_FEATURE_DD_SIGNAL_HANDLING(...) __VA_ARGS__
#endif
# 1086 "./include/autoconf.h"
#define IF_NOT_FEATURE_DD_SIGNAL_HANDLING(...)
#define CONFIG_FEATURE_DD_THIRD_STATUS_LINE 1
#define ENABLE_FEATURE_DD_THIRD_STATUS_LINE 1
#ifdef MAKE_SUID
# define IF_FEATURE_DD_THIRD_STATUS_LINE(...) __VA_ARGS__ "CONFIG_FEATURE_DD_THIRD_STATUS_LINE"
#else
# 1092 "./include/autoconf.h"
# define IF_FEATURE_DD_THIRD_STATUS_LINE(...) __VA_ARGS__
#endif
# 1094 "./include/autoconf.h"
#define IF_NOT_FEATURE_DD_THIRD_STATUS_LINE(...)
#define CONFIG_FEATURE_DD_IBS_OBS 1
#define ENABLE_FEATURE_DD_IBS_OBS 1
#ifdef MAKE_SUID
# define IF_FEATURE_DD_IBS_OBS(...) __VA_ARGS__ "CONFIG_FEATURE_DD_IBS_OBS"
#else
# 1100 "./include/autoconf.h"
# define IF_FEATURE_DD_IBS_OBS(...) __VA_ARGS__
#endif
# 1102 "./include/autoconf.h"
#define IF_NOT_FEATURE_DD_IBS_OBS(...)
#define CONFIG_FEATURE_DD_STATUS 1
#define ENABLE_FEATURE_DD_STATUS 1
#ifdef MAKE_SUID
# define IF_FEATURE_DD_STATUS(...) __VA_ARGS__ "CONFIG_FEATURE_DD_STATUS"
#else
# 1108 "./include/autoconf.h"
# define IF_FEATURE_DD_STATUS(...) __VA_ARGS__
#endif
# 1110 "./include/autoconf.h"
#define IF_NOT_FEATURE_DD_STATUS(...)
#undef CONFIG_DF
#define ENABLE_DF 0
#define IF_DF(...)
#define IF_NOT_DF(...) __VA_ARGS__
#undef CONFIG_FEATURE_DF_FANCY
#define ENABLE_FEATURE_DF_FANCY 0
#define IF_FEATURE_DF_FANCY(...)
#define IF_NOT_FEATURE_DF_FANCY(...) __VA_ARGS__
#define CONFIG_DIRNAME 1
#define ENABLE_DIRNAME 1
#ifdef MAKE_SUID
# define IF_DIRNAME(...) __VA_ARGS__ "CONFIG_DIRNAME"
#else
# 1124 "./include/autoconf.h"
# define IF_DIRNAME(...) __VA_ARGS__
#endif
# 1126 "./include/autoconf.h"
#define IF_NOT_DIRNAME(...)
#define CONFIG_DOS2UNIX 1
#define ENABLE_DOS2UNIX 1
#ifdef MAKE_SUID
# define IF_DOS2UNIX(...) __VA_ARGS__ "CONFIG_DOS2UNIX"
#else
# 1132 "./include/autoconf.h"
# define IF_DOS2UNIX(...) __VA_ARGS__
#endif
# 1134 "./include/autoconf.h"
#define IF_NOT_DOS2UNIX(...)
#define CONFIG_UNIX2DOS 1
#define ENABLE_UNIX2DOS 1
#ifdef MAKE_SUID
# define IF_UNIX2DOS(...) __VA_ARGS__ "CONFIG_UNIX2DOS"
#else
# 1140 "./include/autoconf.h"
# define IF_UNIX2DOS(...) __VA_ARGS__
#endif
# 1142 "./include/autoconf.h"
#define IF_NOT_UNIX2DOS(...)
#define CONFIG_DU 1
#define ENABLE_DU 1
#ifdef MAKE_SUID
# define IF_DU(...) __VA_ARGS__ "CONFIG_DU"
#else
# 1148 "./include/autoconf.h"
# define IF_DU(...) __VA_ARGS__
#endif
# 1150 "./include/autoconf.h"
#define IF_NOT_DU(...)
#define CONFIG_FEATURE_DU_DEFAULT_BLOCKSIZE_1K 1
#define ENABLE_FEATURE_DU_DEFAULT_BLOCKSIZE_1K 1
#ifdef MAKE_SUID
# define IF_FEATURE_DU_DEFAULT_BLOCKSIZE_1K(...) __VA_ARGS__ "CONFIG_FEATURE_DU_DEFAULT_BLOCKSIZE_1K"
#else
# 1156 "./include/autoconf.h"
# define IF_FEATURE_DU_DEFAULT_BLOCKSIZE_1K(...) __VA_ARGS__
#endif
# 1158 "./include/autoconf.h"
#define IF_NOT_FEATURE_DU_DEFAULT_BLOCKSIZE_1K(...)
#define CONFIG_ECHO 1
#define ENABLE_ECHO 1
#ifdef MAKE_SUID
# define IF_ECHO(...) __VA_ARGS__ "CONFIG_ECHO"
#else
# 1164 "./include/autoconf.h"
# define IF_ECHO(...) __VA_ARGS__
#endif
# 1166 "./include/autoconf.h"
#define IF_NOT_ECHO(...)
#define CONFIG_FEATURE_FANCY_ECHO 1
#define ENABLE_FEATURE_FANCY_ECHO 1
#ifdef MAKE_SUID
# define IF_FEATURE_FANCY_ECHO(...) __VA_ARGS__ "CONFIG_FEATURE_FANCY_ECHO"
#else
# 1172 "./include/autoconf.h"
# define IF_FEATURE_FANCY_ECHO(...) __VA_ARGS__
#endif
# 1174 "./include/autoconf.h"
#define IF_NOT_FEATURE_FANCY_ECHO(...)
#define CONFIG_ENV 1
#define ENABLE_ENV 1
#ifdef MAKE_SUID
# define IF_ENV(...) __VA_ARGS__ "CONFIG_ENV"
#else
# 1180 "./include/autoconf.h"
# define IF_ENV(...) __VA_ARGS__
#endif
# 1182 "./include/autoconf.h"
#define IF_NOT_ENV(...)
#define CONFIG_FEATURE_ENV_LONG_OPTIONS 1
#define ENABLE_FEATURE_ENV_LONG_OPTIONS 1
#ifdef MAKE_SUID
# define IF_FEATURE_ENV_LONG_OPTIONS(...) __VA_ARGS__ "CONFIG_FEATURE_ENV_LONG_OPTIONS"
#else
# 1188 "./include/autoconf.h"
# define IF_FEATURE_ENV_LONG_OPTIONS(...) __VA_ARGS__
#endif
# 1190 "./include/autoconf.h"
#define IF_NOT_FEATURE_ENV_LONG_OPTIONS(...)
#define CONFIG_EXPAND 1
#define ENABLE_EXPAND 1
#ifdef MAKE_SUID
# define IF_EXPAND(...) __VA_ARGS__ "CONFIG_EXPAND"
#else
# 1196 "./include/autoconf.h"
# define IF_EXPAND(...) __VA_ARGS__
#endif
# 1198 "./include/autoconf.h"
#define IF_NOT_EXPAND(...)
#define CONFIG_FEATURE_EXPAND_LONG_OPTIONS 1
#define ENABLE_FEATURE_EXPAND_LONG_OPTIONS 1
#ifdef MAKE_SUID
# define IF_FEATURE_EXPAND_LONG_OPTIONS(...) __VA_ARGS__ "CONFIG_FEATURE_EXPAND_LONG_OPTIONS"
#else
# 1204 "./include/autoconf.h"
# define IF_FEATURE_EXPAND_LONG_OPTIONS(...) __VA_ARGS__
#endif
# 1206 "./include/autoconf.h"
#define IF_NOT_FEATURE_EXPAND_LONG_OPTIONS(...)
#define CONFIG_UNEXPAND 1
#define ENABLE_UNEXPAND 1
#ifdef MAKE_SUID
# define IF_UNEXPAND(...) __VA_ARGS__ "CONFIG_UNEXPAND"
#else
# 1212 "./include/autoconf.h"
# define IF_UNEXPAND(...) __VA_ARGS__
#endif
# 1214 "./include/autoconf.h"
#define IF_NOT_UNEXPAND(...)
#define CONFIG_FEATURE_UNEXPAND_LONG_OPTIONS 1
#define ENABLE_FEATURE_UNEXPAND_LONG_OPTIONS 1
#ifdef MAKE_SUID
# define IF_FEATURE_UNEXPAND_LONG_OPTIONS(...) __VA_ARGS__ "CONFIG_FEATURE_UNEXPAND_LONG_OPTIONS"
#else
# 1220 "./include/autoconf.h"
# define IF_FEATURE_UNEXPAND_LONG_OPTIONS(...) __VA_ARGS__
#endif
# 1222 "./include/autoconf.h"
#define IF_NOT_FEATURE_UNEXPAND_LONG_OPTIONS(...)
#define CONFIG_EXPR 1
#define ENABLE_EXPR 1
#ifdef MAKE_SUID
# define IF_EXPR(...) __VA_ARGS__ "CONFIG_EXPR"
#else
# 1228 "./include/autoconf.h"
# define IF_EXPR(...) __VA_ARGS__
#endif
# 1230 "./include/autoconf.h"
#define IF_NOT_EXPR(...)
#define CONFIG_EXPR_MATH_SUPPORT_64 1
#define ENABLE_EXPR_MATH_SUPPORT_64 1
#ifdef MAKE_SUID
# define IF_EXPR_MATH_SUPPORT_64(...) __VA_ARGS__ "CONFIG_EXPR_MATH_SUPPORT_64"
#else
# 1236 "./include/autoconf.h"
# define IF_EXPR_MATH_SUPPORT_64(...) __VA_ARGS__
#endif
# 1238 "./include/autoconf.h"
#define IF_NOT_EXPR_MATH_SUPPORT_64(...)
#define CONFIG_FALSE 1
#define ENABLE_FALSE 1
#ifdef MAKE_SUID
# define IF_FALSE(...) __VA_ARGS__ "CONFIG_FALSE"
#else
# 1244 "./include/autoconf.h"
# define IF_FALSE(...) __VA_ARGS__
#endif
# 1246 "./include/autoconf.h"
#define IF_NOT_FALSE(...)
#define CONFIG_FOLD 1
#define ENABLE_FOLD 1
#ifdef MAKE_SUID
# define IF_FOLD(...) __VA_ARGS__ "CONFIG_FOLD"
#else
# 1252 "./include/autoconf.h"
# define IF_FOLD(...) __VA_ARGS__
#endif
# 1254 "./include/autoconf.h"
#define IF_NOT_FOLD(...)
#define CONFIG_FSYNC 1
#define ENABLE_FSYNC 1
#ifdef MAKE_SUID
# define IF_FSYNC(...) __VA_ARGS__ "CONFIG_FSYNC"
#else
# 1260 "./include/autoconf.h"
# define IF_FSYNC(...) __VA_ARGS__
#endif
# 1262 "./include/autoconf.h"
#define IF_NOT_FSYNC(...)
#define CONFIG_HEAD 1
#define ENABLE_HEAD 1
#ifdef MAKE_SUID
# define IF_HEAD(...) __VA_ARGS__ "CONFIG_HEAD"
#else
# 1268 "./include/autoconf.h"
# define IF_HEAD(...) __VA_ARGS__
#endif
# 1270 "./include/autoconf.h"
#define IF_NOT_HEAD(...)
#define CONFIG_FEATURE_FANCY_HEAD 1
#define ENABLE_FEATURE_FANCY_HEAD 1
#ifdef MAKE_SUID
# define IF_FEATURE_FANCY_HEAD(...) __VA_ARGS__ "CONFIG_FEATURE_FANCY_HEAD"
#else
# 1276 "./include/autoconf.h"
# define IF_FEATURE_FANCY_HEAD(...) __VA_ARGS__
#endif
# 1278 "./include/autoconf.h"
#define IF_NOT_FEATURE_FANCY_HEAD(...)
#define CONFIG_HOSTID 1
#define ENABLE_HOSTID 1
#ifdef MAKE_SUID
# define IF_HOSTID(...) __VA_ARGS__ "CONFIG_HOSTID"
#else
# 1284 "./include/autoconf.h"
# define IF_HOSTID(...) __VA_ARGS__
#endif
# 1286 "./include/autoconf.h"
#define IF_NOT_HOSTID(...)
#define CONFIG_ID 1
#define ENABLE_ID 1
#ifdef MAKE_SUID
# define IF_ID(...) __VA_ARGS__ "CONFIG_ID"
#else
# 1292 "./include/autoconf.h"
# define IF_ID(...) __VA_ARGS__
#endif
# 1294 "./include/autoconf.h"
#define IF_NOT_ID(...)
#define CONFIG_GROUPS 1
#define ENABLE_GROUPS 1
#ifdef MAKE_SUID
# define IF_GROUPS(...) __VA_ARGS__ "CONFIG_GROUPS"
#else
# 1300 "./include/autoconf.h"
# define IF_GROUPS(...) __VA_ARGS__
#endif
# 1302 "./include/autoconf.h"
#define IF_NOT_GROUPS(...)
#define CONFIG_INSTALL 1
#define ENABLE_INSTALL 1
#ifdef MAKE_SUID
# define IF_INSTALL(...) __VA_ARGS__ "CONFIG_INSTALL"
#else
# 1308 "./include/autoconf.h"
# define IF_INSTALL(...) __VA_ARGS__
#endif
# 1310 "./include/autoconf.h"
#define IF_NOT_INSTALL(...)
#define CONFIG_FEATURE_INSTALL_LONG_OPTIONS 1
#define ENABLE_FEATURE_INSTALL_LONG_OPTIONS 1
#ifdef MAKE_SUID
# define IF_FEATURE_INSTALL_LONG_OPTIONS(...) __VA_ARGS__ "CONFIG_FEATURE_INSTALL_LONG_OPTIONS"
#else
# 1316 "./include/autoconf.h"
# define IF_FEATURE_INSTALL_LONG_OPTIONS(...) __VA_ARGS__
#endif
# 1318 "./include/autoconf.h"
#define IF_NOT_FEATURE_INSTALL_LONG_OPTIONS(...)
#define CONFIG_LN 1
#define ENABLE_LN 1
#ifdef MAKE_SUID
# define IF_LN(...) __VA_ARGS__ "CONFIG_LN"
#else
# 1324 "./include/autoconf.h"
# define IF_LN(...) __VA_ARGS__
#endif
# 1326 "./include/autoconf.h"
#define IF_NOT_LN(...)
#define CONFIG_LOGNAME 1
#define ENABLE_LOGNAME 1
#ifdef MAKE_SUID
# define IF_LOGNAME(...) __VA_ARGS__ "CONFIG_LOGNAME"
#else
# 1332 "./include/autoconf.h"
# define IF_LOGNAME(...) __VA_ARGS__
#endif
# 1334 "./include/autoconf.h"
#define IF_NOT_LOGNAME(...)
#define CONFIG_LS 1
#define ENABLE_LS 1
#ifdef MAKE_SUID
# define IF_LS(...) __VA_ARGS__ "CONFIG_LS"
#else
# 1340 "./include/autoconf.h"
# define IF_LS(...) __VA_ARGS__
#endif
# 1342 "./include/autoconf.h"
#define IF_NOT_LS(...)
#define CONFIG_FEATURE_LS_FILETYPES 1
#define ENABLE_FEATURE_LS_FILETYPES 1
#ifdef MAKE_SUID
# define IF_FEATURE_LS_FILETYPES(...) __VA_ARGS__ "CONFIG_FEATURE_LS_FILETYPES"
#else
# 1348 "./include/autoconf.h"
# define IF_FEATURE_LS_FILETYPES(...) __VA_ARGS__
#endif
# 1350 "./include/autoconf.h"
#define IF_NOT_FEATURE_LS_FILETYPES(...)
#define CONFIG_FEATURE_LS_FOLLOWLINKS 1
#define ENABLE_FEATURE_LS_FOLLOWLINKS 1
#ifdef MAKE_SUID
# define IF_FEATURE_LS_FOLLOWLINKS(...) __VA_ARGS__ "CONFIG_FEATURE_LS_FOLLOWLINKS"
#else
# 1356 "./include/autoconf.h"
# define IF_FEATURE_LS_FOLLOWLINKS(...) __VA_ARGS__
#endif
# 1358 "./include/autoconf.h"
#define IF_NOT_FEATURE_LS_FOLLOWLINKS(...)
#define CONFIG_FEATURE_LS_RECURSIVE 1
#define ENABLE_FEATURE_LS_RECURSIVE 1
#ifdef MAKE_SUID
# define IF_FEATURE_LS_RECURSIVE(...) __VA_ARGS__ "CONFIG_FEATURE_LS_RECURSIVE"
#else
# 1364 "./include/autoconf.h"
# define IF_FEATURE_LS_RECURSIVE(...) __VA_ARGS__
#endif
# 1366 "./include/autoconf.h"
#define IF_NOT_FEATURE_LS_RECURSIVE(...)
#define CONFIG_FEATURE_LS_SORTFILES 1
#define ENABLE_FEATURE_LS_SORTFILES 1
#ifdef MAKE_SUID
# define IF_FEATURE_LS_SORTFILES(...) __VA_ARGS__ "CONFIG_FEATURE_LS_SORTFILES"
#else
# 1372 "./include/autoconf.h"
# define IF_FEATURE_LS_SORTFILES(...) __VA_ARGS__
#endif
# 1374 "./include/autoconf.h"
#define IF_NOT_FEATURE_LS_SORTFILES(...)
#define CONFIG_FEATURE_LS_TIMESTAMPS 1
#define ENABLE_FEATURE_LS_TIMESTAMPS 1
#ifdef MAKE_SUID
# define IF_FEATURE_LS_TIMESTAMPS(...) __VA_ARGS__ "CONFIG_FEATURE_LS_TIMESTAMPS"
#else
# 1380 "./include/autoconf.h"
# define IF_FEATURE_LS_TIMESTAMPS(...) __VA_ARGS__
#endif
# 1382 "./include/autoconf.h"
#define IF_NOT_FEATURE_LS_TIMESTAMPS(...)
#define CONFIG_FEATURE_LS_USERNAME 1
#define ENABLE_FEATURE_LS_USERNAME 1
#ifdef MAKE_SUID
# define IF_FEATURE_LS_USERNAME(...) __VA_ARGS__ "CONFIG_FEATURE_LS_USERNAME"
#else
# 1388 "./include/autoconf.h"
# define IF_FEATURE_LS_USERNAME(...) __VA_ARGS__
#endif
# 1390 "./include/autoconf.h"
#define IF_NOT_FEATURE_LS_USERNAME(...)
#define CONFIG_FEATURE_LS_COLOR 1
#define ENABLE_FEATURE_LS_COLOR 1
#ifdef MAKE_SUID
# define IF_FEATURE_LS_COLOR(...) __VA_ARGS__ "CONFIG_FEATURE_LS_COLOR"
#else
# 1396 "./include/autoconf.h"
# define IF_FEATURE_LS_COLOR(...) __VA_ARGS__
#endif
# 1398 "./include/autoconf.h"
#define IF_NOT_FEATURE_LS_COLOR(...)
#define CONFIG_FEATURE_LS_COLOR_IS_DEFAULT 1
#define ENABLE_FEATURE_LS_COLOR_IS_DEFAULT 1
#ifdef MAKE_SUID
# define IF_FEATURE_LS_COLOR_IS_DEFAULT(...) __VA_ARGS__ "CONFIG_FEATURE_LS_COLOR_IS_DEFAULT"
#else
# 1404 "./include/autoconf.h"
# define IF_FEATURE_LS_COLOR_IS_DEFAULT(...) __VA_ARGS__
#endif
# 1406 "./include/autoconf.h"
#define IF_NOT_FEATURE_LS_COLOR_IS_DEFAULT(...)
#define CONFIG_MD5SUM 1
#define ENABLE_MD5SUM 1
#ifdef MAKE_SUID
# define IF_MD5SUM(...) __VA_ARGS__ "CONFIG_MD5SUM"
#else
# 1412 "./include/autoconf.h"
# define IF_MD5SUM(...) __VA_ARGS__
#endif
# 1414 "./include/autoconf.h"
#define IF_NOT_MD5SUM(...)
#define CONFIG_SHA1SUM 1
#define ENABLE_SHA1SUM 1
#ifdef MAKE_SUID
# define IF_SHA1SUM(...) __VA_ARGS__ "CONFIG_SHA1SUM"
#else
# 1420 "./include/autoconf.h"
# define IF_SHA1SUM(...) __VA_ARGS__
#endif
# 1422 "./include/autoconf.h"
#define IF_NOT_SHA1SUM(...)
#define CONFIG_SHA256SUM 1
#define ENABLE_SHA256SUM 1
#ifdef MAKE_SUID
# define IF_SHA256SUM(...) __VA_ARGS__ "CONFIG_SHA256SUM"
#else
# 1428 "./include/autoconf.h"
# define IF_SHA256SUM(...) __VA_ARGS__
#endif
# 1430 "./include/autoconf.h"
#define IF_NOT_SHA256SUM(...)
#define CONFIG_SHA512SUM 1
#define ENABLE_SHA512SUM 1
#ifdef MAKE_SUID
# define IF_SHA512SUM(...) __VA_ARGS__ "CONFIG_SHA512SUM"
#else
# 1436 "./include/autoconf.h"
# define IF_SHA512SUM(...) __VA_ARGS__
#endif
# 1438 "./include/autoconf.h"
#define IF_NOT_SHA512SUM(...)
#define CONFIG_SHA3SUM 1
#define ENABLE_SHA3SUM 1
#ifdef MAKE_SUID
# define IF_SHA3SUM(...) __VA_ARGS__ "CONFIG_SHA3SUM"
#else
# 1444 "./include/autoconf.h"
# define IF_SHA3SUM(...) __VA_ARGS__
#endif
# 1446 "./include/autoconf.h"
#define IF_NOT_SHA3SUM(...)

/*
 * Common options for md5sum, sha1sum, sha256sum, sha512sum, sha3sum
 */
#define CONFIG_FEATURE_MD5_SHA1_SUM_CHECK 1
#define ENABLE_FEATURE_MD5_SHA1_SUM_CHECK 1
#ifdef MAKE_SUID
# define IF_FEATURE_MD5_SHA1_SUM_CHECK(...) __VA_ARGS__ "CONFIG_FEATURE_MD5_SHA1_SUM_CHECK"
#else
# 1456 "./include/autoconf.h"
# define IF_FEATURE_MD5_SHA1_SUM_CHECK(...) __VA_ARGS__
#endif
# 1458 "./include/autoconf.h"
#define IF_NOT_FEATURE_MD5_SHA1_SUM_CHECK(...)
#define CONFIG_MKDIR 1
#define ENABLE_MKDIR 1
#ifdef MAKE_SUID
# define IF_MKDIR(...) __VA_ARGS__ "CONFIG_MKDIR"
#else
# 1464 "./include/autoconf.h"
# define IF_MKDIR(...) __VA_ARGS__
#endif
# 1466 "./include/autoconf.h"
#define IF_NOT_MKDIR(...)
#define CONFIG_FEATURE_MKDIR_LONG_OPTIONS 1
#define ENABLE_FEATURE_MKDIR_LONG_OPTIONS 1
#ifdef MAKE_SUID
# define IF_FEATURE_MKDIR_LONG_OPTIONS(...) __VA_ARGS__ "CONFIG_FEATURE_MKDIR_LONG_OPTIONS"
#else
# 1472 "./include/autoconf.h"
# define IF_FEATURE_MKDIR_LONG_OPTIONS(...) __VA_ARGS__
#endif
# 1474 "./include/autoconf.h"
#define IF_NOT_FEATURE_MKDIR_LONG_OPTIONS(...)
#define CONFIG_MKFIFO 1
#define ENABLE_MKFIFO 1
#ifdef MAKE_SUID
# define IF_MKFIFO(...) __VA_ARGS__ "CONFIG_MKFIFO"
#else
# 1480 "./include/autoconf.h"
# define IF_MKFIFO(...) __VA_ARGS__
#endif
# 1482 "./include/autoconf.h"
#define IF_NOT_MKFIFO(...)
#undef CONFIG_MKNOD
#define ENABLE_MKNOD 0
#define IF_MKNOD(...)
#define IF_NOT_MKNOD(...) __VA_ARGS__
#define CONFIG_MV 1
#define ENABLE_MV 1
#ifdef MAKE_SUID
# define IF_MV(...) __VA_ARGS__ "CONFIG_MV"
#else
# 1492 "./include/autoconf.h"
# define IF_MV(...) __VA_ARGS__
#endif
# 1494 "./include/autoconf.h"
#define IF_NOT_MV(...)
#define CONFIG_FEATURE_MV_LONG_OPTIONS 1
#define ENABLE_FEATURE_MV_LONG_OPTIONS 1
#ifdef MAKE_SUID
# define IF_FEATURE_MV_LONG_OPTIONS(...) __VA_ARGS__ "CONFIG_FEATURE_MV_LONG_OPTIONS"
#else
# 1500 "./include/autoconf.h"
# define IF_FEATURE_MV_LONG_OPTIONS(...) __VA_ARGS__
#endif
# 1502 "./include/autoconf.h"
#define IF_NOT_FEATURE_MV_LONG_OPTIONS(...)
#define CONFIG_NICE 1
#define ENABLE_NICE 1
#ifdef MAKE_SUID
# define IF_NICE(...) __VA_ARGS__ "CONFIG_NICE"
#else
# 1508 "./include/autoconf.h"
# define IF_NICE(...) __VA_ARGS__
#endif
# 1510 "./include/autoconf.h"
#define IF_NOT_NICE(...)
#define CONFIG_NOHUP 1
#define ENABLE_NOHUP 1
#ifdef MAKE_SUID
# define IF_NOHUP(...) __VA_ARGS__ "CONFIG_NOHUP"
#else
# 1516 "./include/autoconf.h"
# define IF_NOHUP(...) __VA_ARGS__
#endif
# 1518 "./include/autoconf.h"
#define IF_NOT_NOHUP(...)
#define CONFIG_OD 1
#define ENABLE_OD 1
#ifdef MAKE_SUID
# define IF_OD(...) __VA_ARGS__ "CONFIG_OD"
#else
# 1524 "./include/autoconf.h"
# define IF_OD(...) __VA_ARGS__
#endif
# 1526 "./include/autoconf.h"
#define IF_NOT_OD(...)
#define CONFIG_PRINTENV 1
#define ENABLE_PRINTENV 1
#ifdef MAKE_SUID
# define IF_PRINTENV(...) __VA_ARGS__ "CONFIG_PRINTENV"
#else
# 1532 "./include/autoconf.h"
# define IF_PRINTENV(...) __VA_ARGS__
#endif
# 1534 "./include/autoconf.h"
#define IF_NOT_PRINTENV(...)
#define CONFIG_PRINTF 1
#define ENABLE_PRINTF 1
#ifdef MAKE_SUID
# define IF_PRINTF(...) __VA_ARGS__ "CONFIG_PRINTF"
#else
# 1540 "./include/autoconf.h"
# define IF_PRINTF(...) __VA_ARGS__
#endif
# 1542 "./include/autoconf.h"
#define IF_NOT_PRINTF(...)
#define CONFIG_PWD 1
#define ENABLE_PWD 1
#ifdef MAKE_SUID
# define IF_PWD(...) __VA_ARGS__ "CONFIG_PWD"
#else
# 1548 "./include/autoconf.h"
# define IF_PWD(...) __VA_ARGS__
#endif
# 1550 "./include/autoconf.h"
#define IF_NOT_PWD(...)
#define CONFIG_READLINK 1
#define ENABLE_READLINK 1
#ifdef MAKE_SUID
# define IF_READLINK(...) __VA_ARGS__ "CONFIG_READLINK"
#else
# 1556 "./include/autoconf.h"
# define IF_READLINK(...) __VA_ARGS__
#endif
# 1558 "./include/autoconf.h"
#define IF_NOT_READLINK(...)
#define CONFIG_FEATURE_READLINK_FOLLOW 1
#define ENABLE_FEATURE_READLINK_FOLLOW 1
#ifdef MAKE_SUID
# define IF_FEATURE_READLINK_FOLLOW(...) __VA_ARGS__ "CONFIG_FEATURE_READLINK_FOLLOW"
#else
# 1564 "./include/autoconf.h"
# define IF_FEATURE_READLINK_FOLLOW(...) __VA_ARGS__
#endif
# 1566 "./include/autoconf.h"
#define IF_NOT_FEATURE_READLINK_FOLLOW(...)
#define CONFIG_REALPATH 1
#define ENABLE_REALPATH 1
#ifdef MAKE_SUID
# define IF_REALPATH(...) __VA_ARGS__ "CONFIG_REALPATH"
#else
# 1572 "./include/autoconf.h"
# define IF_REALPATH(...) __VA_ARGS__
#endif
# 1574 "./include/autoconf.h"
#define IF_NOT_REALPATH(...)
#define CONFIG_RM 1
#define ENABLE_RM 1
#ifdef MAKE_SUID
# define IF_RM(...) __VA_ARGS__ "CONFIG_RM"
#else
# 1580 "./include/autoconf.h"
# define IF_RM(...) __VA_ARGS__
#endif
# 1582 "./include/autoconf.h"
#define IF_NOT_RM(...)
#define CONFIG_RMDIR 1
#define ENABLE_RMDIR 1
#ifdef MAKE_SUID
# define IF_RMDIR(...) __VA_ARGS__ "CONFIG_RMDIR"
#else
# 1588 "./include/autoconf.h"
# define IF_RMDIR(...) __VA_ARGS__
#endif
# 1590 "./include/autoconf.h"
#define IF_NOT_RMDIR(...)
#undef CONFIG_FEATURE_RMDIR_LONG_OPTIONS
#define ENABLE_FEATURE_RMDIR_LONG_OPTIONS 0
#define IF_FEATURE_RMDIR_LONG_OPTIONS(...)
#define IF_NOT_FEATURE_RMDIR_LONG_OPTIONS(...) __VA_ARGS__
#define CONFIG_SEQ 1
#define ENABLE_SEQ 1
#ifdef MAKE_SUID
# define IF_SEQ(...) __VA_ARGS__ "CONFIG_SEQ"
#else
# 1600 "./include/autoconf.h"
# define IF_SEQ(...) __VA_ARGS__
#endif
# 1602 "./include/autoconf.h"
#define IF_NOT_SEQ(...)
#define CONFIG_SHUF 1
#define ENABLE_SHUF 1
#ifdef MAKE_SUID
# define IF_SHUF(...) __VA_ARGS__ "CONFIG_SHUF"
#else
# 1608 "./include/autoconf.h"
# define IF_SHUF(...) __VA_ARGS__
#endif
# 1610 "./include/autoconf.h"
#define IF_NOT_SHUF(...)
#define CONFIG_SLEEP 1
#define ENABLE_SLEEP 1
#ifdef MAKE_SUID
# define IF_SLEEP(...) __VA_ARGS__ "CONFIG_SLEEP"
#else
# 1616 "./include/autoconf.h"
# define IF_SLEEP(...) __VA_ARGS__
#endif
# 1618 "./include/autoconf.h"
#define IF_NOT_SLEEP(...)
#define CONFIG_FEATURE_FANCY_SLEEP 1
#define ENABLE_FEATURE_FANCY_SLEEP 1
#ifdef MAKE_SUID
# define IF_FEATURE_FANCY_SLEEP(...) __VA_ARGS__ "CONFIG_FEATURE_FANCY_SLEEP"
#else
# 1624 "./include/autoconf.h"
# define IF_FEATURE_FANCY_SLEEP(...) __VA_ARGS__
#endif
# 1626 "./include/autoconf.h"
#define IF_NOT_FEATURE_FANCY_SLEEP(...)
#define CONFIG_FEATURE_FLOAT_SLEEP 1
#define ENABLE_FEATURE_FLOAT_SLEEP 1
#ifdef MAKE_SUID
# define IF_FEATURE_FLOAT_SLEEP(...) __VA_ARGS__ "CONFIG_FEATURE_FLOAT_SLEEP"
#else
# 1632 "./include/autoconf.h"
# define IF_FEATURE_FLOAT_SLEEP(...) __VA_ARGS__
#endif
# 1634 "./include/autoconf.h"
#define IF_NOT_FEATURE_FLOAT_SLEEP(...)
#define CONFIG_SORT 1
#define ENABLE_SORT 1
#ifdef MAKE_SUID
# define IF_SORT(...) __VA_ARGS__ "CONFIG_SORT"
#else
# 1640 "./include/autoconf.h"
# define IF_SORT(...) __VA_ARGS__
#endif
# 1642 "./include/autoconf.h"
#define IF_NOT_SORT(...)
#define CONFIG_FEATURE_SORT_BIG 1
#define ENABLE_FEATURE_SORT_BIG 1
#ifdef MAKE_SUID
# define IF_FEATURE_SORT_BIG(...) __VA_ARGS__ "CONFIG_FEATURE_SORT_BIG"
#else
# 1648 "./include/autoconf.h"
# define IF_FEATURE_SORT_BIG(...) __VA_ARGS__
#endif
# 1650 "./include/autoconf.h"
#define IF_NOT_FEATURE_SORT_BIG(...)
#define CONFIG_SPLIT 1
#define ENABLE_SPLIT 1
#ifdef MAKE_SUID
# define IF_SPLIT(...) __VA_ARGS__ "CONFIG_SPLIT"
#else
# 1656 "./include/autoconf.h"
# define IF_SPLIT(...) __VA_ARGS__
#endif
# 1658 "./include/autoconf.h"
#define IF_NOT_SPLIT(...)
#define CONFIG_FEATURE_SPLIT_FANCY 1
#define ENABLE_FEATURE_SPLIT_FANCY 1
#ifdef MAKE_SUID
# define IF_FEATURE_SPLIT_FANCY(...) __VA_ARGS__ "CONFIG_FEATURE_SPLIT_FANCY"
#else
# 1664 "./include/autoconf.h"
# define IF_FEATURE_SPLIT_FANCY(...) __VA_ARGS__
#endif
# 1666 "./include/autoconf.h"
#define IF_NOT_FEATURE_SPLIT_FANCY(...)
#undef CONFIG_STAT
#define ENABLE_STAT 0
#define IF_STAT(...)
#define IF_NOT_STAT(...) __VA_ARGS__
#undef CONFIG_FEATURE_STAT_FORMAT
#define ENABLE_FEATURE_STAT_FORMAT 0
#define IF_FEATURE_STAT_FORMAT(...)
#define IF_NOT_FEATURE_STAT_FORMAT(...) __VA_ARGS__
#undef CONFIG_FEATURE_STAT_FILESYSTEM
#define ENABLE_FEATURE_STAT_FILESYSTEM 0
#define IF_FEATURE_STAT_FILESYSTEM(...)
#define IF_NOT_FEATURE_STAT_FILESYSTEM(...) __VA_ARGS__
#undef CONFIG_STTY
#define ENABLE_STTY 0
#define IF_STTY(...)
#define IF_NOT_STTY(...) __VA_ARGS__
#define CONFIG_SUM 1
#define ENABLE_SUM 1
#ifdef MAKE_SUID
# define IF_SUM(...) __VA_ARGS__ "CONFIG_SUM"
#else
# 1688 "./include/autoconf.h"
# define IF_SUM(...) __VA_ARGS__
#endif
# 1690 "./include/autoconf.h"
#define IF_NOT_SUM(...)
#define CONFIG_SYNC 1
#define ENABLE_SYNC 1
#ifdef MAKE_SUID
# define IF_SYNC(...) __VA_ARGS__ "CONFIG_SYNC"
#else
# 1696 "./include/autoconf.h"
# define IF_SYNC(...) __VA_ARGS__
#endif
# 1698 "./include/autoconf.h"
#define IF_NOT_SYNC(...)
#undef CONFIG_FEATURE_SYNC_FANCY
#define ENABLE_FEATURE_SYNC_FANCY 0
#define IF_FEATURE_SYNC_FANCY(...)
#define IF_NOT_FEATURE_SYNC_FANCY(...) __VA_ARGS__
#undef CONFIG_TAC
#define ENABLE_TAC 0
#define IF_TAC(...)
#define IF_NOT_TAC(...) __VA_ARGS__
#define CONFIG_TAIL 1
#define ENABLE_TAIL 1
#ifdef MAKE_SUID
# define IF_TAIL(...) __VA_ARGS__ "CONFIG_TAIL"
#else
# 1712 "./include/autoconf.h"
# define IF_TAIL(...) __VA_ARGS__
#endif
# 1714 "./include/autoconf.h"
#define IF_NOT_TAIL(...)
#define CONFIG_FEATURE_FANCY_TAIL 1
#define ENABLE_FEATURE_FANCY_TAIL 1
#ifdef MAKE_SUID
# define IF_FEATURE_FANCY_TAIL(...) __VA_ARGS__ "CONFIG_FEATURE_FANCY_TAIL"
#else
# 1720 "./include/autoconf.h"
# define IF_FEATURE_FANCY_TAIL(...) __VA_ARGS__
#endif
# 1722 "./include/autoconf.h"
#define IF_NOT_FEATURE_FANCY_TAIL(...)
#define CONFIG_TEE 1
#define ENABLE_TEE 1
#ifdef MAKE_SUID
# define IF_TEE(...) __VA_ARGS__ "CONFIG_TEE"
#else
# 1728 "./include/autoconf.h"
# define IF_TEE(...) __VA_ARGS__
#endif
# 1730 "./include/autoconf.h"
#define IF_NOT_TEE(...)
#define CONFIG_FEATURE_TEE_USE_BLOCK_IO 1
#define ENABLE_FEATURE_TEE_USE_BLOCK_IO 1
#ifdef MAKE_SUID
# define IF_FEATURE_TEE_USE_BLOCK_IO(...) __VA_ARGS__ "CONFIG_FEATURE_TEE_USE_BLOCK_IO"
#else
# 1736 "./include/autoconf.h"
# define IF_FEATURE_TEE_USE_BLOCK_IO(...) __VA_ARGS__
#endif
# 1738 "./include/autoconf.h"
#define IF_NOT_FEATURE_TEE_USE_BLOCK_IO(...)
#define CONFIG_TEST 1
#define ENABLE_TEST 1
#ifdef MAKE_SUID
# define IF_TEST(...) __VA_ARGS__ "CONFIG_TEST"
#else
# 1744 "./include/autoconf.h"
# define IF_TEST(...) __VA_ARGS__
#endif
# 1746 "./include/autoconf.h"
#define IF_NOT_TEST(...)
#undef CONFIG_TEST1
#define ENABLE_TEST1 0
#define IF_TEST1(...)
#define IF_NOT_TEST1(...) __VA_ARGS__
#undef CONFIG_TEST2
#define ENABLE_TEST2 0
#define IF_TEST2(...)
#define IF_NOT_TEST2(...) __VA_ARGS__
#define CONFIG_FEATURE_TEST_64 1
#define ENABLE_FEATURE_TEST_64 1
#ifdef MAKE_SUID
# define IF_FEATURE_TEST_64(...) __VA_ARGS__ "CONFIG_FEATURE_TEST_64"
#else
# 1760 "./include/autoconf.h"
# define IF_FEATURE_TEST_64(...) __VA_ARGS__
#endif
# 1762 "./include/autoconf.h"
#define IF_NOT_FEATURE_TEST_64(...)
#define CONFIG_TOUCH 1
#define ENABLE_TOUCH 1
#ifdef MAKE_SUID
# define IF_TOUCH(...) __VA_ARGS__ "CONFIG_TOUCH"
#else
# 1768 "./include/autoconf.h"
# define IF_TOUCH(...) __VA_ARGS__
#endif
# 1770 "./include/autoconf.h"
#define IF_NOT_TOUCH(...)
#define CONFIG_FEATURE_TOUCH_NODEREF 1
#define ENABLE_FEATURE_TOUCH_NODEREF 1
#ifdef MAKE_SUID
# define IF_FEATURE_TOUCH_NODEREF(...) __VA_ARGS__ "CONFIG_FEATURE_TOUCH_NODEREF"
#else
# 1776 "./include/autoconf.h"
# define IF_FEATURE_TOUCH_NODEREF(...) __VA_ARGS__
#endif
# 1778 "./include/autoconf.h"
#define IF_NOT_FEATURE_TOUCH_NODEREF(...)
#define CONFIG_FEATURE_TOUCH_SUSV3 1
#define ENABLE_FEATURE_TOUCH_SUSV3 1
#ifdef MAKE_SUID
# define IF_FEATURE_TOUCH_SUSV3(...) __VA_ARGS__ "CONFIG_FEATURE_TOUCH_SUSV3"
#else
# 1784 "./include/autoconf.h"
# define IF_FEATURE_TOUCH_SUSV3(...) __VA_ARGS__
#endif
# 1786 "./include/autoconf.h"
#define IF_NOT_FEATURE_TOUCH_SUSV3(...)
#define CONFIG_TR 1
#define ENABLE_TR 1
#ifdef MAKE_SUID
# define IF_TR(...) __VA_ARGS__ "CONFIG_TR"
#else
# 1792 "./include/autoconf.h"
# define IF_TR(...) __VA_ARGS__
#endif
# 1794 "./include/autoconf.h"
#define IF_NOT_TR(...)
#define CONFIG_FEATURE_TR_CLASSES 1
#define ENABLE_FEATURE_TR_CLASSES 1
#ifdef MAKE_SUID
# define IF_FEATURE_TR_CLASSES(...) __VA_ARGS__ "CONFIG_FEATURE_TR_CLASSES"
#else
# 1800 "./include/autoconf.h"
# define IF_FEATURE_TR_CLASSES(...) __VA_ARGS__
#endif
# 1802 "./include/autoconf.h"
#define IF_NOT_FEATURE_TR_CLASSES(...)
#define CONFIG_FEATURE_TR_EQUIV 1
#define ENABLE_FEATURE_TR_EQUIV 1
#ifdef MAKE_SUID
# define IF_FEATURE_TR_EQUIV(...) __VA_ARGS__ "CONFIG_FEATURE_TR_EQUIV"
#else
# 1808 "./include/autoconf.h"
# define IF_FEATURE_TR_EQUIV(...) __VA_ARGS__
#endif
# 1810 "./include/autoconf.h"
#define IF_NOT_FEATURE_TR_EQUIV(...)
#define CONFIG_TRUE 1
#define ENABLE_TRUE 1
#ifdef MAKE_SUID
# define IF_TRUE(...) __VA_ARGS__ "CONFIG_TRUE"
#else
# 1816 "./include/autoconf.h"
# define IF_TRUE(...) __VA_ARGS__
#endif
# 1818 "./include/autoconf.h"
#define IF_NOT_TRUE(...)
#define CONFIG_TRUNCATE 1
#define ENABLE_TRUNCATE 1
#ifdef MAKE_SUID
# define IF_TRUNCATE(...) __VA_ARGS__ "CONFIG_TRUNCATE"
#else
# 1824 "./include/autoconf.h"
# define IF_TRUNCATE(...) __VA_ARGS__
#endif
# 1826 "./include/autoconf.h"
#define IF_NOT_TRUNCATE(...)
#define CONFIG_TTY 1
#define ENABLE_TTY 1
#ifdef MAKE_SUID
# define IF_TTY(...) __VA_ARGS__ "CONFIG_TTY"
#else
# 1832 "./include/autoconf.h"
# define IF_TTY(...) __VA_ARGS__
#endif
# 1834 "./include/autoconf.h"
#define IF_NOT_TTY(...)
#define CONFIG_UNAME 1
#define ENABLE_UNAME 1
#ifdef MAKE_SUID
# define IF_UNAME(...) __VA_ARGS__ "CONFIG_UNAME"
#else
# 1840 "./include/autoconf.h"
# define IF_UNAME(...) __VA_ARGS__
#endif
# 1842 "./include/autoconf.h"
#define IF_NOT_UNAME(...)
#define CONFIG_UNAME_OSNAME "FreeBSD"
#define ENABLE_UNAME_OSNAME 1
#ifdef MAKE_SUID
# define IF_UNAME_OSNAME(...) __VA_ARGS__ "CONFIG_UNAME_OSNAME"
#else
# 1848 "./include/autoconf.h"
# define IF_UNAME_OSNAME(...) __VA_ARGS__
#endif
# 1850 "./include/autoconf.h"
#define IF_NOT_UNAME_OSNAME(...)
#define CONFIG_UNIQ 1
#define ENABLE_UNIQ 1
#ifdef MAKE_SUID
# define IF_UNIQ(...) __VA_ARGS__ "CONFIG_UNIQ"
#else
# 1856 "./include/autoconf.h"
# define IF_UNIQ(...) __VA_ARGS__
#endif
# 1858 "./include/autoconf.h"
#define IF_NOT_UNIQ(...)
#define CONFIG_UNLINK 1
#define ENABLE_UNLINK 1
#ifdef MAKE_SUID
# define IF_UNLINK(...) __VA_ARGS__ "CONFIG_UNLINK"
#else
# 1864 "./include/autoconf.h"
# define IF_UNLINK(...) __VA_ARGS__
#endif
# 1866 "./include/autoconf.h"
#define IF_NOT_UNLINK(...)
#define CONFIG_USLEEP 1
#define ENABLE_USLEEP 1
#ifdef MAKE_SUID
# define IF_USLEEP(...) __VA_ARGS__ "CONFIG_USLEEP"
#else
# 1872 "./include/autoconf.h"
# define IF_USLEEP(...) __VA_ARGS__
#endif
# 1874 "./include/autoconf.h"
#define IF_NOT_USLEEP(...)
#define CONFIG_UUDECODE 1
#define ENABLE_UUDECODE 1
#ifdef MAKE_SUID
# define IF_UUDECODE(...) __VA_ARGS__ "CONFIG_UUDECODE"
#else
# 1880 "./include/autoconf.h"
# define IF_UUDECODE(...) __VA_ARGS__
#endif
# 1882 "./include/autoconf.h"
#define IF_NOT_UUDECODE(...)
#undef CONFIG_BASE64
#define ENABLE_BASE64 0
#define IF_BASE64(...)
#define IF_NOT_BASE64(...) __VA_ARGS__
#define CONFIG_UUENCODE 1
#define ENABLE_UUENCODE 1
#ifdef MAKE_SUID
# define IF_UUENCODE(...) __VA_ARGS__ "CONFIG_UUENCODE"
#else
# 1892 "./include/autoconf.h"
# define IF_UUENCODE(...) __VA_ARGS__
#endif
# 1894 "./include/autoconf.h"
#define IF_NOT_UUENCODE(...)
#define CONFIG_WC 1
#define ENABLE_WC 1
#ifdef MAKE_SUID
# define IF_WC(...) __VA_ARGS__ "CONFIG_WC"
#else
# 1900 "./include/autoconf.h"
# define IF_WC(...) __VA_ARGS__
#endif
# 1902 "./include/autoconf.h"
#define IF_NOT_WC(...)
#define CONFIG_FEATURE_WC_LARGE 1
#define ENABLE_FEATURE_WC_LARGE 1
#ifdef MAKE_SUID
# define IF_FEATURE_WC_LARGE(...) __VA_ARGS__ "CONFIG_FEATURE_WC_LARGE"
#else
# 1908 "./include/autoconf.h"
# define IF_FEATURE_WC_LARGE(...) __VA_ARGS__
#endif
# 1910 "./include/autoconf.h"
#define IF_NOT_FEATURE_WC_LARGE(...)
#undef CONFIG_WHO
#define ENABLE_WHO 0
#define IF_WHO(...)
#define IF_NOT_WHO(...) __VA_ARGS__
#undef CONFIG_USERS
#define ENABLE_USERS 0
#define IF_USERS(...)
#define IF_NOT_USERS(...) __VA_ARGS__
#define CONFIG_WHOAMI 1
#define ENABLE_WHOAMI 1
#ifdef MAKE_SUID
# define IF_WHOAMI(...) __VA_ARGS__ "CONFIG_WHOAMI"
#else
# 1924 "./include/autoconf.h"
# define IF_WHOAMI(...) __VA_ARGS__
#endif
# 1926 "./include/autoconf.h"
#define IF_NOT_WHOAMI(...)
#define CONFIG_YES 1
#define ENABLE_YES 1
#ifdef MAKE_SUID
# define IF_YES(...) __VA_ARGS__ "CONFIG_YES"
#else
# 1932 "./include/autoconf.h"
# define IF_YES(...) __VA_ARGS__
#endif
# 1934 "./include/autoconf.h"
#define IF_NOT_YES(...)

/*
 * Common options
 */
#define CONFIG_FEATURE_VERBOSE 1
#define ENABLE_FEATURE_VERBOSE 1
#ifdef MAKE_SUID
# define IF_FEATURE_VERBOSE(...) __VA_ARGS__ "CONFIG_FEATURE_VERBOSE"
#else
# 1944 "./include/autoconf.h"
# define IF_FEATURE_VERBOSE(...) __VA_ARGS__
#endif
# 1946 "./include/autoconf.h"
#define IF_NOT_FEATURE_VERBOSE(...)

/*
 * Common options for cp and mv
 */
#define CONFIG_FEATURE_PRESERVE_HARDLINKS 1
#define ENABLE_FEATURE_PRESERVE_HARDLINKS 1
#ifdef MAKE_SUID
# define IF_FEATURE_PRESERVE_HARDLINKS(...) __VA_ARGS__ "CONFIG_FEATURE_PRESERVE_HARDLINKS"
#else
# 1956 "./include/autoconf.h"
# define IF_FEATURE_PRESERVE_HARDLINKS(...) __VA_ARGS__
#endif
# 1958 "./include/autoconf.h"
#define IF_NOT_FEATURE_PRESERVE_HARDLINKS(...)

/*
 * Common options for ls, more and telnet
 */
#define CONFIG_FEATURE_AUTOWIDTH 1
#define ENABLE_FEATURE_AUTOWIDTH 1
#ifdef MAKE_SUID
# define IF_FEATURE_AUTOWIDTH(...) __VA_ARGS__ "CONFIG_FEATURE_AUTOWIDTH"
#else
# 1968 "./include/autoconf.h"
# define IF_FEATURE_AUTOWIDTH(...) __VA_ARGS__
#endif
# 1970 "./include/autoconf.h"
#define IF_NOT_FEATURE_AUTOWIDTH(...)

/*
 * Common options for df, du, ls
 */
#define CONFIG_FEATURE_HUMAN_READABLE 1
#define ENABLE_FEATURE_HUMAN_READABLE 1
#ifdef MAKE_SUID
# define IF_FEATURE_HUMAN_READABLE(...) __VA_ARGS__ "CONFIG_FEATURE_HUMAN_READABLE"
#else
# 1980 "./include/autoconf.h"
# define IF_FEATURE_HUMAN_READABLE(...) __VA_ARGS__
#endif
# 1982 "./include/autoconf.h"
#define IF_NOT_FEATURE_HUMAN_READABLE(...)

/*
 * Console Utilities
 */
#undef CONFIG_CHVT
#define ENABLE_CHVT 0
#define IF_CHVT(...)
#define IF_NOT_CHVT(...) __VA_ARGS__
#define CONFIG_CLEAR 1
#define ENABLE_CLEAR 1
#ifdef MAKE_SUID
# define IF_CLEAR(...) __VA_ARGS__ "CONFIG_CLEAR"
#else
# 1996 "./include/autoconf.h"
# define IF_CLEAR(...) __VA_ARGS__
#endif
# 1998 "./include/autoconf.h"
#define IF_NOT_CLEAR(...)
#undef CONFIG_DEALLOCVT
#define ENABLE_DEALLOCVT 0
#define IF_DEALLOCVT(...)
#define IF_NOT_DEALLOCVT(...) __VA_ARGS__
#undef CONFIG_DUMPKMAP
#define ENABLE_DUMPKMAP 0
#define IF_DUMPKMAP(...)
#define IF_NOT_DUMPKMAP(...) __VA_ARGS__
#undef CONFIG_FGCONSOLE
#define ENABLE_FGCONSOLE 0
#define IF_FGCONSOLE(...)
#define IF_NOT_FGCONSOLE(...) __VA_ARGS__
#undef CONFIG_KBD_MODE
#define ENABLE_KBD_MODE 0
#define IF_KBD_MODE(...)
#define IF_NOT_KBD_MODE(...) __VA_ARGS__
#undef CONFIG_LOADFONT
#define ENABLE_LOADFONT 0
#define IF_LOADFONT(...)
#define IF_NOT_LOADFONT(...) __VA_ARGS__
#undef CONFIG_SETFONT
#define ENABLE_SETFONT 0
#define IF_SETFONT(...)
#define IF_NOT_SETFONT(...) __VA_ARGS__
#undef CONFIG_FEATURE_SETFONT_TEXTUAL_MAP
#define ENABLE_FEATURE_SETFONT_TEXTUAL_MAP 0
#define IF_FEATURE_SETFONT_TEXTUAL_MAP(...)
#define IF_NOT_FEATURE_SETFONT_TEXTUAL_MAP(...) __VA_ARGS__
#define CONFIG_DEFAULT_SETFONT_DIR ""
#define ENABLE_DEFAULT_SETFONT_DIR 1
#ifdef MAKE_SUID
# define IF_DEFAULT_SETFONT_DIR(...) __VA_ARGS__ "CONFIG_DEFAULT_SETFONT_DIR"
#else
# 2032 "./include/autoconf.h"
# define IF_DEFAULT_SETFONT_DIR(...) __VA_ARGS__
#endif
# 2034 "./include/autoconf.h"
#define IF_NOT_DEFAULT_SETFONT_DIR(...)
#undef CONFIG_FEATURE_LOADFONT_PSF2
#define ENABLE_FEATURE_LOADFONT_PSF2 0
#define IF_FEATURE_LOADFONT_PSF2(...)
#define IF_NOT_FEATURE_LOADFONT_PSF2(...) __VA_ARGS__
#undef CONFIG_FEATURE_LOADFONT_RAW
#define ENABLE_FEATURE_LOADFONT_RAW 0
#define IF_FEATURE_LOADFONT_RAW(...)
#define IF_NOT_FEATURE_LOADFONT_RAW(...) __VA_ARGS__
#undef CONFIG_LOADKMAP
#define ENABLE_LOADKMAP 0
#define IF_LOADKMAP(...)
#define IF_NOT_LOADKMAP(...) __VA_ARGS__
#undef CONFIG_OPENVT
#define ENABLE_OPENVT 0
#define IF_OPENVT(...)
#define IF_NOT_OPENVT(...) __VA_ARGS__
#define CONFIG_RESET 1
#define ENABLE_RESET 1
#ifdef MAKE_SUID
# define IF_RESET(...) __VA_ARGS__ "CONFIG_RESET"
#else
# 2056 "./include/autoconf.h"
# define IF_RESET(...) __VA_ARGS__
#endif
# 2058 "./include/autoconf.h"
#define IF_NOT_RESET(...)
#define CONFIG_RESIZE 1
#define ENABLE_RESIZE 1
#ifdef MAKE_SUID
# define IF_RESIZE(...) __VA_ARGS__ "CONFIG_RESIZE"
#else
# 2064 "./include/autoconf.h"
# define IF_RESIZE(...) __VA_ARGS__
#endif
# 2066 "./include/autoconf.h"
#define IF_NOT_RESIZE(...)
#define CONFIG_FEATURE_RESIZE_PRINT 1
#define ENABLE_FEATURE_RESIZE_PRINT 1
#ifdef MAKE_SUID
# define IF_FEATURE_RESIZE_PRINT(...) __VA_ARGS__ "CONFIG_FEATURE_RESIZE_PRINT"
#else
# 2072 "./include/autoconf.h"
# define IF_FEATURE_RESIZE_PRINT(...) __VA_ARGS__
#endif
# 2074 "./include/autoconf.h"
#define IF_NOT_FEATURE_RESIZE_PRINT(...)
#undef CONFIG_SETCONSOLE
#define ENABLE_SETCONSOLE 0
#define IF_SETCONSOLE(...)
#define IF_NOT_SETCONSOLE(...) __VA_ARGS__
#undef CONFIG_FEATURE_SETCONSOLE_LONG_OPTIONS
#define ENABLE_FEATURE_SETCONSOLE_LONG_OPTIONS 0
#define IF_FEATURE_SETCONSOLE_LONG_OPTIONS(...)
#define IF_NOT_FEATURE_SETCONSOLE_LONG_OPTIONS(...) __VA_ARGS__
#undef CONFIG_SETKEYCODES
#define ENABLE_SETKEYCODES 0
#define IF_SETKEYCODES(...)
#define IF_NOT_SETKEYCODES(...) __VA_ARGS__
#undef CONFIG_SETLOGCONS
#define ENABLE_SETLOGCONS 0
#define IF_SETLOGCONS(...)
#define IF_NOT_SETLOGCONS(...) __VA_ARGS__
#undef CONFIG_SHOWKEY
#define ENABLE_SHOWKEY 0
#define IF_SHOWKEY(...)
#define IF_NOT_SHOWKEY(...) __VA_ARGS__

/*
 * Debian Utilities
 */
#define CONFIG_MKTEMP 1
#define ENABLE_MKTEMP 1
#ifdef MAKE_SUID
# define IF_MKTEMP(...) __VA_ARGS__ "CONFIG_MKTEMP"
#else
# 2104 "./include/autoconf.h"
# define IF_MKTEMP(...) __VA_ARGS__
#endif
# 2106 "./include/autoconf.h"
#define IF_NOT_MKTEMP(...)
#define CONFIG_PIPE_PROGRESS 1
#define ENABLE_PIPE_PROGRESS 1
#ifdef MAKE_SUID
# define IF_PIPE_PROGRESS(...) __VA_ARGS__ "CONFIG_PIPE_PROGRESS"
#else
# 2112 "./include/autoconf.h"
# define IF_PIPE_PROGRESS(...) __VA_ARGS__
#endif
# 2114 "./include/autoconf.h"
#define IF_NOT_PIPE_PROGRESS(...)
#define CONFIG_RUN_PARTS 1
#define ENABLE_RUN_PARTS 1
#ifdef MAKE_SUID
# define IF_RUN_PARTS(...) __VA_ARGS__ "CONFIG_RUN_PARTS"
#else
# 2120 "./include/autoconf.h"
# define IF_RUN_PARTS(...) __VA_ARGS__
#endif
# 2122 "./include/autoconf.h"
#define IF_NOT_RUN_PARTS(...)
#define CONFIG_FEATURE_RUN_PARTS_LONG_OPTIONS 1
#define ENABLE_FEATURE_RUN_PARTS_LONG_OPTIONS 1
#ifdef MAKE_SUID
# define IF_FEATURE_RUN_PARTS_LONG_OPTIONS(...) __VA_ARGS__ "CONFIG_FEATURE_RUN_PARTS_LONG_OPTIONS"
#else
# 2128 "./include/autoconf.h"
# define IF_FEATURE_RUN_PARTS_LONG_OPTIONS(...) __VA_ARGS__
#endif
# 2130 "./include/autoconf.h"
#define IF_NOT_FEATURE_RUN_PARTS_LONG_OPTIONS(...)
#define CONFIG_FEATURE_RUN_PARTS_FANCY 1
#define ENABLE_FEATURE_RUN_PARTS_FANCY 1
#ifdef MAKE_SUID
# define IF_FEATURE_RUN_PARTS_FANCY(...) __VA_ARGS__ "CONFIG_FEATURE_RUN_PARTS_FANCY"
#else
# 2136 "./include/autoconf.h"
# define IF_FEATURE_RUN_PARTS_FANCY(...) __VA_ARGS__
#endif
# 2138 "./include/autoconf.h"
#define IF_NOT_FEATURE_RUN_PARTS_FANCY(...)
#undef CONFIG_START_STOP_DAEMON
#define ENABLE_START_STOP_DAEMON 0
#define IF_START_STOP_DAEMON(...)
#define IF_NOT_START_STOP_DAEMON(...) __VA_ARGS__
#undef CONFIG_FEATURE_START_STOP_DAEMON_FANCY
#define ENABLE_FEATURE_START_STOP_DAEMON_FANCY 0
#define IF_FEATURE_START_STOP_DAEMON_FANCY(...)
#define IF_NOT_FEATURE_START_STOP_DAEMON_FANCY(...) __VA_ARGS__
#undef CONFIG_FEATURE_START_STOP_DAEMON_LONG_OPTIONS
#define ENABLE_FEATURE_START_STOP_DAEMON_LONG_OPTIONS 0
#define IF_FEATURE_START_STOP_DAEMON_LONG_OPTIONS(...)
#define IF_NOT_FEATURE_START_STOP_DAEMON_LONG_OPTIONS(...) __VA_ARGS__
#define CONFIG_WHICH 1
#define ENABLE_WHICH 1
#ifdef MAKE_SUID
# define IF_WHICH(...) __VA_ARGS__ "CONFIG_WHICH"
#else
# 2156 "./include/autoconf.h"
# define IF_WHICH(...) __VA_ARGS__
#endif
# 2158 "./include/autoconf.h"
#define IF_NOT_WHICH(...)

/*
 * Editors
 */
#define CONFIG_AWK 1
#define ENABLE_AWK 1
#ifdef MAKE_SUID
# define IF_AWK(...) __VA_ARGS__ "CONFIG_AWK"
#else
# 2168 "./include/autoconf.h"
# define IF_AWK(...) __VA_ARGS__
#endif
# 2170 "./include/autoconf.h"
#define IF_NOT_AWK(...)
#define CONFIG_FEATURE_AWK_LIBM 1
#define ENABLE_FEATURE_AWK_LIBM 1
#ifdef MAKE_SUID
# define IF_FEATURE_AWK_LIBM(...) __VA_ARGS__ "CONFIG_FEATURE_AWK_LIBM"
#else
# 2176 "./include/autoconf.h"
# define IF_FEATURE_AWK_LIBM(...) __VA_ARGS__
#endif
# 2178 "./include/autoconf.h"
#define IF_NOT_FEATURE_AWK_LIBM(...)
#define CONFIG_FEATURE_AWK_GNU_EXTENSIONS 1
#define ENABLE_FEATURE_AWK_GNU_EXTENSIONS 1
#ifdef MAKE_SUID
# define IF_FEATURE_AWK_GNU_EXTENSIONS(...) __VA_ARGS__ "CONFIG_FEATURE_AWK_GNU_EXTENSIONS"
#else
# 2184 "./include/autoconf.h"
# define IF_FEATURE_AWK_GNU_EXTENSIONS(...) __VA_ARGS__
#endif
# 2186 "./include/autoconf.h"
#define IF_NOT_FEATURE_AWK_GNU_EXTENSIONS(...)
#define CONFIG_CMP 1
#define ENABLE_CMP 1
#ifdef MAKE_SUID
# define IF_CMP(...) __VA_ARGS__ "CONFIG_CMP"
#else
# 2192 "./include/autoconf.h"
# define IF_CMP(...) __VA_ARGS__
#endif
# 2194 "./include/autoconf.h"
#define IF_NOT_CMP(...)
#define CONFIG_DIFF 1
#define ENABLE_DIFF 1
#ifdef MAKE_SUID
# define IF_DIFF(...) __VA_ARGS__ "CONFIG_DIFF"
#else
# 2200 "./include/autoconf.h"
# define IF_DIFF(...) __VA_ARGS__
#endif
# 2202 "./include/autoconf.h"
#define IF_NOT_DIFF(...)
#define CONFIG_FEATURE_DIFF_LONG_OPTIONS 1
#define ENABLE_FEATURE_DIFF_LONG_OPTIONS 1
#ifdef MAKE_SUID
# define IF_FEATURE_DIFF_LONG_OPTIONS(...) __VA_ARGS__ "CONFIG_FEATURE_DIFF_LONG_OPTIONS"
#else
# 2208 "./include/autoconf.h"
# define IF_FEATURE_DIFF_LONG_OPTIONS(...) __VA_ARGS__
#endif
# 2210 "./include/autoconf.h"
#define IF_NOT_FEATURE_DIFF_LONG_OPTIONS(...)
#define CONFIG_FEATURE_DIFF_DIR 1
#define ENABLE_FEATURE_DIFF_DIR 1
#ifdef MAKE_SUID
# define IF_FEATURE_DIFF_DIR(...) __VA_ARGS__ "CONFIG_FEATURE_DIFF_DIR"
#else
# 2216 "./include/autoconf.h"
# define IF_FEATURE_DIFF_DIR(...) __VA_ARGS__
#endif
# 2218 "./include/autoconf.h"
#define IF_NOT_FEATURE_DIFF_DIR(...)
#define CONFIG_ED 1
#define ENABLE_ED 1
#ifdef MAKE_SUID
# define IF_ED(...) __VA_ARGS__ "CONFIG_ED"
#else
# 2224 "./include/autoconf.h"
# define IF_ED(...) __VA_ARGS__
#endif
# 2226 "./include/autoconf.h"
#define IF_NOT_ED(...)
#define CONFIG_PATCH 1
#define ENABLE_PATCH 1
#ifdef MAKE_SUID
# define IF_PATCH(...) __VA_ARGS__ "CONFIG_PATCH"
#else
# 2232 "./include/autoconf.h"
# define IF_PATCH(...) __VA_ARGS__
#endif
# 2234 "./include/autoconf.h"
#define IF_NOT_PATCH(...)
#define CONFIG_SED 1
#define ENABLE_SED 1
#ifdef MAKE_SUID
# define IF_SED(...) __VA_ARGS__ "CONFIG_SED"
#else
# 2240 "./include/autoconf.h"
# define IF_SED(...) __VA_ARGS__
#endif
# 2242 "./include/autoconf.h"
#define IF_NOT_SED(...)
#define CONFIG_VI 1
#define ENABLE_VI 1
#ifdef MAKE_SUID
# define IF_VI(...) __VA_ARGS__ "CONFIG_VI"
#else
# 2248 "./include/autoconf.h"
# define IF_VI(...) __VA_ARGS__
#endif
# 2250 "./include/autoconf.h"
#define IF_NOT_VI(...)
#define CONFIG_FEATURE_VI_MAX_LEN 1024
#define ENABLE_FEATURE_VI_MAX_LEN 1
#ifdef MAKE_SUID
# define IF_FEATURE_VI_MAX_LEN(...) __VA_ARGS__ "CONFIG_FEATURE_VI_MAX_LEN"
#else
# 2256 "./include/autoconf.h"
# define IF_FEATURE_VI_MAX_LEN(...) __VA_ARGS__
#endif
# 2258 "./include/autoconf.h"
#define IF_NOT_FEATURE_VI_MAX_LEN(...)
#define CONFIG_FEATURE_VI_8BIT 1
#define ENABLE_FEATURE_VI_8BIT 1
#ifdef MAKE_SUID
# define IF_FEATURE_VI_8BIT(...) __VA_ARGS__ "CONFIG_FEATURE_VI_8BIT"
#else
# 2264 "./include/autoconf.h"
# define IF_FEATURE_VI_8BIT(...) __VA_ARGS__
#endif
# 2266 "./include/autoconf.h"
#define IF_NOT_FEATURE_VI_8BIT(...)
#define CONFIG_FEATURE_VI_COLON 1
#define ENABLE_FEATURE_VI_COLON 1
#ifdef MAKE_SUID
# define IF_FEATURE_VI_COLON(...) __VA_ARGS__ "CONFIG_FEATURE_VI_COLON"
#else
# 2272 "./include/autoconf.h"
# define IF_FEATURE_VI_COLON(...) __VA_ARGS__
#endif
# 2274 "./include/autoconf.h"
#define IF_NOT_FEATURE_VI_COLON(...)
#define CONFIG_FEATURE_VI_YANKMARK 1
#define ENABLE_FEATURE_VI_YANKMARK 1
#ifdef MAKE_SUID
# define IF_FEATURE_VI_YANKMARK(...) __VA_ARGS__ "CONFIG_FEATURE_VI_YANKMARK"
#else
# 2280 "./include/autoconf.h"
# define IF_FEATURE_VI_YANKMARK(...) __VA_ARGS__
#endif
# 2282 "./include/autoconf.h"
#define IF_NOT_FEATURE_VI_YANKMARK(...)
#define CONFIG_FEATURE_VI_SEARCH 1
#define ENABLE_FEATURE_VI_SEARCH 1
#ifdef MAKE_SUID
# define IF_FEATURE_VI_SEARCH(...) __VA_ARGS__ "CONFIG_FEATURE_VI_SEARCH"
#else
# 2288 "./include/autoconf.h"
# define IF_FEATURE_VI_SEARCH(...) __VA_ARGS__
#endif
# 2290 "./include/autoconf.h"
#define IF_NOT_FEATURE_VI_SEARCH(...)
#undef CONFIG_FEATURE_VI_REGEX_SEARCH
#define ENABLE_FEATURE_VI_REGEX_SEARCH 0
#define IF_FEATURE_VI_REGEX_SEARCH(...)
#define IF_NOT_FEATURE_VI_REGEX_SEARCH(...) __VA_ARGS__
#define CONFIG_FEATURE_VI_USE_SIGNALS 1
#define ENABLE_FEATURE_VI_USE_SIGNALS 1
#ifdef MAKE_SUID
# define IF_FEATURE_VI_USE_SIGNALS(...) __VA_ARGS__ "CONFIG_FEATURE_VI_USE_SIGNALS"
#else
# 2300 "./include/autoconf.h"
# define IF_FEATURE_VI_USE_SIGNALS(...) __VA_ARGS__
#endif
# 2302 "./include/autoconf.h"
#define IF_NOT_FEATURE_VI_USE_SIGNALS(...)
#define CONFIG_FEATURE_VI_DOT_CMD 1
#define ENABLE_FEATURE_VI_DOT_CMD 1
#ifdef MAKE_SUID
# define IF_FEATURE_VI_DOT_CMD(...) __VA_ARGS__ "CONFIG_FEATURE_VI_DOT_CMD"
#else
# 2308 "./include/autoconf.h"
# define IF_FEATURE_VI_DOT_CMD(...) __VA_ARGS__
#endif
# 2310 "./include/autoconf.h"
#define IF_NOT_FEATURE_VI_DOT_CMD(...)
#define CONFIG_FEATURE_VI_READONLY 1
#define ENABLE_FEATURE_VI_READONLY 1
#ifdef MAKE_SUID
# define IF_FEATURE_VI_READONLY(...) __VA_ARGS__ "CONFIG_FEATURE_VI_READONLY"
#else
# 2316 "./include/autoconf.h"
# define IF_FEATURE_VI_READONLY(...) __VA_ARGS__
#endif
# 2318 "./include/autoconf.h"
#define IF_NOT_FEATURE_VI_READONLY(...)
#define CONFIG_FEATURE_VI_SETOPTS 1
#define ENABLE_FEATURE_VI_SETOPTS 1
#ifdef MAKE_SUID
# define IF_FEATURE_VI_SETOPTS(...) __VA_ARGS__ "CONFIG_FEATURE_VI_SETOPTS"
#else
# 2324 "./include/autoconf.h"
# define IF_FEATURE_VI_SETOPTS(...) __VA_ARGS__
#endif
# 2326 "./include/autoconf.h"
#define IF_NOT_FEATURE_VI_SETOPTS(...)
#define CONFIG_FEATURE_VI_SET 1
#define ENABLE_FEATURE_VI_SET 1
#ifdef MAKE_SUID
# define IF_FEATURE_VI_SET(...) __VA_ARGS__ "CONFIG_FEATURE_VI_SET"
#else
# 2332 "./include/autoconf.h"
# define IF_FEATURE_VI_SET(...) __VA_ARGS__
#endif
# 2334 "./include/autoconf.h"
#define IF_NOT_FEATURE_VI_SET(...)
#define CONFIG_FEATURE_VI_WIN_RESIZE 1
#define ENABLE_FEATURE_VI_WIN_RESIZE 1
#ifdef MAKE_SUID
# define IF_FEATURE_VI_WIN_RESIZE(...) __VA_ARGS__ "CONFIG_FEATURE_VI_WIN_RESIZE"
#else
# 2340 "./include/autoconf.h"
# define IF_FEATURE_VI_WIN_RESIZE(...) __VA_ARGS__
#endif
# 2342 "./include/autoconf.h"
#define IF_NOT_FEATURE_VI_WIN_RESIZE(...)
#define CONFIG_FEATURE_VI_ASK_TERMINAL 1
#define ENABLE_FEATURE_VI_ASK_TERMINAL 1
#ifdef MAKE_SUID
# define IF_FEATURE_VI_ASK_TERMINAL(...) __VA_ARGS__ "CONFIG_FEATURE_VI_ASK_TERMINAL"
#else
# 2348 "./include/autoconf.h"
# define IF_FEATURE_VI_ASK_TERMINAL(...) __VA_ARGS__
#endif
# 2350 "./include/autoconf.h"
#define IF_NOT_FEATURE_VI_ASK_TERMINAL(...)
#define CONFIG_FEATURE_VI_UNDO 1
#define ENABLE_FEATURE_VI_UNDO 1
#ifdef MAKE_SUID
# define IF_FEATURE_VI_UNDO(...) __VA_ARGS__ "CONFIG_FEATURE_VI_UNDO"
#else
# 2356 "./include/autoconf.h"
# define IF_FEATURE_VI_UNDO(...) __VA_ARGS__
#endif
# 2358 "./include/autoconf.h"
#define IF_NOT_FEATURE_VI_UNDO(...)
#define CONFIG_FEATURE_VI_UNDO_QUEUE 1
#define ENABLE_FEATURE_VI_UNDO_QUEUE 1
#ifdef MAKE_SUID
# define IF_FEATURE_VI_UNDO_QUEUE(...) __VA_ARGS__ "CONFIG_FEATURE_VI_UNDO_QUEUE"
#else
# 2364 "./include/autoconf.h"
# define IF_FEATURE_VI_UNDO_QUEUE(...) __VA_ARGS__
#endif
# 2366 "./include/autoconf.h"
#define IF_NOT_FEATURE_VI_UNDO_QUEUE(...)
#define CONFIG_FEATURE_VI_UNDO_QUEUE_MAX 256
#define ENABLE_FEATURE_VI_UNDO_QUEUE_MAX 1
#ifdef MAKE_SUID
# define IF_FEATURE_VI_UNDO_QUEUE_MAX(...) __VA_ARGS__ "CONFIG_FEATURE_VI_UNDO_QUEUE_MAX"
#else
# 2372 "./include/autoconf.h"
# define IF_FEATURE_VI_UNDO_QUEUE_MAX(...) __VA_ARGS__
#endif
# 2374 "./include/autoconf.h"
#define IF_NOT_FEATURE_VI_UNDO_QUEUE_MAX(...)
#define CONFIG_FEATURE_ALLOW_EXEC 1
#define ENABLE_FEATURE_ALLOW_EXEC 1
#ifdef MAKE_SUID
# define IF_FEATURE_ALLOW_EXEC(...) __VA_ARGS__ "CONFIG_FEATURE_ALLOW_EXEC"
#else
# 2380 "./include/autoconf.h"
# define IF_FEATURE_ALLOW_EXEC(...) __VA_ARGS__
#endif
# 2382 "./include/autoconf.h"
#define IF_NOT_FEATURE_ALLOW_EXEC(...)

/*
 * Finding Utilities
 */
#define CONFIG_FIND 1
#define ENABLE_FIND 1
#ifdef MAKE_SUID
# define IF_FIND(...) __VA_ARGS__ "CONFIG_FIND"
#else
# 2392 "./include/autoconf.h"
# define IF_FIND(...) __VA_ARGS__
#endif
# 2394 "./include/autoconf.h"
#define IF_NOT_FIND(...)
#define CONFIG_FEATURE_FIND_PRINT0 1
#define ENABLE_FEATURE_FIND_PRINT0 1
#ifdef MAKE_SUID
# define IF_FEATURE_FIND_PRINT0(...) __VA_ARGS__ "CONFIG_FEATURE_FIND_PRINT0"
#else
# 2400 "./include/autoconf.h"
# define IF_FEATURE_FIND_PRINT0(...) __VA_ARGS__
#endif
# 2402 "./include/autoconf.h"
#define IF_NOT_FEATURE_FIND_PRINT0(...)
#define CONFIG_FEATURE_FIND_MTIME 1
#define ENABLE_FEATURE_FIND_MTIME 1
#ifdef MAKE_SUID
# define IF_FEATURE_FIND_MTIME(...) __VA_ARGS__ "CONFIG_FEATURE_FIND_MTIME"
#else
# 2408 "./include/autoconf.h"
# define IF_FEATURE_FIND_MTIME(...) __VA_ARGS__
#endif
# 2410 "./include/autoconf.h"
#define IF_NOT_FEATURE_FIND_MTIME(...)
#define CONFIG_FEATURE_FIND_MMIN 1
#define ENABLE_FEATURE_FIND_MMIN 1
#ifdef MAKE_SUID
# define IF_FEATURE_FIND_MMIN(...) __VA_ARGS__ "CONFIG_FEATURE_FIND_MMIN"
#else
# 2416 "./include/autoconf.h"
# define IF_FEATURE_FIND_MMIN(...) __VA_ARGS__
#endif
# 2418 "./include/autoconf.h"
#define IF_NOT_FEATURE_FIND_MMIN(...)
#define CONFIG_FEATURE_FIND_PERM 1
#define ENABLE_FEATURE_FIND_PERM 1
#ifdef MAKE_SUID
# define IF_FEATURE_FIND_PERM(...) __VA_ARGS__ "CONFIG_FEATURE_FIND_PERM"
#else
# 2424 "./include/autoconf.h"
# define IF_FEATURE_FIND_PERM(...) __VA_ARGS__
#endif
# 2426 "./include/autoconf.h"
#define IF_NOT_FEATURE_FIND_PERM(...)
#define CONFIG_FEATURE_FIND_TYPE 1
#define ENABLE_FEATURE_FIND_TYPE 1
#ifdef MAKE_SUID
# define IF_FEATURE_FIND_TYPE(...) __VA_ARGS__ "CONFIG_FEATURE_FIND_TYPE"
#else
# 2432 "./include/autoconf.h"
# define IF_FEATURE_FIND_TYPE(...) __VA_ARGS__
#endif
# 2434 "./include/autoconf.h"
#define IF_NOT_FEATURE_FIND_TYPE(...)
#define CONFIG_FEATURE_FIND_XDEV 1
#define ENABLE_FEATURE_FIND_XDEV 1
#ifdef MAKE_SUID
# define IF_FEATURE_FIND_XDEV(...) __VA_ARGS__ "CONFIG_FEATURE_FIND_XDEV"
#else
# 2440 "./include/autoconf.h"
# define IF_FEATURE_FIND_XDEV(...) __VA_ARGS__
#endif
# 2442 "./include/autoconf.h"
#define IF_NOT_FEATURE_FIND_XDEV(...)
#define CONFIG_FEATURE_FIND_MAXDEPTH 1
#define ENABLE_FEATURE_FIND_MAXDEPTH 1
#ifdef MAKE_SUID
# define IF_FEATURE_FIND_MAXDEPTH(...) __VA_ARGS__ "CONFIG_FEATURE_FIND_MAXDEPTH"
#else
# 2448 "./include/autoconf.h"
# define IF_FEATURE_FIND_MAXDEPTH(...) __VA_ARGS__
#endif
# 2450 "./include/autoconf.h"
#define IF_NOT_FEATURE_FIND_MAXDEPTH(...)
#define CONFIG_FEATURE_FIND_NEWER 1
#define ENABLE_FEATURE_FIND_NEWER 1
#ifdef MAKE_SUID
# define IF_FEATURE_FIND_NEWER(...) __VA_ARGS__ "CONFIG_FEATURE_FIND_NEWER"
#else
# 2456 "./include/autoconf.h"
# define IF_FEATURE_FIND_NEWER(...) __VA_ARGS__
#endif
# 2458 "./include/autoconf.h"
#define IF_NOT_FEATURE_FIND_NEWER(...)
#define CONFIG_FEATURE_FIND_INUM 1
#define ENABLE_FEATURE_FIND_INUM 1
#ifdef MAKE_SUID
# define IF_FEATURE_FIND_INUM(...) __VA_ARGS__ "CONFIG_FEATURE_FIND_INUM"
#else
# 2464 "./include/autoconf.h"
# define IF_FEATURE_FIND_INUM(...) __VA_ARGS__
#endif
# 2466 "./include/autoconf.h"
#define IF_NOT_FEATURE_FIND_INUM(...)
#define CONFIG_FEATURE_FIND_EXEC 1
#define ENABLE_FEATURE_FIND_EXEC 1
#ifdef MAKE_SUID
# define IF_FEATURE_FIND_EXEC(...) __VA_ARGS__ "CONFIG_FEATURE_FIND_EXEC"
#else
# 2472 "./include/autoconf.h"
# define IF_FEATURE_FIND_EXEC(...) __VA_ARGS__
#endif
# 2474 "./include/autoconf.h"
#define IF_NOT_FEATURE_FIND_EXEC(...)
#define CONFIG_FEATURE_FIND_EXEC_PLUS 1
#define ENABLE_FEATURE_FIND_EXEC_PLUS 1
#ifdef MAKE_SUID
# define IF_FEATURE_FIND_EXEC_PLUS(...) __VA_ARGS__ "CONFIG_FEATURE_FIND_EXEC_PLUS"
#else
# 2480 "./include/autoconf.h"
# define IF_FEATURE_FIND_EXEC_PLUS(...) __VA_ARGS__
#endif
# 2482 "./include/autoconf.h"
#define IF_NOT_FEATURE_FIND_EXEC_PLUS(...)
#define CONFIG_FEATURE_FIND_USER 1
#define ENABLE_FEATURE_FIND_USER 1
#ifdef MAKE_SUID
# define IF_FEATURE_FIND_USER(...) __VA_ARGS__ "CONFIG_FEATURE_FIND_USER"
#else
# 2488 "./include/autoconf.h"
# define IF_FEATURE_FIND_USER(...) __VA_ARGS__
#endif
# 2490 "./include/autoconf.h"
#define IF_NOT_FEATURE_FIND_USER(...)
#define CONFIG_FEATURE_FIND_GROUP 1
#define ENABLE_FEATURE_FIND_GROUP 1
#ifdef MAKE_SUID
# define IF_FEATURE_FIND_GROUP(...) __VA_ARGS__ "CONFIG_FEATURE_FIND_GROUP"
#else
# 2496 "./include/autoconf.h"
# define IF_FEATURE_FIND_GROUP(...) __VA_ARGS__
#endif
# 2498 "./include/autoconf.h"
#define IF_NOT_FEATURE_FIND_GROUP(...)
#define CONFIG_FEATURE_FIND_NOT 1
#define ENABLE_FEATURE_FIND_NOT 1
#ifdef MAKE_SUID
# define IF_FEATURE_FIND_NOT(...) __VA_ARGS__ "CONFIG_FEATURE_FIND_NOT"
#else
# 2504 "./include/autoconf.h"
# define IF_FEATURE_FIND_NOT(...) __VA_ARGS__
#endif
# 2506 "./include/autoconf.h"
#define IF_NOT_FEATURE_FIND_NOT(...)
#define CONFIG_FEATURE_FIND_DEPTH 1
#define ENABLE_FEATURE_FIND_DEPTH 1
#ifdef MAKE_SUID
# define IF_FEATURE_FIND_DEPTH(...) __VA_ARGS__ "CONFIG_FEATURE_FIND_DEPTH"
#else
# 2512 "./include/autoconf.h"
# define IF_FEATURE_FIND_DEPTH(...) __VA_ARGS__
#endif
# 2514 "./include/autoconf.h"
#define IF_NOT_FEATURE_FIND_DEPTH(...)
#define CONFIG_FEATURE_FIND_PAREN 1
#define ENABLE_FEATURE_FIND_PAREN 1
#ifdef MAKE_SUID
# define IF_FEATURE_FIND_PAREN(...) __VA_ARGS__ "CONFIG_FEATURE_FIND_PAREN"
#else
# 2520 "./include/autoconf.h"
# define IF_FEATURE_FIND_PAREN(...) __VA_ARGS__
#endif
# 2522 "./include/autoconf.h"
#define IF_NOT_FEATURE_FIND_PAREN(...)
#define CONFIG_FEATURE_FIND_SIZE 1
#define ENABLE_FEATURE_FIND_SIZE 1
#ifdef MAKE_SUID
# define IF_FEATURE_FIND_SIZE(...) __VA_ARGS__ "CONFIG_FEATURE_FIND_SIZE"
#else
# 2528 "./include/autoconf.h"
# define IF_FEATURE_FIND_SIZE(...) __VA_ARGS__
#endif
# 2530 "./include/autoconf.h"
#define IF_NOT_FEATURE_FIND_SIZE(...)
#define CONFIG_FEATURE_FIND_PRUNE 1
#define ENABLE_FEATURE_FIND_PRUNE 1
#ifdef MAKE_SUID
# define IF_FEATURE_FIND_PRUNE(...) __VA_ARGS__ "CONFIG_FEATURE_FIND_PRUNE"
#else
# 2536 "./include/autoconf.h"
# define IF_FEATURE_FIND_PRUNE(...) __VA_ARGS__
#endif
# 2538 "./include/autoconf.h"
#define IF_NOT_FEATURE_FIND_PRUNE(...)
#define CONFIG_FEATURE_FIND_DELETE 1
#define ENABLE_FEATURE_FIND_DELETE 1
#ifdef MAKE_SUID
# define IF_FEATURE_FIND_DELETE(...) __VA_ARGS__ "CONFIG_FEATURE_FIND_DELETE"
#else
# 2544 "./include/autoconf.h"
# define IF_FEATURE_FIND_DELETE(...) __VA_ARGS__
#endif
# 2546 "./include/autoconf.h"
#define IF_NOT_FEATURE_FIND_DELETE(...)
#define CONFIG_FEATURE_FIND_PATH 1
#define ENABLE_FEATURE_FIND_PATH 1
#ifdef MAKE_SUID
# define IF_FEATURE_FIND_PATH(...) __VA_ARGS__ "CONFIG_FEATURE_FIND_PATH"
#else
# 2552 "./include/autoconf.h"
# define IF_FEATURE_FIND_PATH(...) __VA_ARGS__
#endif
# 2554 "./include/autoconf.h"
#define IF_NOT_FEATURE_FIND_PATH(...)
#define CONFIG_FEATURE_FIND_REGEX 1
#define ENABLE_FEATURE_FIND_REGEX 1
#ifdef MAKE_SUID
# define IF_FEATURE_FIND_REGEX(...) __VA_ARGS__ "CONFIG_FEATURE_FIND_REGEX"
#else
# 2560 "./include/autoconf.h"
# define IF_FEATURE_FIND_REGEX(...) __VA_ARGS__
#endif
# 2562 "./include/autoconf.h"
#define IF_NOT_FEATURE_FIND_REGEX(...)
#undef CONFIG_FEATURE_FIND_CONTEXT
#define ENABLE_FEATURE_FIND_CONTEXT 0
#define IF_FEATURE_FIND_CONTEXT(...)
#define IF_NOT_FEATURE_FIND_CONTEXT(...) __VA_ARGS__
#define CONFIG_FEATURE_FIND_LINKS 1
#define ENABLE_FEATURE_FIND_LINKS 1
#ifdef MAKE_SUID
# define IF_FEATURE_FIND_LINKS(...) __VA_ARGS__ "CONFIG_FEATURE_FIND_LINKS"
#else
# 2572 "./include/autoconf.h"
# define IF_FEATURE_FIND_LINKS(...) __VA_ARGS__
#endif
# 2574 "./include/autoconf.h"
#define IF_NOT_FEATURE_FIND_LINKS(...)
#define CONFIG_GREP 1
#define ENABLE_GREP 1
#ifdef MAKE_SUID
# define IF_GREP(...) __VA_ARGS__ "CONFIG_GREP"
#else
# 2580 "./include/autoconf.h"
# define IF_GREP(...) __VA_ARGS__
#endif
# 2582 "./include/autoconf.h"
#define IF_NOT_GREP(...)
#undef CONFIG_EGREP
#define ENABLE_EGREP 0
#define IF_EGREP(...)
#define IF_NOT_EGREP(...) __VA_ARGS__
#undef CONFIG_FGREP
#define ENABLE_FGREP 0
#define IF_FGREP(...)
#define IF_NOT_FGREP(...) __VA_ARGS__
#define CONFIG_FEATURE_GREP_CONTEXT 1
#define ENABLE_FEATURE_GREP_CONTEXT 1
#ifdef MAKE_SUID
# define IF_FEATURE_GREP_CONTEXT(...) __VA_ARGS__ "CONFIG_FEATURE_GREP_CONTEXT"
#else
# 2596 "./include/autoconf.h"
# define IF_FEATURE_GREP_CONTEXT(...) __VA_ARGS__
#endif
# 2598 "./include/autoconf.h"
#define IF_NOT_FEATURE_GREP_CONTEXT(...)
#define CONFIG_XARGS 1
#define ENABLE_XARGS 1
#ifdef MAKE_SUID
# define IF_XARGS(...) __VA_ARGS__ "CONFIG_XARGS"
#else
# 2604 "./include/autoconf.h"
# define IF_XARGS(...) __VA_ARGS__
#endif
# 2606 "./include/autoconf.h"
#define IF_NOT_XARGS(...)
#define CONFIG_FEATURE_XARGS_SUPPORT_CONFIRMATION 1
#define ENABLE_FEATURE_XARGS_SUPPORT_CONFIRMATION 1
#ifdef MAKE_SUID
# define IF_FEATURE_XARGS_SUPPORT_CONFIRMATION(...) __VA_ARGS__ "CONFIG_FEATURE_XARGS_SUPPORT_CONFIRMATION"
#else
# 2612 "./include/autoconf.h"
# define IF_FEATURE_XARGS_SUPPORT_CONFIRMATION(...) __VA_ARGS__
#endif
# 2614 "./include/autoconf.h"
#define IF_NOT_FEATURE_XARGS_SUPPORT_CONFIRMATION(...)
#define CONFIG_FEATURE_XARGS_SUPPORT_QUOTES 1
#define ENABLE_FEATURE_XARGS_SUPPORT_QUOTES 1
#ifdef MAKE_SUID
# define IF_FEATURE_XARGS_SUPPORT_QUOTES(...) __VA_ARGS__ "CONFIG_FEATURE_XARGS_SUPPORT_QUOTES"
#else
# 2620 "./include/autoconf.h"
# define IF_FEATURE_XARGS_SUPPORT_QUOTES(...) __VA_ARGS__
#endif
# 2622 "./include/autoconf.h"
#define IF_NOT_FEATURE_XARGS_SUPPORT_QUOTES(...)
#define CONFIG_FEATURE_XARGS_SUPPORT_TERMOPT 1
#define ENABLE_FEATURE_XARGS_SUPPORT_TERMOPT 1
#ifdef MAKE_SUID
# define IF_FEATURE_XARGS_SUPPORT_TERMOPT(...) __VA_ARGS__ "CONFIG_FEATURE_XARGS_SUPPORT_TERMOPT"
#else
# 2628 "./include/autoconf.h"
# define IF_FEATURE_XARGS_SUPPORT_TERMOPT(...) __VA_ARGS__
#endif
# 2630 "./include/autoconf.h"
#define IF_NOT_FEATURE_XARGS_SUPPORT_TERMOPT(...)
#define CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM 1
#define ENABLE_FEATURE_XARGS_SUPPORT_ZERO_TERM 1
#ifdef MAKE_SUID
# define IF_FEATURE_XARGS_SUPPORT_ZERO_TERM(...) __VA_ARGS__ "CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM"
#else
# 2636 "./include/autoconf.h"
# define IF_FEATURE_XARGS_SUPPORT_ZERO_TERM(...) __VA_ARGS__
#endif
# 2638 "./include/autoconf.h"
#define IF_NOT_FEATURE_XARGS_SUPPORT_ZERO_TERM(...)
#define CONFIG_FEATURE_XARGS_SUPPORT_REPL_STR 1
#define ENABLE_FEATURE_XARGS_SUPPORT_REPL_STR 1
#ifdef MAKE_SUID
# define IF_FEATURE_XARGS_SUPPORT_REPL_STR(...) __VA_ARGS__ "CONFIG_FEATURE_XARGS_SUPPORT_REPL_STR"
#else
# 2644 "./include/autoconf.h"
# define IF_FEATURE_XARGS_SUPPORT_REPL_STR(...) __VA_ARGS__
#endif
# 2646 "./include/autoconf.h"
#define IF_NOT_FEATURE_XARGS_SUPPORT_REPL_STR(...)

/*
 * Init Utilities
 */
#undef CONFIG_BOOTCHARTD
#define ENABLE_BOOTCHARTD 0
#define IF_BOOTCHARTD(...)
#define IF_NOT_BOOTCHARTD(...) __VA_ARGS__
#undef CONFIG_FEATURE_BOOTCHARTD_BLOATED_HEADER
#define ENABLE_FEATURE_BOOTCHARTD_BLOATED_HEADER 0
#define IF_FEATURE_BOOTCHARTD_BLOATED_HEADER(...)
#define IF_NOT_FEATURE_BOOTCHARTD_BLOATED_HEADER(...) __VA_ARGS__
#undef CONFIG_FEATURE_BOOTCHARTD_CONFIG_FILE
#define ENABLE_FEATURE_BOOTCHARTD_CONFIG_FILE 0
#define IF_FEATURE_BOOTCHARTD_CONFIG_FILE(...)
#define IF_NOT_FEATURE_BOOTCHARTD_CONFIG_FILE(...) __VA_ARGS__
#undef CONFIG_HALT
#define ENABLE_HALT 0
#define IF_HALT(...)
#define IF_NOT_HALT(...) __VA_ARGS__
#undef CONFIG_POWEROFF
#define ENABLE_POWEROFF 0
#define IF_POWEROFF(...)
#define IF_NOT_POWEROFF(...) __VA_ARGS__
#undef CONFIG_REBOOT
#define ENABLE_REBOOT 0
#define IF_REBOOT(...)
#define IF_NOT_REBOOT(...) __VA_ARGS__
#undef CONFIG_FEATURE_CALL_TELINIT
#define ENABLE_FEATURE_CALL_TELINIT 0
#define IF_FEATURE_CALL_TELINIT(...)
#define IF_NOT_FEATURE_CALL_TELINIT(...) __VA_ARGS__
#define CONFIG_TELINIT_PATH ""
#define ENABLE_TELINIT_PATH 1
#ifdef MAKE_SUID
# define IF_TELINIT_PATH(...) __VA_ARGS__ "CONFIG_TELINIT_PATH"
#else
# 2684 "./include/autoconf.h"
# define IF_TELINIT_PATH(...) __VA_ARGS__
#endif
# 2686 "./include/autoconf.h"
#define IF_NOT_TELINIT_PATH(...)
#undef CONFIG_INIT
#define ENABLE_INIT 0
#define IF_INIT(...)
#define IF_NOT_INIT(...) __VA_ARGS__
#undef CONFIG_LINUXRC
#define ENABLE_LINUXRC 0
#define IF_LINUXRC(...)
#define IF_NOT_LINUXRC(...) __VA_ARGS__
#undef CONFIG_FEATURE_USE_INITTAB
#define ENABLE_FEATURE_USE_INITTAB 0
#define IF_FEATURE_USE_INITTAB(...)
#define IF_NOT_FEATURE_USE_INITTAB(...) __VA_ARGS__
#undef CONFIG_FEATURE_KILL_REMOVED
#define ENABLE_FEATURE_KILL_REMOVED 0
#define IF_FEATURE_KILL_REMOVED(...)
#define IF_NOT_FEATURE_KILL_REMOVED(...) __VA_ARGS__
#define CONFIG_FEATURE_KILL_DELAY 0
#define ENABLE_FEATURE_KILL_DELAY 1
#ifdef MAKE_SUID
# define IF_FEATURE_KILL_DELAY(...) __VA_ARGS__ "CONFIG_FEATURE_KILL_DELAY"
#else
# 2708 "./include/autoconf.h"
# define IF_FEATURE_KILL_DELAY(...) __VA_ARGS__
#endif
# 2710 "./include/autoconf.h"
#define IF_NOT_FEATURE_KILL_DELAY(...)
#undef CONFIG_FEATURE_INIT_SCTTY
#define ENABLE_FEATURE_INIT_SCTTY 0
#define IF_FEATURE_INIT_SCTTY(...)
#define IF_NOT_FEATURE_INIT_SCTTY(...) __VA_ARGS__
#undef CONFIG_FEATURE_INIT_SYSLOG
#define ENABLE_FEATURE_INIT_SYSLOG 0
#define IF_FEATURE_INIT_SYSLOG(...)
#define IF_NOT_FEATURE_INIT_SYSLOG(...) __VA_ARGS__
#undef CONFIG_FEATURE_EXTRA_QUIET
#define ENABLE_FEATURE_EXTRA_QUIET 0
#define IF_FEATURE_EXTRA_QUIET(...)
#define IF_NOT_FEATURE_EXTRA_QUIET(...) __VA_ARGS__
#undef CONFIG_FEATURE_INIT_COREDUMPS
#define ENABLE_FEATURE_INIT_COREDUMPS 0
#define IF_FEATURE_INIT_COREDUMPS(...)
#define IF_NOT_FEATURE_INIT_COREDUMPS(...) __VA_ARGS__
#define CONFIG_INIT_TERMINAL_TYPE ""
#define ENABLE_INIT_TERMINAL_TYPE 1
#ifdef MAKE_SUID
# define IF_INIT_TERMINAL_TYPE(...) __VA_ARGS__ "CONFIG_INIT_TERMINAL_TYPE"
#else
# 2732 "./include/autoconf.h"
# define IF_INIT_TERMINAL_TYPE(...) __VA_ARGS__
#endif
# 2734 "./include/autoconf.h"
#define IF_NOT_INIT_TERMINAL_TYPE(...)
#undef CONFIG_FEATURE_INIT_MODIFY_CMDLINE
#define ENABLE_FEATURE_INIT_MODIFY_CMDLINE 0
#define IF_FEATURE_INIT_MODIFY_CMDLINE(...)
#define IF_NOT_FEATURE_INIT_MODIFY_CMDLINE(...) __VA_ARGS__
#undef CONFIG_MESG
#define ENABLE_MESG 0
#define IF_MESG(...)
#define IF_NOT_MESG(...) __VA_ARGS__
#undef CONFIG_FEATURE_MESG_ENABLE_ONLY_GROUP
#define ENABLE_FEATURE_MESG_ENABLE_ONLY_GROUP 0
#define IF_FEATURE_MESG_ENABLE_ONLY_GROUP(...)
#define IF_NOT_FEATURE_MESG_ENABLE_ONLY_GROUP(...) __VA_ARGS__

/*
 * Login/Password Management Utilities
 */
#undef CONFIG_FEATURE_SHADOWPASSWDS
#define ENABLE_FEATURE_SHADOWPASSWDS 0
#define IF_FEATURE_SHADOWPASSWDS(...)
#define IF_NOT_FEATURE_SHADOWPASSWDS(...) __VA_ARGS__
#define CONFIG_USE_BB_PWD_GRP 1
#define ENABLE_USE_BB_PWD_GRP 1
#ifdef MAKE_SUID
# define IF_USE_BB_PWD_GRP(...) __VA_ARGS__ "CONFIG_USE_BB_PWD_GRP"
#else
# 2760 "./include/autoconf.h"
# define IF_USE_BB_PWD_GRP(...) __VA_ARGS__
#endif
# 2762 "./include/autoconf.h"
#define IF_NOT_USE_BB_PWD_GRP(...)
#undef CONFIG_USE_BB_SHADOW
#define ENABLE_USE_BB_SHADOW 0
#define IF_USE_BB_SHADOW(...)
#define IF_NOT_USE_BB_SHADOW(...) __VA_ARGS__
#undef CONFIG_USE_BB_CRYPT
#define ENABLE_USE_BB_CRYPT 0
#define IF_USE_BB_CRYPT(...)
#define IF_NOT_USE_BB_CRYPT(...) __VA_ARGS__
#undef CONFIG_USE_BB_CRYPT_SHA
#define ENABLE_USE_BB_CRYPT_SHA 0
#define IF_USE_BB_CRYPT_SHA(...)
#define IF_NOT_USE_BB_CRYPT_SHA(...) __VA_ARGS__
#undef CONFIG_ADD_SHELL
#define ENABLE_ADD_SHELL 0
#define IF_ADD_SHELL(...)
#define IF_NOT_ADD_SHELL(...) __VA_ARGS__
#undef CONFIG_REMOVE_SHELL
#define ENABLE_REMOVE_SHELL 0
#define IF_REMOVE_SHELL(...)
#define IF_NOT_REMOVE_SHELL(...) __VA_ARGS__
#define CONFIG_ADDGROUP 1
#define ENABLE_ADDGROUP 1
#ifdef MAKE_SUID
# define IF_ADDGROUP(...) __VA_ARGS__ "CONFIG_ADDGROUP"
#else
# 2788 "./include/autoconf.h"
# define IF_ADDGROUP(...) __VA_ARGS__
#endif
# 2790 "./include/autoconf.h"
#define IF_NOT_ADDGROUP(...)
#define CONFIG_FEATURE_ADDGROUP_LONG_OPTIONS 1
#define ENABLE_FEATURE_ADDGROUP_LONG_OPTIONS 1
#ifdef MAKE_SUID
# define IF_FEATURE_ADDGROUP_LONG_OPTIONS(...) __VA_ARGS__ "CONFIG_FEATURE_ADDGROUP_LONG_OPTIONS"
#else
# 2796 "./include/autoconf.h"
# define IF_FEATURE_ADDGROUP_LONG_OPTIONS(...) __VA_ARGS__
#endif
# 2798 "./include/autoconf.h"
#define IF_NOT_FEATURE_ADDGROUP_LONG_OPTIONS(...)
#define CONFIG_FEATURE_ADDUSER_TO_GROUP 1
#define ENABLE_FEATURE_ADDUSER_TO_GROUP 1
#ifdef MAKE_SUID
# define IF_FEATURE_ADDUSER_TO_GROUP(...) __VA_ARGS__ "CONFIG_FEATURE_ADDUSER_TO_GROUP"
#else
# 2804 "./include/autoconf.h"
# define IF_FEATURE_ADDUSER_TO_GROUP(...) __VA_ARGS__
#endif
# 2806 "./include/autoconf.h"
#define IF_NOT_FEATURE_ADDUSER_TO_GROUP(...)
#undef CONFIG_ADDUSER
#define ENABLE_ADDUSER 0
#define IF_ADDUSER(...)
#define IF_NOT_ADDUSER(...) __VA_ARGS__
#undef CONFIG_FEATURE_ADDUSER_LONG_OPTIONS
#define ENABLE_FEATURE_ADDUSER_LONG_OPTIONS 0
#define IF_FEATURE_ADDUSER_LONG_OPTIONS(...)
#define IF_NOT_FEATURE_ADDUSER_LONG_OPTIONS(...) __VA_ARGS__
#undef CONFIG_FEATURE_CHECK_NAMES
#define ENABLE_FEATURE_CHECK_NAMES 0
#define IF_FEATURE_CHECK_NAMES(...)
#define IF_NOT_FEATURE_CHECK_NAMES(...) __VA_ARGS__
#define CONFIG_LAST_ID 60000
#define ENABLE_LAST_ID 1
#ifdef MAKE_SUID
# define IF_LAST_ID(...) __VA_ARGS__ "CONFIG_LAST_ID"
#else
# 2824 "./include/autoconf.h"
# define IF_LAST_ID(...) __VA_ARGS__
#endif
# 2826 "./include/autoconf.h"
#define IF_NOT_LAST_ID(...)
#define CONFIG_FIRST_SYSTEM_ID 100
#define ENABLE_FIRST_SYSTEM_ID 1
#ifdef MAKE_SUID
# define IF_FIRST_SYSTEM_ID(...) __VA_ARGS__ "CONFIG_FIRST_SYSTEM_ID"
#else
# 2832 "./include/autoconf.h"
# define IF_FIRST_SYSTEM_ID(...) __VA_ARGS__
#endif
# 2834 "./include/autoconf.h"
#define IF_NOT_FIRST_SYSTEM_ID(...)
#define CONFIG_LAST_SYSTEM_ID 999
#define ENABLE_LAST_SYSTEM_ID 1
#ifdef MAKE_SUID
# define IF_LAST_SYSTEM_ID(...) __VA_ARGS__ "CONFIG_LAST_SYSTEM_ID"
#else
# 2840 "./include/autoconf.h"
# define IF_LAST_SYSTEM_ID(...) __VA_ARGS__
#endif
# 2842 "./include/autoconf.h"
#define IF_NOT_LAST_SYSTEM_ID(...)
#undef CONFIG_CHPASSWD
#define ENABLE_CHPASSWD 0
#define IF_CHPASSWD(...)
#define IF_NOT_CHPASSWD(...) __VA_ARGS__
#define CONFIG_FEATURE_DEFAULT_PASSWD_ALGO ""
#define ENABLE_FEATURE_DEFAULT_PASSWD_ALGO 1
#ifdef MAKE_SUID
# define IF_FEATURE_DEFAULT_PASSWD_ALGO(...) __VA_ARGS__ "CONFIG_FEATURE_DEFAULT_PASSWD_ALGO"
#else
# 2852 "./include/autoconf.h"
# define IF_FEATURE_DEFAULT_PASSWD_ALGO(...) __VA_ARGS__
#endif
# 2854 "./include/autoconf.h"
#define IF_NOT_FEATURE_DEFAULT_PASSWD_ALGO(...)
#undef CONFIG_CRYPTPW
#define ENABLE_CRYPTPW 0
#define IF_CRYPTPW(...)
#define IF_NOT_CRYPTPW(...) __VA_ARGS__
#undef CONFIG_MKPASSWD
#define ENABLE_MKPASSWD 0
#define IF_MKPASSWD(...)
#define IF_NOT_MKPASSWD(...) __VA_ARGS__
#undef CONFIG_DELUSER
#define ENABLE_DELUSER 0
#define IF_DELUSER(...)
#define IF_NOT_DELUSER(...) __VA_ARGS__
#define CONFIG_DELGROUP 1
#define ENABLE_DELGROUP 1
#ifdef MAKE_SUID
# define IF_DELGROUP(...) __VA_ARGS__ "CONFIG_DELGROUP"
#else
# 2872 "./include/autoconf.h"
# define IF_DELGROUP(...) __VA_ARGS__
#endif
# 2874 "./include/autoconf.h"
#define IF_NOT_DELGROUP(...)
#define CONFIG_FEATURE_DEL_USER_FROM_GROUP 1
#define ENABLE_FEATURE_DEL_USER_FROM_GROUP 1
#ifdef MAKE_SUID
# define IF_FEATURE_DEL_USER_FROM_GROUP(...) __VA_ARGS__ "CONFIG_FEATURE_DEL_USER_FROM_GROUP"
#else
# 2880 "./include/autoconf.h"
# define IF_FEATURE_DEL_USER_FROM_GROUP(...) __VA_ARGS__
#endif
# 2882 "./include/autoconf.h"
#define IF_NOT_FEATURE_DEL_USER_FROM_GROUP(...)
#undef CONFIG_GETTY
#define ENABLE_GETTY 0
#define IF_GETTY(...)
#define IF_NOT_GETTY(...) __VA_ARGS__
#undef CONFIG_LOGIN
#define ENABLE_LOGIN 0
#define IF_LOGIN(...)
#define IF_NOT_LOGIN(...) __VA_ARGS__
#undef CONFIG_LOGIN_SESSION_AS_CHILD
#define ENABLE_LOGIN_SESSION_AS_CHILD 0
#define IF_LOGIN_SESSION_AS_CHILD(...)
#define IF_NOT_LOGIN_SESSION_AS_CHILD(...) __VA_ARGS__
#undef CONFIG_LOGIN_SCRIPTS
#define ENABLE_LOGIN_SCRIPTS 0
#define IF_LOGIN_SCRIPTS(...)
#define IF_NOT_LOGIN_SCRIPTS(...) __VA_ARGS__
#undef CONFIG_FEATURE_NOLOGIN
#define ENABLE_FEATURE_NOLOGIN 0
#define IF_FEATURE_NOLOGIN(...)
#define IF_NOT_FEATURE_NOLOGIN(...) __VA_ARGS__
#undef CONFIG_FEATURE_SECURETTY
#define ENABLE_FEATURE_SECURETTY 0
#define IF_FEATURE_SECURETTY(...)
#define IF_NOT_FEATURE_SECURETTY(...) __VA_ARGS__
#undef CONFIG_PASSWD
#define ENABLE_PASSWD 0
#define IF_PASSWD(...)
#define IF_NOT_PASSWD(...) __VA_ARGS__
#undef CONFIG_FEATURE_PASSWD_WEAK_CHECK
#define ENABLE_FEATURE_PASSWD_WEAK_CHECK 0
#define IF_FEATURE_PASSWD_WEAK_CHECK(...)
#define IF_NOT_FEATURE_PASSWD_WEAK_CHECK(...) __VA_ARGS__
#undef CONFIG_SU
#define ENABLE_SU 0
#define IF_SU(...)
#define IF_NOT_SU(...) __VA_ARGS__
#undef CONFIG_FEATURE_SU_SYSLOG
#define ENABLE_FEATURE_SU_SYSLOG 0
#define IF_FEATURE_SU_SYSLOG(...)
#define IF_NOT_FEATURE_SU_SYSLOG(...) __VA_ARGS__
#undef CONFIG_FEATURE_SU_CHECKS_SHELLS
#define ENABLE_FEATURE_SU_CHECKS_SHELLS 0
#define IF_FEATURE_SU_CHECKS_SHELLS(...)
#define IF_NOT_FEATURE_SU_CHECKS_SHELLS(...) __VA_ARGS__
#undef CONFIG_SULOGIN
#define ENABLE_SULOGIN 0
#define IF_SULOGIN(...)
#define IF_NOT_SULOGIN(...) __VA_ARGS__
#undef CONFIG_VLOCK
#define ENABLE_VLOCK 0
#define IF_VLOCK(...)
#define IF_NOT_VLOCK(...) __VA_ARGS__

/*
 * Linux Ext2 FS Progs
 */
#define CONFIG_CHATTR 1
#define ENABLE_CHATTR 1
#ifdef MAKE_SUID
# define IF_CHATTR(...) __VA_ARGS__ "CONFIG_CHATTR"
#else
# 2944 "./include/autoconf.h"
# define IF_CHATTR(...) __VA_ARGS__
#endif
# 2946 "./include/autoconf.h"
#define IF_NOT_CHATTR(...)
#undef CONFIG_FSCK
#define ENABLE_FSCK 0
#define IF_FSCK(...)
#define IF_NOT_FSCK(...) __VA_ARGS__
#undef CONFIG_LSATTR
#define ENABLE_LSATTR 0
#define IF_LSATTR(...)
#define IF_NOT_LSATTR(...) __VA_ARGS__
#undef CONFIG_TUNE2FS
#define ENABLE_TUNE2FS 0
#define IF_TUNE2FS(...)
#define IF_NOT_TUNE2FS(...) __VA_ARGS__

/*
 * Linux Module Utilities
 */
#undef CONFIG_MODPROBE_SMALL
#define ENABLE_MODPROBE_SMALL 0
#define IF_MODPROBE_SMALL(...)
#define IF_NOT_MODPROBE_SMALL(...) __VA_ARGS__
#undef CONFIG_DEPMOD
#define ENABLE_DEPMOD 0
#define IF_DEPMOD(...)
#define IF_NOT_DEPMOD(...) __VA_ARGS__
#undef CONFIG_INSMOD
#define ENABLE_INSMOD 0
#define IF_INSMOD(...)
#define IF_NOT_INSMOD(...) __VA_ARGS__
#undef CONFIG_LSMOD
#define ENABLE_LSMOD 0
#define IF_LSMOD(...)
#define IF_NOT_LSMOD(...) __VA_ARGS__
#undef CONFIG_FEATURE_LSMOD_PRETTY_2_6_OUTPUT
#define ENABLE_FEATURE_LSMOD_PRETTY_2_6_OUTPUT 0
#define IF_FEATURE_LSMOD_PRETTY_2_6_OUTPUT(...)
#define IF_NOT_FEATURE_LSMOD_PRETTY_2_6_OUTPUT(...) __VA_ARGS__
#undef CONFIG_MODINFO
#define ENABLE_MODINFO 0
#define IF_MODINFO(...)
#define IF_NOT_MODINFO(...) __VA_ARGS__
#undef CONFIG_FEATURE_MODPROBE_SMALL_OPTIONS_ON_CMDLINE
#define ENABLE_FEATURE_MODPROBE_SMALL_OPTIONS_ON_CMDLINE 0
#define IF_FEATURE_MODPROBE_SMALL_OPTIONS_ON_CMDLINE(...)
#define IF_NOT_FEATURE_MODPROBE_SMALL_OPTIONS_ON_CMDLINE(...) __VA_ARGS__
#undef CONFIG_FEATURE_MODPROBE_SMALL_CHECK_ALREADY_LOADED
#define ENABLE_FEATURE_MODPROBE_SMALL_CHECK_ALREADY_LOADED 0
#define IF_FEATURE_MODPROBE_SMALL_CHECK_ALREADY_LOADED(...)
#define IF_NOT_FEATURE_MODPROBE_SMALL_CHECK_ALREADY_LOADED(...) __VA_ARGS__
#undef CONFIG_MODPROBE
#define ENABLE_MODPROBE 0
#define IF_MODPROBE(...)
#define IF_NOT_MODPROBE(...) __VA_ARGS__
#undef CONFIG_FEATURE_MODPROBE_BLACKLIST
#define ENABLE_FEATURE_MODPROBE_BLACKLIST 0
#define IF_FEATURE_MODPROBE_BLACKLIST(...)
#define IF_NOT_FEATURE_MODPROBE_BLACKLIST(...) __VA_ARGS__
#undef CONFIG_RMMOD
#define ENABLE_RMMOD 0
#define IF_RMMOD(...)
#define IF_NOT_RMMOD(...) __VA_ARGS__

/*
 * Options common to multiple modutils
 */
#undef CONFIG_FEATURE_2_4_MODULES
#define ENABLE_FEATURE_2_4_MODULES 0
#define IF_FEATURE_2_4_MODULES(...)
#define IF_NOT_FEATURE_2_4_MODULES(...) __VA_ARGS__
#undef CONFIG_FEATURE_INSMOD_TRY_MMAP
#define ENABLE_FEATURE_INSMOD_TRY_MMAP 0
#define IF_FEATURE_INSMOD_TRY_MMAP(...)
#define IF_NOT_FEATURE_INSMOD_TRY_MMAP(...) __VA_ARGS__
#undef CONFIG_FEATURE_INSMOD_VERSION_CHECKING
#define ENABLE_FEATURE_INSMOD_VERSION_CHECKING 0
#define IF_FEATURE_INSMOD_VERSION_CHECKING(...)
#define IF_NOT_FEATURE_INSMOD_VERSION_CHECKING(...) __VA_ARGS__
#undef CONFIG_FEATURE_INSMOD_KSYMOOPS_SYMBOLS
#define ENABLE_FEATURE_INSMOD_KSYMOOPS_SYMBOLS 0
#define IF_FEATURE_INSMOD_KSYMOOPS_SYMBOLS(...)
#define IF_NOT_FEATURE_INSMOD_KSYMOOPS_SYMBOLS(...) __VA_ARGS__
#undef CONFIG_FEATURE_INSMOD_LOADINKMEM
#define ENABLE_FEATURE_INSMOD_LOADINKMEM 0
#define IF_FEATURE_INSMOD_LOADINKMEM(...)
#define IF_NOT_FEATURE_INSMOD_LOADINKMEM(...) __VA_ARGS__
#undef CONFIG_FEATURE_INSMOD_LOAD_MAP
#define ENABLE_FEATURE_INSMOD_LOAD_MAP 0
#define IF_FEATURE_INSMOD_LOAD_MAP(...)
#define IF_NOT_FEATURE_INSMOD_LOAD_MAP(...) __VA_ARGS__
#undef CONFIG_FEATURE_INSMOD_LOAD_MAP_FULL
#define ENABLE_FEATURE_INSMOD_LOAD_MAP_FULL 0
#define IF_FEATURE_INSMOD_LOAD_MAP_FULL(...)
#define IF_NOT_FEATURE_INSMOD_LOAD_MAP_FULL(...) __VA_ARGS__
#undef CONFIG_FEATURE_CHECK_TAINTED_MODULE
#define ENABLE_FEATURE_CHECK_TAINTED_MODULE 0
#define IF_FEATURE_CHECK_TAINTED_MODULE(...)
#define IF_NOT_FEATURE_CHECK_TAINTED_MODULE(...) __VA_ARGS__
#undef CONFIG_FEATURE_MODUTILS_ALIAS
#define ENABLE_FEATURE_MODUTILS_ALIAS 0
#define IF_FEATURE_MODUTILS_ALIAS(...)
#define IF_NOT_FEATURE_MODUTILS_ALIAS(...) __VA_ARGS__
#undef CONFIG_FEATURE_MODUTILS_SYMBOLS
#define ENABLE_FEATURE_MODUTILS_SYMBOLS 0
#define IF_FEATURE_MODUTILS_SYMBOLS(...)
#define IF_NOT_FEATURE_MODUTILS_SYMBOLS(...) __VA_ARGS__
#define CONFIG_DEFAULT_MODULES_DIR ""
#define ENABLE_DEFAULT_MODULES_DIR 1
#ifdef MAKE_SUID
# define IF_DEFAULT_MODULES_DIR(...) __VA_ARGS__ "CONFIG_DEFAULT_MODULES_DIR"
#else
# 3056 "./include/autoconf.h"
# define IF_DEFAULT_MODULES_DIR(...) __VA_ARGS__
#endif
# 3058 "./include/autoconf.h"
#define IF_NOT_DEFAULT_MODULES_DIR(...)
#define CONFIG_DEFAULT_DEPMOD_FILE ""
#define ENABLE_DEFAULT_DEPMOD_FILE 1
#ifdef MAKE_SUID
# define IF_DEFAULT_DEPMOD_FILE(...) __VA_ARGS__ "CONFIG_DEFAULT_DEPMOD_FILE"
#else
# 3064 "./include/autoconf.h"
# define IF_DEFAULT_DEPMOD_FILE(...) __VA_ARGS__
#endif
# 3066 "./include/autoconf.h"
#define IF_NOT_DEFAULT_DEPMOD_FILE(...)

/*
 * Linux System Utilities
 */
#undef CONFIG_ACPID
#define ENABLE_ACPID 0
#define IF_ACPID(...)
#define IF_NOT_ACPID(...) __VA_ARGS__
#undef CONFIG_FEATURE_ACPID_COMPAT
#define ENABLE_FEATURE_ACPID_COMPAT 0
#define IF_FEATURE_ACPID_COMPAT(...)
#define IF_NOT_FEATURE_ACPID_COMPAT(...) __VA_ARGS__
#undef CONFIG_BLKDISCARD
#define ENABLE_BLKDISCARD 0
#define IF_BLKDISCARD(...)
#define IF_NOT_BLKDISCARD(...) __VA_ARGS__
#undef CONFIG_BLKID
#define ENABLE_BLKID 0
#define IF_BLKID(...)
#define IF_NOT_BLKID(...) __VA_ARGS__
#undef CONFIG_FEATURE_BLKID_TYPE
#define ENABLE_FEATURE_BLKID_TYPE 0
#define IF_FEATURE_BLKID_TYPE(...)
#define IF_NOT_FEATURE_BLKID_TYPE(...) __VA_ARGS__
#undef CONFIG_BLOCKDEV
#define ENABLE_BLOCKDEV 0
#define IF_BLOCKDEV(...)
#define IF_NOT_BLOCKDEV(...) __VA_ARGS__
#undef CONFIG_DMESG
#define ENABLE_DMESG 0
#define IF_DMESG(...)
#define IF_NOT_DMESG(...) __VA_ARGS__
#undef CONFIG_FEATURE_DMESG_PRETTY
#define ENABLE_FEATURE_DMESG_PRETTY 0
#define IF_FEATURE_DMESG_PRETTY(...)
#define IF_NOT_FEATURE_DMESG_PRETTY(...) __VA_ARGS__
#define CONFIG_FATATTR 1
#define ENABLE_FATATTR 1
#ifdef MAKE_SUID
# define IF_FATATTR(...) __VA_ARGS__ "CONFIG_FATATTR"
#else
# 3108 "./include/autoconf.h"
# define IF_FATATTR(...) __VA_ARGS__
#endif
# 3110 "./include/autoconf.h"
#define IF_NOT_FATATTR(...)
#undef CONFIG_FBSET
#define ENABLE_FBSET 0
#define IF_FBSET(...)
#define IF_NOT_FBSET(...) __VA_ARGS__
#undef CONFIG_FEATURE_FBSET_FANCY
#define ENABLE_FEATURE_FBSET_FANCY 0
#define IF_FEATURE_FBSET_FANCY(...)
#define IF_NOT_FEATURE_FBSET_FANCY(...) __VA_ARGS__
#undef CONFIG_FEATURE_FBSET_READMODE
#define ENABLE_FEATURE_FBSET_READMODE 0
#define IF_FEATURE_FBSET_READMODE(...)
#define IF_NOT_FEATURE_FBSET_READMODE(...) __VA_ARGS__
#undef CONFIG_FDFORMAT
#define ENABLE_FDFORMAT 0
#define IF_FDFORMAT(...)
#define IF_NOT_FDFORMAT(...) __VA_ARGS__
#undef CONFIG_FDISK
#define ENABLE_FDISK 0
#define IF_FDISK(...)
#define IF_NOT_FDISK(...) __VA_ARGS__
#undef CONFIG_FDISK_SUPPORT_LARGE_DISKS
#define ENABLE_FDISK_SUPPORT_LARGE_DISKS 0
#define IF_FDISK_SUPPORT_LARGE_DISKS(...)
#define IF_NOT_FDISK_SUPPORT_LARGE_DISKS(...) __VA_ARGS__
#undef CONFIG_FEATURE_FDISK_WRITABLE
#define ENABLE_FEATURE_FDISK_WRITABLE 0
#define IF_FEATURE_FDISK_WRITABLE(...)
#define IF_NOT_FEATURE_FDISK_WRITABLE(...) __VA_ARGS__
#undef CONFIG_FEATURE_AIX_LABEL
#define ENABLE_FEATURE_AIX_LABEL 0
#define IF_FEATURE_AIX_LABEL(...)
#define IF_NOT_FEATURE_AIX_LABEL(...) __VA_ARGS__
#undef CONFIG_FEATURE_SGI_LABEL
#define ENABLE_FEATURE_SGI_LABEL 0
#define IF_FEATURE_SGI_LABEL(...)
#define IF_NOT_FEATURE_SGI_LABEL(...) __VA_ARGS__
#undef CONFIG_FEATURE_SUN_LABEL
#define ENABLE_FEATURE_SUN_LABEL 0
#define IF_FEATURE_SUN_LABEL(...)
#define IF_NOT_FEATURE_SUN_LABEL(...) __VA_ARGS__
#undef CONFIG_FEATURE_OSF_LABEL
#define ENABLE_FEATURE_OSF_LABEL 0
#define IF_FEATURE_OSF_LABEL(...)
#define IF_NOT_FEATURE_OSF_LABEL(...) __VA_ARGS__
#undef CONFIG_FEATURE_GPT_LABEL
#define ENABLE_FEATURE_GPT_LABEL 0
#define IF_FEATURE_GPT_LABEL(...)
#define IF_NOT_FEATURE_GPT_LABEL(...) __VA_ARGS__
#undef CONFIG_FEATURE_FDISK_ADVANCED
#define ENABLE_FEATURE_FDISK_ADVANCED 0
#define IF_FEATURE_FDISK_ADVANCED(...)
#define IF_NOT_FEATURE_FDISK_ADVANCED(...) __VA_ARGS__
#undef CONFIG_FINDFS
#define ENABLE_FINDFS 0
#define IF_FINDFS(...)
#define IF_NOT_FINDFS(...) __VA_ARGS__
#define CONFIG_FLOCK 1
#define ENABLE_FLOCK 1
#ifdef MAKE_SUID
# define IF_FLOCK(...) __VA_ARGS__ "CONFIG_FLOCK"
#else
# 3172 "./include/autoconf.h"
# define IF_FLOCK(...) __VA_ARGS__
#endif
# 3174 "./include/autoconf.h"
#define IF_NOT_FLOCK(...)
#undef CONFIG_FDFLUSH
#define ENABLE_FDFLUSH 0
#define IF_FDFLUSH(...)
#define IF_NOT_FDFLUSH(...) __VA_ARGS__
#undef CONFIG_FREERAMDISK
#define ENABLE_FREERAMDISK 0
#define IF_FREERAMDISK(...)
#define IF_NOT_FREERAMDISK(...) __VA_ARGS__
#undef CONFIG_FSCK_MINIX
#define ENABLE_FSCK_MINIX 0
#define IF_FSCK_MINIX(...)
#define IF_NOT_FSCK_MINIX(...) __VA_ARGS__
#undef CONFIG_FSTRIM
#define ENABLE_FSTRIM 0
#define IF_FSTRIM(...)
#define IF_NOT_FSTRIM(...) __VA_ARGS__
#define CONFIG_GETOPT 1
#define ENABLE_GETOPT 1
#ifdef MAKE_SUID
# define IF_GETOPT(...) __VA_ARGS__ "CONFIG_GETOPT"
#else
# 3196 "./include/autoconf.h"
# define IF_GETOPT(...) __VA_ARGS__
#endif
# 3198 "./include/autoconf.h"
#define IF_NOT_GETOPT(...)
#define CONFIG_FEATURE_GETOPT_LONG 1
#define ENABLE_FEATURE_GETOPT_LONG 1
#ifdef MAKE_SUID
# define IF_FEATURE_GETOPT_LONG(...) __VA_ARGS__ "CONFIG_FEATURE_GETOPT_LONG"
#else
# 3204 "./include/autoconf.h"
# define IF_FEATURE_GETOPT_LONG(...) __VA_ARGS__
#endif
# 3206 "./include/autoconf.h"
#define IF_NOT_FEATURE_GETOPT_LONG(...)
#define CONFIG_HEXDUMP 1
#define ENABLE_HEXDUMP 1
#ifdef MAKE_SUID
# define IF_HEXDUMP(...) __VA_ARGS__ "CONFIG_HEXDUMP"
#else
# 3212 "./include/autoconf.h"
# define IF_HEXDUMP(...) __VA_ARGS__
#endif
# 3214 "./include/autoconf.h"
#define IF_NOT_HEXDUMP(...)
#undef CONFIG_FEATURE_HEXDUMP_REVERSE
#define ENABLE_FEATURE_HEXDUMP_REVERSE 0
#define IF_FEATURE_HEXDUMP_REVERSE(...)
#define IF_NOT_FEATURE_HEXDUMP_REVERSE(...) __VA_ARGS__
#define CONFIG_HD 1
#define ENABLE_HD 1
#ifdef MAKE_SUID
# define IF_HD(...) __VA_ARGS__ "CONFIG_HD"
#else
# 3224 "./include/autoconf.h"
# define IF_HD(...) __VA_ARGS__
#endif
# 3226 "./include/autoconf.h"
#define IF_NOT_HD(...)
#undef CONFIG_HWCLOCK
#define ENABLE_HWCLOCK 0
#define IF_HWCLOCK(...)
#define IF_NOT_HWCLOCK(...) __VA_ARGS__
#undef CONFIG_FEATURE_HWCLOCK_LONG_OPTIONS
#define ENABLE_FEATURE_HWCLOCK_LONG_OPTIONS 0
#define IF_FEATURE_HWCLOCK_LONG_OPTIONS(...)
#define IF_NOT_FEATURE_HWCLOCK_LONG_OPTIONS(...) __VA_ARGS__
#undef CONFIG_FEATURE_HWCLOCK_ADJTIME_FHS
#define ENABLE_FEATURE_HWCLOCK_ADJTIME_FHS 0
#define IF_FEATURE_HWCLOCK_ADJTIME_FHS(...)
#define IF_NOT_FEATURE_HWCLOCK_ADJTIME_FHS(...) __VA_ARGS__
#undef CONFIG_IPCRM
#define ENABLE_IPCRM 0
#define IF_IPCRM(...)
#define IF_NOT_IPCRM(...) __VA_ARGS__
#undef CONFIG_IPCS
#define ENABLE_IPCS 0
#define IF_IPCS(...)
#define IF_NOT_IPCS(...) __VA_ARGS__
#undef CONFIG_LOSETUP
#define ENABLE_LOSETUP 0
#define IF_LOSETUP(...)
#define IF_NOT_LOSETUP(...) __VA_ARGS__
#define CONFIG_LSPCI 1
#define ENABLE_LSPCI 1
#ifdef MAKE_SUID
# define IF_LSPCI(...) __VA_ARGS__ "CONFIG_LSPCI"
#else
# 3256 "./include/autoconf.h"
# define IF_LSPCI(...) __VA_ARGS__
#endif
# 3258 "./include/autoconf.h"
#define IF_NOT_LSPCI(...)
#define CONFIG_LSUSB 1
#define ENABLE_LSUSB 1
#ifdef MAKE_SUID
# define IF_LSUSB(...) __VA_ARGS__ "CONFIG_LSUSB"
#else
# 3264 "./include/autoconf.h"
# define IF_LSUSB(...) __VA_ARGS__
#endif
# 3266 "./include/autoconf.h"
#define IF_NOT_LSUSB(...)
#undef CONFIG_MDEV
#define ENABLE_MDEV 0
#define IF_MDEV(...)
#define IF_NOT_MDEV(...) __VA_ARGS__
#undef CONFIG_FEATURE_MDEV_CONF
#define ENABLE_FEATURE_MDEV_CONF 0
#define IF_FEATURE_MDEV_CONF(...)
#define IF_NOT_FEATURE_MDEV_CONF(...) __VA_ARGS__
#undef CONFIG_FEATURE_MDEV_RENAME
#define ENABLE_FEATURE_MDEV_RENAME 0
#define IF_FEATURE_MDEV_RENAME(...)
#define IF_NOT_FEATURE_MDEV_RENAME(...) __VA_ARGS__
#undef CONFIG_FEATURE_MDEV_RENAME_REGEXP
#define ENABLE_FEATURE_MDEV_RENAME_REGEXP 0
#define IF_FEATURE_MDEV_RENAME_REGEXP(...)
#define IF_NOT_FEATURE_MDEV_RENAME_REGEXP(...) __VA_ARGS__
#undef CONFIG_FEATURE_MDEV_EXEC
#define ENABLE_FEATURE_MDEV_EXEC 0
#define IF_FEATURE_MDEV_EXEC(...)
#define IF_NOT_FEATURE_MDEV_EXEC(...) __VA_ARGS__
#undef CONFIG_FEATURE_MDEV_LOAD_FIRMWARE
#define ENABLE_FEATURE_MDEV_LOAD_FIRMWARE 0
#define IF_FEATURE_MDEV_LOAD_FIRMWARE(...)
#define IF_NOT_FEATURE_MDEV_LOAD_FIRMWARE(...) __VA_ARGS__
#undef CONFIG_MKE2FS
#define ENABLE_MKE2FS 0
#define IF_MKE2FS(...)
#define IF_NOT_MKE2FS(...) __VA_ARGS__
#undef CONFIG_MKFS_EXT2
#define ENABLE_MKFS_EXT2 0
#define IF_MKFS_EXT2(...)
#define IF_NOT_MKFS_EXT2(...) __VA_ARGS__
#undef CONFIG_MKFS_MINIX
#define ENABLE_MKFS_MINIX 0
#define IF_MKFS_MINIX(...)
#define IF_NOT_MKFS_MINIX(...) __VA_ARGS__
#undef CONFIG_FEATURE_MINIX2
#define ENABLE_FEATURE_MINIX2 0
#define IF_FEATURE_MINIX2(...)
#define IF_NOT_FEATURE_MINIX2(...) __VA_ARGS__
#undef CONFIG_MKFS_REISER
#define ENABLE_MKFS_REISER 0
#define IF_MKFS_REISER(...)
#define IF_NOT_MKFS_REISER(...) __VA_ARGS__
#undef CONFIG_MKDOSFS
#define ENABLE_MKDOSFS 0
#define IF_MKDOSFS(...)
#define IF_NOT_MKDOSFS(...) __VA_ARGS__
#undef CONFIG_MKFS_VFAT
#define ENABLE_MKFS_VFAT 0
#define IF_MKFS_VFAT(...)
#define IF_NOT_MKFS_VFAT(...) __VA_ARGS__
#undef CONFIG_MKSWAP
#define ENABLE_MKSWAP 0
#define IF_MKSWAP(...)
#define IF_NOT_MKSWAP(...) __VA_ARGS__
#undef CONFIG_FEATURE_MKSWAP_UUID
#define ENABLE_FEATURE_MKSWAP_UUID 0
#define IF_FEATURE_MKSWAP_UUID(...)
#define IF_NOT_FEATURE_MKSWAP_UUID(...) __VA_ARGS__
#define CONFIG_MORE 1
#define ENABLE_MORE 1
#ifdef MAKE_SUID
# define IF_MORE(...) __VA_ARGS__ "CONFIG_MORE"
#else
# 3332 "./include/autoconf.h"
# define IF_MORE(...) __VA_ARGS__
#endif
# 3334 "./include/autoconf.h"
#define IF_NOT_MORE(...)
#undef CONFIG_MOUNT
#define ENABLE_MOUNT 0
#define IF_MOUNT(...)
#define IF_NOT_MOUNT(...) __VA_ARGS__
#undef CONFIG_FEATURE_MOUNT_FAKE
#define ENABLE_FEATURE_MOUNT_FAKE 0
#define IF_FEATURE_MOUNT_FAKE(...)
#define IF_NOT_FEATURE_MOUNT_FAKE(...) __VA_ARGS__
#undef CONFIG_FEATURE_MOUNT_VERBOSE
#define ENABLE_FEATURE_MOUNT_VERBOSE 0
#define IF_FEATURE_MOUNT_VERBOSE(...)
#define IF_NOT_FEATURE_MOUNT_VERBOSE(...) __VA_ARGS__
#undef CONFIG_FEATURE_MOUNT_HELPERS
#define ENABLE_FEATURE_MOUNT_HELPERS 0
#define IF_FEATURE_MOUNT_HELPERS(...)
#define IF_NOT_FEATURE_MOUNT_HELPERS(...) __VA_ARGS__
#undef CONFIG_FEATURE_MOUNT_LABEL
#define ENABLE_FEATURE_MOUNT_LABEL 0
#define IF_FEATURE_MOUNT_LABEL(...)
#define IF_NOT_FEATURE_MOUNT_LABEL(...) __VA_ARGS__
#undef CONFIG_FEATURE_MOUNT_NFS
#define ENABLE_FEATURE_MOUNT_NFS 0
#define IF_FEATURE_MOUNT_NFS(...)
#define IF_NOT_FEATURE_MOUNT_NFS(...) __VA_ARGS__
#undef CONFIG_FEATURE_MOUNT_CIFS
#define ENABLE_FEATURE_MOUNT_CIFS 0
#define IF_FEATURE_MOUNT_CIFS(...)
#define IF_NOT_FEATURE_MOUNT_CIFS(...) __VA_ARGS__
#undef CONFIG_FEATURE_MOUNT_FLAGS
#define ENABLE_FEATURE_MOUNT_FLAGS 0
#define IF_FEATURE_MOUNT_FLAGS(...)
#define IF_NOT_FEATURE_MOUNT_FLAGS(...) __VA_ARGS__
#undef CONFIG_FEATURE_MOUNT_FSTAB
#define ENABLE_FEATURE_MOUNT_FSTAB 0
#define IF_FEATURE_MOUNT_FSTAB(...)
#define IF_NOT_FEATURE_MOUNT_FSTAB(...) __VA_ARGS__
#undef CONFIG_FEATURE_MOUNT_OTHERTAB
#define ENABLE_FEATURE_MOUNT_OTHERTAB 0
#define IF_FEATURE_MOUNT_OTHERTAB(...)
#define IF_NOT_FEATURE_MOUNT_OTHERTAB(...) __VA_ARGS__
#undef CONFIG_NSENTER
#define ENABLE_NSENTER 0
#define IF_NSENTER(...)
#define IF_NOT_NSENTER(...) __VA_ARGS__
#undef CONFIG_FEATURE_NSENTER_LONG_OPTS
#define ENABLE_FEATURE_NSENTER_LONG_OPTS 0
#define IF_FEATURE_NSENTER_LONG_OPTS(...)
#define IF_NOT_FEATURE_NSENTER_LONG_OPTS(...) __VA_ARGS__
#undef CONFIG_PIVOT_ROOT
#define ENABLE_PIVOT_ROOT 0
#define IF_PIVOT_ROOT(...)
#define IF_NOT_PIVOT_ROOT(...) __VA_ARGS__
#undef CONFIG_RDATE
#define ENABLE_RDATE 0
#define IF_RDATE(...)
#define IF_NOT_RDATE(...) __VA_ARGS__
#undef CONFIG_RDEV
#define ENABLE_RDEV 0
#define IF_RDEV(...)
#define IF_NOT_RDEV(...) __VA_ARGS__
#define CONFIG_READPROFILE 1
#define ENABLE_READPROFILE 1
#ifdef MAKE_SUID
# define IF_READPROFILE(...) __VA_ARGS__ "CONFIG_READPROFILE"
#else
# 3400 "./include/autoconf.h"
# define IF_READPROFILE(...) __VA_ARGS__
#endif
# 3402 "./include/autoconf.h"
#define IF_NOT_READPROFILE(...)
#define CONFIG_REV 1
#define ENABLE_REV 1
#ifdef MAKE_SUID
# define IF_REV(...) __VA_ARGS__ "CONFIG_REV"
#else
# 3408 "./include/autoconf.h"
# define IF_REV(...) __VA_ARGS__
#endif
# 3410 "./include/autoconf.h"
#define IF_NOT_REV(...)
#undef CONFIG_RTCWAKE
#define ENABLE_RTCWAKE 0
#define IF_RTCWAKE(...)
#define IF_NOT_RTCWAKE(...) __VA_ARGS__
#undef CONFIG_SCRIPT
#define ENABLE_SCRIPT 0
#define IF_SCRIPT(...)
#define IF_NOT_SCRIPT(...) __VA_ARGS__
#define CONFIG_SCRIPTREPLAY 1
#define ENABLE_SCRIPTREPLAY 1
#ifdef MAKE_SUID
# define IF_SCRIPTREPLAY(...) __VA_ARGS__ "CONFIG_SCRIPTREPLAY"
#else
# 3424 "./include/autoconf.h"
# define IF_SCRIPTREPLAY(...) __VA_ARGS__
#endif
# 3426 "./include/autoconf.h"
#define IF_NOT_SCRIPTREPLAY(...)
#undef CONFIG_SETARCH
#define ENABLE_SETARCH 0
#define IF_SETARCH(...)
#define IF_NOT_SETARCH(...) __VA_ARGS__
#undef CONFIG_LINUX32
#define ENABLE_LINUX32 0
#define IF_LINUX32(...)
#define IF_NOT_LINUX32(...) __VA_ARGS__
#undef CONFIG_LINUX64
#define ENABLE_LINUX64 0
#define IF_LINUX64(...)
#define IF_NOT_LINUX64(...) __VA_ARGS__
#undef CONFIG_SWAPON
#define ENABLE_SWAPON 0
#define IF_SWAPON(...)
#define IF_NOT_SWAPON(...) __VA_ARGS__
#undef CONFIG_FEATURE_SWAPON_DISCARD
#define ENABLE_FEATURE_SWAPON_DISCARD 0
#define IF_FEATURE_SWAPON_DISCARD(...)
#define IF_NOT_FEATURE_SWAPON_DISCARD(...) __VA_ARGS__
#undef CONFIG_FEATURE_SWAPON_PRI
#define ENABLE_FEATURE_SWAPON_PRI 0
#define IF_FEATURE_SWAPON_PRI(...)
#define IF_NOT_FEATURE_SWAPON_PRI(...) __VA_ARGS__
#undef CONFIG_SWAPOFF
#define ENABLE_SWAPOFF 0
#define IF_SWAPOFF(...)
#define IF_NOT_SWAPOFF(...) __VA_ARGS__
#undef CONFIG_SWITCH_ROOT
#define ENABLE_SWITCH_ROOT 0
#define IF_SWITCH_ROOT(...)
#define IF_NOT_SWITCH_ROOT(...) __VA_ARGS__
#undef CONFIG_UEVENT
#define ENABLE_UEVENT 0
#define IF_UEVENT(...)
#define IF_NOT_UEVENT(...) __VA_ARGS__
#undef CONFIG_UMOUNT
#define ENABLE_UMOUNT 0
#define IF_UMOUNT(...)
#define IF_NOT_UMOUNT(...) __VA_ARGS__
#undef CONFIG_FEATURE_UMOUNT_ALL
#define ENABLE_FEATURE_UMOUNT_ALL 0
#define IF_FEATURE_UMOUNT_ALL(...)
#define IF_NOT_FEATURE_UMOUNT_ALL(...) __VA_ARGS__
#undef CONFIG_UNSHARE
#define ENABLE_UNSHARE 0
#define IF_UNSHARE(...)
#define IF_NOT_UNSHARE(...) __VA_ARGS__
#undef CONFIG_FEATURE_MOUNT_LOOP
#define ENABLE_FEATURE_MOUNT_LOOP 0
#define IF_FEATURE_MOUNT_LOOP(...)
#define IF_NOT_FEATURE_MOUNT_LOOP(...) __VA_ARGS__
#undef CONFIG_FEATURE_MOUNT_LOOP_CREATE
#define ENABLE_FEATURE_MOUNT_LOOP_CREATE 0
#define IF_FEATURE_MOUNT_LOOP_CREATE(...)
#define IF_NOT_FEATURE_MOUNT_LOOP_CREATE(...) __VA_ARGS__
#undef CONFIG_FEATURE_MTAB_SUPPORT
#define ENABLE_FEATURE_MTAB_SUPPORT 0
#define IF_FEATURE_MTAB_SUPPORT(...)
#define IF_NOT_FEATURE_MTAB_SUPPORT(...) __VA_ARGS__
#undef CONFIG_VOLUMEID
#define ENABLE_VOLUMEID 0
#define IF_VOLUMEID(...)
#define IF_NOT_VOLUMEID(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_BCACHE
#define ENABLE_FEATURE_VOLUMEID_BCACHE 0
#define IF_FEATURE_VOLUMEID_BCACHE(...)
#define IF_NOT_FEATURE_VOLUMEID_BCACHE(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_BTRFS
#define ENABLE_FEATURE_VOLUMEID_BTRFS 0
#define IF_FEATURE_VOLUMEID_BTRFS(...)
#define IF_NOT_FEATURE_VOLUMEID_BTRFS(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_CRAMFS
#define ENABLE_FEATURE_VOLUMEID_CRAMFS 0
#define IF_FEATURE_VOLUMEID_CRAMFS(...)
#define IF_NOT_FEATURE_VOLUMEID_CRAMFS(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_EXFAT
#define ENABLE_FEATURE_VOLUMEID_EXFAT 0
#define IF_FEATURE_VOLUMEID_EXFAT(...)
#define IF_NOT_FEATURE_VOLUMEID_EXFAT(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_EXT
#define ENABLE_FEATURE_VOLUMEID_EXT 0
#define IF_FEATURE_VOLUMEID_EXT(...)
#define IF_NOT_FEATURE_VOLUMEID_EXT(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_F2FS
#define ENABLE_FEATURE_VOLUMEID_F2FS 0
#define IF_FEATURE_VOLUMEID_F2FS(...)
#define IF_NOT_FEATURE_VOLUMEID_F2FS(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_FAT
#define ENABLE_FEATURE_VOLUMEID_FAT 0
#define IF_FEATURE_VOLUMEID_FAT(...)
#define IF_NOT_FEATURE_VOLUMEID_FAT(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_HFS
#define ENABLE_FEATURE_VOLUMEID_HFS 0
#define IF_FEATURE_VOLUMEID_HFS(...)
#define IF_NOT_FEATURE_VOLUMEID_HFS(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_ISO9660
#define ENABLE_FEATURE_VOLUMEID_ISO9660 0
#define IF_FEATURE_VOLUMEID_ISO9660(...)
#define IF_NOT_FEATURE_VOLUMEID_ISO9660(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_JFS
#define ENABLE_FEATURE_VOLUMEID_JFS 0
#define IF_FEATURE_VOLUMEID_JFS(...)
#define IF_NOT_FEATURE_VOLUMEID_JFS(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_LINUXRAID
#define ENABLE_FEATURE_VOLUMEID_LINUXRAID 0
#define IF_FEATURE_VOLUMEID_LINUXRAID(...)
#define IF_NOT_FEATURE_VOLUMEID_LINUXRAID(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_LINUXSWAP
#define ENABLE_FEATURE_VOLUMEID_LINUXSWAP 0
#define IF_FEATURE_VOLUMEID_LINUXSWAP(...)
#define IF_NOT_FEATURE_VOLUMEID_LINUXSWAP(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_LUKS
#define ENABLE_FEATURE_VOLUMEID_LUKS 0
#define IF_FEATURE_VOLUMEID_LUKS(...)
#define IF_NOT_FEATURE_VOLUMEID_LUKS(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_NILFS
#define ENABLE_FEATURE_VOLUMEID_NILFS 0
#define IF_FEATURE_VOLUMEID_NILFS(...)
#define IF_NOT_FEATURE_VOLUMEID_NILFS(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_NTFS
#define ENABLE_FEATURE_VOLUMEID_NTFS 0
#define IF_FEATURE_VOLUMEID_NTFS(...)
#define IF_NOT_FEATURE_VOLUMEID_NTFS(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_OCFS2
#define ENABLE_FEATURE_VOLUMEID_OCFS2 0
#define IF_FEATURE_VOLUMEID_OCFS2(...)
#define IF_NOT_FEATURE_VOLUMEID_OCFS2(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_REISERFS
#define ENABLE_FEATURE_VOLUMEID_REISERFS 0
#define IF_FEATURE_VOLUMEID_REISERFS(...)
#define IF_NOT_FEATURE_VOLUMEID_REISERFS(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_ROMFS
#define ENABLE_FEATURE_VOLUMEID_ROMFS 0
#define IF_FEATURE_VOLUMEID_ROMFS(...)
#define IF_NOT_FEATURE_VOLUMEID_ROMFS(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_SQUASHFS
#define ENABLE_FEATURE_VOLUMEID_SQUASHFS 0
#define IF_FEATURE_VOLUMEID_SQUASHFS(...)
#define IF_NOT_FEATURE_VOLUMEID_SQUASHFS(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_SYSV
#define ENABLE_FEATURE_VOLUMEID_SYSV 0
#define IF_FEATURE_VOLUMEID_SYSV(...)
#define IF_NOT_FEATURE_VOLUMEID_SYSV(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_UBIFS
#define ENABLE_FEATURE_VOLUMEID_UBIFS 0
#define IF_FEATURE_VOLUMEID_UBIFS(...)
#define IF_NOT_FEATURE_VOLUMEID_UBIFS(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_UDF
#define ENABLE_FEATURE_VOLUMEID_UDF 0
#define IF_FEATURE_VOLUMEID_UDF(...)
#define IF_NOT_FEATURE_VOLUMEID_UDF(...) __VA_ARGS__
#undef CONFIG_FEATURE_VOLUMEID_XFS
#define ENABLE_FEATURE_VOLUMEID_XFS 0
#define IF_FEATURE_VOLUMEID_XFS(...)
#define IF_NOT_FEATURE_VOLUMEID_XFS(...) __VA_ARGS__

/*
 * Miscellaneous Utilities
 */
#undef CONFIG_ADJTIMEX
#define ENABLE_ADJTIMEX 0
#define IF_ADJTIMEX(...)
#define IF_NOT_ADJTIMEX(...) __VA_ARGS__
#undef CONFIG_BBCONFIG
#define ENABLE_BBCONFIG 0
#define IF_BBCONFIG(...)
#define IF_NOT_BBCONFIG(...) __VA_ARGS__
#undef CONFIG_FEATURE_COMPRESS_BBCONFIG
#define ENABLE_FEATURE_COMPRESS_BBCONFIG 0
#define IF_FEATURE_COMPRESS_BBCONFIG(...)
#define IF_NOT_FEATURE_COMPRESS_BBCONFIG(...) __VA_ARGS__
#undef CONFIG_BEEP
#define ENABLE_BEEP 0
#define IF_BEEP(...)
#define IF_NOT_BEEP(...) __VA_ARGS__
#define CONFIG_FEATURE_BEEP_FREQ 0
#define ENABLE_FEATURE_BEEP_FREQ 1
#ifdef MAKE_SUID
# define IF_FEATURE_BEEP_FREQ(...) __VA_ARGS__ "CONFIG_FEATURE_BEEP_FREQ"
#else
# 3608 "./include/autoconf.h"
# define IF_FEATURE_BEEP_FREQ(...) __VA_ARGS__
#endif
# 3610 "./include/autoconf.h"
#define IF_NOT_FEATURE_BEEP_FREQ(...)
#define CONFIG_FEATURE_BEEP_LENGTH_MS 0
#define ENABLE_FEATURE_BEEP_LENGTH_MS 1
#ifdef MAKE_SUID
# define IF_FEATURE_BEEP_LENGTH_MS(...) __VA_ARGS__ "CONFIG_FEATURE_BEEP_LENGTH_MS"
#else
# 3616 "./include/autoconf.h"
# define IF_FEATURE_BEEP_LENGTH_MS(...) __VA_ARGS__
#endif
# 3618 "./include/autoconf.h"
#define IF_NOT_FEATURE_BEEP_LENGTH_MS(...)
#undef CONFIG_CHAT
#define ENABLE_CHAT 0
#define IF_CHAT(...)
#define IF_NOT_CHAT(...) __VA_ARGS__
#undef CONFIG_FEATURE_CHAT_NOFAIL
#define ENABLE_FEATURE_CHAT_NOFAIL 0
#define IF_FEATURE_CHAT_NOFAIL(...)
#define IF_NOT_FEATURE_CHAT_NOFAIL(...) __VA_ARGS__
#undef CONFIG_FEATURE_CHAT_TTY_HIFI
#define ENABLE_FEATURE_CHAT_TTY_HIFI 0
#define IF_FEATURE_CHAT_TTY_HIFI(...)
#define IF_NOT_FEATURE_CHAT_TTY_HIFI(...) __VA_ARGS__
#undef CONFIG_FEATURE_CHAT_IMPLICIT_CR
#define ENABLE_FEATURE_CHAT_IMPLICIT_CR 0
#define IF_FEATURE_CHAT_IMPLICIT_CR(...)
#define IF_NOT_FEATURE_CHAT_IMPLICIT_CR(...) __VA_ARGS__
#undef CONFIG_FEATURE_CHAT_SWALLOW_OPTS
#define ENABLE_FEATURE_CHAT_SWALLOW_OPTS 0
#define IF_FEATURE_CHAT_SWALLOW_OPTS(...)
#define IF_NOT_FEATURE_CHAT_SWALLOW_OPTS(...) __VA_ARGS__
#undef CONFIG_FEATURE_CHAT_SEND_ESCAPES
#define ENABLE_FEATURE_CHAT_SEND_ESCAPES 0
#define IF_FEATURE_CHAT_SEND_ESCAPES(...)
#define IF_NOT_FEATURE_CHAT_SEND_ESCAPES(...) __VA_ARGS__
#undef CONFIG_FEATURE_CHAT_VAR_ABORT_LEN
#define ENABLE_FEATURE_CHAT_VAR_ABORT_LEN 0
#define IF_FEATURE_CHAT_VAR_ABORT_LEN(...)
#define IF_NOT_FEATURE_CHAT_VAR_ABORT_LEN(...) __VA_ARGS__
#undef CONFIG_FEATURE_CHAT_CLR_ABORT
#define ENABLE_FEATURE_CHAT_CLR_ABORT 0
#define IF_FEATURE_CHAT_CLR_ABORT(...)
#define IF_NOT_FEATURE_CHAT_CLR_ABORT(...) __VA_ARGS__
#define CONFIG_CHRT 1
#define ENABLE_CHRT 1
#ifdef MAKE_SUID
# define IF_CHRT(...) __VA_ARGS__ "CONFIG_CHRT"
#else
# 3656 "./include/autoconf.h"
# define IF_CHRT(...) __VA_ARGS__
#endif
# 3658 "./include/autoconf.h"
#define IF_NOT_CHRT(...)
#undef CONFIG_CONSPY
#define ENABLE_CONSPY 0
#define IF_CONSPY(...)
#define IF_NOT_CONSPY(...) __VA_ARGS__
#undef CONFIG_CROND
#define ENABLE_CROND 0
#define IF_CROND(...)
#define IF_NOT_CROND(...) __VA_ARGS__
#undef CONFIG_FEATURE_CROND_D
#define ENABLE_FEATURE_CROND_D 0
#define IF_FEATURE_CROND_D(...)
#define IF_NOT_FEATURE_CROND_D(...) __VA_ARGS__
#undef CONFIG_FEATURE_CROND_CALL_SENDMAIL
#define ENABLE_FEATURE_CROND_CALL_SENDMAIL 0
#define IF_FEATURE_CROND_CALL_SENDMAIL(...)
#define IF_NOT_FEATURE_CROND_CALL_SENDMAIL(...) __VA_ARGS__
#define CONFIG_FEATURE_CROND_DIR "/var/spool/cron"
#define ENABLE_FEATURE_CROND_DIR 1
#ifdef MAKE_SUID
# define IF_FEATURE_CROND_DIR(...) __VA_ARGS__ "CONFIG_FEATURE_CROND_DIR"
#else
# 3680 "./include/autoconf.h"
# define IF_FEATURE_CROND_DIR(...) __VA_ARGS__
#endif
# 3682 "./include/autoconf.h"
#define IF_NOT_FEATURE_CROND_DIR(...)
#define CONFIG_CRONTAB 1
#define ENABLE_CRONTAB 1
#ifdef MAKE_SUID
# define IF_CRONTAB(...) __VA_ARGS__ "CONFIG_CRONTAB"
#else
# 3688 "./include/autoconf.h"
# define IF_CRONTAB(...) __VA_ARGS__
#endif
# 3690 "./include/autoconf.h"
#define IF_NOT_CRONTAB(...)
#define CONFIG_DC 1
#define ENABLE_DC 1
#ifdef MAKE_SUID
# define IF_DC(...) __VA_ARGS__ "CONFIG_DC"
#else
# 3696 "./include/autoconf.h"
# define IF_DC(...) __VA_ARGS__
#endif
# 3698 "./include/autoconf.h"
#define IF_NOT_DC(...)
#define CONFIG_FEATURE_DC_LIBM 1
#define ENABLE_FEATURE_DC_LIBM 1
#ifdef MAKE_SUID
# define IF_FEATURE_DC_LIBM(...) __VA_ARGS__ "CONFIG_FEATURE_DC_LIBM"
#else
# 3704 "./include/autoconf.h"
# define IF_FEATURE_DC_LIBM(...) __VA_ARGS__
#endif
# 3706 "./include/autoconf.h"
#define IF_NOT_FEATURE_DC_LIBM(...)
#undef CONFIG_DEVFSD
#define ENABLE_DEVFSD 0
#define IF_DEVFSD(...)
#define IF_NOT_DEVFSD(...) __VA_ARGS__
#undef CONFIG_DEVFSD_MODLOAD
#define ENABLE_DEVFSD_MODLOAD 0
#define IF_DEVFSD_MODLOAD(...)
#define IF_NOT_DEVFSD_MODLOAD(...) __VA_ARGS__
#undef CONFIG_DEVFSD_FG_NP
#define ENABLE_DEVFSD_FG_NP 0
#define IF_DEVFSD_FG_NP(...)
#define IF_NOT_DEVFSD_FG_NP(...) __VA_ARGS__
#undef CONFIG_DEVFSD_VERBOSE
#define ENABLE_DEVFSD_VERBOSE 0
#define IF_DEVFSD_VERBOSE(...)
#define IF_NOT_DEVFSD_VERBOSE(...) __VA_ARGS__
#undef CONFIG_FEATURE_DEVFS
#define ENABLE_FEATURE_DEVFS 0
#define IF_FEATURE_DEVFS(...)
#define IF_NOT_FEATURE_DEVFS(...) __VA_ARGS__
#undef CONFIG_DEVMEM
#define ENABLE_DEVMEM 0
#define IF_DEVMEM(...)
#define IF_NOT_DEVMEM(...) __VA_ARGS__
#undef CONFIG_EJECT
#define ENABLE_EJECT 0
#define IF_EJECT(...)
#define IF_NOT_EJECT(...) __VA_ARGS__
#undef CONFIG_FEATURE_EJECT_SCSI
#define ENABLE_FEATURE_EJECT_SCSI 0
#define IF_FEATURE_EJECT_SCSI(...)
#define IF_NOT_FEATURE_EJECT_SCSI(...) __VA_ARGS__
#undef CONFIG_FBSPLASH
#define ENABLE_FBSPLASH 0
#define IF_FBSPLASH(...)
#define IF_NOT_FBSPLASH(...) __VA_ARGS__
#undef CONFIG_FLASH_ERASEALL
#define ENABLE_FLASH_ERASEALL 0
#define IF_FLASH_ERASEALL(...)
#define IF_NOT_FLASH_ERASEALL(...) __VA_ARGS__
#undef CONFIG_FLASH_LOCK
#define ENABLE_FLASH_LOCK 0
#define IF_FLASH_LOCK(...)
#define IF_NOT_FLASH_LOCK(...) __VA_ARGS__
#undef CONFIG_FLASH_UNLOCK
#define ENABLE_FLASH_UNLOCK 0
#define IF_FLASH_UNLOCK(...)
#define IF_NOT_FLASH_UNLOCK(...) __VA_ARGS__
#undef CONFIG_FLASHCP
#define ENABLE_FLASHCP 0
#define IF_FLASHCP(...)
#define IF_NOT_FLASHCP(...) __VA_ARGS__
#undef CONFIG_HDPARM
#define ENABLE_HDPARM 0
#define IF_HDPARM(...)
#define IF_NOT_HDPARM(...) __VA_ARGS__
#undef CONFIG_FEATURE_HDPARM_GET_IDENTITY
#define ENABLE_FEATURE_HDPARM_GET_IDENTITY 0
#define IF_FEATURE_HDPARM_GET_IDENTITY(...)
#define IF_NOT_FEATURE_HDPARM_GET_IDENTITY(...) __VA_ARGS__
#undef CONFIG_FEATURE_HDPARM_HDIO_SCAN_HWIF
#define ENABLE_FEATURE_HDPARM_HDIO_SCAN_HWIF 0
#define IF_FEATURE_HDPARM_HDIO_SCAN_HWIF(...)
#define IF_NOT_FEATURE_HDPARM_HDIO_SCAN_HWIF(...) __VA_ARGS__
#undef CONFIG_FEATURE_HDPARM_HDIO_UNREGISTER_HWIF
#define ENABLE_FEATURE_HDPARM_HDIO_UNREGISTER_HWIF 0
#define IF_FEATURE_HDPARM_HDIO_UNREGISTER_HWIF(...)
#define IF_NOT_FEATURE_HDPARM_HDIO_UNREGISTER_HWIF(...) __VA_ARGS__
#undef CONFIG_FEATURE_HDPARM_HDIO_DRIVE_RESET
#define ENABLE_FEATURE_HDPARM_HDIO_DRIVE_RESET 0
#define IF_FEATURE_HDPARM_HDIO_DRIVE_RESET(...)
#define IF_NOT_FEATURE_HDPARM_HDIO_DRIVE_RESET(...) __VA_ARGS__
#undef CONFIG_FEATURE_HDPARM_HDIO_TRISTATE_HWIF
#define ENABLE_FEATURE_HDPARM_HDIO_TRISTATE_HWIF 0
#define IF_FEATURE_HDPARM_HDIO_TRISTATE_HWIF(...)
#define IF_NOT_FEATURE_HDPARM_HDIO_TRISTATE_HWIF(...) __VA_ARGS__
#undef CONFIG_FEATURE_HDPARM_HDIO_GETSET_DMA
#define ENABLE_FEATURE_HDPARM_HDIO_GETSET_DMA 0
#define IF_FEATURE_HDPARM_HDIO_GETSET_DMA(...)
#define IF_NOT_FEATURE_HDPARM_HDIO_GETSET_DMA(...) __VA_ARGS__
#undef CONFIG_I2CGET
#define ENABLE_I2CGET 0
#define IF_I2CGET(...)
#define IF_NOT_I2CGET(...) __VA_ARGS__
#undef CONFIG_I2CSET
#define ENABLE_I2CSET 0
#define IF_I2CSET(...)
#define IF_NOT_I2CSET(...) __VA_ARGS__
#undef CONFIG_I2CDUMP
#define ENABLE_I2CDUMP 0
#define IF_I2CDUMP(...)
#define IF_NOT_I2CDUMP(...) __VA_ARGS__
#undef CONFIG_I2CDETECT
#define ENABLE_I2CDETECT 0
#define IF_I2CDETECT(...)
#define IF_NOT_I2CDETECT(...) __VA_ARGS__
#undef CONFIG_INOTIFYD
#define ENABLE_INOTIFYD 0
#define IF_INOTIFYD(...)
#define IF_NOT_INOTIFYD(...) __VA_ARGS__
#undef CONFIG_IONICE
#define ENABLE_IONICE 0
#define IF_IONICE(...)
#define IF_NOT_IONICE(...) __VA_ARGS__
#undef CONFIG_LAST
#define ENABLE_LAST 0
#define IF_LAST(...)
#define IF_NOT_LAST(...) __VA_ARGS__
#undef CONFIG_FEATURE_LAST_FANCY
#define ENABLE_FEATURE_LAST_FANCY 0
#define IF_FEATURE_LAST_FANCY(...)
#define IF_NOT_FEATURE_LAST_FANCY(...) __VA_ARGS__
#define CONFIG_LESS 1
#define ENABLE_LESS 1
#ifdef MAKE_SUID
# define IF_LESS(...) __VA_ARGS__ "CONFIG_LESS"
#else
# 3824 "./include/autoconf.h"
# define IF_LESS(...) __VA_ARGS__
#endif
# 3826 "./include/autoconf.h"
#define IF_NOT_LESS(...)
#define CONFIG_FEATURE_LESS_MAXLINES 9999999
#define ENABLE_FEATURE_LESS_MAXLINES 1
#ifdef MAKE_SUID
# define IF_FEATURE_LESS_MAXLINES(...) __VA_ARGS__ "CONFIG_FEATURE_LESS_MAXLINES"
#else
# 3832 "./include/autoconf.h"
# define IF_FEATURE_LESS_MAXLINES(...) __VA_ARGS__
#endif
# 3834 "./include/autoconf.h"
#define IF_NOT_FEATURE_LESS_MAXLINES(...)
#define CONFIG_FEATURE_LESS_BRACKETS 1
#define ENABLE_FEATURE_LESS_BRACKETS 1
#ifdef MAKE_SUID
# define IF_FEATURE_LESS_BRACKETS(...) __VA_ARGS__ "CONFIG_FEATURE_LESS_BRACKETS"
#else
# 3840 "./include/autoconf.h"
# define IF_FEATURE_LESS_BRACKETS(...) __VA_ARGS__
#endif
# 3842 "./include/autoconf.h"
#define IF_NOT_FEATURE_LESS_BRACKETS(...)
#define CONFIG_FEATURE_LESS_FLAGS 1
#define ENABLE_FEATURE_LESS_FLAGS 1
#ifdef MAKE_SUID
# define IF_FEATURE_LESS_FLAGS(...) __VA_ARGS__ "CONFIG_FEATURE_LESS_FLAGS"
#else
# 3848 "./include/autoconf.h"
# define IF_FEATURE_LESS_FLAGS(...) __VA_ARGS__
#endif
# 3850 "./include/autoconf.h"
#define IF_NOT_FEATURE_LESS_FLAGS(...)
#define CONFIG_FEATURE_LESS_TRUNCATE 1
#define ENABLE_FEATURE_LESS_TRUNCATE 1
#ifdef MAKE_SUID
# define IF_FEATURE_LESS_TRUNCATE(...) __VA_ARGS__ "CONFIG_FEATURE_LESS_TRUNCATE"
#else
# 3856 "./include/autoconf.h"
# define IF_FEATURE_LESS_TRUNCATE(...) __VA_ARGS__
#endif
# 3858 "./include/autoconf.h"
#define IF_NOT_FEATURE_LESS_TRUNCATE(...)
#define CONFIG_FEATURE_LESS_MARKS 1
#define ENABLE_FEATURE_LESS_MARKS 1
#ifdef MAKE_SUID
# define IF_FEATURE_LESS_MARKS(...) __VA_ARGS__ "CONFIG_FEATURE_LESS_MARKS"
#else
# 3864 "./include/autoconf.h"
# define IF_FEATURE_LESS_MARKS(...) __VA_ARGS__
#endif
# 3866 "./include/autoconf.h"
#define IF_NOT_FEATURE_LESS_MARKS(...)
#define CONFIG_FEATURE_LESS_REGEXP 1
#define ENABLE_FEATURE_LESS_REGEXP 1
#ifdef MAKE_SUID
# define IF_FEATURE_LESS_REGEXP(...) __VA_ARGS__ "CONFIG_FEATURE_LESS_REGEXP"
#else
# 3872 "./include/autoconf.h"
# define IF_FEATURE_LESS_REGEXP(...) __VA_ARGS__
#endif
# 3874 "./include/autoconf.h"
#define IF_NOT_FEATURE_LESS_REGEXP(...)
#undef CONFIG_FEATURE_LESS_WINCH
#define ENABLE_FEATURE_LESS_WINCH 0
#define IF_FEATURE_LESS_WINCH(...)
#define IF_NOT_FEATURE_LESS_WINCH(...) __VA_ARGS__
#undef CONFIG_FEATURE_LESS_ASK_TERMINAL
#define ENABLE_FEATURE_LESS_ASK_TERMINAL 0
#define IF_FEATURE_LESS_ASK_TERMINAL(...)
#define IF_NOT_FEATURE_LESS_ASK_TERMINAL(...) __VA_ARGS__
#undef CONFIG_FEATURE_LESS_DASHCMD
#define ENABLE_FEATURE_LESS_DASHCMD 0
#define IF_FEATURE_LESS_DASHCMD(...)
#define IF_NOT_FEATURE_LESS_DASHCMD(...) __VA_ARGS__
#undef CONFIG_FEATURE_LESS_LINENUMS
#define ENABLE_FEATURE_LESS_LINENUMS 0
#define IF_FEATURE_LESS_LINENUMS(...)
#define IF_NOT_FEATURE_LESS_LINENUMS(...) __VA_ARGS__
#undef CONFIG_MAKEDEVS
#define ENABLE_MAKEDEVS 0
#define IF_MAKEDEVS(...)
#define IF_NOT_MAKEDEVS(...) __VA_ARGS__
#undef CONFIG_FEATURE_MAKEDEVS_LEAF
#define ENABLE_FEATURE_MAKEDEVS_LEAF 0
#define IF_FEATURE_MAKEDEVS_LEAF(...)
#define IF_NOT_FEATURE_MAKEDEVS_LEAF(...) __VA_ARGS__
#undef CONFIG_FEATURE_MAKEDEVS_TABLE
#define ENABLE_FEATURE_MAKEDEVS_TABLE 0
#define IF_FEATURE_MAKEDEVS_TABLE(...)
#define IF_NOT_FEATURE_MAKEDEVS_TABLE(...) __VA_ARGS__
#undef CONFIG_MAN
#define ENABLE_MAN 0
#define IF_MAN(...)
#define IF_NOT_MAN(...) __VA_ARGS__
#define CONFIG_MICROCOM 1
#define ENABLE_MICROCOM 1
#ifdef MAKE_SUID
# define IF_MICROCOM(...) __VA_ARGS__ "CONFIG_MICROCOM"
#else
# 3912 "./include/autoconf.h"
# define IF_MICROCOM(...) __VA_ARGS__
#endif
# 3914 "./include/autoconf.h"
#define IF_NOT_MICROCOM(...)
#undef CONFIG_MOUNTPOINT
#define ENABLE_MOUNTPOINT 0
#define IF_MOUNTPOINT(...)
#define IF_NOT_MOUNTPOINT(...) __VA_ARGS__
#undef CONFIG_MT
#define ENABLE_MT 0
#define IF_MT(...)
#define IF_NOT_MT(...) __VA_ARGS__
#undef CONFIG_NANDWRITE
#define ENABLE_NANDWRITE 0
#define IF_NANDWRITE(...)
#define IF_NOT_NANDWRITE(...) __VA_ARGS__
#undef CONFIG_NANDDUMP
#define ENABLE_NANDDUMP 0
#define IF_NANDDUMP(...)
#define IF_NOT_NANDDUMP(...) __VA_ARGS__
#undef CONFIG_RAIDAUTORUN
#define ENABLE_RAIDAUTORUN 0
#define IF_RAIDAUTORUN(...)
#define IF_NOT_RAIDAUTORUN(...) __VA_ARGS__
#undef CONFIG_READAHEAD
#define ENABLE_READAHEAD 0
#define IF_READAHEAD(...)
#define IF_NOT_READAHEAD(...) __VA_ARGS__
#undef CONFIG_RFKILL
#define ENABLE_RFKILL 0
#define IF_RFKILL(...)
#define IF_NOT_RFKILL(...) __VA_ARGS__
#undef CONFIG_RUNLEVEL
#define ENABLE_RUNLEVEL 0
#define IF_RUNLEVEL(...)
#define IF_NOT_RUNLEVEL(...) __VA_ARGS__
#undef CONFIG_RX
#define ENABLE_RX 0
#define IF_RX(...)
#define IF_NOT_RX(...) __VA_ARGS__
#undef CONFIG_SETSERIAL
#define ENABLE_SETSERIAL 0
#define IF_SETSERIAL(...)
#define IF_NOT_SETSERIAL(...) __VA_ARGS__
#define CONFIG_SETSID 1
#define ENABLE_SETSID 1
#ifdef MAKE_SUID
# define IF_SETSID(...) __VA_ARGS__ "CONFIG_SETSID"
#else
# 3960 "./include/autoconf.h"
# define IF_SETSID(...) __VA_ARGS__
#endif
# 3962 "./include/autoconf.h"
#define IF_NOT_SETSID(...)
#define CONFIG_STRINGS 1
#define ENABLE_STRINGS 1
#ifdef MAKE_SUID
# define IF_STRINGS(...) __VA_ARGS__ "CONFIG_STRINGS"
#else
# 3968 "./include/autoconf.h"
# define IF_STRINGS(...) __VA_ARGS__
#endif
# 3970 "./include/autoconf.h"
#define IF_NOT_STRINGS(...)
#undef CONFIG_TASKSET
#define ENABLE_TASKSET 0
#define IF_TASKSET(...)
#define IF_NOT_TASKSET(...) __VA_ARGS__
#undef CONFIG_FEATURE_TASKSET_FANCY
#define ENABLE_FEATURE_TASKSET_FANCY 0
#define IF_FEATURE_TASKSET_FANCY(...)
#define IF_NOT_FEATURE_TASKSET_FANCY(...) __VA_ARGS__
#undef CONFIG_TIME
#define ENABLE_TIME 0
#define IF_TIME(...)
#define IF_NOT_TIME(...) __VA_ARGS__
#define CONFIG_TIMEOUT 1
#define ENABLE_TIMEOUT 1
#ifdef MAKE_SUID
# define IF_TIMEOUT(...) __VA_ARGS__ "CONFIG_TIMEOUT"
#else
# 3988 "./include/autoconf.h"
# define IF_TIMEOUT(...) __VA_ARGS__
#endif
# 3990 "./include/autoconf.h"
#define IF_NOT_TIMEOUT(...)
#define CONFIG_TTYSIZE 1
#define ENABLE_TTYSIZE 1
#ifdef MAKE_SUID
# define IF_TTYSIZE(...) __VA_ARGS__ "CONFIG_TTYSIZE"
#else
# 3996 "./include/autoconf.h"
# define IF_TTYSIZE(...) __VA_ARGS__
#endif
# 3998 "./include/autoconf.h"
#define IF_NOT_TTYSIZE(...)
#undef CONFIG_UBIATTACH
#define ENABLE_UBIATTACH 0
#define IF_UBIATTACH(...)
#define IF_NOT_UBIATTACH(...) __VA_ARGS__
#undef CONFIG_UBIDETACH
#define ENABLE_UBIDETACH 0
#define IF_UBIDETACH(...)
#define IF_NOT_UBIDETACH(...) __VA_ARGS__
#undef CONFIG_UBIMKVOL
#define ENABLE_UBIMKVOL 0
#define IF_UBIMKVOL(...)
#define IF_NOT_UBIMKVOL(...) __VA_ARGS__
#undef CONFIG_UBIRMVOL
#define ENABLE_UBIRMVOL 0
#define IF_UBIRMVOL(...)
#define IF_NOT_UBIRMVOL(...) __VA_ARGS__
#undef CONFIG_UBIRSVOL
#define ENABLE_UBIRSVOL 0
#define IF_UBIRSVOL(...)
#define IF_NOT_UBIRSVOL(...) __VA_ARGS__
#undef CONFIG_UBIUPDATEVOL
#define ENABLE_UBIUPDATEVOL 0
#define IF_UBIUPDATEVOL(...)
#define IF_NOT_UBIUPDATEVOL(...) __VA_ARGS__
#undef CONFIG_UBIRENAME
#define ENABLE_UBIRENAME 0
#define IF_UBIRENAME(...)
#define IF_NOT_UBIRENAME(...) __VA_ARGS__
#define CONFIG_VOLNAME 1
#define ENABLE_VOLNAME 1
#ifdef MAKE_SUID
# define IF_VOLNAME(...) __VA_ARGS__ "CONFIG_VOLNAME"
#else
# 4032 "./include/autoconf.h"
# define IF_VOLNAME(...) __VA_ARGS__
#endif
# 4034 "./include/autoconf.h"
#define IF_NOT_VOLNAME(...)
#undef CONFIG_WALL
#define ENABLE_WALL 0
#define IF_WALL(...)
#define IF_NOT_WALL(...) __VA_ARGS__
#undef CONFIG_WATCHDOG
#define ENABLE_WATCHDOG 0
#define IF_WATCHDOG(...)
#define IF_NOT_WATCHDOG(...) __VA_ARGS__

/*
 * Networking Utilities
 */
#undef CONFIG_FEATURE_IPV6
#define ENABLE_FEATURE_IPV6 0
#define IF_FEATURE_IPV6(...)
#define IF_NOT_FEATURE_IPV6(...) __VA_ARGS__
#undef CONFIG_FEATURE_UNIX_LOCAL
#define ENABLE_FEATURE_UNIX_LOCAL 0
#define IF_FEATURE_UNIX_LOCAL(...)
#define IF_NOT_FEATURE_UNIX_LOCAL(...) __VA_ARGS__
#undef CONFIG_FEATURE_PREFER_IPV4_ADDRESS
#define ENABLE_FEATURE_PREFER_IPV4_ADDRESS 0
#define IF_FEATURE_PREFER_IPV4_ADDRESS(...)
#define IF_NOT_FEATURE_PREFER_IPV4_ADDRESS(...) __VA_ARGS__
#undef CONFIG_VERBOSE_RESOLUTION_ERRORS
#define ENABLE_VERBOSE_RESOLUTION_ERRORS 0
#define IF_VERBOSE_RESOLUTION_ERRORS(...)
#define IF_NOT_VERBOSE_RESOLUTION_ERRORS(...) __VA_ARGS__
#undef CONFIG_ARP
#define ENABLE_ARP 0
#define IF_ARP(...)
#define IF_NOT_ARP(...) __VA_ARGS__
#undef CONFIG_ARPING
#define ENABLE_ARPING 0
#define IF_ARPING(...)
#define IF_NOT_ARPING(...) __VA_ARGS__
#undef CONFIG_BRCTL
#define ENABLE_BRCTL 0
#define IF_BRCTL(...)
#define IF_NOT_BRCTL(...) __VA_ARGS__
#undef CONFIG_FEATURE_BRCTL_FANCY
#define ENABLE_FEATURE_BRCTL_FANCY 0
#define IF_FEATURE_BRCTL_FANCY(...)
#define IF_NOT_FEATURE_BRCTL_FANCY(...) __VA_ARGS__
#undef CONFIG_FEATURE_BRCTL_SHOW
#define ENABLE_FEATURE_BRCTL_SHOW 0
#define IF_FEATURE_BRCTL_SHOW(...)
#define IF_NOT_FEATURE_BRCTL_SHOW(...) __VA_ARGS__
#define CONFIG_DNSD 1
#define ENABLE_DNSD 1
#ifdef MAKE_SUID
# define IF_DNSD(...) __VA_ARGS__ "CONFIG_DNSD"
#else
# 4088 "./include/autoconf.h"
# define IF_DNSD(...) __VA_ARGS__
#endif
# 4090 "./include/autoconf.h"
#define IF_NOT_DNSD(...)
#undef CONFIG_ETHER_WAKE
#define ENABLE_ETHER_WAKE 0
#define IF_ETHER_WAKE(...)
#define IF_NOT_ETHER_WAKE(...) __VA_ARGS__
#define CONFIG_FTPD 1
#define ENABLE_FTPD 1
#ifdef MAKE_SUID
# define IF_FTPD(...) __VA_ARGS__ "CONFIG_FTPD"
#else
# 4100 "./include/autoconf.h"
# define IF_FTPD(...) __VA_ARGS__
#endif
# 4102 "./include/autoconf.h"
#define IF_NOT_FTPD(...)
#undef CONFIG_FEATURE_FTPD_WRITE
#define ENABLE_FEATURE_FTPD_WRITE 0
#define IF_FEATURE_FTPD_WRITE(...)
#define IF_NOT_FEATURE_FTPD_WRITE(...) __VA_ARGS__
#define CONFIG_FEATURE_FTPD_ACCEPT_BROKEN_LIST 1
#define ENABLE_FEATURE_FTPD_ACCEPT_BROKEN_LIST 1
#ifdef MAKE_SUID
# define IF_FEATURE_FTPD_ACCEPT_BROKEN_LIST(...) __VA_ARGS__ "CONFIG_FEATURE_FTPD_ACCEPT_BROKEN_LIST"
#else
# 4112 "./include/autoconf.h"
# define IF_FEATURE_FTPD_ACCEPT_BROKEN_LIST(...) __VA_ARGS__
#endif
# 4114 "./include/autoconf.h"
#define IF_NOT_FEATURE_FTPD_ACCEPT_BROKEN_LIST(...)
#undef CONFIG_FEATURE_FTPD_AUTHENTICATION
#define ENABLE_FEATURE_FTPD_AUTHENTICATION 0
#define IF_FEATURE_FTPD_AUTHENTICATION(...)
#define IF_NOT_FEATURE_FTPD_AUTHENTICATION(...) __VA_ARGS__
#define CONFIG_FTPGET 1
#define ENABLE_FTPGET 1
#ifdef MAKE_SUID
# define IF_FTPGET(...) __VA_ARGS__ "CONFIG_FTPGET"
#else
# 4124 "./include/autoconf.h"
# define IF_FTPGET(...) __VA_ARGS__
#endif
# 4126 "./include/autoconf.h"
#define IF_NOT_FTPGET(...)
#define CONFIG_FTPPUT 1
#define ENABLE_FTPPUT 1
#ifdef MAKE_SUID
# define IF_FTPPUT(...) __VA_ARGS__ "CONFIG_FTPPUT"
#else
# 4132 "./include/autoconf.h"
# define IF_FTPPUT(...) __VA_ARGS__
#endif
# 4134 "./include/autoconf.h"
#define IF_NOT_FTPPUT(...)
#define CONFIG_FEATURE_FTPGETPUT_LONG_OPTIONS 1
#define ENABLE_FEATURE_FTPGETPUT_LONG_OPTIONS 1
#ifdef MAKE_SUID
# define IF_FEATURE_FTPGETPUT_LONG_OPTIONS(...) __VA_ARGS__ "CONFIG_FEATURE_FTPGETPUT_LONG_OPTIONS"
#else
# 4140 "./include/autoconf.h"
# define IF_FEATURE_FTPGETPUT_LONG_OPTIONS(...) __VA_ARGS__
#endif
# 4142 "./include/autoconf.h"
#define IF_NOT_FEATURE_FTPGETPUT_LONG_OPTIONS(...)
#define CONFIG_HOSTNAME 1
#define ENABLE_HOSTNAME 1
#ifdef MAKE_SUID
# define IF_HOSTNAME(...) __VA_ARGS__ "CONFIG_HOSTNAME"
#else
# 4148 "./include/autoconf.h"
# define IF_HOSTNAME(...) __VA_ARGS__
#endif
# 4150 "./include/autoconf.h"
#define IF_NOT_HOSTNAME(...)
#undef CONFIG_DNSDOMAINNAME
#define ENABLE_DNSDOMAINNAME 0
#define IF_DNSDOMAINNAME(...)
#define IF_NOT_DNSDOMAINNAME(...) __VA_ARGS__
#define CONFIG_HTTPD 1
#define ENABLE_HTTPD 1
#ifdef MAKE_SUID
# define IF_HTTPD(...) __VA_ARGS__ "CONFIG_HTTPD"
#else
# 4160 "./include/autoconf.h"
# define IF_HTTPD(...) __VA_ARGS__
#endif
# 4162 "./include/autoconf.h"
#define IF_NOT_HTTPD(...)
#define CONFIG_FEATURE_HTTPD_RANGES 1
#define ENABLE_FEATURE_HTTPD_RANGES 1
#ifdef MAKE_SUID
# define IF_FEATURE_HTTPD_RANGES(...) __VA_ARGS__ "CONFIG_FEATURE_HTTPD_RANGES"
#else
# 4168 "./include/autoconf.h"
# define IF_FEATURE_HTTPD_RANGES(...) __VA_ARGS__
#endif
# 4170 "./include/autoconf.h"
#define IF_NOT_FEATURE_HTTPD_RANGES(...)
#undef CONFIG_FEATURE_HTTPD_SETUID
#define ENABLE_FEATURE_HTTPD_SETUID 0
#define IF_FEATURE_HTTPD_SETUID(...)
#define IF_NOT_FEATURE_HTTPD_SETUID(...) __VA_ARGS__
#define CONFIG_FEATURE_HTTPD_BASIC_AUTH 1
#define ENABLE_FEATURE_HTTPD_BASIC_AUTH 1
#ifdef MAKE_SUID
# define IF_FEATURE_HTTPD_BASIC_AUTH(...) __VA_ARGS__ "CONFIG_FEATURE_HTTPD_BASIC_AUTH"
#else
# 4180 "./include/autoconf.h"
# define IF_FEATURE_HTTPD_BASIC_AUTH(...) __VA_ARGS__
#endif
# 4182 "./include/autoconf.h"
#define IF_NOT_FEATURE_HTTPD_BASIC_AUTH(...)
#define CONFIG_FEATURE_HTTPD_AUTH_MD5 1
#define ENABLE_FEATURE_HTTPD_AUTH_MD5 1
#ifdef MAKE_SUID
# define IF_FEATURE_HTTPD_AUTH_MD5(...) __VA_ARGS__ "CONFIG_FEATURE_HTTPD_AUTH_MD5"
#else
# 4188 "./include/autoconf.h"
# define IF_FEATURE_HTTPD_AUTH_MD5(...) __VA_ARGS__
#endif
# 4190 "./include/autoconf.h"
#define IF_NOT_FEATURE_HTTPD_AUTH_MD5(...)
#define CONFIG_FEATURE_HTTPD_CGI 1
#define ENABLE_FEATURE_HTTPD_CGI 1
#ifdef MAKE_SUID
# define IF_FEATURE_HTTPD_CGI(...) __VA_ARGS__ "CONFIG_FEATURE_HTTPD_CGI"
#else
# 4196 "./include/autoconf.h"
# define IF_FEATURE_HTTPD_CGI(...) __VA_ARGS__
#endif
# 4198 "./include/autoconf.h"
#define IF_NOT_FEATURE_HTTPD_CGI(...)
#define CONFIG_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR 1
#define ENABLE_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR 1
#ifdef MAKE_SUID
# define IF_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR(...) __VA_ARGS__ "CONFIG_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR"
#else
# 4204 "./include/autoconf.h"
# define IF_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR(...) __VA_ARGS__
#endif
# 4206 "./include/autoconf.h"
#define IF_NOT_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR(...)
#define CONFIG_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV 1
#define ENABLE_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV 1
#ifdef MAKE_SUID
# define IF_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV(...) __VA_ARGS__ "CONFIG_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV"
#else
# 4212 "./include/autoconf.h"
# define IF_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV(...) __VA_ARGS__
#endif
# 4214 "./include/autoconf.h"
#define IF_NOT_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV(...)
#define CONFIG_FEATURE_HTTPD_ENCODE_URL_STR 1
#define ENABLE_FEATURE_HTTPD_ENCODE_URL_STR 1
#ifdef MAKE_SUID
# define IF_FEATURE_HTTPD_ENCODE_URL_STR(...) __VA_ARGS__ "CONFIG_FEATURE_HTTPD_ENCODE_URL_STR"
#else
# 4220 "./include/autoconf.h"
# define IF_FEATURE_HTTPD_ENCODE_URL_STR(...) __VA_ARGS__
#endif
# 4222 "./include/autoconf.h"
#define IF_NOT_FEATURE_HTTPD_ENCODE_URL_STR(...)
#define CONFIG_FEATURE_HTTPD_ERROR_PAGES 1
#define ENABLE_FEATURE_HTTPD_ERROR_PAGES 1
#ifdef MAKE_SUID
# define IF_FEATURE_HTTPD_ERROR_PAGES(...) __VA_ARGS__ "CONFIG_FEATURE_HTTPD_ERROR_PAGES"
#else
# 4228 "./include/autoconf.h"
# define IF_FEATURE_HTTPD_ERROR_PAGES(...) __VA_ARGS__
#endif
# 4230 "./include/autoconf.h"
#define IF_NOT_FEATURE_HTTPD_ERROR_PAGES(...)
#define CONFIG_FEATURE_HTTPD_PROXY 1
#define ENABLE_FEATURE_HTTPD_PROXY 1
#ifdef MAKE_SUID
# define IF_FEATURE_HTTPD_PROXY(...) __VA_ARGS__ "CONFIG_FEATURE_HTTPD_PROXY"
#else
# 4236 "./include/autoconf.h"
# define IF_FEATURE_HTTPD_PROXY(...) __VA_ARGS__
#endif
# 4238 "./include/autoconf.h"
#define IF_NOT_FEATURE_HTTPD_PROXY(...)
#define CONFIG_FEATURE_HTTPD_GZIP 1
#define ENABLE_FEATURE_HTTPD_GZIP 1
#ifdef MAKE_SUID
# define IF_FEATURE_HTTPD_GZIP(...) __VA_ARGS__ "CONFIG_FEATURE_HTTPD_GZIP"
#else
# 4244 "./include/autoconf.h"
# define IF_FEATURE_HTTPD_GZIP(...) __VA_ARGS__
#endif
# 4246 "./include/autoconf.h"
#define IF_NOT_FEATURE_HTTPD_GZIP(...)
#undef CONFIG_IFCONFIG
#define ENABLE_IFCONFIG 0
#define IF_IFCONFIG(...)
#define IF_NOT_IFCONFIG(...) __VA_ARGS__
#undef CONFIG_FEATURE_IFCONFIG_STATUS
#define ENABLE_FEATURE_IFCONFIG_STATUS 0
#define IF_FEATURE_IFCONFIG_STATUS(...)
#define IF_NOT_FEATURE_IFCONFIG_STATUS(...) __VA_ARGS__
#undef CONFIG_FEATURE_IFCONFIG_SLIP
#define ENABLE_FEATURE_IFCONFIG_SLIP 0
#define IF_FEATURE_IFCONFIG_SLIP(...)
#define IF_NOT_FEATURE_IFCONFIG_SLIP(...) __VA_ARGS__
#undef CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ
#define ENABLE_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ 0
#define IF_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ(...)
#define IF_NOT_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ(...) __VA_ARGS__
#undef CONFIG_FEATURE_IFCONFIG_HW
#define ENABLE_FEATURE_IFCONFIG_HW 0
#define IF_FEATURE_IFCONFIG_HW(...)
#define IF_NOT_FEATURE_IFCONFIG_HW(...) __VA_ARGS__
#undef CONFIG_FEATURE_IFCONFIG_BROADCAST_PLUS
#define ENABLE_FEATURE_IFCONFIG_BROADCAST_PLUS 0
#define IF_FEATURE_IFCONFIG_BROADCAST_PLUS(...)
#define IF_NOT_FEATURE_IFCONFIG_BROADCAST_PLUS(...) __VA_ARGS__
#undef CONFIG_IFENSLAVE
#define ENABLE_IFENSLAVE 0
#define IF_IFENSLAVE(...)
#define IF_NOT_IFENSLAVE(...) __VA_ARGS__
#undef CONFIG_IFPLUGD
#define ENABLE_IFPLUGD 0
#define IF_IFPLUGD(...)
#define IF_NOT_IFPLUGD(...) __VA_ARGS__
#undef CONFIG_IFUP
#define ENABLE_IFUP 0
#define IF_IFUP(...)
#define IF_NOT_IFUP(...) __VA_ARGS__
#undef CONFIG_IFDOWN
#define ENABLE_IFDOWN 0
#define IF_IFDOWN(...)
#define IF_NOT_IFDOWN(...) __VA_ARGS__
#define CONFIG_IFUPDOWN_IFSTATE_PATH ""
#define ENABLE_IFUPDOWN_IFSTATE_PATH 1
#ifdef MAKE_SUID
# define IF_IFUPDOWN_IFSTATE_PATH(...) __VA_ARGS__ "CONFIG_IFUPDOWN_IFSTATE_PATH"
#else
# 4292 "./include/autoconf.h"
# define IF_IFUPDOWN_IFSTATE_PATH(...) __VA_ARGS__
#endif
# 4294 "./include/autoconf.h"
#define IF_NOT_IFUPDOWN_IFSTATE_PATH(...)
#undef CONFIG_FEATURE_IFUPDOWN_IP
#define ENABLE_FEATURE_IFUPDOWN_IP 0
#define IF_FEATURE_IFUPDOWN_IP(...)
#define IF_NOT_FEATURE_IFUPDOWN_IP(...) __VA_ARGS__
#undef CONFIG_FEATURE_IFUPDOWN_IPV4
#define ENABLE_FEATURE_IFUPDOWN_IPV4 0
#define IF_FEATURE_IFUPDOWN_IPV4(...)
#define IF_NOT_FEATURE_IFUPDOWN_IPV4(...) __VA_ARGS__
#undef CONFIG_FEATURE_IFUPDOWN_IPV6
#define ENABLE_FEATURE_IFUPDOWN_IPV6 0
#define IF_FEATURE_IFUPDOWN_IPV6(...)
#define IF_NOT_FEATURE_IFUPDOWN_IPV6(...) __VA_ARGS__
#undef CONFIG_FEATURE_IFUPDOWN_MAPPING
#define ENABLE_FEATURE_IFUPDOWN_MAPPING 0
#define IF_FEATURE_IFUPDOWN_MAPPING(...)
#define IF_NOT_FEATURE_IFUPDOWN_MAPPING(...) __VA_ARGS__
#undef CONFIG_FEATURE_IFUPDOWN_EXTERNAL_DHCP
#define ENABLE_FEATURE_IFUPDOWN_EXTERNAL_DHCP 0
#define IF_FEATURE_IFUPDOWN_EXTERNAL_DHCP(...)
#define IF_NOT_FEATURE_IFUPDOWN_EXTERNAL_DHCP(...) __VA_ARGS__
#undef CONFIG_INETD
#define ENABLE_INETD 0
#define IF_INETD(...)
#define IF_NOT_INETD(...) __VA_ARGS__
#undef CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_ECHO
#define ENABLE_FEATURE_INETD_SUPPORT_BUILTIN_ECHO 0
#define IF_FEATURE_INETD_SUPPORT_BUILTIN_ECHO(...)
#define IF_NOT_FEATURE_INETD_SUPPORT_BUILTIN_ECHO(...) __VA_ARGS__
#undef CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_DISCARD
#define ENABLE_FEATURE_INETD_SUPPORT_BUILTIN_DISCARD 0
#define IF_FEATURE_INETD_SUPPORT_BUILTIN_DISCARD(...)
#define IF_NOT_FEATURE_INETD_SUPPORT_BUILTIN_DISCARD(...) __VA_ARGS__
#undef CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_TIME
#define ENABLE_FEATURE_INETD_SUPPORT_BUILTIN_TIME 0
#define IF_FEATURE_INETD_SUPPORT_BUILTIN_TIME(...)
#define IF_NOT_FEATURE_INETD_SUPPORT_BUILTIN_TIME(...) __VA_ARGS__
#undef CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_DAYTIME
#define ENABLE_FEATURE_INETD_SUPPORT_BUILTIN_DAYTIME 0
#define IF_FEATURE_INETD_SUPPORT_BUILTIN_DAYTIME(...)
#define IF_NOT_FEATURE_INETD_SUPPORT_BUILTIN_DAYTIME(...) __VA_ARGS__
#undef CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_CHARGEN
#define ENABLE_FEATURE_INETD_SUPPORT_BUILTIN_CHARGEN 0
#define IF_FEATURE_INETD_SUPPORT_BUILTIN_CHARGEN(...)
#define IF_NOT_FEATURE_INETD_SUPPORT_BUILTIN_CHARGEN(...) __VA_ARGS__
#undef CONFIG_FEATURE_INETD_RPC
#define ENABLE_FEATURE_INETD_RPC 0
#define IF_FEATURE_INETD_RPC(...)
#define IF_NOT_FEATURE_INETD_RPC(...) __VA_ARGS__
#undef CONFIG_IP
#define ENABLE_IP 0
#define IF_IP(...)
#define IF_NOT_IP(...) __VA_ARGS__
#undef CONFIG_IPADDR
#define ENABLE_IPADDR 0
#define IF_IPADDR(...)
#define IF_NOT_IPADDR(...) __VA_ARGS__
#undef CONFIG_IPLINK
#define ENABLE_IPLINK 0
#define IF_IPLINK(...)
#define IF_NOT_IPLINK(...) __VA_ARGS__
#undef CONFIG_IPROUTE
#define ENABLE_IPROUTE 0
#define IF_IPROUTE(...)
#define IF_NOT_IPROUTE(...) __VA_ARGS__
#undef CONFIG_IPTUNNEL
#define ENABLE_IPTUNNEL 0
#define IF_IPTUNNEL(...)
#define IF_NOT_IPTUNNEL(...) __VA_ARGS__
#undef CONFIG_IPRULE
#define ENABLE_IPRULE 0
#define IF_IPRULE(...)
#define IF_NOT_IPRULE(...) __VA_ARGS__
#undef CONFIG_IPNEIGH
#define ENABLE_IPNEIGH 0
#define IF_IPNEIGH(...)
#define IF_NOT_IPNEIGH(...) __VA_ARGS__
#undef CONFIG_FEATURE_IP_ADDRESS
#define ENABLE_FEATURE_IP_ADDRESS 0
#define IF_FEATURE_IP_ADDRESS(...)
#define IF_NOT_FEATURE_IP_ADDRESS(...) __VA_ARGS__
#undef CONFIG_FEATURE_IP_LINK
#define ENABLE_FEATURE_IP_LINK 0
#define IF_FEATURE_IP_LINK(...)
#define IF_NOT_FEATURE_IP_LINK(...) __VA_ARGS__
#undef CONFIG_FEATURE_IP_ROUTE
#define ENABLE_FEATURE_IP_ROUTE 0
#define IF_FEATURE_IP_ROUTE(...)
#define IF_NOT_FEATURE_IP_ROUTE(...) __VA_ARGS__
#define CONFIG_FEATURE_IP_ROUTE_DIR ""
#define ENABLE_FEATURE_IP_ROUTE_DIR 1
#ifdef MAKE_SUID
# define IF_FEATURE_IP_ROUTE_DIR(...) __VA_ARGS__ "CONFIG_FEATURE_IP_ROUTE_DIR"
#else
# 4388 "./include/autoconf.h"
# define IF_FEATURE_IP_ROUTE_DIR(...) __VA_ARGS__
#endif
# 4390 "./include/autoconf.h"
#define IF_NOT_FEATURE_IP_ROUTE_DIR(...)
#undef CONFIG_FEATURE_IP_TUNNEL
#define ENABLE_FEATURE_IP_TUNNEL 0
#define IF_FEATURE_IP_TUNNEL(...)
#define IF_NOT_FEATURE_IP_TUNNEL(...) __VA_ARGS__
#undef CONFIG_FEATURE_IP_RULE
#define ENABLE_FEATURE_IP_RULE 0
#define IF_FEATURE_IP_RULE(...)
#define IF_NOT_FEATURE_IP_RULE(...) __VA_ARGS__
#undef CONFIG_FEATURE_IP_NEIGH
#define ENABLE_FEATURE_IP_NEIGH 0
#define IF_FEATURE_IP_NEIGH(...)
#define IF_NOT_FEATURE_IP_NEIGH(...) __VA_ARGS__
#undef CONFIG_FEATURE_IP_RARE_PROTOCOLS
#define ENABLE_FEATURE_IP_RARE_PROTOCOLS 0
#define IF_FEATURE_IP_RARE_PROTOCOLS(...)
#define IF_NOT_FEATURE_IP_RARE_PROTOCOLS(...) __VA_ARGS__
#define CONFIG_IPCALC 1
#define ENABLE_IPCALC 1
#ifdef MAKE_SUID
# define IF_IPCALC(...) __VA_ARGS__ "CONFIG_IPCALC"
#else
# 4412 "./include/autoconf.h"
# define IF_IPCALC(...) __VA_ARGS__
#endif
# 4414 "./include/autoconf.h"
#define IF_NOT_IPCALC(...)
#define CONFIG_FEATURE_IPCALC_FANCY 1
#define ENABLE_FEATURE_IPCALC_FANCY 1
#ifdef MAKE_SUID
# define IF_FEATURE_IPCALC_FANCY(...) __VA_ARGS__ "CONFIG_FEATURE_IPCALC_FANCY"
#else
# 4420 "./include/autoconf.h"
# define IF_FEATURE_IPCALC_FANCY(...) __VA_ARGS__
#endif
# 4422 "./include/autoconf.h"
#define IF_NOT_FEATURE_IPCALC_FANCY(...)
#define CONFIG_FEATURE_IPCALC_LONG_OPTIONS 1
#define ENABLE_FEATURE_IPCALC_LONG_OPTIONS 1
#ifdef MAKE_SUID
# define IF_FEATURE_IPCALC_LONG_OPTIONS(...) __VA_ARGS__ "CONFIG_FEATURE_IPCALC_LONG_OPTIONS"
#else
# 4428 "./include/autoconf.h"
# define IF_FEATURE_IPCALC_LONG_OPTIONS(...) __VA_ARGS__
#endif
# 4430 "./include/autoconf.h"
#define IF_NOT_FEATURE_IPCALC_LONG_OPTIONS(...)
#define CONFIG_FAKEIDENTD 1
#define ENABLE_FAKEIDENTD 1
#ifdef MAKE_SUID
# define IF_FAKEIDENTD(...) __VA_ARGS__ "CONFIG_FAKEIDENTD"
#else
# 4436 "./include/autoconf.h"
# define IF_FAKEIDENTD(...) __VA_ARGS__
#endif
# 4438 "./include/autoconf.h"
#define IF_NOT_FAKEIDENTD(...)
#undef CONFIG_NAMEIF
#define ENABLE_NAMEIF 0
#define IF_NAMEIF(...)
#define IF_NOT_NAMEIF(...) __VA_ARGS__
#undef CONFIG_FEATURE_NAMEIF_EXTENDED
#define ENABLE_FEATURE_NAMEIF_EXTENDED 0
#define IF_FEATURE_NAMEIF_EXTENDED(...)
#define IF_NOT_FEATURE_NAMEIF_EXTENDED(...) __VA_ARGS__
#undef CONFIG_NBDCLIENT
#define ENABLE_NBDCLIENT 0
#define IF_NBDCLIENT(...)
#define IF_NOT_NBDCLIENT(...) __VA_ARGS__
#define CONFIG_NC 1
#define ENABLE_NC 1
#ifdef MAKE_SUID
# define IF_NC(...) __VA_ARGS__ "CONFIG_NC"
#else
# 4456 "./include/autoconf.h"
# define IF_NC(...) __VA_ARGS__
#endif
# 4458 "./include/autoconf.h"
#define IF_NOT_NC(...)
#undef CONFIG_NC_SERVER
#define ENABLE_NC_SERVER 0
#define IF_NC_SERVER(...)
#define IF_NOT_NC_SERVER(...) __VA_ARGS__
#undef CONFIG_NC_EXTRA
#define ENABLE_NC_EXTRA 0
#define IF_NC_EXTRA(...)
#define IF_NOT_NC_EXTRA(...) __VA_ARGS__
#undef CONFIG_NC_110_COMPAT
#define ENABLE_NC_110_COMPAT 0
#define IF_NC_110_COMPAT(...)
#define IF_NOT_NC_110_COMPAT(...) __VA_ARGS__
#undef CONFIG_NETSTAT
#define ENABLE_NETSTAT 0
#define IF_NETSTAT(...)
#define IF_NOT_NETSTAT(...) __VA_ARGS__
#undef CONFIG_FEATURE_NETSTAT_WIDE
#define ENABLE_FEATURE_NETSTAT_WIDE 0
#define IF_FEATURE_NETSTAT_WIDE(...)
#define IF_NOT_FEATURE_NETSTAT_WIDE(...) __VA_ARGS__
#undef CONFIG_FEATURE_NETSTAT_PRG
#define ENABLE_FEATURE_NETSTAT_PRG 0
#define IF_FEATURE_NETSTAT_PRG(...)
#define IF_NOT_FEATURE_NETSTAT_PRG(...) __VA_ARGS__
#undef CONFIG_NSLOOKUP
#define ENABLE_NSLOOKUP 0
#define IF_NSLOOKUP(...)
#define IF_NOT_NSLOOKUP(...) __VA_ARGS__
#undef CONFIG_NTPD
#define ENABLE_NTPD 0
#define IF_NTPD(...)
#define IF_NOT_NTPD(...) __VA_ARGS__
#undef CONFIG_FEATURE_NTPD_SERVER
#define ENABLE_FEATURE_NTPD_SERVER 0
#define IF_FEATURE_NTPD_SERVER(...)
#define IF_NOT_FEATURE_NTPD_SERVER(...) __VA_ARGS__
#undef CONFIG_FEATURE_NTPD_CONF
#define ENABLE_FEATURE_NTPD_CONF 0
#define IF_FEATURE_NTPD_CONF(...)
#define IF_NOT_FEATURE_NTPD_CONF(...) __VA_ARGS__
#undef CONFIG_PING
#define ENABLE_PING 0
#define IF_PING(...)
#define IF_NOT_PING(...) __VA_ARGS__
#undef CONFIG_PING6
#define ENABLE_PING6 0
#define IF_PING6(...)
#define IF_NOT_PING6(...) __VA_ARGS__
#undef CONFIG_FEATURE_FANCY_PING
#define ENABLE_FEATURE_FANCY_PING 0
#define IF_FEATURE_FANCY_PING(...)
#define IF_NOT_FEATURE_FANCY_PING(...) __VA_ARGS__
#define CONFIG_PSCAN 1
#define ENABLE_PSCAN 1
#ifdef MAKE_SUID
# define IF_PSCAN(...) __VA_ARGS__ "CONFIG_PSCAN"
#else
# 4516 "./include/autoconf.h"
# define IF_PSCAN(...) __VA_ARGS__
#endif
# 4518 "./include/autoconf.h"
#define IF_NOT_PSCAN(...)
#undef CONFIG_ROUTE
#define ENABLE_ROUTE 0
#define IF_ROUTE(...)
#define IF_NOT_ROUTE(...) __VA_ARGS__
#undef CONFIG_SLATTACH
#define ENABLE_SLATTACH 0
#define IF_SLATTACH(...)
#define IF_NOT_SLATTACH(...) __VA_ARGS__
#undef CONFIG_TCPSVD
#define ENABLE_TCPSVD 0
#define IF_TCPSVD(...)
#define IF_NOT_TCPSVD(...) __VA_ARGS__
#undef CONFIG_UDPSVD
#define ENABLE_UDPSVD 0
#define IF_UDPSVD(...)
#define IF_NOT_UDPSVD(...) __VA_ARGS__
#define CONFIG_TELNET 1
#define ENABLE_TELNET 1
#ifdef MAKE_SUID
# define IF_TELNET(...) __VA_ARGS__ "CONFIG_TELNET"
#else
# 4540 "./include/autoconf.h"
# define IF_TELNET(...) __VA_ARGS__
#endif
# 4542 "./include/autoconf.h"
#define IF_NOT_TELNET(...)
#define CONFIG_FEATURE_TELNET_TTYPE 1
#define ENABLE_FEATURE_TELNET_TTYPE 1
#ifdef MAKE_SUID
# define IF_FEATURE_TELNET_TTYPE(...) __VA_ARGS__ "CONFIG_FEATURE_TELNET_TTYPE"
#else
# 4548 "./include/autoconf.h"
# define IF_FEATURE_TELNET_TTYPE(...) __VA_ARGS__
#endif
# 4550 "./include/autoconf.h"
#define IF_NOT_FEATURE_TELNET_TTYPE(...)
#define CONFIG_FEATURE_TELNET_AUTOLOGIN 1
#define ENABLE_FEATURE_TELNET_AUTOLOGIN 1
#ifdef MAKE_SUID
# define IF_FEATURE_TELNET_AUTOLOGIN(...) __VA_ARGS__ "CONFIG_FEATURE_TELNET_AUTOLOGIN"
#else
# 4556 "./include/autoconf.h"
# define IF_FEATURE_TELNET_AUTOLOGIN(...) __VA_ARGS__
#endif
# 4558 "./include/autoconf.h"
#define IF_NOT_FEATURE_TELNET_AUTOLOGIN(...)
#define CONFIG_TELNETD 1
#define ENABLE_TELNETD 1
#ifdef MAKE_SUID
# define IF_TELNETD(...) __VA_ARGS__ "CONFIG_TELNETD"
#else
# 4564 "./include/autoconf.h"
# define IF_TELNETD(...) __VA_ARGS__
#endif
# 4566 "./include/autoconf.h"
#define IF_NOT_TELNETD(...)
#define CONFIG_FEATURE_TELNETD_STANDALONE 1
#define ENABLE_FEATURE_TELNETD_STANDALONE 1
#ifdef MAKE_SUID
# define IF_FEATURE_TELNETD_STANDALONE(...) __VA_ARGS__ "CONFIG_FEATURE_TELNETD_STANDALONE"
#else
# 4572 "./include/autoconf.h"
# define IF_FEATURE_TELNETD_STANDALONE(...) __VA_ARGS__
#endif
# 4574 "./include/autoconf.h"
#define IF_NOT_FEATURE_TELNETD_STANDALONE(...)
#define CONFIG_FEATURE_TELNETD_INETD_WAIT 1
#define ENABLE_FEATURE_TELNETD_INETD_WAIT 1
#ifdef MAKE_SUID
# define IF_FEATURE_TELNETD_INETD_WAIT(...) __VA_ARGS__ "CONFIG_FEATURE_TELNETD_INETD_WAIT"
#else
# 4580 "./include/autoconf.h"
# define IF_FEATURE_TELNETD_INETD_WAIT(...) __VA_ARGS__
#endif
# 4582 "./include/autoconf.h"
#define IF_NOT_FEATURE_TELNETD_INETD_WAIT(...)
#define CONFIG_TFTP 1
#define ENABLE_TFTP 1
#ifdef MAKE_SUID
# define IF_TFTP(...) __VA_ARGS__ "CONFIG_TFTP"
#else
# 4588 "./include/autoconf.h"
# define IF_TFTP(...) __VA_ARGS__
#endif
# 4590 "./include/autoconf.h"
#define IF_NOT_TFTP(...)
#define CONFIG_TFTPD 1
#define ENABLE_TFTPD 1
#ifdef MAKE_SUID
# define IF_TFTPD(...) __VA_ARGS__ "CONFIG_TFTPD"
#else
# 4596 "./include/autoconf.h"
# define IF_TFTPD(...) __VA_ARGS__
#endif
# 4598 "./include/autoconf.h"
#define IF_NOT_TFTPD(...)

/*
 * Common options for tftp/tftpd
 */
#define CONFIG_FEATURE_TFTP_GET 1
#define ENABLE_FEATURE_TFTP_GET 1
#ifdef MAKE_SUID
# define IF_FEATURE_TFTP_GET(...) __VA_ARGS__ "CONFIG_FEATURE_TFTP_GET"
#else
# 4608 "./include/autoconf.h"
# define IF_FEATURE_TFTP_GET(...) __VA_ARGS__
#endif
# 4610 "./include/autoconf.h"
#define IF_NOT_FEATURE_TFTP_GET(...)
#define CONFIG_FEATURE_TFTP_PUT 1
#define ENABLE_FEATURE_TFTP_PUT 1
#ifdef MAKE_SUID
# define IF_FEATURE_TFTP_PUT(...) __VA_ARGS__ "CONFIG_FEATURE_TFTP_PUT"
#else
# 4616 "./include/autoconf.h"
# define IF_FEATURE_TFTP_PUT(...) __VA_ARGS__
#endif
# 4618 "./include/autoconf.h"
#define IF_NOT_FEATURE_TFTP_PUT(...)
#define CONFIG_FEATURE_TFTP_BLOCKSIZE 1
#define ENABLE_FEATURE_TFTP_BLOCKSIZE 1
#ifdef MAKE_SUID
# define IF_FEATURE_TFTP_BLOCKSIZE(...) __VA_ARGS__ "CONFIG_FEATURE_TFTP_BLOCKSIZE"
#else
# 4624 "./include/autoconf.h"
# define IF_FEATURE_TFTP_BLOCKSIZE(...) __VA_ARGS__
#endif
# 4626 "./include/autoconf.h"
#define IF_NOT_FEATURE_TFTP_BLOCKSIZE(...)
#define CONFIG_FEATURE_TFTP_PROGRESS_BAR 1
#define ENABLE_FEATURE_TFTP_PROGRESS_BAR 1
#ifdef MAKE_SUID
# define IF_FEATURE_TFTP_PROGRESS_BAR(...) __VA_ARGS__ "CONFIG_FEATURE_TFTP_PROGRESS_BAR"
#else
# 4632 "./include/autoconf.h"
# define IF_FEATURE_TFTP_PROGRESS_BAR(...) __VA_ARGS__
#endif
# 4634 "./include/autoconf.h"
#define IF_NOT_FEATURE_TFTP_PROGRESS_BAR(...)
#undef CONFIG_TFTP_DEBUG
#define ENABLE_TFTP_DEBUG 0
#define IF_TFTP_DEBUG(...)
#define IF_NOT_TFTP_DEBUG(...) __VA_ARGS__
#undef CONFIG_TRACEROUTE
#define ENABLE_TRACEROUTE 0
#define IF_TRACEROUTE(...)
#define IF_NOT_TRACEROUTE(...) __VA_ARGS__
#undef CONFIG_TRACEROUTE6
#define ENABLE_TRACEROUTE6 0
#define IF_TRACEROUTE6(...)
#define IF_NOT_TRACEROUTE6(...) __VA_ARGS__
#undef CONFIG_FEATURE_TRACEROUTE_VERBOSE
#define ENABLE_FEATURE_TRACEROUTE_VERBOSE 0
#define IF_FEATURE_TRACEROUTE_VERBOSE(...)
#define IF_NOT_FEATURE_TRACEROUTE_VERBOSE(...) __VA_ARGS__
#undef CONFIG_FEATURE_TRACEROUTE_USE_ICMP
#define ENABLE_FEATURE_TRACEROUTE_USE_ICMP 0
#define IF_FEATURE_TRACEROUTE_USE_ICMP(...)
#define IF_NOT_FEATURE_TRACEROUTE_USE_ICMP(...) __VA_ARGS__
#undef CONFIG_TUNCTL
#define ENABLE_TUNCTL 0
#define IF_TUNCTL(...)
#define IF_NOT_TUNCTL(...) __VA_ARGS__
#undef CONFIG_FEATURE_TUNCTL_UG
#define ENABLE_FEATURE_TUNCTL_UG 0
#define IF_FEATURE_TUNCTL_UG(...)
#define IF_NOT_FEATURE_TUNCTL_UG(...) __VA_ARGS__
#undef CONFIG_VCONFIG
#define ENABLE_VCONFIG 0
#define IF_VCONFIG(...)
#define IF_NOT_VCONFIG(...) __VA_ARGS__
#define CONFIG_WGET 1
#define ENABLE_WGET 1
#ifdef MAKE_SUID
# define IF_WGET(...) __VA_ARGS__ "CONFIG_WGET"
#else
# 4672 "./include/autoconf.h"
# define IF_WGET(...) __VA_ARGS__
#endif
# 4674 "./include/autoconf.h"
#define IF_NOT_WGET(...)
#define CONFIG_FEATURE_WGET_STATUSBAR 1
#define ENABLE_FEATURE_WGET_STATUSBAR 1
#ifdef MAKE_SUID
# define IF_FEATURE_WGET_STATUSBAR(...) __VA_ARGS__ "CONFIG_FEATURE_WGET_STATUSBAR"
#else
# 4680 "./include/autoconf.h"
# define IF_FEATURE_WGET_STATUSBAR(...) __VA_ARGS__
#endif
# 4682 "./include/autoconf.h"
#define IF_NOT_FEATURE_WGET_STATUSBAR(...)
#define CONFIG_FEATURE_WGET_AUTHENTICATION 1
#define ENABLE_FEATURE_WGET_AUTHENTICATION 1
#ifdef MAKE_SUID
# define IF_FEATURE_WGET_AUTHENTICATION(...) __VA_ARGS__ "CONFIG_FEATURE_WGET_AUTHENTICATION"
#else
# 4688 "./include/autoconf.h"
# define IF_FEATURE_WGET_AUTHENTICATION(...) __VA_ARGS__
#endif
# 4690 "./include/autoconf.h"
#define IF_NOT_FEATURE_WGET_AUTHENTICATION(...)
#define CONFIG_FEATURE_WGET_LONG_OPTIONS 1
#define ENABLE_FEATURE_WGET_LONG_OPTIONS 1
#ifdef MAKE_SUID
# define IF_FEATURE_WGET_LONG_OPTIONS(...) __VA_ARGS__ "CONFIG_FEATURE_WGET_LONG_OPTIONS"
#else
# 4696 "./include/autoconf.h"
# define IF_FEATURE_WGET_LONG_OPTIONS(...) __VA_ARGS__
#endif
# 4698 "./include/autoconf.h"
#define IF_NOT_FEATURE_WGET_LONG_OPTIONS(...)
#define CONFIG_FEATURE_WGET_TIMEOUT 1
#define ENABLE_FEATURE_WGET_TIMEOUT 1
#ifdef MAKE_SUID
# define IF_FEATURE_WGET_TIMEOUT(...) __VA_ARGS__ "CONFIG_FEATURE_WGET_TIMEOUT"
#else
# 4704 "./include/autoconf.h"
# define IF_FEATURE_WGET_TIMEOUT(...) __VA_ARGS__
#endif
# 4706 "./include/autoconf.h"
#define IF_NOT_FEATURE_WGET_TIMEOUT(...)
#define CONFIG_FEATURE_WGET_OPENSSL 1
#define ENABLE_FEATURE_WGET_OPENSSL 1
#ifdef MAKE_SUID
# define IF_FEATURE_WGET_OPENSSL(...) __VA_ARGS__ "CONFIG_FEATURE_WGET_OPENSSL"
#else
# 4712 "./include/autoconf.h"
# define IF_FEATURE_WGET_OPENSSL(...) __VA_ARGS__
#endif
# 4714 "./include/autoconf.h"
#define IF_NOT_FEATURE_WGET_OPENSSL(...)
#define CONFIG_FEATURE_WGET_SSL_HELPER 1
#define ENABLE_FEATURE_WGET_SSL_HELPER 1
#ifdef MAKE_SUID
# define IF_FEATURE_WGET_SSL_HELPER(...) __VA_ARGS__ "CONFIG_FEATURE_WGET_SSL_HELPER"
#else
# 4720 "./include/autoconf.h"
# define IF_FEATURE_WGET_SSL_HELPER(...) __VA_ARGS__
#endif
# 4722 "./include/autoconf.h"
#define IF_NOT_FEATURE_WGET_SSL_HELPER(...)
#undef CONFIG_WHOIS
#define ENABLE_WHOIS 0
#define IF_WHOIS(...)
#define IF_NOT_WHOIS(...) __VA_ARGS__
#undef CONFIG_ZCIP
#define ENABLE_ZCIP 0
#define IF_ZCIP(...)
#define IF_NOT_ZCIP(...) __VA_ARGS__
#undef CONFIG_UDHCPC6
#define ENABLE_UDHCPC6 0
#define IF_UDHCPC6(...)
#define IF_NOT_UDHCPC6(...) __VA_ARGS__
#undef CONFIG_UDHCPD
#define ENABLE_UDHCPD 0
#define IF_UDHCPD(...)
#define IF_NOT_UDHCPD(...) __VA_ARGS__
#undef CONFIG_DHCPRELAY
#define ENABLE_DHCPRELAY 0
#define IF_DHCPRELAY(...)
#define IF_NOT_DHCPRELAY(...) __VA_ARGS__
#undef CONFIG_DUMPLEASES
#define ENABLE_DUMPLEASES 0
#define IF_DUMPLEASES(...)
#define IF_NOT_DUMPLEASES(...) __VA_ARGS__
#undef CONFIG_FEATURE_UDHCPD_WRITE_LEASES_EARLY
#define ENABLE_FEATURE_UDHCPD_WRITE_LEASES_EARLY 0
#define IF_FEATURE_UDHCPD_WRITE_LEASES_EARLY(...)
#define IF_NOT_FEATURE_UDHCPD_WRITE_LEASES_EARLY(...) __VA_ARGS__
#undef CONFIG_FEATURE_UDHCPD_BASE_IP_ON_MAC
#define ENABLE_FEATURE_UDHCPD_BASE_IP_ON_MAC 0
#define IF_FEATURE_UDHCPD_BASE_IP_ON_MAC(...)
#define IF_NOT_FEATURE_UDHCPD_BASE_IP_ON_MAC(...) __VA_ARGS__
#define CONFIG_DHCPD_LEASES_FILE ""
#define ENABLE_DHCPD_LEASES_FILE 1
#ifdef MAKE_SUID
# define IF_DHCPD_LEASES_FILE(...) __VA_ARGS__ "CONFIG_DHCPD_LEASES_FILE"
#else
# 4760 "./include/autoconf.h"
# define IF_DHCPD_LEASES_FILE(...) __VA_ARGS__
#endif
# 4762 "./include/autoconf.h"
#define IF_NOT_DHCPD_LEASES_FILE(...)
#undef CONFIG_UDHCPC
#define ENABLE_UDHCPC 0
#define IF_UDHCPC(...)
#define IF_NOT_UDHCPC(...) __VA_ARGS__
#undef CONFIG_FEATURE_UDHCPC_ARPING
#define ENABLE_FEATURE_UDHCPC_ARPING 0
#define IF_FEATURE_UDHCPC_ARPING(...)
#define IF_NOT_FEATURE_UDHCPC_ARPING(...) __VA_ARGS__
#undef CONFIG_FEATURE_UDHCPC_SANITIZEOPT
#define ENABLE_FEATURE_UDHCPC_SANITIZEOPT 0
#define IF_FEATURE_UDHCPC_SANITIZEOPT(...)
#define IF_NOT_FEATURE_UDHCPC_SANITIZEOPT(...) __VA_ARGS__
#undef CONFIG_FEATURE_UDHCP_PORT
#define ENABLE_FEATURE_UDHCP_PORT 0
#define IF_FEATURE_UDHCP_PORT(...)
#define IF_NOT_FEATURE_UDHCP_PORT(...) __VA_ARGS__
#define CONFIG_UDHCP_DEBUG 0
#define ENABLE_UDHCP_DEBUG 1
#ifdef MAKE_SUID
# define IF_UDHCP_DEBUG(...) __VA_ARGS__ "CONFIG_UDHCP_DEBUG"
#else
# 4784 "./include/autoconf.h"
# define IF_UDHCP_DEBUG(...) __VA_ARGS__
#endif
# 4786 "./include/autoconf.h"
#define IF_NOT_UDHCP_DEBUG(...)
#undef CONFIG_FEATURE_UDHCP_RFC3397
#define ENABLE_FEATURE_UDHCP_RFC3397 0
#define IF_FEATURE_UDHCP_RFC3397(...)
#define IF_NOT_FEATURE_UDHCP_RFC3397(...) __VA_ARGS__
#undef CONFIG_FEATURE_UDHCP_8021Q
#define ENABLE_FEATURE_UDHCP_8021Q 0
#define IF_FEATURE_UDHCP_8021Q(...)
#define IF_NOT_FEATURE_UDHCP_8021Q(...) __VA_ARGS__
#define CONFIG_UDHCPC_DEFAULT_SCRIPT ""
#define ENABLE_UDHCPC_DEFAULT_SCRIPT 1
#ifdef MAKE_SUID
# define IF_UDHCPC_DEFAULT_SCRIPT(...) __VA_ARGS__ "CONFIG_UDHCPC_DEFAULT_SCRIPT"
#else
# 4800 "./include/autoconf.h"
# define IF_UDHCPC_DEFAULT_SCRIPT(...) __VA_ARGS__
#endif
# 4802 "./include/autoconf.h"
#define IF_NOT_UDHCPC_DEFAULT_SCRIPT(...)
#define CONFIG_UDHCPC_SLACK_FOR_BUGGY_SERVERS 0
#define ENABLE_UDHCPC_SLACK_FOR_BUGGY_SERVERS 1
#ifdef MAKE_SUID
# define IF_UDHCPC_SLACK_FOR_BUGGY_SERVERS(...) __VA_ARGS__ "CONFIG_UDHCPC_SLACK_FOR_BUGGY_SERVERS"
#else
# 4808 "./include/autoconf.h"
# define IF_UDHCPC_SLACK_FOR_BUGGY_SERVERS(...) __VA_ARGS__
#endif
# 4810 "./include/autoconf.h"
#define IF_NOT_UDHCPC_SLACK_FOR_BUGGY_SERVERS(...)
#define CONFIG_IFUPDOWN_UDHCPC_CMD_OPTIONS ""
#define ENABLE_IFUPDOWN_UDHCPC_CMD_OPTIONS 1
#ifdef MAKE_SUID
# define IF_IFUPDOWN_UDHCPC_CMD_OPTIONS(...) __VA_ARGS__ "CONFIG_IFUPDOWN_UDHCPC_CMD_OPTIONS"
#else
# 4816 "./include/autoconf.h"
# define IF_IFUPDOWN_UDHCPC_CMD_OPTIONS(...) __VA_ARGS__
#endif
# 4818 "./include/autoconf.h"
#define IF_NOT_IFUPDOWN_UDHCPC_CMD_OPTIONS(...)

/*
 * Print Utilities
 */
#undef CONFIG_LPD
#define ENABLE_LPD 0
#define IF_LPD(...)
#define IF_NOT_LPD(...) __VA_ARGS__
#define CONFIG_LPR 1
#define ENABLE_LPR 1
#ifdef MAKE_SUID
# define IF_LPR(...) __VA_ARGS__ "CONFIG_LPR"
#else
# 4832 "./include/autoconf.h"
# define IF_LPR(...) __VA_ARGS__
#endif
# 4834 "./include/autoconf.h"
#define IF_NOT_LPR(...)
#define CONFIG_LPQ 1
#define ENABLE_LPQ 1
#ifdef MAKE_SUID
# define IF_LPQ(...) __VA_ARGS__ "CONFIG_LPQ"
#else
# 4840 "./include/autoconf.h"
# define IF_LPQ(...) __VA_ARGS__
#endif
# 4842 "./include/autoconf.h"
#define IF_NOT_LPQ(...)

/*
 * Mail Utilities
 */
#undef CONFIG_MAKEMIME
#define ENABLE_MAKEMIME 0
#define IF_MAKEMIME(...)
#define IF_NOT_MAKEMIME(...) __VA_ARGS__
#undef CONFIG_POPMAILDIR
#define ENABLE_POPMAILDIR 0
#define IF_POPMAILDIR(...)
#define IF_NOT_POPMAILDIR(...) __VA_ARGS__
#undef CONFIG_FEATURE_POPMAILDIR_DELIVERY
#define ENABLE_FEATURE_POPMAILDIR_DELIVERY 0
#define IF_FEATURE_POPMAILDIR_DELIVERY(...)
#define IF_NOT_FEATURE_POPMAILDIR_DELIVERY(...) __VA_ARGS__
#undef CONFIG_REFORMIME
#define ENABLE_REFORMIME 0
#define IF_REFORMIME(...)
#define IF_NOT_REFORMIME(...) __VA_ARGS__
#undef CONFIG_FEATURE_REFORMIME_COMPAT
#define ENABLE_FEATURE_REFORMIME_COMPAT 0
#define IF_FEATURE_REFORMIME_COMPAT(...)
#define IF_NOT_FEATURE_REFORMIME_COMPAT(...) __VA_ARGS__
#undef CONFIG_SENDMAIL
#define ENABLE_SENDMAIL 0
#define IF_SENDMAIL(...)
#define IF_NOT_SENDMAIL(...) __VA_ARGS__
#define CONFIG_FEATURE_MIME_CHARSET ""
#define ENABLE_FEATURE_MIME_CHARSET 1
#ifdef MAKE_SUID
# define IF_FEATURE_MIME_CHARSET(...) __VA_ARGS__ "CONFIG_FEATURE_MIME_CHARSET"
#else
# 4876 "./include/autoconf.h"
# define IF_FEATURE_MIME_CHARSET(...) __VA_ARGS__
#endif
# 4878 "./include/autoconf.h"
#define IF_NOT_FEATURE_MIME_CHARSET(...)

/*
 * Process Utilities
 */
#undef CONFIG_FREE
#define ENABLE_FREE 0
#define IF_FREE(...)
#define IF_NOT_FREE(...) __VA_ARGS__
#undef CONFIG_FUSER
#define ENABLE_FUSER 0
#define IF_FUSER(...)
#define IF_NOT_FUSER(...) __VA_ARGS__
#define CONFIG_IOSTAT 1
#define ENABLE_IOSTAT 1
#ifdef MAKE_SUID
# define IF_IOSTAT(...) __VA_ARGS__ "CONFIG_IOSTAT"
#else
# 4896 "./include/autoconf.h"
# define IF_IOSTAT(...) __VA_ARGS__
#endif
# 4898 "./include/autoconf.h"
#define IF_NOT_IOSTAT(...)
#define CONFIG_KILL 1
#define ENABLE_KILL 1
#ifdef MAKE_SUID
# define IF_KILL(...) __VA_ARGS__ "CONFIG_KILL"
#else
# 4904 "./include/autoconf.h"
# define IF_KILL(...) __VA_ARGS__
#endif
# 4906 "./include/autoconf.h"
#define IF_NOT_KILL(...)
#define CONFIG_KILLALL 1
#define ENABLE_KILLALL 1
#ifdef MAKE_SUID
# define IF_KILLALL(...) __VA_ARGS__ "CONFIG_KILLALL"
#else
# 4912 "./include/autoconf.h"
# define IF_KILLALL(...) __VA_ARGS__
#endif
# 4914 "./include/autoconf.h"
#define IF_NOT_KILLALL(...)
#define CONFIG_KILLALL5 1
#define ENABLE_KILLALL5 1
#ifdef MAKE_SUID
# define IF_KILLALL5(...) __VA_ARGS__ "CONFIG_KILLALL5"
#else
# 4920 "./include/autoconf.h"
# define IF_KILLALL5(...) __VA_ARGS__
#endif
# 4922 "./include/autoconf.h"
#define IF_NOT_KILLALL5(...)
#define CONFIG_LSOF 1
#define ENABLE_LSOF 1
#ifdef MAKE_SUID
# define IF_LSOF(...) __VA_ARGS__ "CONFIG_LSOF"
#else
# 4928 "./include/autoconf.h"
# define IF_LSOF(...) __VA_ARGS__
#endif
# 4930 "./include/autoconf.h"
#define IF_NOT_LSOF(...)
#define CONFIG_MPSTAT 1
#define ENABLE_MPSTAT 1
#ifdef MAKE_SUID
# define IF_MPSTAT(...) __VA_ARGS__ "CONFIG_MPSTAT"
#else
# 4936 "./include/autoconf.h"
# define IF_MPSTAT(...) __VA_ARGS__
#endif
# 4938 "./include/autoconf.h"
#define IF_NOT_MPSTAT(...)
#undef CONFIG_NMETER
#define ENABLE_NMETER 0
#define IF_NMETER(...)
#define IF_NOT_NMETER(...) __VA_ARGS__
#define CONFIG_PGREP 1
#define ENABLE_PGREP 1
#ifdef MAKE_SUID
# define IF_PGREP(...) __VA_ARGS__ "CONFIG_PGREP"
#else
# 4948 "./include/autoconf.h"
# define IF_PGREP(...) __VA_ARGS__
#endif
# 4950 "./include/autoconf.h"
#define IF_NOT_PGREP(...)
#define CONFIG_PKILL 1
#define ENABLE_PKILL 1
#ifdef MAKE_SUID
# define IF_PKILL(...) __VA_ARGS__ "CONFIG_PKILL"
#else
# 4956 "./include/autoconf.h"
# define IF_PKILL(...) __VA_ARGS__
#endif
# 4958 "./include/autoconf.h"
#define IF_NOT_PKILL(...)
#undef CONFIG_PIDOF
#define ENABLE_PIDOF 0
#define IF_PIDOF(...)
#define IF_NOT_PIDOF(...) __VA_ARGS__
#undef CONFIG_FEATURE_PIDOF_SINGLE
#define ENABLE_FEATURE_PIDOF_SINGLE 0
#define IF_FEATURE_PIDOF_SINGLE(...)
#define IF_NOT_FEATURE_PIDOF_SINGLE(...) __VA_ARGS__
#undef CONFIG_FEATURE_PIDOF_OMIT
#define ENABLE_FEATURE_PIDOF_OMIT 0
#define IF_FEATURE_PIDOF_OMIT(...)
#define IF_NOT_FEATURE_PIDOF_OMIT(...) __VA_ARGS__
#define CONFIG_PMAP 1
#define ENABLE_PMAP 1
#ifdef MAKE_SUID
# define IF_PMAP(...) __VA_ARGS__ "CONFIG_PMAP"
#else
# 4976 "./include/autoconf.h"
# define IF_PMAP(...) __VA_ARGS__
#endif
# 4978 "./include/autoconf.h"
#define IF_NOT_PMAP(...)
#define CONFIG_POWERTOP 1
#define ENABLE_POWERTOP 1
#ifdef MAKE_SUID
# define IF_POWERTOP(...) __VA_ARGS__ "CONFIG_POWERTOP"
#else
# 4984 "./include/autoconf.h"
# define IF_POWERTOP(...) __VA_ARGS__
#endif
# 4986 "./include/autoconf.h"
#define IF_NOT_POWERTOP(...)
#define CONFIG_PS 1
#define ENABLE_PS 1
#ifdef MAKE_SUID
# define IF_PS(...) __VA_ARGS__ "CONFIG_PS"
#else
# 4992 "./include/autoconf.h"
# define IF_PS(...) __VA_ARGS__
#endif
# 4994 "./include/autoconf.h"
#define IF_NOT_PS(...)
#define CONFIG_FEATURE_PS_WIDE 1
#define ENABLE_FEATURE_PS_WIDE 1
#ifdef MAKE_SUID
# define IF_FEATURE_PS_WIDE(...) __VA_ARGS__ "CONFIG_FEATURE_PS_WIDE"
#else
# 5000 "./include/autoconf.h"
# define IF_FEATURE_PS_WIDE(...) __VA_ARGS__
#endif
# 5002 "./include/autoconf.h"
#define IF_NOT_FEATURE_PS_WIDE(...)
#define CONFIG_FEATURE_PS_LONG 1
#define ENABLE_FEATURE_PS_LONG 1
#ifdef MAKE_SUID
# define IF_FEATURE_PS_LONG(...) __VA_ARGS__ "CONFIG_FEATURE_PS_LONG"
#else
# 5008 "./include/autoconf.h"
# define IF_FEATURE_PS_LONG(...) __VA_ARGS__
#endif
# 5010 "./include/autoconf.h"
#define IF_NOT_FEATURE_PS_LONG(...)
#undef CONFIG_FEATURE_PS_TIME
#define ENABLE_FEATURE_PS_TIME 0
#define IF_FEATURE_PS_TIME(...)
#define IF_NOT_FEATURE_PS_TIME(...) __VA_ARGS__
#undef CONFIG_FEATURE_PS_ADDITIONAL_COLUMNS
#define ENABLE_FEATURE_PS_ADDITIONAL_COLUMNS 0
#define IF_FEATURE_PS_ADDITIONAL_COLUMNS(...)
#define IF_NOT_FEATURE_PS_ADDITIONAL_COLUMNS(...) __VA_ARGS__
#undef CONFIG_FEATURE_PS_UNUSUAL_SYSTEMS
#define ENABLE_FEATURE_PS_UNUSUAL_SYSTEMS 0
#define IF_FEATURE_PS_UNUSUAL_SYSTEMS(...)
#define IF_NOT_FEATURE_PS_UNUSUAL_SYSTEMS(...) __VA_ARGS__
#define CONFIG_PSTREE 1
#define ENABLE_PSTREE 1
#ifdef MAKE_SUID
# define IF_PSTREE(...) __VA_ARGS__ "CONFIG_PSTREE"
#else
# 5028 "./include/autoconf.h"
# define IF_PSTREE(...) __VA_ARGS__
#endif
# 5030 "./include/autoconf.h"
#define IF_NOT_PSTREE(...)
#define CONFIG_PWDX 1
#define ENABLE_PWDX 1
#ifdef MAKE_SUID
# define IF_PWDX(...) __VA_ARGS__ "CONFIG_PWDX"
#else
# 5036 "./include/autoconf.h"
# define IF_PWDX(...) __VA_ARGS__
#endif
# 5038 "./include/autoconf.h"
#define IF_NOT_PWDX(...)
#define CONFIG_RENICE 1
#define ENABLE_RENICE 1
#ifdef MAKE_SUID
# define IF_RENICE(...) __VA_ARGS__ "CONFIG_RENICE"
#else
# 5044 "./include/autoconf.h"
# define IF_RENICE(...) __VA_ARGS__
#endif
# 5046 "./include/autoconf.h"
#define IF_NOT_RENICE(...)
#define CONFIG_SMEMCAP 1
#define ENABLE_SMEMCAP 1
#ifdef MAKE_SUID
# define IF_SMEMCAP(...) __VA_ARGS__ "CONFIG_SMEMCAP"
#else
# 5052 "./include/autoconf.h"
# define IF_SMEMCAP(...) __VA_ARGS__
#endif
# 5054 "./include/autoconf.h"
#define IF_NOT_SMEMCAP(...)
#define CONFIG_BB_SYSCTL 1
#define ENABLE_BB_SYSCTL 1
#ifdef MAKE_SUID
# define IF_BB_SYSCTL(...) __VA_ARGS__ "CONFIG_BB_SYSCTL"
#else
# 5060 "./include/autoconf.h"
# define IF_BB_SYSCTL(...) __VA_ARGS__
#endif
# 5062 "./include/autoconf.h"
#define IF_NOT_BB_SYSCTL(...)
#undef CONFIG_TOP
#define ENABLE_TOP 0
#define IF_TOP(...)
#define IF_NOT_TOP(...) __VA_ARGS__
#undef CONFIG_FEATURE_TOP_CPU_USAGE_PERCENTAGE
#define ENABLE_FEATURE_TOP_CPU_USAGE_PERCENTAGE 0
#define IF_FEATURE_TOP_CPU_USAGE_PERCENTAGE(...)
#define IF_NOT_FEATURE_TOP_CPU_USAGE_PERCENTAGE(...) __VA_ARGS__
#undef CONFIG_FEATURE_TOP_CPU_GLOBAL_PERCENTS
#define ENABLE_FEATURE_TOP_CPU_GLOBAL_PERCENTS 0
#define IF_FEATURE_TOP_CPU_GLOBAL_PERCENTS(...)
#define IF_NOT_FEATURE_TOP_CPU_GLOBAL_PERCENTS(...) __VA_ARGS__
#undef CONFIG_FEATURE_TOP_SMP_CPU
#define ENABLE_FEATURE_TOP_SMP_CPU 0
#define IF_FEATURE_TOP_SMP_CPU(...)
#define IF_NOT_FEATURE_TOP_SMP_CPU(...) __VA_ARGS__
#undef CONFIG_FEATURE_TOP_DECIMALS
#define ENABLE_FEATURE_TOP_DECIMALS 0
#define IF_FEATURE_TOP_DECIMALS(...)
#define IF_NOT_FEATURE_TOP_DECIMALS(...) __VA_ARGS__
#undef CONFIG_FEATURE_TOP_SMP_PROCESS
#define ENABLE_FEATURE_TOP_SMP_PROCESS 0
#define IF_FEATURE_TOP_SMP_PROCESS(...)
#define IF_NOT_FEATURE_TOP_SMP_PROCESS(...) __VA_ARGS__
#undef CONFIG_FEATURE_TOPMEM
#define ENABLE_FEATURE_TOPMEM 0
#define IF_FEATURE_TOPMEM(...)
#define IF_NOT_FEATURE_TOPMEM(...) __VA_ARGS__
#undef CONFIG_UPTIME
#define ENABLE_UPTIME 0
#define IF_UPTIME(...)
#define IF_NOT_UPTIME(...) __VA_ARGS__
#undef CONFIG_FEATURE_UPTIME_UTMP_SUPPORT
#define ENABLE_FEATURE_UPTIME_UTMP_SUPPORT 0
#define IF_FEATURE_UPTIME_UTMP_SUPPORT(...)
#define IF_NOT_FEATURE_UPTIME_UTMP_SUPPORT(...) __VA_ARGS__
#define CONFIG_WATCH 1
#define ENABLE_WATCH 1
#ifdef MAKE_SUID
# define IF_WATCH(...) __VA_ARGS__ "CONFIG_WATCH"
#else
# 5104 "./include/autoconf.h"
# define IF_WATCH(...) __VA_ARGS__
#endif
# 5106 "./include/autoconf.h"
#define IF_NOT_WATCH(...)
#define CONFIG_FEATURE_SHOW_THREADS 1
#define ENABLE_FEATURE_SHOW_THREADS 1
#ifdef MAKE_SUID
# define IF_FEATURE_SHOW_THREADS(...) __VA_ARGS__ "CONFIG_FEATURE_SHOW_THREADS"
#else
# 5112 "./include/autoconf.h"
# define IF_FEATURE_SHOW_THREADS(...) __VA_ARGS__
#endif
# 5114 "./include/autoconf.h"
#define IF_NOT_FEATURE_SHOW_THREADS(...)

/*
 * Runit Utilities
 */
#undef CONFIG_CHPST
#define ENABLE_CHPST 0
#define IF_CHPST(...)
#define IF_NOT_CHPST(...) __VA_ARGS__
#undef CONFIG_SETUIDGID
#define ENABLE_SETUIDGID 0
#define IF_SETUIDGID(...)
#define IF_NOT_SETUIDGID(...) __VA_ARGS__
#undef CONFIG_ENVUIDGID
#define ENABLE_ENVUIDGID 0
#define IF_ENVUIDGID(...)
#define IF_NOT_ENVUIDGID(...) __VA_ARGS__
#undef CONFIG_ENVDIR
#define ENABLE_ENVDIR 0
#define IF_ENVDIR(...)
#define IF_NOT_ENVDIR(...) __VA_ARGS__
#undef CONFIG_SOFTLIMIT
#define ENABLE_SOFTLIMIT 0
#define IF_SOFTLIMIT(...)
#define IF_NOT_SOFTLIMIT(...) __VA_ARGS__
#undef CONFIG_RUNSV
#define ENABLE_RUNSV 0
#define IF_RUNSV(...)
#define IF_NOT_RUNSV(...) __VA_ARGS__
#undef CONFIG_RUNSVDIR
#define ENABLE_RUNSVDIR 0
#define IF_RUNSVDIR(...)
#define IF_NOT_RUNSVDIR(...) __VA_ARGS__
#undef CONFIG_FEATURE_RUNSVDIR_LOG
#define ENABLE_FEATURE_RUNSVDIR_LOG 0
#define IF_FEATURE_RUNSVDIR_LOG(...)
#define IF_NOT_FEATURE_RUNSVDIR_LOG(...) __VA_ARGS__
#undef CONFIG_SV
#define ENABLE_SV 0
#define IF_SV(...)
#define IF_NOT_SV(...) __VA_ARGS__
#define CONFIG_SV_DEFAULT_SERVICE_DIR ""
#define ENABLE_SV_DEFAULT_SERVICE_DIR 1
#ifdef MAKE_SUID
# define IF_SV_DEFAULT_SERVICE_DIR(...) __VA_ARGS__ "CONFIG_SV_DEFAULT_SERVICE_DIR"
#else
# 5160 "./include/autoconf.h"
# define IF_SV_DEFAULT_SERVICE_DIR(...) __VA_ARGS__
#endif
# 5162 "./include/autoconf.h"
#define IF_NOT_SV_DEFAULT_SERVICE_DIR(...)
#undef CONFIG_SVC
#define ENABLE_SVC 0
#define IF_SVC(...)
#define IF_NOT_SVC(...) __VA_ARGS__
#undef CONFIG_SVLOGD
#define ENABLE_SVLOGD 0
#define IF_SVLOGD(...)
#define IF_NOT_SVLOGD(...) __VA_ARGS__
#undef CONFIG_CHCON
#define ENABLE_CHCON 0
#define IF_CHCON(...)
#define IF_NOT_CHCON(...) __VA_ARGS__
#undef CONFIG_FEATURE_CHCON_LONG_OPTIONS
#define ENABLE_FEATURE_CHCON_LONG_OPTIONS 0
#define IF_FEATURE_CHCON_LONG_OPTIONS(...)
#define IF_NOT_FEATURE_CHCON_LONG_OPTIONS(...) __VA_ARGS__
#undef CONFIG_GETENFORCE
#define ENABLE_GETENFORCE 0
#define IF_GETENFORCE(...)
#define IF_NOT_GETENFORCE(...) __VA_ARGS__
#undef CONFIG_GETSEBOOL
#define ENABLE_GETSEBOOL 0
#define IF_GETSEBOOL(...)
#define IF_NOT_GETSEBOOL(...) __VA_ARGS__
#undef CONFIG_LOAD_POLICY
#define ENABLE_LOAD_POLICY 0
#define IF_LOAD_POLICY(...)
#define IF_NOT_LOAD_POLICY(...) __VA_ARGS__
#undef CONFIG_MATCHPATHCON
#define ENABLE_MATCHPATHCON 0
#define IF_MATCHPATHCON(...)
#define IF_NOT_MATCHPATHCON(...) __VA_ARGS__
#undef CONFIG_RUNCON
#define ENABLE_RUNCON 0
#define IF_RUNCON(...)
#define IF_NOT_RUNCON(...) __VA_ARGS__
#undef CONFIG_FEATURE_RUNCON_LONG_OPTIONS
#define ENABLE_FEATURE_RUNCON_LONG_OPTIONS 0
#define IF_FEATURE_RUNCON_LONG_OPTIONS(...)
#define IF_NOT_FEATURE_RUNCON_LONG_OPTIONS(...) __VA_ARGS__
#undef CONFIG_SELINUXENABLED
#define ENABLE_SELINUXENABLED 0
#define IF_SELINUXENABLED(...)
#define IF_NOT_SELINUXENABLED(...) __VA_ARGS__
#undef CONFIG_SESTATUS
#define ENABLE_SESTATUS 0
#define IF_SESTATUS(...)
#define IF_NOT_SESTATUS(...) __VA_ARGS__
#undef CONFIG_SETENFORCE
#define ENABLE_SETENFORCE 0
#define IF_SETENFORCE(...)
#define IF_NOT_SETENFORCE(...) __VA_ARGS__
#undef CONFIG_SETFILES
#define ENABLE_SETFILES 0
#define IF_SETFILES(...)
#define IF_NOT_SETFILES(...) __VA_ARGS__
#undef CONFIG_FEATURE_SETFILES_CHECK_OPTION
#define ENABLE_FEATURE_SETFILES_CHECK_OPTION 0
#define IF_FEATURE_SETFILES_CHECK_OPTION(...)
#define IF_NOT_FEATURE_SETFILES_CHECK_OPTION(...) __VA_ARGS__
#undef CONFIG_RESTORECON
#define ENABLE_RESTORECON 0
#define IF_RESTORECON(...)
#define IF_NOT_RESTORECON(...) __VA_ARGS__
#undef CONFIG_SETSEBOOL
#define ENABLE_SETSEBOOL 0
#define IF_SETSEBOOL(...)
#define IF_NOT_SETSEBOOL(...) __VA_ARGS__

/*
 * Shells
 */
#define CONFIG_SH_IS_ASH 1
#define ENABLE_SH_IS_ASH 1
#ifdef MAKE_SUID
# define IF_SH_IS_ASH(...) __VA_ARGS__ "CONFIG_SH_IS_ASH"
#else
# 5240 "./include/autoconf.h"
# define IF_SH_IS_ASH(...) __VA_ARGS__
#endif
# 5242 "./include/autoconf.h"
#define IF_NOT_SH_IS_ASH(...)
#undef CONFIG_SH_IS_HUSH
#define ENABLE_SH_IS_HUSH 0
#define IF_SH_IS_HUSH(...)
#define IF_NOT_SH_IS_HUSH(...) __VA_ARGS__
#undef CONFIG_SH_IS_NONE
#define ENABLE_SH_IS_NONE 0
#define IF_SH_IS_NONE(...)
#define IF_NOT_SH_IS_NONE(...) __VA_ARGS__
#undef CONFIG_BASH_IS_ASH
#define ENABLE_BASH_IS_ASH 0
#define IF_BASH_IS_ASH(...)
#define IF_NOT_BASH_IS_ASH(...) __VA_ARGS__
#undef CONFIG_BASH_IS_HUSH
#define ENABLE_BASH_IS_HUSH 0
#define IF_BASH_IS_HUSH(...)
#define IF_NOT_BASH_IS_HUSH(...) __VA_ARGS__
#define CONFIG_BASH_IS_NONE 1
#define ENABLE_BASH_IS_NONE 1
#ifdef MAKE_SUID
# define IF_BASH_IS_NONE(...) __VA_ARGS__ "CONFIG_BASH_IS_NONE"
#else
# 5264 "./include/autoconf.h"
# define IF_BASH_IS_NONE(...) __VA_ARGS__
#endif
# 5266 "./include/autoconf.h"
#define IF_NOT_BASH_IS_NONE(...)
#define CONFIG_ASH 1
#define ENABLE_ASH 1
#ifdef MAKE_SUID
# define IF_ASH(...) __VA_ARGS__ "CONFIG_ASH"
#else
# 5272 "./include/autoconf.h"
# define IF_ASH(...) __VA_ARGS__
#endif
# 5274 "./include/autoconf.h"
#define IF_NOT_ASH(...)
#undef CONFIG_ASH_OPTIMIZE_FOR_SIZE
#define ENABLE_ASH_OPTIMIZE_FOR_SIZE 0
#define IF_ASH_OPTIMIZE_FOR_SIZE(...)
#define IF_NOT_ASH_OPTIMIZE_FOR_SIZE(...) __VA_ARGS__
#undef CONFIG_ASH_INTERNAL_GLOB
#define ENABLE_ASH_INTERNAL_GLOB 0
#define IF_ASH_INTERNAL_GLOB(...)
#define IF_NOT_ASH_INTERNAL_GLOB(...) __VA_ARGS__
#undef CONFIG_ASH_RANDOM_SUPPORT
#define ENABLE_ASH_RANDOM_SUPPORT 0
#define IF_ASH_RANDOM_SUPPORT(...)
#define IF_NOT_ASH_RANDOM_SUPPORT(...) __VA_ARGS__
#undef CONFIG_ASH_EXPAND_PRMT
#define ENABLE_ASH_EXPAND_PRMT 0
#define IF_ASH_EXPAND_PRMT(...)
#define IF_NOT_ASH_EXPAND_PRMT(...) __VA_ARGS__
#undef CONFIG_ASH_BASH_COMPAT
#define ENABLE_ASH_BASH_COMPAT 0
#define IF_ASH_BASH_COMPAT(...)
#define IF_NOT_ASH_BASH_COMPAT(...) __VA_ARGS__
#undef CONFIG_ASH_IDLE_TIMEOUT
#define ENABLE_ASH_IDLE_TIMEOUT 0
#define IF_ASH_IDLE_TIMEOUT(...)
#define IF_NOT_ASH_IDLE_TIMEOUT(...) __VA_ARGS__
#undef CONFIG_ASH_JOB_CONTROL
#define ENABLE_ASH_JOB_CONTROL 0
#define IF_ASH_JOB_CONTROL(...)
#define IF_NOT_ASH_JOB_CONTROL(...) __VA_ARGS__
#undef CONFIG_ASH_ALIAS
#define ENABLE_ASH_ALIAS 0
#define IF_ASH_ALIAS(...)
#define IF_NOT_ASH_ALIAS(...) __VA_ARGS__
#undef CONFIG_ASH_GETOPTS
#define ENABLE_ASH_GETOPTS 0
#define IF_ASH_GETOPTS(...)
#define IF_NOT_ASH_GETOPTS(...) __VA_ARGS__
#undef CONFIG_ASH_BUILTIN_ECHO
#define ENABLE_ASH_BUILTIN_ECHO 0
#define IF_ASH_BUILTIN_ECHO(...)
#define IF_NOT_ASH_BUILTIN_ECHO(...) __VA_ARGS__
#undef CONFIG_ASH_BUILTIN_PRINTF
#define ENABLE_ASH_BUILTIN_PRINTF 0
#define IF_ASH_BUILTIN_PRINTF(...)
#define IF_NOT_ASH_BUILTIN_PRINTF(...) __VA_ARGS__
#undef CONFIG_ASH_BUILTIN_TEST
#define ENABLE_ASH_BUILTIN_TEST 0
#define IF_ASH_BUILTIN_TEST(...)
#define IF_NOT_ASH_BUILTIN_TEST(...) __VA_ARGS__
#define CONFIG_ASH_HELP 1
#define ENABLE_ASH_HELP 1
#ifdef MAKE_SUID
# define IF_ASH_HELP(...) __VA_ARGS__ "CONFIG_ASH_HELP"
#else
# 5328 "./include/autoconf.h"
# define IF_ASH_HELP(...) __VA_ARGS__
#endif
# 5330 "./include/autoconf.h"
#define IF_NOT_ASH_HELP(...)
#undef CONFIG_ASH_CMDCMD
#define ENABLE_ASH_CMDCMD 0
#define IF_ASH_CMDCMD(...)
#define IF_NOT_ASH_CMDCMD(...) __VA_ARGS__
#undef CONFIG_ASH_MAIL
#define ENABLE_ASH_MAIL 0
#define IF_ASH_MAIL(...)
#define IF_NOT_ASH_MAIL(...) __VA_ARGS__
#undef CONFIG_CTTYHACK
#define ENABLE_CTTYHACK 0
#define IF_CTTYHACK(...)
#define IF_NOT_CTTYHACK(...) __VA_ARGS__
#undef CONFIG_HUSH
#define ENABLE_HUSH 0
#define IF_HUSH(...)
#define IF_NOT_HUSH(...) __VA_ARGS__
#undef CONFIG_HUSH_BASH_COMPAT
#define ENABLE_HUSH_BASH_COMPAT 0
#define IF_HUSH_BASH_COMPAT(...)
#define IF_NOT_HUSH_BASH_COMPAT(...) __VA_ARGS__
#undef CONFIG_HUSH_BRACE_EXPANSION
#define ENABLE_HUSH_BRACE_EXPANSION 0
#define IF_HUSH_BRACE_EXPANSION(...)
#define IF_NOT_HUSH_BRACE_EXPANSION(...) __VA_ARGS__
#undef CONFIG_HUSH_HELP
#define ENABLE_HUSH_HELP 0
#define IF_HUSH_HELP(...)
#define IF_NOT_HUSH_HELP(...) __VA_ARGS__
#undef CONFIG_HUSH_INTERACTIVE
#define ENABLE_HUSH_INTERACTIVE 0
#define IF_HUSH_INTERACTIVE(...)
#define IF_NOT_HUSH_INTERACTIVE(...) __VA_ARGS__
#undef CONFIG_HUSH_SAVEHISTORY
#define ENABLE_HUSH_SAVEHISTORY 0
#define IF_HUSH_SAVEHISTORY(...)
#define IF_NOT_HUSH_SAVEHISTORY(...) __VA_ARGS__
#undef CONFIG_HUSH_JOB
#define ENABLE_HUSH_JOB 0
#define IF_HUSH_JOB(...)
#define IF_NOT_HUSH_JOB(...) __VA_ARGS__
#undef CONFIG_HUSH_TICK
#define ENABLE_HUSH_TICK 0
#define IF_HUSH_TICK(...)
#define IF_NOT_HUSH_TICK(...) __VA_ARGS__
#undef CONFIG_HUSH_IF
#define ENABLE_HUSH_IF 0
#define IF_HUSH_IF(...)
#define IF_NOT_HUSH_IF(...) __VA_ARGS__
#undef CONFIG_HUSH_LOOPS
#define ENABLE_HUSH_LOOPS 0
#define IF_HUSH_LOOPS(...)
#define IF_NOT_HUSH_LOOPS(...) __VA_ARGS__
#undef CONFIG_HUSH_CASE
#define ENABLE_HUSH_CASE 0
#define IF_HUSH_CASE(...)
#define IF_NOT_HUSH_CASE(...) __VA_ARGS__
#undef CONFIG_HUSH_FUNCTIONS
#define ENABLE_HUSH_FUNCTIONS 0
#define IF_HUSH_FUNCTIONS(...)
#define IF_NOT_HUSH_FUNCTIONS(...) __VA_ARGS__
#undef CONFIG_HUSH_LOCAL
#define ENABLE_HUSH_LOCAL 0
#define IF_HUSH_LOCAL(...)
#define IF_NOT_HUSH_LOCAL(...) __VA_ARGS__
#undef CONFIG_HUSH_RANDOM_SUPPORT
#define ENABLE_HUSH_RANDOM_SUPPORT 0
#define IF_HUSH_RANDOM_SUPPORT(...)
#define IF_NOT_HUSH_RANDOM_SUPPORT(...) __VA_ARGS__
#undef CONFIG_HUSH_EXPORT_N
#define ENABLE_HUSH_EXPORT_N 0
#define IF_HUSH_EXPORT_N(...)
#define IF_NOT_HUSH_EXPORT_N(...) __VA_ARGS__
#undef CONFIG_HUSH_MODE_X
#define ENABLE_HUSH_MODE_X 0
#define IF_HUSH_MODE_X(...)
#define IF_NOT_HUSH_MODE_X(...) __VA_ARGS__
#undef CONFIG_MSH
#define ENABLE_MSH 0
#define IF_MSH(...)
#define IF_NOT_MSH(...) __VA_ARGS__
#undef CONFIG_FEATURE_SH_MATH
#define ENABLE_FEATURE_SH_MATH 0
#define IF_FEATURE_SH_MATH(...)
#define IF_NOT_FEATURE_SH_MATH(...) __VA_ARGS__
#undef CONFIG_FEATURE_SH_MATH_64
#define ENABLE_FEATURE_SH_MATH_64 0
#define IF_FEATURE_SH_MATH_64(...)
#define IF_NOT_FEATURE_SH_MATH_64(...) __VA_ARGS__
#undef CONFIG_FEATURE_SH_EXTRA_QUIET
#define ENABLE_FEATURE_SH_EXTRA_QUIET 0
#define IF_FEATURE_SH_EXTRA_QUIET(...)
#define IF_NOT_FEATURE_SH_EXTRA_QUIET(...) __VA_ARGS__
#undef CONFIG_FEATURE_SH_STANDALONE
#define ENABLE_FEATURE_SH_STANDALONE 0
#define IF_FEATURE_SH_STANDALONE(...)
#define IF_NOT_FEATURE_SH_STANDALONE(...) __VA_ARGS__
#undef CONFIG_FEATURE_SH_NOFORK
#define ENABLE_FEATURE_SH_NOFORK 0
#define IF_FEATURE_SH_NOFORK(...)
#define IF_NOT_FEATURE_SH_NOFORK(...) __VA_ARGS__
#define CONFIG_FEATURE_SH_HISTFILESIZE 1
#define ENABLE_FEATURE_SH_HISTFILESIZE 1
#ifdef MAKE_SUID
# define IF_FEATURE_SH_HISTFILESIZE(...) __VA_ARGS__ "CONFIG_FEATURE_SH_HISTFILESIZE"
#else
# 5436 "./include/autoconf.h"
# define IF_FEATURE_SH_HISTFILESIZE(...) __VA_ARGS__
#endif
# 5438 "./include/autoconf.h"
#define IF_NOT_FEATURE_SH_HISTFILESIZE(...)

/*
 * System Logging Utilities
 */
#undef CONFIG_KLOGD
#define ENABLE_KLOGD 0
#define IF_KLOGD(...)
#define IF_NOT_KLOGD(...) __VA_ARGS__
#undef CONFIG_FEATURE_KLOGD_KLOGCTL
#define ENABLE_FEATURE_KLOGD_KLOGCTL 0
#define IF_FEATURE_KLOGD_KLOGCTL(...)
#define IF_NOT_FEATURE_KLOGD_KLOGCTL(...) __VA_ARGS__
#define CONFIG_LOGGER 1
#define ENABLE_LOGGER 1
#ifdef MAKE_SUID
# define IF_LOGGER(...) __VA_ARGS__ "CONFIG_LOGGER"
#else
# 5456 "./include/autoconf.h"
# define IF_LOGGER(...) __VA_ARGS__
#endif
# 5458 "./include/autoconf.h"
#define IF_NOT_LOGGER(...)
#define CONFIG_LOGREAD 1
#define ENABLE_LOGREAD 1
#ifdef MAKE_SUID
# define IF_LOGREAD(...) __VA_ARGS__ "CONFIG_LOGREAD"
#else
# 5464 "./include/autoconf.h"
# define IF_LOGREAD(...) __VA_ARGS__
#endif
# 5466 "./include/autoconf.h"
#define IF_NOT_LOGREAD(...)
#define CONFIG_FEATURE_LOGREAD_REDUCED_LOCKING 1
#define ENABLE_FEATURE_LOGREAD_REDUCED_LOCKING 1
#ifdef MAKE_SUID
# define IF_FEATURE_LOGREAD_REDUCED_LOCKING(...) __VA_ARGS__ "CONFIG_FEATURE_LOGREAD_REDUCED_LOCKING"
#else
# 5472 "./include/autoconf.h"
# define IF_FEATURE_LOGREAD_REDUCED_LOCKING(...) __VA_ARGS__
#endif
# 5474 "./include/autoconf.h"
#define IF_NOT_FEATURE_LOGREAD_REDUCED_LOCKING(...)
#define CONFIG_SYSLOGD 1
#define ENABLE_SYSLOGD 1
#ifdef MAKE_SUID
# define IF_SYSLOGD(...) __VA_ARGS__ "CONFIG_SYSLOGD"
#else
# 5480 "./include/autoconf.h"
# define IF_SYSLOGD(...) __VA_ARGS__
#endif
# 5482 "./include/autoconf.h"
#define IF_NOT_SYSLOGD(...)
#define CONFIG_FEATURE_ROTATE_LOGFILE 1
#define ENABLE_FEATURE_ROTATE_LOGFILE 1
#ifdef MAKE_SUID
# define IF_FEATURE_ROTATE_LOGFILE(...) __VA_ARGS__ "CONFIG_FEATURE_ROTATE_LOGFILE"
#else
# 5488 "./include/autoconf.h"
# define IF_FEATURE_ROTATE_LOGFILE(...) __VA_ARGS__
#endif
# 5490 "./include/autoconf.h"
#define IF_NOT_FEATURE_ROTATE_LOGFILE(...)
#define CONFIG_FEATURE_REMOTE_LOG 1
#define ENABLE_FEATURE_REMOTE_LOG 1
#ifdef MAKE_SUID
# define IF_FEATURE_REMOTE_LOG(...) __VA_ARGS__ "CONFIG_FEATURE_REMOTE_LOG"
#else
# 5496 "./include/autoconf.h"
# define IF_FEATURE_REMOTE_LOG(...) __VA_ARGS__
#endif
# 5498 "./include/autoconf.h"
#define IF_NOT_FEATURE_REMOTE_LOG(...)
#undef CONFIG_FEATURE_SYSLOGD_DUP
#define ENABLE_FEATURE_SYSLOGD_DUP 0
#define IF_FEATURE_SYSLOGD_DUP(...)
#define IF_NOT_FEATURE_SYSLOGD_DUP(...) __VA_ARGS__
#define CONFIG_FEATURE_SYSLOGD_CFG 1
#define ENABLE_FEATURE_SYSLOGD_CFG 1
#ifdef MAKE_SUID
# define IF_FEATURE_SYSLOGD_CFG(...) __VA_ARGS__ "CONFIG_FEATURE_SYSLOGD_CFG"
#else
# 5508 "./include/autoconf.h"
# define IF_FEATURE_SYSLOGD_CFG(...) __VA_ARGS__
#endif
# 5510 "./include/autoconf.h"
#define IF_NOT_FEATURE_SYSLOGD_CFG(...)
#define CONFIG_FEATURE_SYSLOGD_READ_BUFFER_SIZE 256
#define ENABLE_FEATURE_SYSLOGD_READ_BUFFER_SIZE 1
#ifdef MAKE_SUID
# define IF_FEATURE_SYSLOGD_READ_BUFFER_SIZE(...) __VA_ARGS__ "CONFIG_FEATURE_SYSLOGD_READ_BUFFER_SIZE"
#else
# 5516 "./include/autoconf.h"
# define IF_FEATURE_SYSLOGD_READ_BUFFER_SIZE(...) __VA_ARGS__
#endif
# 5518 "./include/autoconf.h"
#define IF_NOT_FEATURE_SYSLOGD_READ_BUFFER_SIZE(...)
#define CONFIG_FEATURE_IPC_SYSLOG 1
#define ENABLE_FEATURE_IPC_SYSLOG 1
#ifdef MAKE_SUID
# define IF_FEATURE_IPC_SYSLOG(...) __VA_ARGS__ "CONFIG_FEATURE_IPC_SYSLOG"
#else
# 5524 "./include/autoconf.h"
# define IF_FEATURE_IPC_SYSLOG(...) __VA_ARGS__
#endif
# 5526 "./include/autoconf.h"
#define IF_NOT_FEATURE_IPC_SYSLOG(...)
#define CONFIG_FEATURE_IPC_SYSLOG_BUFFER_SIZE 16
#define ENABLE_FEATURE_IPC_SYSLOG_BUFFER_SIZE 1
#ifdef MAKE_SUID
# define IF_FEATURE_IPC_SYSLOG_BUFFER_SIZE(...) __VA_ARGS__ "CONFIG_FEATURE_IPC_SYSLOG_BUFFER_SIZE"
#else
# 5532 "./include/autoconf.h"
# define IF_FEATURE_IPC_SYSLOG_BUFFER_SIZE(...) __VA_ARGS__
#endif
# 5534 "./include/autoconf.h"
#define IF_NOT_FEATURE_IPC_SYSLOG_BUFFER_SIZE(...)
#define CONFIG_FEATURE_KMSG_SYSLOG 1
#define ENABLE_FEATURE_KMSG_SYSLOG 1
#ifdef MAKE_SUID
# define IF_FEATURE_KMSG_SYSLOG(...) __VA_ARGS__ "CONFIG_FEATURE_KMSG_SYSLOG"
#else
# 5540 "./include/autoconf.h"
# define IF_FEATURE_KMSG_SYSLOG(...) __VA_ARGS__
#endif
# 5542 "./include/autoconf.h"
#define IF_NOT_FEATURE_KMSG_SYSLOG(...)
# 1 "<built-in>" 2
# 1 "shell/ash.c"
/* vi: set sw=4 ts=4: */
/*
 * ash shell port for busybox
 *
 * This code is derived from software contributed to Berkeley by
 * Kenneth Almquist.
 *
 * Original BSD copyright notice is retained at the end of this file.
 *
 * Copyright (c) 1989, 1991, 1993, 1994
 *      The Regents of the University of California.  All rights reserved.
 *
 * Copyright (c) 1997-2005 Herbert Xu <herbert@gondor.apana.org.au>
 * was re-ported from NetBSD and debianized.
 *
 * Licensed under GPLv2 or later, see file LICENSE in this source tree.
 */
//config:config ASH
//config:	bool "ash"
//config:	default y
//config:	depends on !NOMMU
//config:	help
//config:	  Tha 'ash' shell adds about 60k in the default configuration and is
//config:	  the most complete and most pedantically correct shell included with
//config:	  busybox. This shell is actually a derivative of the Debian 'dash'
//config:	  shell (by Herbert Xu), which was created by porting the 'ash' shell
//config:	  (written by Kenneth Almquist) from NetBSD.
//config:
//config:config ASH_OPTIMIZE_FOR_SIZE
//config:	bool "Optimize for size instead of speed"
//config:	default y
//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
//config:	help
//config:	  Compile ash for reduced size at the price of speed.
//config:
//config:config ASH_INTERNAL_GLOB
//config:	bool "Use internal glob() implementation"
//config:	default y	# Y is bigger, but because of uclibc glob() bug, let Y be default for now
//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
//config:	help
//config:	  Do not use glob() function from libc, use internal implementation.
//config:	  Use this if you are getting "glob.h: No such file or directory"
//config:	  or similar build errors.
//config:
//config:config ASH_RANDOM_SUPPORT
//config:	bool "Pseudorandom generator and $RANDOM variable"
//config:	default y
//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
//config:	help
//config:	  Enable pseudorandom generator and dynamic variable "$RANDOM".
//config:	  Each read of "$RANDOM" will generate a new pseudorandom value.
//config:	  You can reset the generator by using a specified start value.
//config:	  After "unset RANDOM" the generator will switch off and this
//config:	  variable will no longer have special treatment.
//config:
//config:config ASH_EXPAND_PRMT
//config:	bool "Expand prompt string"
//config:	default y
//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
//config:	help
//config:	  "PS#" may contain volatile content, such as backquote commands.
//config:	  This option recreates the prompt string from the environment
//config:	  variable each time it is displayed.
//config:
//config:config ASH_BASH_COMPAT
//config:	bool "bash-compatible extensions"
//config:	default y
//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
//config:	help
//config:	  Enable bash-compatible extensions.
//config:
//config:config ASH_IDLE_TIMEOUT
//config:	bool "Idle timeout variable"
//config:	default n
//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
//config:	help
//config:	  Enables bash-like auto-logout after $TMOUT seconds of idle time.
//config:
//config:config ASH_JOB_CONTROL
//config:	bool "Job control"
//config:	default y
//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
//config:	help
//config:	  Enable job control in the ash shell.
//config:
//config:config ASH_ALIAS
//config:	bool "Alias support"
//config:	default y
//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
//config:	help
//config:	  Enable alias support in the ash shell.
//config:
//config:config ASH_GETOPTS
//config:	bool "Builtin getopt to parse positional parameters"
//config:	default y
//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
//config:	help
//config:	  Enable support for getopts builtin in ash.
//config:
//config:config ASH_BUILTIN_ECHO
//config:	bool "Builtin version of 'echo'"
//config:	default y
//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
//config:	help
//config:	  Enable support for echo builtin in ash.
//config:
//config:config ASH_BUILTIN_PRINTF
//config:	bool "Builtin version of 'printf'"
//config:	default y
//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
//config:	help
//config:	  Enable support for printf builtin in ash.
//config:
//config:config ASH_BUILTIN_TEST
//config:	bool "Builtin version of 'test'"
//config:	default y
//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
//config:	help
//config:	  Enable support for test builtin in ash.
//config:
//config:config ASH_HELP
//config:	bool "help builtin"
//config:	default y
//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
//config:	help
//config:	  Enable help builtin in ash.
//config:
//config:config ASH_CMDCMD
//config:	bool "'command' command to override shell builtins"
//config:	default y
//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
//config:	help
//config:	  Enable support for the ash 'command' builtin, which allows
//config:	  you to run the specified command with the specified arguments,
//config:	  even when there is an ash builtin command with the same name.
//config:
//config:config ASH_MAIL
//config:	bool "Check for new mail on interactive shells"
//config:	default y
//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
//config:	help
//config:	  Enable "check for new mail" function in the ash shell.

//applet:IF_ASH(APPLET(ash, BB_DIR_BIN, BB_SUID_DROP))
//applet:IF_SH_IS_ASH(APPLET_ODDNAME(sh, ash, BB_DIR_BIN, BB_SUID_DROP, ash))
//applet:IF_BASH_IS_ASH(APPLET_ODDNAME(bash, ash, BB_DIR_BIN, BB_SUID_DROP, ash))

//kbuild:lib-$(CONFIG_ASH) += ash.o ash_ptr_hack.o shell_common.o
//kbuild:lib-$(CONFIG_SH_IS_ASH) += ash.o ash_ptr_hack.o shell_common.o
//kbuild:lib-$(CONFIG_BASH_IS_ASH) += ash.o ash_ptr_hack.o shell_common.o
//kbuild:lib-$(CONFIG_ASH_RANDOM_SUPPORT) += random.o

/*
 * The following should be set to reflect the type of system you have:
 *      JOBS -> 1 if you have Berkeley job control, 0 otherwise.
 *      define SYSV if you are running under System V.
 *      define DEBUG=1 to compile in debugging ('set -o debug' to turn on)
 *      define DEBUG=2 to compile in and turn on debugging.
 *
 * When debugging is on (DEBUG is 1 and "set -o debug" was executed),
 * debugging info will be written to ./trace and a quit signal
 * will generate a core dump.
 */
#define DEBUG 0
/* Tweak debug output verbosity here */
#define DEBUG_TIME 0
#define DEBUG_PID 1
#define DEBUG_SIG 1
#define DEBUG_INTONOFF 0

#define PROFILE 0

#define JOBS ENABLE_ASH_JOB_CONTROL

#if 0 /* expanded by -frewrite-includes */
#include <setjmp.h>
#endif /* expanded by -frewrite-includes */
# 175 "shell/ash.c"
# 1 "/usr/include/setjmp.h" 1 3 4
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)setjmp.h	8.2 (Berkeley) 1/21/94
 * $FreeBSD: releng/11.0/include/setjmp.h 265878 2014-05-11 13:48:21Z jilles $
 */

#ifndef _SETJMP_H_
#define _SETJMP_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 41 "/usr/include/setjmp.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 * $FreeBSD: releng/11.0/sys/sys/cdefs.h 300967 2016-05-29 17:32:19Z dim $
 */

#ifndef	_SYS_CDEFS_H_
#define	_SYS_CDEFS_H_

/*
 * Testing against Clang-specific extensions.
 */
#ifndef	__has_attribute
#define	__has_attribute(x)	0
#endif
# 45 "/usr/include/sys/cdefs.h" 3 4
#ifndef	__has_extension
#define	__has_extension		__has_feature
#endif
# 48 "/usr/include/sys/cdefs.h" 3 4
#ifndef	__has_feature
#define	__has_feature(x)	0
#endif
# 51 "/usr/include/sys/cdefs.h" 3 4
#ifndef	__has_include
#define	__has_include(x)	0
#endif
# 54 "/usr/include/sys/cdefs.h" 3 4
#ifndef	__has_builtin
#define	__has_builtin(x)	0
#endif
# 57 "/usr/include/sys/cdefs.h" 3 4

#if defined(__cplusplus)
#define	__BEGIN_DECLS	extern "C" {
#define	__END_DECLS	}
#else
# 62 "/usr/include/sys/cdefs.h" 3 4
#define	__BEGIN_DECLS
#define	__END_DECLS
#endif
# 65 "/usr/include/sys/cdefs.h" 3 4

/*
 * This code has been put in place to help reduce the addition of
 * compiler specific defines in FreeBSD code.  It helps to aid in
 * having a compiler-agnostic source tree.
 */

#if defined(__GNUC__) || defined(__INTEL_COMPILER)

#if __GNUC__ >= 3 || defined(__INTEL_COMPILER)
#define	__GNUCLIKE_ASM 3
#define	__GNUCLIKE_MATH_BUILTIN_CONSTANTS
#else
# 78 "/usr/include/sys/cdefs.h" 3 4
#define	__GNUCLIKE_ASM 2
#endif
# 80 "/usr/include/sys/cdefs.h" 3 4
#define	__GNUCLIKE___TYPEOF 1
#define	__GNUCLIKE___OFFSETOF 1
#define	__GNUCLIKE___SECTION 1

#ifndef __INTEL_COMPILER
#define	__GNUCLIKE_CTOR_SECTION_HANDLING 1
#endif
# 87 "/usr/include/sys/cdefs.h" 3 4

#define	__GNUCLIKE_BUILTIN_CONSTANT_P 1
#if defined(__INTEL_COMPILER) && defined(__cplusplus) && \
   __INTEL_COMPILER < 800
#undef __GNUCLIKE_BUILTIN_CONSTANT_P
#endif
# 93 "/usr/include/sys/cdefs.h" 3 4

#if (__GNUC_MINOR__ > 95 || __GNUC__ >= 3)
#define	__GNUCLIKE_BUILTIN_VARARGS 1
#define	__GNUCLIKE_BUILTIN_STDARG 1
#define	__GNUCLIKE_BUILTIN_VAALIST 1
#endif
# 99 "/usr/include/sys/cdefs.h" 3 4

#if defined(__GNUC__)
#define	__GNUC_VA_LIST_COMPATIBILITY 1
#endif
# 103 "/usr/include/sys/cdefs.h" 3 4

/*
 * Compiler memory barriers, specific to gcc and clang.
 */
#if defined(__GNUC__)
#define	__compiler_membar()	__asm __volatile(" " : : : "memory")
#endif
# 110 "/usr/include/sys/cdefs.h" 3 4

#ifndef __INTEL_COMPILER
#define	__GNUCLIKE_BUILTIN_NEXT_ARG 1
#define	__GNUCLIKE_MATH_BUILTIN_RELOPS
#endif
# 115 "/usr/include/sys/cdefs.h" 3 4

#define	__GNUCLIKE_BUILTIN_MEMCPY 1

/* XXX: if __GNUC__ >= 2: not tested everywhere originally, where replaced */
#define	__CC_SUPPORTS_INLINE 1
#define	__CC_SUPPORTS___INLINE 1
#define	__CC_SUPPORTS___INLINE__ 1

#define	__CC_SUPPORTS___FUNC__ 1
#define	__CC_SUPPORTS_WARNING 1

#define	__CC_SUPPORTS_VARADIC_XXX 1 /* see varargs.h */

#define	__CC_SUPPORTS_DYNAMIC_ARRAY_INIT 1

#endif /* __GNUC__ || __INTEL_COMPILER */
# 131 "/usr/include/sys/cdefs.h" 3 4

/*
 * Macro to test if we're using a specific version of gcc or later.
 */
#if defined(__GNUC__) && !defined(__INTEL_COMPILER)
#define	__GNUC_PREREQ__(ma, mi)	\
	(__GNUC__ > (ma) || __GNUC__ == (ma) && __GNUC_MINOR__ >= (mi))
#else
# 139 "/usr/include/sys/cdefs.h" 3 4
#define	__GNUC_PREREQ__(ma, mi)	0
#endif
# 141 "/usr/include/sys/cdefs.h" 3 4

/*
 * The __CONCAT macro is used to concatenate parts of symbol names, e.g.
 * with "#define OLD(foo) __CONCAT(old,foo)", OLD(foo) produces oldfoo.
 * The __CONCAT macro is a bit tricky to use if it must work in non-ANSI
 * mode -- there must be no spaces between its arguments, and for nested
 * __CONCAT's, all the __CONCAT's must be at the left.  __CONCAT can also
 * concatenate double-quoted strings produced by the __STRING macro, but
 * this only works with ANSI C.
 *
 * __XSTRING is like __STRING, but it expands any macros in its argument
 * first.  It is only available with ANSI C.
 */
#if defined(__STDC__) || defined(__cplusplus)
#define	__P(protos)	protos		/* full-blown ANSI C */
#define	__CONCAT1(x,y)	x ## y
#define	__CONCAT(x,y)	__CONCAT1(x,y)
#define	__STRING(x)	#x		/* stringify without expanding x */
#define	__XSTRING(x)	__STRING(x)	/* expand x, then stringify */

#define	__const		const		/* define reserved names to standard */
#define	__signed	signed
#define	__volatile	volatile
#if defined(__cplusplus)
#define	__inline	inline		/* convert to C++ keyword */
#else
# 167 "/usr/include/sys/cdefs.h" 3 4
#if !(defined(__CC_SUPPORTS___INLINE))
#define	__inline			/* delete GCC keyword */
#endif /* ! __CC_SUPPORTS___INLINE */
# 170 "/usr/include/sys/cdefs.h" 3 4
#endif /* !__cplusplus */
# 171 "/usr/include/sys/cdefs.h" 3 4

#else	/* !(__STDC__ || __cplusplus) */
# 173 "/usr/include/sys/cdefs.h" 3 4
#define	__P(protos)	()		/* traditional C preprocessor */
#define	__CONCAT(x,y)	x/**/y
#define	__STRING(x)	"x"

#if !defined(__CC_SUPPORTS___INLINE)
#define	__const				/* delete pseudo-ANSI C keywords */
#define	__inline
#define	__signed
#define	__volatile
/*
 * In non-ANSI C environments, new programs will want ANSI-only C keywords
 * deleted from the program and old programs will want them left alone.
 * When using a compiler other than gcc, programs using the ANSI C keywords
 * const, inline etc. as normal identifiers should define -DNO_ANSI_KEYWORDS.
 * When using "gcc -traditional", we assume that this is the intent; if
 * __GNUC__ is defined but __STDC__ is not, we leave the new keywords alone.
 */
#ifndef	NO_ANSI_KEYWORDS
#define	const				/* delete ANSI C keywords */
#define	inline
#define	signed
#define	volatile
#endif	/* !NO_ANSI_KEYWORDS */
# 196 "/usr/include/sys/cdefs.h" 3 4
#endif	/* !__CC_SUPPORTS___INLINE */
# 197 "/usr/include/sys/cdefs.h" 3 4
#endif	/* !(__STDC__ || __cplusplus) */
# 198 "/usr/include/sys/cdefs.h" 3 4

/*
 * Compiler-dependent macros to help declare dead (non-returning) and
 * pure (no side effects) functions, and unused variables.  They are
 * null except for versions of gcc that are known to support the features
 * properly (old versions of gcc-2 supported the dead and pure features
 * in a different (wrong) way).  If we do not provide an implementation
 * for a given compiler, let the compile fail if it is told to use
 * a feature that we cannot live without.
 */
#ifdef lint
#define	__dead2
#define	__pure2
#define	__unused
#define	__packed
#define	__aligned(x)
#define	__alloc_align(x)
#define	__alloc_size(x)
#define	__section(x)
#define	__weak_symbol
#else
# 219 "/usr/include/sys/cdefs.h" 3 4
#define	__weak_symbol	__attribute__((__weak__))
#if !__GNUC_PREREQ__(2, 5) && !defined(__INTEL_COMPILER)
#define	__dead2
#define	__pure2
#define	__unused
#endif
# 225 "/usr/include/sys/cdefs.h" 3 4
#if __GNUC__ == 2 && __GNUC_MINOR__ >= 5 && __GNUC_MINOR__ < 7 && !defined(__INTEL_COMPILER)
#define	__dead2		__attribute__((__noreturn__))
#define	__pure2		__attribute__((__const__))
#define	__unused
/* XXX Find out what to do for __packed, __aligned and __section */
#endif
# 231 "/usr/include/sys/cdefs.h" 3 4
#if __GNUC_PREREQ__(2, 7) || defined(__INTEL_COMPILER)
#define	__dead2		__attribute__((__noreturn__))
#define	__pure2		__attribute__((__const__))
#define	__unused	__attribute__((__unused__))
#define	__used		__attribute__((__used__))
#define	__packed	__attribute__((__packed__))
#define	__aligned(x)	__attribute__((__aligned__(x)))
#define	__section(x)	__attribute__((__section__(x)))
#endif
# 240 "/usr/include/sys/cdefs.h" 3 4
#if __GNUC_PREREQ__(4, 3) || __has_attribute(__alloc_size__)
#define	__alloc_size(x)	__attribute__((__alloc_size__(x)))
#else
# 243 "/usr/include/sys/cdefs.h" 3 4
#define	__alloc_size(x)
#endif
# 245 "/usr/include/sys/cdefs.h" 3 4
#if __GNUC_PREREQ__(4, 9) || __has_attribute(__alloc_align__)
#define	__alloc_align(x)	__attribute__((__alloc_align__(x)))
#else
# 248 "/usr/include/sys/cdefs.h" 3 4
#define	__alloc_align(x)
#endif
# 250 "/usr/include/sys/cdefs.h" 3 4
#endif /* lint */
# 251 "/usr/include/sys/cdefs.h" 3 4

#if !__GNUC_PREREQ__(2, 95)
#define	__alignof(x)	__offsetof(struct { char __a; x __b; }, __b)
#endif
# 255 "/usr/include/sys/cdefs.h" 3 4

/*
 * Keywords added in C11.
 */

#if !defined(__STDC_VERSION__) || __STDC_VERSION__ < 201112L || defined(lint)

#if !__has_extension(c_alignas)
#if (defined(__cplusplus) && __cplusplus >= 201103L) || \
    __has_extension(cxx_alignas)
#define	_Alignas(x)		alignas(x)
#else
# 267 "/usr/include/sys/cdefs.h" 3 4
/* XXX: Only emulates _Alignas(constant-expression); not _Alignas(type-name). */
#define	_Alignas(x)		__aligned(x)
#endif
# 270 "/usr/include/sys/cdefs.h" 3 4
#endif
# 271 "/usr/include/sys/cdefs.h" 3 4

#if defined(__cplusplus) && __cplusplus >= 201103L
#define	_Alignof(x)		alignof(x)
#else
# 275 "/usr/include/sys/cdefs.h" 3 4
#define	_Alignof(x)		__alignof(x)
#endif
# 277 "/usr/include/sys/cdefs.h" 3 4

#if !defined(__cplusplus) && !__has_extension(c_atomic) && \
    !__has_extension(cxx_atomic)
/*
 * No native support for _Atomic(). Place object in structure to prevent
 * most forms of direct non-atomic access.
 */
#define	_Atomic(T)		struct { T volatile __val; }
#endif
# 286 "/usr/include/sys/cdefs.h" 3 4

#if defined(__cplusplus) && __cplusplus >= 201103L
#define	_Noreturn		[[noreturn]]
#else
# 290 "/usr/include/sys/cdefs.h" 3 4
#define	_Noreturn		__dead2
#endif
# 292 "/usr/include/sys/cdefs.h" 3 4

#if !__has_extension(c_static_assert)
#if (defined(__cplusplus) && __cplusplus >= 201103L) || \
    __has_extension(cxx_static_assert)
#define	_Static_assert(x, y)	static_assert(x, y)
#elif __GNUC_PREREQ__(4,6)
# 298 "/usr/include/sys/cdefs.h" 3 4
/* Nothing, gcc 4.6 and higher has _Static_assert built-in */
#elif defined(__COUNTER__)
# 300 "/usr/include/sys/cdefs.h" 3 4
#define	_Static_assert(x, y)	__Static_assert(x, __COUNTER__)
#define	__Static_assert(x, y)	___Static_assert(x, y)
#define	___Static_assert(x, y)	typedef char __assert_ ## y[(x) ? 1 : -1] \
				__unused
#else
# 305 "/usr/include/sys/cdefs.h" 3 4
#define	_Static_assert(x, y)	struct __hack
#endif
# 307 "/usr/include/sys/cdefs.h" 3 4
#endif
# 308 "/usr/include/sys/cdefs.h" 3 4

#if !__has_extension(c_thread_local)
/*
 * XXX: Some compilers (Clang 3.3, GCC 4.7) falsely announce C++11 mode
 * without actually supporting the thread_local keyword. Don't check for
 * the presence of C++11 when defining _Thread_local.
 */
#if /* (defined(__cplusplus) && __cplusplus >= 201103L) || */ \
    __has_extension(cxx_thread_local)
#define	_Thread_local		thread_local
#else
# 319 "/usr/include/sys/cdefs.h" 3 4
#define	_Thread_local		__thread
#endif
# 321 "/usr/include/sys/cdefs.h" 3 4
#endif
# 322 "/usr/include/sys/cdefs.h" 3 4

#endif /* __STDC_VERSION__ || __STDC_VERSION__ < 201112L */
# 324 "/usr/include/sys/cdefs.h" 3 4

/*
 * Emulation of C11 _Generic().  Unlike the previously defined C11
 * keywords, it is not possible to implement this using exactly the same
 * syntax.  Therefore implement something similar under the name
 * __generic().  Unlike _Generic(), this macro can only distinguish
 * between a single type, so it requires nested invocations to
 * distinguish multiple cases.
 */

#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L) || \
    __has_extension(c_generic_selections)
#define	__generic(expr, t, yes, no)					\
	_Generic(expr, t: yes, default: no)
#elif __GNUC_PREREQ__(3, 1) && !defined(__cplusplus)
# 339 "/usr/include/sys/cdefs.h" 3 4
#define	__generic(expr, t, yes, no)					\
	__builtin_choose_expr(						\
	    __builtin_types_compatible_p(__typeof(expr), t), yes, no)
#endif
# 343 "/usr/include/sys/cdefs.h" 3 4

#if __GNUC_PREREQ__(2, 96)
#define	__malloc_like	__attribute__((__malloc__))
#define	__pure		__attribute__((__pure__))
#else
# 348 "/usr/include/sys/cdefs.h" 3 4
#define	__malloc_like
#define	__pure
#endif
# 351 "/usr/include/sys/cdefs.h" 3 4

#if __GNUC_PREREQ__(3, 1) || (defined(__INTEL_COMPILER) && __INTEL_COMPILER >= 800)
#define	__always_inline	__attribute__((__always_inline__))
#else
# 355 "/usr/include/sys/cdefs.h" 3 4
#define	__always_inline
#endif
# 357 "/usr/include/sys/cdefs.h" 3 4

#if __GNUC_PREREQ__(3, 1)
#define	__noinline	__attribute__ ((__noinline__))
#else
# 361 "/usr/include/sys/cdefs.h" 3 4
#define	__noinline
#endif
# 363 "/usr/include/sys/cdefs.h" 3 4

#if __GNUC_PREREQ__(3, 3)
#define	__nonnull(x)	__attribute__((__nonnull__(x)))
#define	__nonnull_all	__attribute__((__nonnull__))
#else
# 368 "/usr/include/sys/cdefs.h" 3 4
#define	__nonnull(x)
#define	__nonnull_all
#endif
# 371 "/usr/include/sys/cdefs.h" 3 4

#if __GNUC_PREREQ__(3, 4)
#define	__fastcall	__attribute__((__fastcall__))
#define	__result_use_check	__attribute__((__warn_unused_result__))
#else
# 376 "/usr/include/sys/cdefs.h" 3 4
#define	__fastcall
#define	__result_use_check
#endif
# 379 "/usr/include/sys/cdefs.h" 3 4

#if __GNUC_PREREQ__(4, 1)
#define	__returns_twice	__attribute__((__returns_twice__))
#else
# 383 "/usr/include/sys/cdefs.h" 3 4
#define	__returns_twice
#endif
# 385 "/usr/include/sys/cdefs.h" 3 4

#if __GNUC_PREREQ__(4, 6) || __has_builtin(__builtin_unreachable)
#define	__unreachable()	__builtin_unreachable()
#else
# 389 "/usr/include/sys/cdefs.h" 3 4
#define	__unreachable()	((void)0)
#endif
# 391 "/usr/include/sys/cdefs.h" 3 4

/* XXX: should use `#if __STDC_VERSION__ < 199901'. */
#if !__GNUC_PREREQ__(2, 7) && !defined(__INTEL_COMPILER)
#define	__func__	NULL
#endif
# 396 "/usr/include/sys/cdefs.h" 3 4

#if (defined(__INTEL_COMPILER) || (defined(__GNUC__) && __GNUC__ >= 2)) && !defined(__STRICT_ANSI__) || __STDC_VERSION__ >= 199901
#define	__LONG_LONG_SUPPORTED
#endif
# 400 "/usr/include/sys/cdefs.h" 3 4

/* C++11 exposes a load of C99 stuff */
#if defined(__cplusplus) && __cplusplus >= 201103L
#define	__LONG_LONG_SUPPORTED
#ifndef	__STDC_LIMIT_MACROS
#define	__STDC_LIMIT_MACROS
#endif
# 407 "/usr/include/sys/cdefs.h" 3 4
#ifndef	__STDC_CONSTANT_MACROS
#define	__STDC_CONSTANT_MACROS
#endif
# 410 "/usr/include/sys/cdefs.h" 3 4
#endif
# 411 "/usr/include/sys/cdefs.h" 3 4

/*
 * GCC 2.95 provides `__restrict' as an extension to C90 to support the
 * C99-specific `restrict' type qualifier.  We happen to use `__restrict' as
 * a way to define the `restrict' type qualifier without disturbing older
 * software that is unaware of C99 keywords.
 */
#if !(__GNUC__ == 2 && __GNUC_MINOR__ == 95)
#if !defined(__STDC_VERSION__) || __STDC_VERSION__ < 199901 || defined(lint)
#define	__restrict
#else
# 422 "/usr/include/sys/cdefs.h" 3 4
#define	__restrict	restrict
#endif
# 424 "/usr/include/sys/cdefs.h" 3 4
#endif
# 425 "/usr/include/sys/cdefs.h" 3 4

/*
 * GNU C version 2.96 adds explicit branch prediction so that
 * the CPU back-end can hint the processor and also so that
 * code blocks can be reordered such that the predicted path
 * sees a more linear flow, thus improving cache behavior, etc.
 *
 * The following two macros provide us with a way to utilize this
 * compiler feature.  Use __predict_true() if you expect the expression
 * to evaluate to true, and __predict_false() if you expect the
 * expression to evaluate to false.
 *
 * A few notes about usage:
 *
 *	* Generally, __predict_false() error condition checks (unless
 *	  you have some _strong_ reason to do otherwise, in which case
 *	  document it), and/or __predict_true() `no-error' condition
 *	  checks, assuming you want to optimize for the no-error case.
 *
 *	* Other than that, if you don't know the likelihood of a test
 *	  succeeding from empirical or other `hard' evidence, don't
 *	  make predictions.
 *
 *	* These are meant to be used in places that are run `a lot'.
 *	  It is wasteful to make predictions in code that is run
 *	  seldomly (e.g. at subsystem initialization time) as the
 *	  basic block reordering that this affects can often generate
 *	  larger code.
 */
#if __GNUC_PREREQ__(2, 96)
#define	__predict_true(exp)     __builtin_expect((exp), 1)
#define	__predict_false(exp)    __builtin_expect((exp), 0)
#else
# 458 "/usr/include/sys/cdefs.h" 3 4
#define	__predict_true(exp)     (exp)
#define	__predict_false(exp)    (exp)
#endif
# 461 "/usr/include/sys/cdefs.h" 3 4

#if __GNUC_PREREQ__(4, 0)
#define	__null_sentinel	__attribute__((__sentinel__))
#define	__exported	__attribute__((__visibility__("default")))
#define	__hidden	__attribute__((__visibility__("hidden")))
#else
# 467 "/usr/include/sys/cdefs.h" 3 4
#define	__null_sentinel
#define	__exported
#define	__hidden
#endif
# 471 "/usr/include/sys/cdefs.h" 3 4

/*
 * We define this here since <stddef.h>, <sys/queue.h>, and <sys/types.h>
 * require it.
 */
#if __GNUC_PREREQ__(4, 1)
#define	__offsetof(type, field)	 __builtin_offsetof(type, field)
#else
# 479 "/usr/include/sys/cdefs.h" 3 4
#ifndef __cplusplus
#define	__offsetof(type, field) \
	((__size_t)(__uintptr_t)((const volatile void *)&((type *)0)->field))
#else
# 483 "/usr/include/sys/cdefs.h" 3 4
#define	__offsetof(type, field)					\
  (__offsetof__ (reinterpret_cast <__size_t>			\
                 (&reinterpret_cast <const volatile char &>	\
                  (static_cast<type *> (0)->field))))
#endif
# 488 "/usr/include/sys/cdefs.h" 3 4
#endif
# 489 "/usr/include/sys/cdefs.h" 3 4
#define	__rangeof(type, start, end) \
	(__offsetof(type, end) - __offsetof(type, start))

/*
 * Given the pointer x to the member m of the struct s, return
 * a pointer to the containing structure.  When using GCC, we first
 * assign pointer x to a local variable, to check that its type is
 * compatible with member m.
 */
#if __GNUC_PREREQ__(3, 1)
#define	__containerof(x, s, m) ({					\
	const volatile __typeof(((s *)0)->m) *__x = (x);		\
	__DEQUALIFY(s *, (const volatile char *)__x - __offsetof(s, m));\
})
#else
# 504 "/usr/include/sys/cdefs.h" 3 4
#define	__containerof(x, s, m)						\
	__DEQUALIFY(s *, (const volatile char *)(x) - __offsetof(s, m))
#endif
# 507 "/usr/include/sys/cdefs.h" 3 4

/*
 * Compiler-dependent macros to declare that functions take printf-like
 * or scanf-like arguments.  They are null except for versions of gcc
 * that are known to support the features properly (old versions of gcc-2
 * didn't permit keeping the keywords out of the application namespace).
 */
#if !__GNUC_PREREQ__(2, 7) && !defined(__INTEL_COMPILER)
#define	__printflike(fmtarg, firstvararg)
#define	__scanflike(fmtarg, firstvararg)
#define	__format_arg(fmtarg)
#define	__strfmonlike(fmtarg, firstvararg)
#define	__strftimelike(fmtarg, firstvararg)
#else
# 521 "/usr/include/sys/cdefs.h" 3 4
#define	__printflike(fmtarg, firstvararg) \
	    __attribute__((__format__ (__printf__, fmtarg, firstvararg)))
#define	__scanflike(fmtarg, firstvararg) \
	    __attribute__((__format__ (__scanf__, fmtarg, firstvararg)))
#define	__format_arg(fmtarg)	__attribute__((__format_arg__ (fmtarg)))
#define	__strfmonlike(fmtarg, firstvararg) \
	    __attribute__((__format__ (__strfmon__, fmtarg, firstvararg)))
#define	__strftimelike(fmtarg, firstvararg) \
	    __attribute__((__format__ (__strftime__, fmtarg, firstvararg)))
#endif
# 531 "/usr/include/sys/cdefs.h" 3 4

/*
 * FORTIFY_SOURCE, and perhaps other compiler-specific features, require
 * the use of non-standard inlining.  In general we should try to avoid
 * using these but GCC-compatible compilers tend to support the extensions
 * well enough to use them in limited cases.
 */ 
#if defined(__GNUC_GNU_INLINE__) || defined(__GNUC_STDC_INLINE__)
#if __GNUC_PREREQ__(4, 3) || __has_attribute(__artificial__)
#define	__gnu_inline	__attribute__((__gnu_inline__, __artificial__))
#else
# 542 "/usr/include/sys/cdefs.h" 3 4
#define	__gnu_inline	__attribute__((__gnu_inline__))
#endif /* artificial */
# 544 "/usr/include/sys/cdefs.h" 3 4
#else
# 545 "/usr/include/sys/cdefs.h" 3 4
#define	__gnu_inline
#endif
# 547 "/usr/include/sys/cdefs.h" 3 4

/* Compiler-dependent macros that rely on FreeBSD-specific extensions. */
#if defined(__FreeBSD_cc_version) && __FreeBSD_cc_version >= 300001 && \
    defined(__GNUC__) && !defined(__INTEL_COMPILER)
#define	__printf0like(fmtarg, firstvararg) \
	    __attribute__((__format__ (__printf0__, fmtarg, firstvararg)))
#else
# 554 "/usr/include/sys/cdefs.h" 3 4
#define	__printf0like(fmtarg, firstvararg)
#endif
# 556 "/usr/include/sys/cdefs.h" 3 4

#if defined(__GNUC__) || defined(__INTEL_COMPILER)
#ifndef __INTEL_COMPILER
#define	__strong_reference(sym,aliassym)	\
	extern __typeof (sym) aliassym __attribute__ ((__alias__ (#sym)))
#endif
# 562 "/usr/include/sys/cdefs.h" 3 4
#ifdef __STDC__
#define	__weak_reference(sym,alias)	\
	__asm__(".weak " #alias);	\
	__asm__(".equ "  #alias ", " #sym)
#define	__warn_references(sym,msg)	\
	__asm__(".section .gnu.warning." #sym);	\
	__asm__(".asciz \"" msg "\"");	\
	__asm__(".previous")
#define	__sym_compat(sym,impl,verid)	\
	__asm__(".symver " #impl ", " #sym "@" #verid)
#define	__sym_default(sym,impl,verid)	\
	__asm__(".symver " #impl ", " #sym "@@" #verid)
#else
# 575 "/usr/include/sys/cdefs.h" 3 4
#define	__weak_reference(sym,alias)	\
	__asm__(".weak alias");		\
	__asm__(".equ alias, sym")
#define	__warn_references(sym,msg)	\
	__asm__(".section .gnu.warning.sym"); \
	__asm__(".asciz \"msg\"");	\
	__asm__(".previous")
#define	__sym_compat(sym,impl,verid)	\
	__asm__(".symver impl, sym@verid")
#define	__sym_default(impl,sym,verid)	\
	__asm__(".symver impl, sym@@verid")
#endif	/* __STDC__ */
# 587 "/usr/include/sys/cdefs.h" 3 4
#endif	/* __GNUC__ || __INTEL_COMPILER */
# 588 "/usr/include/sys/cdefs.h" 3 4

#define	__GLOBL1(sym)	__asm__(".globl " #sym)
#define	__GLOBL(sym)	__GLOBL1(sym)

#if defined(__GNUC__) || defined(__INTEL_COMPILER)
#define	__IDSTRING(name,string)	__asm__(".ident\t\"" string "\"")
#else
# 595 "/usr/include/sys/cdefs.h" 3 4
/*
 * The following definition might not work well if used in header files,
 * but it should be better than nothing.  If you want a "do nothing"
 * version, then it should generate some harmless declaration, such as:
 *    #define	__IDSTRING(name,string)	struct __hack
 */
#define	__IDSTRING(name,string)	static const char name[] __unused = string
#endif
# 603 "/usr/include/sys/cdefs.h" 3 4

/*
 * Embed the rcs id of a source file in the resulting library.  Note that in
 * more recent ELF binutils, we use .ident allowing the ID to be stripped.
 * Usage:
 *	__FBSDID("$FreeBSD: releng/11.0/sys/sys/cdefs.h 300967 2016-05-29 17:32:19Z dim $");
 */
#ifndef	__FBSDID
#if !defined(lint) && !defined(STRIP_FBSDID)
#define	__FBSDID(s)	__IDSTRING(__CONCAT(__rcsid_,__LINE__),s)
#else
# 614 "/usr/include/sys/cdefs.h" 3 4
#define	__FBSDID(s)	struct __hack
#endif
# 616 "/usr/include/sys/cdefs.h" 3 4
#endif
# 617 "/usr/include/sys/cdefs.h" 3 4

#ifndef	__RCSID
#ifndef	NO__RCSID
#define	__RCSID(s)	__IDSTRING(__CONCAT(__rcsid_,__LINE__),s)
#else
# 622 "/usr/include/sys/cdefs.h" 3 4
#define	__RCSID(s)	struct __hack
#endif
# 624 "/usr/include/sys/cdefs.h" 3 4
#endif
# 625 "/usr/include/sys/cdefs.h" 3 4

#ifndef	__RCSID_SOURCE
#ifndef	NO__RCSID_SOURCE
#define	__RCSID_SOURCE(s)	__IDSTRING(__CONCAT(__rcsid_source_,__LINE__),s)
#else
# 630 "/usr/include/sys/cdefs.h" 3 4
#define	__RCSID_SOURCE(s)	struct __hack
#endif
# 632 "/usr/include/sys/cdefs.h" 3 4
#endif
# 633 "/usr/include/sys/cdefs.h" 3 4

#ifndef	__SCCSID
#ifndef	NO__SCCSID
#define	__SCCSID(s)	__IDSTRING(__CONCAT(__sccsid_,__LINE__),s)
#else
# 638 "/usr/include/sys/cdefs.h" 3 4
#define	__SCCSID(s)	struct __hack
#endif
# 640 "/usr/include/sys/cdefs.h" 3 4
#endif
# 641 "/usr/include/sys/cdefs.h" 3 4

#ifndef	__COPYRIGHT
#ifndef	NO__COPYRIGHT
#define	__COPYRIGHT(s)	__IDSTRING(__CONCAT(__copyright_,__LINE__),s)
#else
# 646 "/usr/include/sys/cdefs.h" 3 4
#define	__COPYRIGHT(s)	struct __hack
#endif
# 648 "/usr/include/sys/cdefs.h" 3 4
#endif
# 649 "/usr/include/sys/cdefs.h" 3 4

#ifndef	__DECONST
#define	__DECONST(type, var)	((type)(__uintptr_t)(const void *)(var))
#endif
# 653 "/usr/include/sys/cdefs.h" 3 4

#ifndef	__DEVOLATILE
#define	__DEVOLATILE(type, var)	((type)(__uintptr_t)(volatile void *)(var))
#endif
# 657 "/usr/include/sys/cdefs.h" 3 4

#ifndef	__DEQUALIFY
#define	__DEQUALIFY(type, var)	((type)(__uintptr_t)(const volatile void *)(var))
#endif
# 661 "/usr/include/sys/cdefs.h" 3 4

/*-
 * The following definitions are an extension of the behavior originally
 * implemented in <sys/_posix.h>, but with a different level of granularity.
 * POSIX.1 requires that the macros we test be defined before any standard
 * header file is included.
 *
 * Here's a quick run-down of the versions:
 *  defined(_POSIX_SOURCE)		1003.1-1988
 *  _POSIX_C_SOURCE == 1		1003.1-1990
 *  _POSIX_C_SOURCE == 2		1003.2-1992 C Language Binding Option
 *  _POSIX_C_SOURCE == 199309		1003.1b-1993
 *  _POSIX_C_SOURCE == 199506		1003.1c-1995, 1003.1i-1995,
 *					and the omnibus ISO/IEC 9945-1: 1996
 *  _POSIX_C_SOURCE == 200112		1003.1-2001
 *  _POSIX_C_SOURCE == 200809		1003.1-2008
 *
 * In addition, the X/Open Portability Guide, which is now the Single UNIX
 * Specification, defines a feature-test macro which indicates the version of
 * that specification, and which subsumes _POSIX_C_SOURCE.
 *
 * Our macros begin with two underscores to avoid namespace screwage.
 */

/* Deal with IEEE Std. 1003.1-1990, in which _POSIX_C_SOURCE == 1. */
#if defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE == 1
#undef _POSIX_C_SOURCE		/* Probably illegal, but beyond caring now. */
#define	_POSIX_C_SOURCE		199009
#endif
# 690 "/usr/include/sys/cdefs.h" 3 4

/* Deal with IEEE Std. 1003.2-1992, in which _POSIX_C_SOURCE == 2. */
#if defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE == 2
#undef _POSIX_C_SOURCE
#define	_POSIX_C_SOURCE		199209
#endif
# 696 "/usr/include/sys/cdefs.h" 3 4

/* Deal with various X/Open Portability Guides and Single UNIX Spec. */
#ifdef _XOPEN_SOURCE
#if _XOPEN_SOURCE - 0 >= 700
#define	__XSI_VISIBLE		700
#undef _POSIX_C_SOURCE
#define	_POSIX_C_SOURCE		200809
#elif _XOPEN_SOURCE - 0 >= 600
# 704 "/usr/include/sys/cdefs.h" 3 4
#define	__XSI_VISIBLE		600
#undef _POSIX_C_SOURCE
#define	_POSIX_C_SOURCE		200112
#elif _XOPEN_SOURCE - 0 >= 500
# 708 "/usr/include/sys/cdefs.h" 3 4
#define	__XSI_VISIBLE		500
#undef _POSIX_C_SOURCE
#define	_POSIX_C_SOURCE		199506
#endif
# 712 "/usr/include/sys/cdefs.h" 3 4
#endif
# 713 "/usr/include/sys/cdefs.h" 3 4

/*
 * Deal with all versions of POSIX.  The ordering relative to the tests above is
 * important.
 */
#if defined(_POSIX_SOURCE) && !defined(_POSIX_C_SOURCE)
#define	_POSIX_C_SOURCE		198808
#endif
# 721 "/usr/include/sys/cdefs.h" 3 4
#ifdef _POSIX_C_SOURCE
#if _POSIX_C_SOURCE >= 200809
#define	__POSIX_VISIBLE		200809
#define	__ISO_C_VISIBLE		1999
#elif _POSIX_C_SOURCE >= 200112
# 726 "/usr/include/sys/cdefs.h" 3 4
#define	__POSIX_VISIBLE		200112
#define	__ISO_C_VISIBLE		1999
#elif _POSIX_C_SOURCE >= 199506
# 729 "/usr/include/sys/cdefs.h" 3 4
#define	__POSIX_VISIBLE		199506
#define	__ISO_C_VISIBLE		1990
#elif _POSIX_C_SOURCE >= 199309
# 732 "/usr/include/sys/cdefs.h" 3 4
#define	__POSIX_VISIBLE		199309
#define	__ISO_C_VISIBLE		1990
#elif _POSIX_C_SOURCE >= 199209
# 735 "/usr/include/sys/cdefs.h" 3 4
#define	__POSIX_VISIBLE		199209
#define	__ISO_C_VISIBLE		1990
#elif _POSIX_C_SOURCE >= 199009
# 738 "/usr/include/sys/cdefs.h" 3 4
#define	__POSIX_VISIBLE		199009
#define	__ISO_C_VISIBLE		1990
#else
# 741 "/usr/include/sys/cdefs.h" 3 4
#define	__POSIX_VISIBLE		198808
#define	__ISO_C_VISIBLE		0
#endif /* _POSIX_C_SOURCE */
# 744 "/usr/include/sys/cdefs.h" 3 4
#else
# 745 "/usr/include/sys/cdefs.h" 3 4
/*-
 * Deal with _ANSI_SOURCE:
 * If it is defined, and no other compilation environment is explicitly
 * requested, then define our internal feature-test macros to zero.  This
 * makes no difference to the preprocessor (undefined symbols in preprocessing
 * expressions are defined to have value zero), but makes it more convenient for
 * a test program to print out the values.
 *
 * If a program mistakenly defines _ANSI_SOURCE and some other macro such as
 * _POSIX_C_SOURCE, we will assume that it wants the broader compilation
 * environment (and in fact we will never get here).
 */
#if defined(_ANSI_SOURCE)	/* Hide almost everything. */
#define	__POSIX_VISIBLE		0
#define	__XSI_VISIBLE		0
#define	__BSD_VISIBLE		0
#define	__ISO_C_VISIBLE		1990
#elif defined(_C99_SOURCE)	/* Localism to specify strict C99 env. */
# 763 "/usr/include/sys/cdefs.h" 3 4
#define	__POSIX_VISIBLE		0
#define	__XSI_VISIBLE		0
#define	__BSD_VISIBLE		0
#define	__ISO_C_VISIBLE		1999
#elif defined(_C11_SOURCE)	/* Localism to specify strict C11 env. */
# 768 "/usr/include/sys/cdefs.h" 3 4
#define	__POSIX_VISIBLE		0
#define	__XSI_VISIBLE		0
#define	__BSD_VISIBLE		0
#define	__ISO_C_VISIBLE		2011
#else				/* Default environment: show everything. */
# 773 "/usr/include/sys/cdefs.h" 3 4
#define	__POSIX_VISIBLE		200809
#define	__XSI_VISIBLE		700
#define	__BSD_VISIBLE		1
#define	__ISO_C_VISIBLE		2011
#endif
# 778 "/usr/include/sys/cdefs.h" 3 4
#endif
# 779 "/usr/include/sys/cdefs.h" 3 4

#if defined(__mips) || defined(__powerpc64__) || defined(__riscv__)
#define	__NO_TLS 1
#endif
# 783 "/usr/include/sys/cdefs.h" 3 4

/*
 * Old versions of GCC use non-standard ARM arch symbols; acle-compat.h
 * translates them to __ARM_ARCH and the modern feature symbols defined by ARM.
 */
#if defined(__arm__) && !defined(__ARM_ARCH)
#if 0 /* expanded by -frewrite-includes */
#include <machine/acle-compat.h>
#endif /* expanded by -frewrite-includes */
# 789 "/usr/include/sys/cdefs.h" 3 4
# 790 "/usr/include/sys/cdefs.h" 3 4
#endif
# 791 "/usr/include/sys/cdefs.h" 3 4

/*
 * Type Safety Checking
 *
 * Clang provides additional attributes to enable checking type safety
 * properties that cannot be enforced by the C type system. 
 */

#if __has_attribute(__argument_with_type_tag__) && \
    __has_attribute(__type_tag_for_datatype__) && !defined(lint)
#define	__arg_type_tag(arg_kind, arg_idx, type_tag_idx) \
	    __attribute__((__argument_with_type_tag__(arg_kind, arg_idx, type_tag_idx)))
#define	__datatype_type_tag(kind, type) \
	    __attribute__((__type_tag_for_datatype__(kind, type)))
#else
# 806 "/usr/include/sys/cdefs.h" 3 4
#define	__arg_type_tag(arg_kind, arg_idx, type_tag_idx)
#define	__datatype_type_tag(kind, type)
#endif
# 809 "/usr/include/sys/cdefs.h" 3 4

/*
 * Lock annotations.
 *
 * Clang provides support for doing basic thread-safety tests at
 * compile-time, by marking which locks will/should be held when
 * entering/leaving a functions.
 *
 * Furthermore, it is also possible to annotate variables and structure
 * members to enforce that they are only accessed when certain locks are
 * held.
 */

#if __has_extension(c_thread_safety_attributes)
#define	__lock_annotate(x)	__attribute__((x))
#else
# 825 "/usr/include/sys/cdefs.h" 3 4
#define	__lock_annotate(x)
#endif
# 827 "/usr/include/sys/cdefs.h" 3 4

/* Structure implements a lock. */
#define	__lockable		__lock_annotate(lockable)

/* Function acquires an exclusive or shared lock. */
#define	__locks_exclusive(...) \
	__lock_annotate(exclusive_lock_function(__VA_ARGS__))
#define	__locks_shared(...) \
	__lock_annotate(shared_lock_function(__VA_ARGS__))

/* Function attempts to acquire an exclusive or shared lock. */
#define	__trylocks_exclusive(...) \
	__lock_annotate(exclusive_trylock_function(__VA_ARGS__))
#define	__trylocks_shared(...) \
	__lock_annotate(shared_trylock_function(__VA_ARGS__))

/* Function releases a lock. */
#define	__unlocks(...)		__lock_annotate(unlock_function(__VA_ARGS__))

/* Function asserts that an exclusive or shared lock is held. */
#define	__asserts_exclusive(...) \
	__lock_annotate(assert_exclusive_lock(__VA_ARGS__))
#define	__asserts_shared(...) \
	__lock_annotate(assert_shared_lock(__VA_ARGS__))

/* Function requires that an exclusive or shared lock is or is not held. */
#define	__requires_exclusive(...) \
	__lock_annotate(exclusive_locks_required(__VA_ARGS__))
#define	__requires_shared(...) \
	__lock_annotate(shared_locks_required(__VA_ARGS__))
#define	__requires_unlocked(...) \
	__lock_annotate(locks_excluded(__VA_ARGS__))

/* Function should not be analyzed. */
#define	__no_lock_analysis	__lock_annotate(no_thread_safety_analysis)

/* Guard variables and structure members by lock. */
#define	__guarded_by(x)		__lock_annotate(guarded_by(x))
#define	__pt_guarded_by(x)	__lock_annotate(pt_guarded_by(x))

#endif /* !_SYS_CDEFS_H_ */
# 868 "/usr/include/sys/cdefs.h" 3 4
# 42 "/usr/include/setjmp.h" 2 3 4

/* The size of the jmp_buf is machine dependent: */
#if 0 /* expanded by -frewrite-includes */
#include <machine/setjmp.h>
#endif /* expanded by -frewrite-includes */
# 44 "/usr/include/setjmp.h" 3 4
# 1 "/usr/include/machine/setjmp.h" 1 3 4
/*-
 * This file is in the public domain.
 */
/* $FreeBSD: releng/11.0/sys/amd64/include/setjmp.h 232275 2012-02-28 22:17:52Z tijl $ */

#if 0 /* expanded by -frewrite-includes */
#include <x86/setjmp.h>
#endif /* expanded by -frewrite-includes */
# 6 "/usr/include/machine/setjmp.h" 3 4
# 1 "/usr/include/x86/setjmp.h" 1 3 4
/*-
 * Copyright (c) 1998 John Birrell <jb@cimlogic.com.au>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN BIRRELL AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/sys/x86/include/setjmp.h 232275 2012-02-28 22:17:52Z tijl $
 */

#ifndef _MACHINE_SETJMP_H_
#define	_MACHINE_SETJMP_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 35 "/usr/include/x86/setjmp.h" 3 4
# 36 "/usr/include/x86/setjmp.h" 3 4

#define	_JBLEN	12		/* Size of the jmp_buf on AMD64. */

/*
 * jmp_buf and sigjmp_buf are encapsulated in different structs to force
 * compile-time diagnostics for mismatches.  The structs are the same
 * internally to avoid some run-time errors for mismatches.
 */
#if __BSD_VISIBLE || __POSIX_VISIBLE || __XSI_VISIBLE
typedef	struct _sigjmp_buf { long _sjb[_JBLEN]; } sigjmp_buf[1];
#endif
# 47 "/usr/include/x86/setjmp.h" 3 4

typedef	struct _jmp_buf { long _jb[_JBLEN]; } jmp_buf[1];

#endif /* !_MACHINE_SETJMP_H_ */
# 51 "/usr/include/x86/setjmp.h" 3 4
# 7 "/usr/include/machine/setjmp.h" 2 3 4
# 45 "/usr/include/setjmp.h" 2 3 4

__BEGIN_DECLS
#if __XSI_VISIBLE >= 600
void	_longjmp(jmp_buf, int) __dead2;
int	_setjmp(jmp_buf) __returns_twice;
#endif
# 51 "/usr/include/setjmp.h" 3 4
void	longjmp(jmp_buf, int) __dead2;
#if __BSD_VISIBLE
void	longjmperror(void);
#endif
# 55 "/usr/include/setjmp.h" 3 4
int	setjmp(jmp_buf) __returns_twice;
#if __POSIX_VISIBLE || __XSI_VISIBLE
void	siglongjmp(sigjmp_buf, int) __dead2;
int	sigsetjmp(sigjmp_buf, int) __returns_twice;
#endif
# 60 "/usr/include/setjmp.h" 3 4
__END_DECLS

#endif /* !_SETJMP_H_ */
# 63 "/usr/include/setjmp.h" 3 4
# 176 "shell/ash.c" 2
#if 0 /* expanded by -frewrite-includes */
#include <fnmatch.h>
#endif /* expanded by -frewrite-includes */
# 176 "shell/ash.c"
# 1 "/usr/include/fnmatch.h" 1 3 4
/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/include/fnmatch.h 203964 2010-02-16 19:39:50Z imp $
 *	@(#)fnmatch.h	8.1 (Berkeley) 6/2/93
 */

#ifndef	_FNMATCH_H_
#define	_FNMATCH_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/fnmatch.h" 3 4
# 37 "/usr/include/fnmatch.h" 3 4

#define	FNM_NOMATCH	1	/* Match failed. */

#define	FNM_NOESCAPE	0x01	/* Disable backslash escaping. */
#define	FNM_PATHNAME	0x02	/* Slash must be matched by slash. */
#define	FNM_PERIOD	0x04	/* Period must be matched by period. */

#if __XSI_VISIBLE
#define	FNM_NOSYS	(-1)	/* Reserved. */
#endif
# 47 "/usr/include/fnmatch.h" 3 4

#if __BSD_VISIBLE
#define	FNM_LEADING_DIR	0x08	/* Ignore /<tail> after Imatch. */
#define	FNM_CASEFOLD	0x10	/* Case insensitive search. */
#define	FNM_IGNORECASE	FNM_CASEFOLD
#define	FNM_FILE_NAME	FNM_PATHNAME
#endif
# 54 "/usr/include/fnmatch.h" 3 4

__BEGIN_DECLS
int	 fnmatch(const char *, const char *, int);
__END_DECLS

#endif /* !_FNMATCH_H_ */
# 60 "/usr/include/fnmatch.h" 3 4
# 177 "shell/ash.c" 2
#if 0 /* expanded by -frewrite-includes */
#include <sys/times.h>
#endif /* expanded by -frewrite-includes */
# 177 "shell/ash.c"
# 1 "/usr/include/sys/times.h" 1 3 4
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)times.h	8.4 (Berkeley) 1/21/94
 * $FreeBSD: releng/11.0/sys/sys/times.h 127976 2004-04-07 04:19:52Z imp $
 */

#ifndef	_SYS_TIMES_H_
#define	_SYS_TIMES_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 41 "/usr/include/sys/times.h" 3 4
# 1 "/usr/include/sys/_types.h" 1 3 4
/*-
 * Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/sys/sys/_types.h 299571 2016-05-12 21:18:17Z cem $
 */

#ifndef _SYS__TYPES_H_
#define _SYS__TYPES_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 32 "/usr/include/sys/_types.h" 3 4
# 33 "/usr/include/sys/_types.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <machine/_types.h>
#endif /* expanded by -frewrite-includes */
# 33 "/usr/include/sys/_types.h" 3 4
# 1 "/usr/include/machine/_types.h" 1 3 4
/*-
 * This file is in the public domain.
 */
/* $FreeBSD: releng/11.0/sys/amd64/include/_types.h 232261 2012-02-28 18:15:28Z tijl $ */

#if 0 /* expanded by -frewrite-includes */
#include <x86/_types.h>
#endif /* expanded by -frewrite-includes */
# 6 "/usr/include/machine/_types.h" 3 4
# 1 "/usr/include/x86/_types.h" 1 3 4
/*-
 * Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	From: @(#)ansi.h	8.2 (Berkeley) 1/4/94
 *	From: @(#)types.h	8.3 (Berkeley) 1/5/94
 * $FreeBSD: releng/11.0/sys/x86/include/_types.h 301029 2016-05-31 08:36:39Z ed $
 */

#ifndef _MACHINE__TYPES_H_
#define	_MACHINE__TYPES_H_

#ifndef _SYS_CDEFS_H_
#error this file needs sys/cdefs.h as a prerequisite
#endif
# 45 "/usr/include/x86/_types.h" 3 4

#if 0 /* expanded by -frewrite-includes */
#include <machine/_limits.h>
#endif /* expanded by -frewrite-includes */
# 46 "/usr/include/x86/_types.h" 3 4
# 1 "/usr/include/machine/_limits.h" 1 3 4
/*-
 * This file is in the public domain.
 */
/* $FreeBSD: releng/11.0/sys/amd64/include/_limits.h 232262 2012-02-28 18:24:28Z tijl $ */

#if 0 /* expanded by -frewrite-includes */
#include <x86/_limits.h>
#endif /* expanded by -frewrite-includes */
# 6 "/usr/include/machine/_limits.h" 3 4
# 1 "/usr/include/x86/_limits.h" 1 3 4
/*-
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)limits.h	8.3 (Berkeley) 1/4/94
 * $FreeBSD: releng/11.0/sys/x86/include/_limits.h 235939 2012-05-24 21:44:46Z obrien $
 */

#ifndef	_MACHINE__LIMITS_H_
#define	_MACHINE__LIMITS_H_

/*
 * According to ANSI (section 2.2.4.2), the values below must be usable by
 * #if preprocessing directives.  Additionally, the expression must have the
 * same type as would an expression that is an object of the corresponding
 * type converted according to the integral promotions.  The subtraction for
 * INT_MIN, etc., is so the value is not unsigned; e.g., 0x80000000 is an
 * unsigned int for 32-bit two's complement ANSI compilers (section 3.1.3.2).
 */

#define	__CHAR_BIT	8		/* number of bits in a char */

#define	__SCHAR_MAX	0x7f		/* max value for a signed char */
#define	__SCHAR_MIN	(-0x7f - 1)	/* min value for a signed char */

#define	__UCHAR_MAX	0xff		/* max value for an unsigned char */

#define	__USHRT_MAX	0xffff		/* max value for an unsigned short */
#define	__SHRT_MAX	0x7fff		/* max value for a short */
#define	__SHRT_MIN	(-0x7fff - 1)	/* min value for a short */

#define	__UINT_MAX	0xffffffff	/* max value for an unsigned int */
#define	__INT_MAX	0x7fffffff	/* max value for an int */
#define	__INT_MIN	(-0x7fffffff - 1)	/* min value for an int */

#ifdef	__LP64__
#define	__ULONG_MAX	0xffffffffffffffff	/* max for an unsigned long */
#define	__LONG_MAX	0x7fffffffffffffff	/* max for a long */
#define	__LONG_MIN	(-0x7fffffffffffffff - 1) /* min for a long */
#else
# 65 "/usr/include/x86/_limits.h" 3 4
#define	__ULONG_MAX	0xffffffffUL
#define	__LONG_MAX	0x7fffffffL
#define	__LONG_MIN	(-0x7fffffffL - 1)
#endif
# 69 "/usr/include/x86/_limits.h" 3 4

			/* max value for an unsigned long long */
#define	__ULLONG_MAX	0xffffffffffffffffULL
#define	__LLONG_MAX	0x7fffffffffffffffLL	/* max value for a long long */
#define	__LLONG_MIN	(-0x7fffffffffffffffLL - 1)  /* min for a long long */

#ifdef	__LP64__
#define	__SSIZE_MAX	__LONG_MAX	/* max value for a ssize_t */
#define	__SIZE_T_MAX	__ULONG_MAX	/* max value for a size_t */
#define	__OFF_MAX	__LONG_MAX	/* max value for an off_t */
#define	__OFF_MIN	__LONG_MIN	/* min value for an off_t */
/* Quads and longs are the same on the amd64.  Ensure they stay in sync. */
#define	__UQUAD_MAX	__ULONG_MAX	/* max value for a uquad_t */
#define	__QUAD_MAX	__LONG_MAX	/* max value for a quad_t */
#define	__QUAD_MIN	__LONG_MIN	/* min value for a quad_t */
#define	__LONG_BIT	64
#else
# 86 "/usr/include/x86/_limits.h" 3 4
#define	__SSIZE_MAX	__INT_MAX
#define	__SIZE_T_MAX	__UINT_MAX
#define	__OFF_MAX	__LLONG_MAX
#define	__OFF_MIN	__LLONG_MIN
#define	__UQUAD_MAX	__ULLONG_MAX
#define	__QUAD_MAX	__LLONG_MAX
#define	__QUAD_MIN	__LLONG_MIN
#define	__LONG_BIT	32
#endif
# 95 "/usr/include/x86/_limits.h" 3 4

#define	__WORD_BIT	32

/* Minimum signal stack size. */
#define	__MINSIGSTKSZ	(512 * 4)

#endif /* !_MACHINE__LIMITS_H_ */
# 102 "/usr/include/x86/_limits.h" 3 4
# 7 "/usr/include/machine/_limits.h" 2 3 4
# 47 "/usr/include/x86/_types.h" 2 3 4

#define __NO_STRICT_ALIGNMENT

/*
 * Basic types upon which most other types are built.
 */
typedef	signed char		__int8_t;
typedef	unsigned char		__uint8_t;
typedef	short			__int16_t;
typedef	unsigned short		__uint16_t;
typedef	int			__int32_t;
typedef	unsigned int		__uint32_t;
#ifdef	__LP64__
typedef	long			__int64_t;
typedef	unsigned long		__uint64_t;
#else
# 63 "/usr/include/x86/_types.h" 3 4
#ifndef lint
__extension__
#endif
# 66 "/usr/include/x86/_types.h" 3 4
/* LONGLONG */
typedef	long long		__int64_t;
#ifndef lint
__extension__
#endif
# 71 "/usr/include/x86/_types.h" 3 4
/* LONGLONG */
typedef	unsigned long long	__uint64_t;
#endif
# 74 "/usr/include/x86/_types.h" 3 4

/*
 * Standard type definitions.
 */
#ifdef	__LP64__
typedef	__int32_t	__clock_t;		/* clock()... */
typedef	__int64_t	__critical_t;
typedef	double		__double_t;
typedef	float		__float_t;
typedef	__int64_t	__intfptr_t;
typedef	__int64_t	__intptr_t;
#else
# 86 "/usr/include/x86/_types.h" 3 4
typedef	unsigned long	__clock_t;
typedef	__int32_t	__critical_t;
typedef	long double	__double_t;
typedef	long double	__float_t;
typedef	__int32_t	__intfptr_t;
typedef	__int32_t	__intptr_t;
#endif
# 93 "/usr/include/x86/_types.h" 3 4
typedef	__int64_t	__intmax_t;
typedef	__int32_t	__int_fast8_t;
typedef	__int32_t	__int_fast16_t;
typedef	__int32_t	__int_fast32_t;
typedef	__int64_t	__int_fast64_t;
typedef	__int8_t	__int_least8_t;
typedef	__int16_t	__int_least16_t;
typedef	__int32_t	__int_least32_t;
typedef	__int64_t	__int_least64_t;
#ifdef	__LP64__
typedef	__int64_t	__ptrdiff_t;		/* ptr1 - ptr2 */
typedef	__int64_t	__register_t;
typedef	__int64_t	__segsz_t;		/* segment size (in pages) */
typedef	__uint64_t	__size_t;		/* sizeof() */
typedef	__int64_t	__ssize_t;		/* byte count or error */
typedef	__int64_t	__time_t;		/* time()... */
typedef	__uint64_t	__uintfptr_t;
typedef	__uint64_t	__uintptr_t;
#else
# 112 "/usr/include/x86/_types.h" 3 4
typedef	__int32_t	__ptrdiff_t;
typedef	__int32_t	__register_t;
typedef	__int32_t	__segsz_t;
typedef	__uint32_t	__size_t;
typedef	__int32_t	__ssize_t;
typedef	__int32_t	__time_t;
typedef	__uint32_t	__uintfptr_t;
typedef	__uint32_t	__uintptr_t;
#endif
# 121 "/usr/include/x86/_types.h" 3 4
typedef	__uint64_t	__uintmax_t;
typedef	__uint32_t	__uint_fast8_t;
typedef	__uint32_t	__uint_fast16_t;
typedef	__uint32_t	__uint_fast32_t;
typedef	__uint64_t	__uint_fast64_t;
typedef	__uint8_t	__uint_least8_t;
typedef	__uint16_t	__uint_least16_t;
typedef	__uint32_t	__uint_least32_t;
typedef	__uint64_t	__uint_least64_t;
#ifdef	__LP64__
typedef	__uint64_t	__u_register_t;
typedef	__uint64_t	__vm_offset_t;
typedef	__uint64_t	__vm_paddr_t;
typedef	__uint64_t	__vm_size_t;
#else
# 136 "/usr/include/x86/_types.h" 3 4
typedef	__uint32_t	__u_register_t;
typedef	__uint32_t	__vm_offset_t;
#ifdef PAE
typedef	__uint64_t	__vm_paddr_t;
#else
# 141 "/usr/include/x86/_types.h" 3 4
typedef	__uint32_t	__vm_paddr_t;
#endif
# 143 "/usr/include/x86/_types.h" 3 4
typedef	__uint32_t	__vm_size_t;
#endif
# 145 "/usr/include/x86/_types.h" 3 4
typedef	__int64_t	__vm_ooffset_t;
typedef	__uint64_t	__vm_pindex_t;
typedef	int		___wchar_t;

#define	__WCHAR_MIN	__INT_MIN	/* min value for a wchar_t */
#define	__WCHAR_MAX	__INT_MAX	/* max value for a wchar_t */

/*
 * Unusual type definitions.
 */
#ifdef __GNUCLIKE_BUILTIN_VARARGS
typedef	__builtin_va_list	__va_list;	/* internally known to gcc */
#else
# 158 "/usr/include/x86/_types.h" 3 4
#ifdef __LP64__
struct __s_va_list {
	__uint32_t	_pad1[2];	/* gp_offset, fp_offset */
	__uint64_t	_pad2[2];	/* overflow_arg_area, reg_save_area */
};
typedef	struct __s_va_list	__va_list;
#else
# 165 "/usr/include/x86/_types.h" 3 4
typedef	char *			__va_list;
#endif
# 167 "/usr/include/x86/_types.h" 3 4
#endif
# 168 "/usr/include/x86/_types.h" 3 4
#if defined(__GNUC_VA_LIST_COMPATIBILITY) && !defined(__GNUC_VA_LIST) \
    && !defined(__NO_GNUC_VA_LIST)
#define __GNUC_VA_LIST
typedef __va_list		__gnuc_va_list;	/* compatibility w/GNU headers*/
#endif
# 173 "/usr/include/x86/_types.h" 3 4

#endif /* !_MACHINE__TYPES_H_ */
# 175 "/usr/include/x86/_types.h" 3 4
# 7 "/usr/include/machine/_types.h" 2 3 4
# 34 "/usr/include/sys/_types.h" 2 3 4

/*
 * Standard type definitions.
 */
typedef	__int32_t	__blksize_t;	/* file block size */
typedef	__int64_t	__blkcnt_t;	/* file block count */
typedef	__int32_t	__clockid_t;	/* clock_gettime()... */
typedef	__uint32_t	__fflags_t;	/* file flags */
typedef	__uint64_t	__fsblkcnt_t;
typedef	__uint64_t	__fsfilcnt_t;
typedef	__uint32_t	__gid_t;
typedef	__int64_t	__id_t;		/* can hold a gid_t, pid_t, or uid_t */
typedef	__uint32_t	__ino_t;	/* inode number */
typedef	long		__key_t;	/* IPC key (for Sys V IPC) */
typedef	__int32_t	__lwpid_t;	/* Thread ID (a.k.a. LWP) */
typedef	__uint16_t	__mode_t;	/* permissions */
typedef	int		__accmode_t;	/* access permissions */
typedef	int		__nl_item;
typedef	__uint16_t	__nlink_t;	/* link count */
typedef	__int64_t	__off_t;	/* file offset */
typedef	__int64_t	__off64_t;	/* file offset (alias) */
typedef	__int32_t	__pid_t;	/* process [group] */
typedef	__int64_t	__rlim_t;	/* resource limit - intentionally */
					/* signed, because of legacy code */
					/* that uses -1 for RLIM_INFINITY */
typedef	__uint8_t	__sa_family_t;
typedef	__uint32_t	__socklen_t;
typedef	long		__suseconds_t;	/* microseconds (signed) */
typedef	struct __timer	*__timer_t;	/* timer_gettime()... */
typedef	struct __mq	*__mqd_t;	/* mq_open()... */
typedef	__uint32_t	__uid_t;
typedef	unsigned int	__useconds_t;	/* microseconds (unsigned) */
typedef	int		__cpuwhich_t;	/* which parameter for cpuset. */
typedef	int		__cpulevel_t;	/* level parameter for cpuset. */
typedef int		__cpusetid_t;	/* cpuset identifier. */

/*
 * Unusual type definitions.
 */
/*
 * rune_t is declared to be an ``int'' instead of the more natural
 * ``unsigned long'' or ``long''.  Two things are happening here.  It is not
 * unsigned so that EOF (-1) can be naturally assigned to it and used.  Also,
 * it looks like 10646 will be a 31 bit standard.  This means that if your
 * ints cannot hold 32 bits, you will be in trouble.  The reason an int was
 * chosen over a long is that the is*() and to*() routines take ints (says
 * ANSI C), but they use __ct_rune_t instead of int.
 *
 * NOTE: rune_t is not covered by ANSI nor other standards, and should not
 * be instantiated outside of lib/libc/locale.  Use wchar_t.  wint_t and
 * rune_t must be the same type.  Also, wint_t should be able to hold all
 * members of the largest character set plus one extra value (WEOF), and
 * must be at least 16 bits.
 */
typedef	int		__ct_rune_t;	/* arg type for ctype funcs */
typedef	__ct_rune_t	__rune_t;	/* rune_t (see above) */
typedef	__ct_rune_t	__wint_t;	/* wint_t (see above) */

/* Clang already provides these types as built-ins, but only in C++ mode. */
#if !defined(__clang__) || !defined(__cplusplus)
typedef	__uint_least16_t __char16_t;
typedef	__uint_least32_t __char32_t;
#endif
# 97 "/usr/include/sys/_types.h" 3 4
/* In C++11, char16_t and char32_t are built-in types. */
#if defined(__cplusplus) && __cplusplus >= 201103L
#define	_CHAR16_T_DECLARED
#define	_CHAR32_T_DECLARED
#endif
# 102 "/usr/include/sys/_types.h" 3 4

typedef	__uint32_t	__dev_t;	/* device number */

typedef	__uint32_t	__fixpt_t;	/* fixed point number */

/*
 * mbstate_t is an opaque object to keep conversion state during multibyte
 * stream conversions.
 */
typedef union {
	char		__mbstate8[128];
	__int64_t	_mbstateL;	/* for alignment */
} __mbstate_t;

typedef __uintmax_t     __rman_res_t;

#endif /* !_SYS__TYPES_H_ */
# 119 "/usr/include/sys/_types.h" 3 4
# 42 "/usr/include/sys/times.h" 2 3 4

#ifndef _CLOCK_T_DECLARED
typedef	__clock_t	clock_t;
#define	_CLOCK_T_DECLARED
#endif
# 47 "/usr/include/sys/times.h" 3 4

struct tms {
	clock_t tms_utime;	/* User CPU time */
	clock_t tms_stime;	/* System CPU time */
	clock_t tms_cutime;	/* User CPU time of terminated child procs */
	clock_t tms_cstime;	/* System CPU time of terminated child procs */
};

#ifndef _KERNEL
#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 56 "/usr/include/sys/times.h" 3 4
# 57 "/usr/include/sys/times.h" 3 4

__BEGIN_DECLS
clock_t	times(struct tms *);
__END_DECLS
#endif
# 62 "/usr/include/sys/times.h" 3 4
#endif /* !_SYS_TIMES_H_ */
# 63 "/usr/include/sys/times.h" 3 4
# 178 "shell/ash.c" 2
#if 0 /* expanded by -frewrite-includes */
#include <sys/utsname.h> /* for setting $HOSTNAME */
#endif /* expanded by -frewrite-includes */
# 178 "shell/ash.c"
# 1 "/usr/include/sys/utsname.h" 1 3 4
/*-
 * Copyright (c) 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chuck Karish of Mindcraft, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)utsname.h	8.1 (Berkeley) 1/4/94
 * $FreeBSD: releng/11.0/sys/sys/utsname.h 127976 2004-04-07 04:19:52Z imp $
 */

#ifndef	_SYS_UTSNAME_H
#define	_SYS_UTSNAME_H

#ifdef _KERNEL
#define	SYS_NMLN	32		/* uname(2) for the FreeBSD 1.1 ABI. */
#endif
# 42 "/usr/include/sys/utsname.h" 3 4

#ifndef SYS_NMLN
#define	SYS_NMLN	256		/* User can override. */
#endif
# 46 "/usr/include/sys/utsname.h" 3 4

struct utsname {
	char	sysname[SYS_NMLN];	/* Name of this OS. */
	char	nodename[SYS_NMLN];	/* Name of this network node. */
	char	release[SYS_NMLN];	/* Release level. */
	char	version[SYS_NMLN];	/* Version level. */
	char	machine[SYS_NMLN];	/* Hardware type. */
};

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 55 "/usr/include/sys/utsname.h" 3 4
# 56 "/usr/include/sys/utsname.h" 3 4

#ifndef _KERNEL
__BEGIN_DECLS
int	__xuname(int, void *);		/* Variable record size. */
__END_DECLS

static __inline int
uname(struct utsname *name)
{
	return __xuname(SYS_NMLN, (void *)name);
}
#endif	/* _KERNEL */
# 68 "/usr/include/sys/utsname.h" 3 4

#endif	/* !_SYS_UTSNAME_H */
# 70 "/usr/include/sys/utsname.h" 3 4
# 179 "shell/ash.c" 2

#if 0 /* expanded by -frewrite-includes */
#include "busybox.h" /* for applet_names */
#endif /* expanded by -frewrite-includes */
# 180 "shell/ash.c"
# 1 "include/busybox.h" 1
/* vi: set sw=4 ts=4: */
/*
 * Licensed under GPLv2 or later, see file LICENSE in this source tree.
 */
#ifndef BUSYBOX_H
#define BUSYBOX_H 1

#if 0 /* expanded by -frewrite-includes */
#include "libbb.h"
#endif /* expanded by -frewrite-includes */
# 8 "include/busybox.h"
# 1 "include/libbb.h" 1
/* vi: set sw=4 ts=4: */
/*
 * Busybox main internal header file
 *
 * Based in part on code from sash, Copyright (c) 1999 by David I. Bell
 * Permission has been granted to redistribute this code under GPL.
 *
 * Licensed under GPLv2, see file LICENSE in this source tree.
 */
#ifndef LIBBB_H
#define LIBBB_H 1

#if 0 /* expanded by -frewrite-includes */
#include "platform.h"
#endif /* expanded by -frewrite-includes */
# 13 "include/libbb.h"
# 1 "include/platform.h" 1
/* vi: set sw=4 ts=4: */
/*
 * Copyright 2006, Bernhard Reutner-Fischer
 *
 * Licensed under GPLv2 or later, see file LICENSE in this source tree.
 */
#ifndef BB_PLATFORM_H
#define BB_PLATFORM_H 1


/* Convenience macros to test the version of gcc. */
#undef __GNUC_PREREQ
#if defined __GNUC__ && defined __GNUC_MINOR__
# define __GNUC_PREREQ(maj, min) \
		((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
#else
# 17 "include/platform.h"
# define __GNUC_PREREQ(maj, min) 0
#endif
# 19 "include/platform.h"

/* __restrict is known in EGCS 1.2 and above. */
#if !__GNUC_PREREQ(2,92)
# ifndef __restrict
#  define __restrict
# endif
# 25 "include/platform.h"
#endif
# 26 "include/platform.h"

#if !__GNUC_PREREQ(2,7)
# ifndef __attribute__
#  define __attribute__(x)
# endif
# 31 "include/platform.h"
#endif
# 32 "include/platform.h"

#undef inline
#if defined(__STDC_VERSION__) && __STDC_VERSION__ > 199901L
/* it's a keyword */
#elif __GNUC_PREREQ(2,7)
# 37 "include/platform.h"
# define inline __inline__
#else
# 39 "include/platform.h"
# define inline
#endif
# 41 "include/platform.h"

#ifndef __const
# define __const const
#endif
# 45 "include/platform.h"

#define UNUSED_PARAM __attribute__ ((__unused__))
#define NORETURN __attribute__ ((__noreturn__))
/* "The malloc attribute is used to tell the compiler that a function
 * may be treated as if any non-NULL pointer it returns cannot alias
 * any other pointer valid when the function returns. This will often
 * improve optimization. Standard functions with this property include
 * malloc and calloc. realloc-like functions have this property as long
 * as the old pointer is never referred to (including comparing it
 * to the new pointer) after the function returns a non-NULL value."
 */
#define RETURNS_MALLOC __attribute__ ((malloc))
#define PACKED __attribute__ ((__packed__))
#define ALIGNED(m) __attribute__ ((__aligned__(m)))

/* __NO_INLINE__: some gcc's do not honor inlining! :( */
#if __GNUC_PREREQ(3,0) && !defined(__NO_INLINE__)
# define ALWAYS_INLINE __attribute__ ((always_inline)) inline
/* I've seen a toolchain where I needed __noinline__ instead of noinline */
# define NOINLINE      __attribute__((__noinline__))
# if !ENABLE_WERROR
#  define DEPRECATED __attribute__ ((__deprecated__))
#  define UNUSED_PARAM_RESULT __attribute__ ((warn_unused_result))
# else
# 69 "include/platform.h"
#  define DEPRECATED
#  define UNUSED_PARAM_RESULT
# endif
# 72 "include/platform.h"
#else
# 73 "include/platform.h"
# define ALWAYS_INLINE inline
# define NOINLINE
# define DEPRECATED
# define UNUSED_PARAM_RESULT
#endif
# 78 "include/platform.h"

/* used by unit test machinery to run registration functions before calling main() */
#define INIT_FUNC __attribute__ ((constructor))

/* -fwhole-program makes all symbols local. The attribute externally_visible
 * forces a symbol global.  */
#if __GNUC_PREREQ(4,1)
# define EXTERNALLY_VISIBLE __attribute__(( visibility("default") ))
//__attribute__ ((__externally_visible__))
#else
# 88 "include/platform.h"
# define EXTERNALLY_VISIBLE
#endif
# 90 "include/platform.h"

/* At 4.4 gcc become much more anal about this, need to use "aliased" types */
#if __GNUC_PREREQ(4,4)
# define FIX_ALIASING __attribute__((__may_alias__))
#else
# 95 "include/platform.h"
# define FIX_ALIASING
#endif
# 97 "include/platform.h"

/* We use __extension__ in some places to suppress -pedantic warnings
 * about GCC extensions.  This feature didn't work properly before
 * gcc 2.8.  */
#if !__GNUC_PREREQ(2,8)
# ifndef __extension__
#  define __extension__
# endif
# 105 "include/platform.h"
#endif
# 106 "include/platform.h"

/* FAST_FUNC is a qualifier which (possibly) makes function call faster
 * and/or smaller by using modified ABI. It is usually only needed
 * on non-static, busybox internal functions. Recent versions of gcc
 * optimize statics automatically. FAST_FUNC on static is required
 * only if you need to match a function pointer's type */
#if __GNUC_PREREQ(3,0) && defined(i386) /* || defined(__x86_64__)? */
/* stdcall makes callee to pop arguments from stack, not caller */
# define FAST_FUNC __attribute__((regparm(3),stdcall))
/* #elif ... - add your favorite arch today! */
#else
# 117 "include/platform.h"
# define FAST_FUNC
#endif
# 119 "include/platform.h"

/* Make all declarations hidden (-fvisibility flag only affects definitions) */
/* (don't include system headers after this until corresponding pop!) */
#if __GNUC_PREREQ(4,1) && !defined(__CYGWIN__)
# define PUSH_AND_SET_FUNCTION_VISIBILITY_TO_HIDDEN _Pragma("GCC visibility push(hidden)")
# define POP_SAVED_FUNCTION_VISIBILITY              _Pragma("GCC visibility pop")
#else
# 126 "include/platform.h"
# define PUSH_AND_SET_FUNCTION_VISIBILITY_TO_HIDDEN
# define POP_SAVED_FUNCTION_VISIBILITY
#endif
# 129 "include/platform.h"

/* gcc-2.95 had no va_copy but only __va_copy. */
#if !__GNUC_PREREQ(3,0)
#if 0 /* expanded by -frewrite-includes */
# include <stdarg.h>
#endif /* expanded by -frewrite-includes */
# 132 "include/platform.h"
# 133 "include/platform.h"
# if !defined va_copy && defined __va_copy
#  define va_copy(d,s) __va_copy((d),(s))
# endif
# 136 "include/platform.h"
#endif
# 137 "include/platform.h"


/* ---- Endian Detection ------------------------------------ */

#if 0 /* expanded by -frewrite-includes */
#include <limits.h>
#endif /* expanded by -frewrite-includes */
# 141 "include/platform.h"
# 1 "/usr/include/limits.h" 1 3 4
/*-
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)limits.h	8.2 (Berkeley) 1/4/94
 * $FreeBSD: releng/11.0/include/limits.h 293491 2016-01-09 14:53:23Z kevlo $
 */

#ifndef _LIMITS_H_
#define	_LIMITS_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/limits.h" 3 4
# 37 "/usr/include/limits.h" 3 4

#if __POSIX_VISIBLE
#define	_POSIX_ARG_MAX		4096
#define	_POSIX_LINK_MAX		8
#define	_POSIX_MAX_CANON	255
#define	_POSIX_MAX_INPUT	255
#define	_POSIX_NAME_MAX		14
#define	_POSIX_PIPE_BUF		512
#define	_POSIX_SSIZE_MAX	32767
#define	_POSIX_STREAM_MAX	8

#if __POSIX_VISIBLE >= 200112
#define	_POSIX_CHILD_MAX	25
#define	_POSIX_NGROUPS_MAX	8
#define	_POSIX_OPEN_MAX		20
#define	_POSIX_PATH_MAX		256
#define	_POSIX_TZNAME_MAX	6
#else
# 55 "/usr/include/limits.h" 3 4
#define	_POSIX_CHILD_MAX	6
#define	_POSIX_NGROUPS_MAX	0
#define	_POSIX_OPEN_MAX		16
#define	_POSIX_PATH_MAX		255
#define	_POSIX_TZNAME_MAX	3
#endif
# 61 "/usr/include/limits.h" 3 4

#if __POSIX_VISIBLE >= 200112
#define	BC_BASE_MAX		   99	/* max ibase/obase values in bc(1) */
#define	BC_DIM_MAX		 2048	/* max array elements in bc(1) */
#define	BC_SCALE_MAX		   99	/* max scale value in bc(1) */
#define	BC_STRING_MAX		 1000	/* max const string length in bc(1) */
#define	CHARCLASS_NAME_MAX	   14	/* max character class name size */
#define	COLL_WEIGHTS_MAX	   10	/* max weights for order keyword */
#define	EXPR_NEST_MAX		   32	/* max expressions nested in expr(1) */
#define	LINE_MAX		 2048	/* max bytes in an input line */
#define	RE_DUP_MAX		  255	/* max RE's in interval notation */

#define	_POSIX2_BC_BASE_MAX	99
#define	_POSIX2_BC_DIM_MAX	2048
#define	_POSIX2_BC_SCALE_MAX	99
#define	_POSIX2_BC_STRING_MAX	1000
#define	_POSIX2_CHARCLASS_NAME_MAX 14
#define	_POSIX2_COLL_WEIGHTS_MAX 2
#define	_POSIX2_EQUIV_CLASS_MAX	2
#define	_POSIX2_EXPR_NEST_MAX	32
#define	_POSIX2_LINE_MAX	2048
#define	_POSIX2_RE_DUP_MAX	255
#endif
# 84 "/usr/include/limits.h" 3 4
#endif
# 85 "/usr/include/limits.h" 3 4

#if __POSIX_VISIBLE >= 199309
#define	_POSIX_AIO_LISTIO_MAX	2
#define	_POSIX_AIO_MAX		1
#define	_POSIX_DELAYTIMER_MAX	32
#define	_POSIX_MQ_OPEN_MAX	8
#define	_POSIX_MQ_PRIO_MAX	32
#define	_POSIX_RTSIG_MAX	8
#define	_POSIX_SEM_NSEMS_MAX	256
#define	_POSIX_SEM_VALUE_MAX	32767
#define	_POSIX_SIGQUEUE_MAX	32
#define	_POSIX_TIMER_MAX	32

#define	_POSIX_CLOCKRES_MIN	20000000
#endif
# 100 "/usr/include/limits.h" 3 4

#if __POSIX_VISIBLE >= 199506
#define	_POSIX_THREAD_DESTRUCTOR_ITERATIONS 4
#define	_POSIX_THREAD_KEYS_MAX	128
#define	_POSIX_THREAD_THREADS_MAX 64
#endif
# 106 "/usr/include/limits.h" 3 4

#if __POSIX_VISIBLE >= 200112
#define	_POSIX_HOST_NAME_MAX	255
#define	_POSIX_LOGIN_NAME_MAX	9
#define	_POSIX_SS_REPL_MAX	4
#define	_POSIX_SYMLINK_MAX	255
#define	_POSIX_SYMLOOP_MAX	8
#define	_POSIX_TRACE_EVENT_NAME_MAX 30
#define	_POSIX_TRACE_NAME_MAX	8
#define	_POSIX_TRACE_SYS_MAX	8
#define	_POSIX_TRACE_USER_EVENT_MAX 32
#define	_POSIX_TTY_NAME_MAX	9

#define	_POSIX_RE_DUP_MAX	_POSIX2_RE_DUP_MAX
#endif
# 121 "/usr/include/limits.h" 3 4

#if __XSI_VISIBLE || __POSIX_VISIBLE >= 200809
#define	NL_ARGMAX		99	/* max # of position args for printf */
#define	NL_MSGMAX		32767
#define	NL_SETMAX		255
#define	NL_TEXTMAX		2048
#endif
# 128 "/usr/include/limits.h" 3 4

#if __XSI_VISIBLE
#define	_XOPEN_IOV_MAX		16
#define	_XOPEN_NAME_MAX		255
#define	_XOPEN_PATH_MAX		1024
#define	PASS_MAX		128	/* _PASSWORD_LEN from <pwd.h> */

#define	NL_LANGMAX		31	/* max LANG name length */
#define	NL_NMAX			1
#endif
# 138 "/usr/include/limits.h" 3 4

#define	MB_LEN_MAX		6	/* 31-bit UTF-8 */

#if 0 /* expanded by -frewrite-includes */
#include <sys/limits.h>
#endif /* expanded by -frewrite-includes */
# 141 "/usr/include/limits.h" 3 4
# 1 "/usr/include/sys/limits.h" 1 3 4
/*-
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/sys/sys/limits.h 219271 2011-03-04 19:28:27Z jilles $
 */

#ifndef _SYS_LIMITS_H_
#define	_SYS_LIMITS_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 35 "/usr/include/sys/limits.h" 3 4
# 36 "/usr/include/sys/limits.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <machine/_limits.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/sys/limits.h" 3 4
# 1 "/usr/include/machine/_limits.h" 1 3 4
/*-
 * This file is in the public domain.
 */
/* $FreeBSD: releng/11.0/sys/amd64/include/_limits.h 232262 2012-02-28 18:24:28Z tijl $ */

#if 0 /* expanded by -frewrite-includes */
#include <x86/_limits.h>
#endif /* expanded by -frewrite-includes */
# 6 "/usr/include/machine/_limits.h" 3 4
# 7 "/usr/include/machine/_limits.h" 3 4
# 37 "/usr/include/sys/limits.h" 2 3 4

#define	CHAR_BIT	__CHAR_BIT	/* number of bits in a char */

#define	SCHAR_MAX	__SCHAR_MAX	/* max value for a signed char */
#define	SCHAR_MIN	__SCHAR_MIN	/* min value for a signed char */

#define	UCHAR_MAX	__UCHAR_MAX	/* max value for an unsigned char */

#ifdef __CHAR_UNSIGNED__
#define	CHAR_MAX	UCHAR_MAX	/* max value for a char */
#define	CHAR_MIN	0		/* min value for a char */
#else
# 49 "/usr/include/sys/limits.h" 3 4
#define	CHAR_MAX	SCHAR_MAX
#define	CHAR_MIN	SCHAR_MIN
#endif
# 52 "/usr/include/sys/limits.h" 3 4

#define	USHRT_MAX	__USHRT_MAX	/* max value for an unsigned short */
#define	SHRT_MAX	__SHRT_MAX	/* max value for a short */
#define	SHRT_MIN	__SHRT_MIN	/* min value for a short */

#define	UINT_MAX	__UINT_MAX	/* max value for an unsigned int */
#define	INT_MAX		__INT_MAX	/* max value for an int */
#define	INT_MIN		__INT_MIN	/* min value for an int */

#define	ULONG_MAX	__ULONG_MAX	/* max for an unsigned long */
#define	LONG_MAX	__LONG_MAX	/* max for a long */
#define	LONG_MIN	__LONG_MIN	/* min for a long */

#ifdef __LONG_LONG_SUPPORTED
#define	ULLONG_MAX	__ULLONG_MAX	/* max for an unsigned long long */
#define	LLONG_MAX	__LLONG_MAX	/* max for a long long */
#define	LLONG_MIN	__LLONG_MIN	/* min for a long long */
#endif
# 70 "/usr/include/sys/limits.h" 3 4

#if __POSIX_VISIBLE || __XSI_VISIBLE
#define	SSIZE_MAX	__SSIZE_MAX	/* max value for an ssize_t */
#endif
# 74 "/usr/include/sys/limits.h" 3 4

#if __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE
#define	SIZE_T_MAX	__SIZE_T_MAX	/* max value for a size_t */

#define	OFF_MAX		__OFF_MAX	/* max value for an off_t */
#define	OFF_MIN		__OFF_MIN	/* min value for an off_t */
#endif
# 81 "/usr/include/sys/limits.h" 3 4

#if __BSD_VISIBLE
#define	GID_MAX		UINT_MAX	/* max value for a gid_t */
#define	UID_MAX		UINT_MAX	/* max value for a uid_t */

#define	UQUAD_MAX	(__UQUAD_MAX)	/* max value for a uquad_t */
#define	QUAD_MAX	(__QUAD_MAX)	/* max value for a quad_t */
#define	QUAD_MIN	(__QUAD_MIN)	/* min value for a quad_t */
#endif
# 90 "/usr/include/sys/limits.h" 3 4

#if __XSI_VISIBLE || __POSIX_VISIBLE >= 200809
#define	LONG_BIT	__LONG_BIT
#define	WORD_BIT	__WORD_BIT
#endif
# 95 "/usr/include/sys/limits.h" 3 4

#if __POSIX_VISIBLE
#define	MQ_PRIO_MAX	64
#endif
# 99 "/usr/include/sys/limits.h" 3 4

#endif /* !_SYS_LIMITS_H_ */
# 101 "/usr/include/sys/limits.h" 3 4
# 142 "/usr/include/limits.h" 2 3 4

#if __POSIX_VISIBLE
#if 0 /* expanded by -frewrite-includes */
#include <sys/syslimits.h>
#endif /* expanded by -frewrite-includes */
# 144 "/usr/include/limits.h" 3 4
# 1 "/usr/include/sys/syslimits.h" 1 3 4
/*-
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)syslimits.h	8.1 (Berkeley) 6/2/93
 * $FreeBSD: releng/11.0/sys/sys/syslimits.h 194498 2009-06-19 17:10:35Z brooks $
 */

#ifndef _SYS_SYSLIMITS_H_
#define _SYS_SYSLIMITS_H_

#if !defined(_KERNEL) && !defined(_LIMITS_H_) && !defined(_SYS_PARAM_H_)
#ifndef _SYS_CDEFS_H_
#error this file needs sys/cdefs.h as a prerequisite
#endif
# 40 "/usr/include/sys/syslimits.h" 3 4
#ifdef __CC_SUPPORTS_WARNING
#warning "No user-serviceable parts inside."
#endif
# 43 "/usr/include/sys/syslimits.h" 3 4
#endif
# 44 "/usr/include/sys/syslimits.h" 3 4

/*
 * Do not add any new variables here.  (See the comment at the end of
 * the file for why.)
 */
#define	ARG_MAX			262144	/* max bytes for an exec function */
#ifndef CHILD_MAX
#define	CHILD_MAX		   40	/* max simultaneous processes */
#endif
# 53 "/usr/include/sys/syslimits.h" 3 4
#define	LINK_MAX		32767	/* max file link count */
#define	MAX_CANON		  255	/* max bytes in term canon input line */
#define	MAX_INPUT		  255	/* max bytes in terminal input */
#define	NAME_MAX		  255	/* max bytes in a file name */
#ifndef NGROUPS_MAX
#define	NGROUPS_MAX	 	 1023	/* max supplemental group id's */
#endif
# 60 "/usr/include/sys/syslimits.h" 3 4
#ifndef OPEN_MAX
#define	OPEN_MAX		   64	/* max open files per process */
#endif
# 63 "/usr/include/sys/syslimits.h" 3 4
#define	PATH_MAX		 1024	/* max bytes in pathname */
#define	PIPE_BUF		  512	/* max bytes for atomic pipe writes */
#define	IOV_MAX			 1024	/* max elements in i/o vector */

/*
 * We leave the following values undefined to force applications to either
 * assume conservative values or call sysconf() to get the current value.
 *
 * HOST_NAME_MAX
 *
 * (We should do this for most of the values currently defined here,
 * but many programs are not prepared to deal with this yet.)
 */
#endif
# 77 "/usr/include/sys/syslimits.h" 3 4
# 145 "/usr/include/limits.h" 2 3 4
#endif
# 146 "/usr/include/limits.h" 3 4

#endif /* !_LIMITS_H_ */
# 148 "/usr/include/limits.h" 3 4
# 142 "include/platform.h" 2
#if defined(__digital__) && defined(__unix__)
#if 0 /* expanded by -frewrite-includes */
# include <sex.h>
#endif /* expanded by -frewrite-includes */
# 143 "include/platform.h"
# 144 "include/platform.h"
#elif defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__) \
   || defined(__APPLE__)
# 146 "include/platform.h"
#if 0 /* expanded by -frewrite-includes */
# include <sys/resource.h>  /* rlimit */
#endif /* expanded by -frewrite-includes */
# 146 "include/platform.h"
# 1 "/usr/include/sys/resource.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)resource.h	8.4 (Berkeley) 1/9/95
 * $FreeBSD: releng/11.0/sys/sys/resource.h 301110 2016-06-01 07:45:03Z ed $
 */

#ifndef _SYS_RESOURCE_H_
#define	_SYS_RESOURCE_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/sys/resource.h" 3 4
# 37 "/usr/include/sys/resource.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_timeval.h>
#endif /* expanded by -frewrite-includes */
# 37 "/usr/include/sys/resource.h" 3 4
# 1 "/usr/include/sys/_timeval.h" 1 3 4
/*-
 * Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/sys/sys/_timeval.h 158471 2006-05-12 05:04:46Z jhb $
 */

#ifndef _SYS__TIMEVAL_H_
#define _SYS__TIMEVAL_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 32 "/usr/include/sys/_timeval.h" 3 4
# 33 "/usr/include/sys/_timeval.h" 3 4

#ifndef _SUSECONDS_T_DECLARED
typedef	__suseconds_t	suseconds_t;
#define	_SUSECONDS_T_DECLARED
#endif
# 38 "/usr/include/sys/_timeval.h" 3 4

#ifndef _TIME_T_DECLARED
typedef	__time_t	time_t;
#define	_TIME_T_DECLARED
#endif
# 43 "/usr/include/sys/_timeval.h" 3 4

/*
 * Structure returned by gettimeofday(2) system call, and used in other calls.
 */
struct timeval {
	time_t		tv_sec;		/* seconds */
	suseconds_t	tv_usec;	/* and microseconds */
};

#endif /* !_SYS__TIMEVAL_H_ */
# 53 "/usr/include/sys/_timeval.h" 3 4
# 38 "/usr/include/sys/resource.h" 2 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 38 "/usr/include/sys/resource.h" 3 4
# 39 "/usr/include/sys/resource.h" 3 4

#ifndef _ID_T_DECLARED
typedef	__id_t		id_t;
#define	_ID_T_DECLARED
#endif
# 44 "/usr/include/sys/resource.h" 3 4

#ifndef _RLIM_T_DECLARED
typedef	__rlim_t	rlim_t;
#define	_RLIM_T_DECLARED
#endif
# 49 "/usr/include/sys/resource.h" 3 4

/*
 * Process priority specifications to get/setpriority.
 */
#define	PRIO_MIN	-20
#define	PRIO_MAX	20

#define	PRIO_PROCESS	0
#define	PRIO_PGRP	1
#define	PRIO_USER	2

/*
 * Resource utilization information.
 *
 * All fields are only modified by curthread and
 * no locks are required to read.
 */

#define	RUSAGE_SELF	0
#define	RUSAGE_CHILDREN	-1
#define	RUSAGE_THREAD	1

struct rusage {
	struct timeval ru_utime;	/* user time used */
	struct timeval ru_stime;	/* system time used */
	long	ru_maxrss;		/* max resident set size */
#define	ru_first	ru_ixrss
	long	ru_ixrss;		/* integral shared memory size */
	long	ru_idrss;		/* integral unshared data " */
	long	ru_isrss;		/* integral unshared stack " */
	long	ru_minflt;		/* page reclaims */
	long	ru_majflt;		/* page faults */
	long	ru_nswap;		/* swaps */
	long	ru_inblock;		/* block input operations */
	long	ru_oublock;		/* block output operations */
	long	ru_msgsnd;		/* messages sent */
	long	ru_msgrcv;		/* messages received */
	long	ru_nsignals;		/* signals received */
	long	ru_nvcsw;		/* voluntary context switches */
	long	ru_nivcsw;		/* involuntary " */
#define	ru_last		ru_nivcsw
};

#if __BSD_VISIBLE
struct __wrusage {
	struct rusage	wru_self;
	struct rusage	wru_children;
};
#endif
# 98 "/usr/include/sys/resource.h" 3 4

/*
 * Resource limits
 */
#define	RLIMIT_CPU	0		/* maximum cpu time in seconds */
#define	RLIMIT_FSIZE	1		/* maximum file size */
#define	RLIMIT_DATA	2		/* data size */
#define	RLIMIT_STACK	3		/* stack size */
#define	RLIMIT_CORE	4		/* core file size */
#define	RLIMIT_RSS	5		/* resident set size */
#define	RLIMIT_MEMLOCK	6		/* locked-in-memory address space */
#define	RLIMIT_NPROC	7		/* number of processes */
#define	RLIMIT_NOFILE	8		/* number of open files */
#define	RLIMIT_SBSIZE	9		/* maximum size of all socket buffers */
#define	RLIMIT_VMEM	10		/* virtual process size (incl. mmap) */
#define	RLIMIT_AS	RLIMIT_VMEM	/* standard name for RLIMIT_VMEM */
#define	RLIMIT_NPTS	11		/* pseudo-terminals */
#define	RLIMIT_SWAP	12		/* swap used */
#define	RLIMIT_KQUEUES	13		/* kqueues allocated */
#define	RLIMIT_UMTXP	14		/* process-shared umtx */

#define	RLIM_NLIMITS	15		/* number of resource limits */

#define	RLIM_INFINITY	((rlim_t)(((__uint64_t)1 << 63) - 1))
/* XXX Missing: RLIM_SAVED_MAX, RLIM_SAVED_CUR */


/*
 * Resource limit string identifiers
 */

#ifdef _RLIMIT_IDENT
static const char *rlimit_ident[RLIM_NLIMITS] = {
	"cpu",
	"fsize",
	"data",
	"stack",
	"core",
	"rss",
	"memlock",
	"nproc",
	"nofile",
	"sbsize",
	"vmem",
	"npts",
	"swap",
	"kqueues",
	"umtx",
};
#endif
# 148 "/usr/include/sys/resource.h" 3 4

struct rlimit {
	rlim_t	rlim_cur;		/* current (soft) limit */
	rlim_t	rlim_max;		/* maximum value for rlim_cur */
};

#if __BSD_VISIBLE

struct orlimit {
	__int32_t	rlim_cur;	/* current (soft) limit */
	__int32_t	rlim_max;	/* maximum value for rlim_cur */
};

struct loadavg {
	__fixpt_t	ldavg[3];
	long		fscale;
};

#define	CP_USER		0
#define	CP_NICE		1
#define	CP_SYS		2
#define	CP_INTR		3
#define	CP_IDLE		4
#define	CPUSTATES	5

#endif	/* __BSD_VISIBLE */
# 174 "/usr/include/sys/resource.h" 3 4

#ifdef _KERNEL

extern struct loadavg averunnable;
void	read_cpu_time(long *cp_time);	/* Writes array of CPUSTATES */

#else
# 181 "/usr/include/sys/resource.h" 3 4

__BEGIN_DECLS
/* XXX 2nd arg to [gs]etpriority() should be an id_t */
int	getpriority(int, int);
int	getrlimit(int, struct rlimit *);
int	getrusage(int, struct rusage *);
int	setpriority(int, int, int);
int	setrlimit(int, const struct rlimit *);
__END_DECLS

#endif	/* _KERNEL */
# 192 "/usr/include/sys/resource.h" 3 4
#endif	/* !_SYS_RESOURCE_H_ */
# 193 "/usr/include/sys/resource.h" 3 4
# 147 "include/platform.h" 2
#if 0 /* expanded by -frewrite-includes */
# include <machine/endian.h>
#endif /* expanded by -frewrite-includes */
# 147 "include/platform.h"
# 1 "/usr/include/machine/endian.h" 1 3 4
/*-
 * This file is in the public domain.
 */
/* $FreeBSD: releng/11.0/sys/amd64/include/endian.h 232266 2012-02-28 19:39:54Z tijl $ */

#if 0 /* expanded by -frewrite-includes */
#include <x86/endian.h>
#endif /* expanded by -frewrite-includes */
# 6 "/usr/include/machine/endian.h" 3 4
# 1 "/usr/include/x86/endian.h" 1 3 4
/*-
 * Copyright (c) 1987, 1991 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)endian.h	7.8 (Berkeley) 4/3/91
 * $FreeBSD: releng/11.0/sys/x86/include/endian.h 233684 2012-03-29 23:31:48Z dim $
 */

#ifndef _MACHINE_ENDIAN_H_
#define	_MACHINE_ENDIAN_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/x86/endian.h" 3 4
# 37 "/usr/include/x86/endian.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 37 "/usr/include/x86/endian.h" 3 4
# 38 "/usr/include/x86/endian.h" 3 4

/*
 * Define the order of 32-bit words in 64-bit words.
 */
#define	_QUAD_HIGHWORD 1
#define	_QUAD_LOWWORD 0

/*
 * Definitions for byte order, according to byte significance from low
 * address to high.
 */
#define	_LITTLE_ENDIAN	1234	/* LSB first: i386, vax */
#define	_BIG_ENDIAN	4321	/* MSB first: 68000, ibm, net */
#define	_PDP_ENDIAN	3412	/* LSB first in word, MSW first in long */

#define	_BYTE_ORDER	_LITTLE_ENDIAN

/*
 * Deprecated variants that don't have enough underscores to be useful in more
 * strict namespaces.
 */
#if __BSD_VISIBLE
#define	LITTLE_ENDIAN	_LITTLE_ENDIAN
#define	BIG_ENDIAN	_BIG_ENDIAN
#define	PDP_ENDIAN	_PDP_ENDIAN
#define	BYTE_ORDER	_BYTE_ORDER
#endif
# 65 "/usr/include/x86/endian.h" 3 4

#define	__bswap16_gen(x)	(__uint16_t)((x) << 8 | (x) >> 8)
#define	__bswap32_gen(x)		\
	(((__uint32_t)__bswap16((x) & 0xffff) << 16) | __bswap16((x) >> 16))
#define	__bswap64_gen(x)		\
	(((__uint64_t)__bswap32((x) & 0xffffffff) << 32) | __bswap32((x) >> 32))

#ifdef __GNUCLIKE_BUILTIN_CONSTANT_P
#define	__bswap16(x)				\
	((__uint16_t)(__builtin_constant_p(x) ?	\
	    __bswap16_gen((__uint16_t)(x)) : __bswap16_var(x)))
#define	__bswap32(x)			\
	(__builtin_constant_p(x) ?	\
	    __bswap32_gen((__uint32_t)(x)) : __bswap32_var(x))
#define	__bswap64(x)			\
	(__builtin_constant_p(x) ?	\
	    __bswap64_gen((__uint64_t)(x)) : __bswap64_var(x))
#else
# 83 "/usr/include/x86/endian.h" 3 4
/* XXX these are broken for use in static initializers. */
#define	__bswap16(x)	__bswap16_var(x)
#define	__bswap32(x)	__bswap32_var(x)
#define	__bswap64(x)	__bswap64_var(x)
#endif
# 88 "/usr/include/x86/endian.h" 3 4

/* These are defined as functions to avoid multiple evaluation of x. */

static __inline __uint16_t
__bswap16_var(__uint16_t _x)
{

	return (__bswap16_gen(_x));
}

static __inline __uint32_t
__bswap32_var(__uint32_t _x)
{

#ifdef __GNUCLIKE_ASM
	__asm("bswap %0" : "+r" (_x));
	return (_x);
#else
# 106 "/usr/include/x86/endian.h" 3 4
	return (__bswap32_gen(_x));
#endif
# 108 "/usr/include/x86/endian.h" 3 4
}

static __inline __uint64_t
__bswap64_var(__uint64_t _x)
{

#if defined(__amd64__) && defined(__GNUCLIKE_ASM)
	__asm("bswap %0" : "+r" (_x));
	return (_x);
#else
# 118 "/usr/include/x86/endian.h" 3 4
	/*
	 * It is important for the optimizations that the following is not
	 * really generic, but expands to 2 __bswap32_var()'s.
	 */
	return (__bswap64_gen(_x));
#endif
# 124 "/usr/include/x86/endian.h" 3 4
}

#define	__htonl(x)	__bswap32(x)
#define	__htons(x)	__bswap16(x)
#define	__ntohl(x)	__bswap32(x)
#define	__ntohs(x)	__bswap16(x)

#endif /* !_MACHINE_ENDIAN_H_ */
# 132 "/usr/include/x86/endian.h" 3 4
# 7 "/usr/include/machine/endian.h" 2 3 4
# 148 "include/platform.h" 2
# define bswap_64 __bswap64
# define bswap_32 __bswap32
# define bswap_16 __bswap16
#else
# 152 "include/platform.h"
#if 0 /* expanded by -frewrite-includes */
# include <byteswap.h>
#endif /* expanded by -frewrite-includes */
# 152 "include/platform.h"
# 153 "include/platform.h"
#if 0 /* expanded by -frewrite-includes */
# include <endian.h>
#endif /* expanded by -frewrite-includes */
# 153 "include/platform.h"
# 154 "include/platform.h"
#endif
# 155 "include/platform.h"

#if defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN
# define BB_BIG_ENDIAN 1
# define BB_LITTLE_ENDIAN 0
#elif defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN
# 160 "include/platform.h"
# define BB_BIG_ENDIAN 0
# define BB_LITTLE_ENDIAN 1
#elif defined(_BYTE_ORDER) && _BYTE_ORDER == _BIG_ENDIAN
# 163 "include/platform.h"
# define BB_BIG_ENDIAN 1
# define BB_LITTLE_ENDIAN 0
#elif defined(_BYTE_ORDER) && _BYTE_ORDER == _LITTLE_ENDIAN
# 166 "include/platform.h"
# define BB_BIG_ENDIAN 0
# define BB_LITTLE_ENDIAN 1
#elif defined(BYTE_ORDER) && BYTE_ORDER == BIG_ENDIAN
# 169 "include/platform.h"
# define BB_BIG_ENDIAN 1
# define BB_LITTLE_ENDIAN 0
#elif defined(BYTE_ORDER) && BYTE_ORDER == LITTLE_ENDIAN
# 172 "include/platform.h"
# define BB_BIG_ENDIAN 0
# define BB_LITTLE_ENDIAN 1
#elif defined(__386__)
# 175 "include/platform.h"
# define BB_BIG_ENDIAN 0
# define BB_LITTLE_ENDIAN 1
#else
# 178 "include/platform.h"
# error "Can't determine endianness"
#endif
# 180 "include/platform.h"

#if ULONG_MAX > 0xffffffff
# define bb_bswap_64(x) bswap_64(x)
#endif
# 184 "include/platform.h"

/* SWAP_LEnn means "convert CPU<->little_endian by swapping bytes" */
#if BB_BIG_ENDIAN
# define SWAP_BE16(x) (x)
# define SWAP_BE32(x) (x)
# define SWAP_BE64(x) (x)
# define SWAP_LE16(x) bswap_16(x)
# define SWAP_LE32(x) bswap_32(x)
# define SWAP_LE64(x) bb_bswap_64(x)
# define IF_BIG_ENDIAN(...) __VA_ARGS__
# define IF_LITTLE_ENDIAN(...)
#else
# 196 "include/platform.h"
# define SWAP_BE16(x) bswap_16(x)
# define SWAP_BE32(x) bswap_32(x)
# define SWAP_BE64(x) bb_bswap_64(x)
# define SWAP_LE16(x) (x)
# define SWAP_LE32(x) (x)
# define SWAP_LE64(x) (x)
# define IF_BIG_ENDIAN(...)
# define IF_LITTLE_ENDIAN(...) __VA_ARGS__
#endif
# 205 "include/platform.h"


/* ---- Unaligned access ------------------------------------ */

#if 0 /* expanded by -frewrite-includes */
#include <stdint.h>
#endif /* expanded by -frewrite-includes */
# 209 "include/platform.h"
# 1 "/usr/include/stdint.h" 1 3 4
/*-
 * Copyright (c) 2001 Mike Barcroft <mike@FreeBSD.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/sys/sys/stdint.h 290492 2015-11-07 12:30:43Z kib $
 */

#ifndef _SYS_STDINT_H_
#define _SYS_STDINT_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 32 "/usr/include/stdint.h" 3 4
# 33 "/usr/include/stdint.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 33 "/usr/include/stdint.h" 3 4
# 34 "/usr/include/stdint.h" 3 4

#if 0 /* expanded by -frewrite-includes */
#include <machine/_stdint.h>
#endif /* expanded by -frewrite-includes */
# 35 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/machine/_stdint.h" 1 3 4
/*-
 * This file is in the public domain.
 */
/* $FreeBSD: releng/11.0/sys/amd64/include/_stdint.h 232264 2012-02-28 18:38:33Z tijl $ */

#if 0 /* expanded by -frewrite-includes */
#include <x86/_stdint.h>
#endif /* expanded by -frewrite-includes */
# 6 "/usr/include/machine/_stdint.h" 3 4
# 1 "/usr/include/x86/_stdint.h" 1 3 4
/*-
 * Copyright (c) 2001, 2002 Mike Barcroft <mike@FreeBSD.org>
 * Copyright (c) 2001 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Klaus Klein.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/sys/x86/include/_stdint.h 301030 2016-05-31 08:38:24Z ed $
 */

#ifndef _MACHINE__STDINT_H_
#define	_MACHINE__STDINT_H_

#if 0 /* expanded by -frewrite-includes */
#include <machine/_limits.h>
#endif /* expanded by -frewrite-includes */
# 43 "/usr/include/x86/_stdint.h" 3 4
# 1 "/usr/include/machine/_limits.h" 1 3 4
/*-
 * This file is in the public domain.
 */
/* $FreeBSD: releng/11.0/sys/amd64/include/_limits.h 232262 2012-02-28 18:24:28Z tijl $ */

#if 0 /* expanded by -frewrite-includes */
#include <x86/_limits.h>
#endif /* expanded by -frewrite-includes */
# 6 "/usr/include/machine/_limits.h" 3 4
# 7 "/usr/include/machine/_limits.h" 3 4
# 44 "/usr/include/x86/_stdint.h" 2 3 4

#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)

#define	INT8_C(c)		(c)
#define	INT16_C(c)		(c)
#define	INT32_C(c)		(c)

#define	UINT8_C(c)		(c)
#define	UINT16_C(c)		(c)
#define	UINT32_C(c)		(c ## U)

#ifdef	__LP64__
#define	INT64_C(c)		(c ## L)
#define	UINT64_C(c)		(c ## UL)
#else
# 59 "/usr/include/x86/_stdint.h" 3 4
#define	INT64_C(c)		(c ## LL)
#define	UINT64_C(c)		(c ## ULL)
#endif
# 62 "/usr/include/x86/_stdint.h" 3 4

#define	INTMAX_C(c)		INT64_C(c)
#define	UINTMAX_C(c)		UINT64_C(c)

#endif /* !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS) */
# 67 "/usr/include/x86/_stdint.h" 3 4

#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)

/*
 * ISO/IEC 9899:1999
 * 7.18.2.1 Limits of exact-width integer types
 */
#define	INT8_MIN	(-0x7f-1)
#define	INT16_MIN	(-0x7fff-1)
#define	INT32_MIN	(-0x7fffffff-1)

#define	INT8_MAX	0x7f
#define	INT16_MAX	0x7fff
#define	INT32_MAX	0x7fffffff

#define	UINT8_MAX	0xff
#define	UINT16_MAX	0xffff
#define	UINT32_MAX	0xffffffffU

#ifdef __LP64__
#define	INT64_MIN	(-0x7fffffffffffffff-1)
#define	INT64_MAX	0x7fffffffffffffff
#define	UINT64_MAX	0xffffffffffffffff
#else
# 91 "/usr/include/x86/_stdint.h" 3 4
#define	INT64_MIN	(-0x7fffffffffffffffLL-1)
#define	INT64_MAX	0x7fffffffffffffffLL
#define	UINT64_MAX	0xffffffffffffffffULL
#endif
# 95 "/usr/include/x86/_stdint.h" 3 4

/*
 * ISO/IEC 9899:1999
 * 7.18.2.2  Limits of minimum-width integer types
 */
/* Minimum values of minimum-width signed integer types. */
#define	INT_LEAST8_MIN	INT8_MIN
#define	INT_LEAST16_MIN	INT16_MIN
#define	INT_LEAST32_MIN	INT32_MIN
#define	INT_LEAST64_MIN	INT64_MIN

/* Maximum values of minimum-width signed integer types. */
#define	INT_LEAST8_MAX	INT8_MAX
#define	INT_LEAST16_MAX	INT16_MAX
#define	INT_LEAST32_MAX	INT32_MAX
#define	INT_LEAST64_MAX	INT64_MAX

/* Maximum values of minimum-width unsigned integer types. */
#define	UINT_LEAST8_MAX	 UINT8_MAX
#define	UINT_LEAST16_MAX UINT16_MAX
#define	UINT_LEAST32_MAX UINT32_MAX
#define	UINT_LEAST64_MAX UINT64_MAX

/*
 * ISO/IEC 9899:1999
 * 7.18.2.3  Limits of fastest minimum-width integer types
 */
/* Minimum values of fastest minimum-width signed integer types. */
#define	INT_FAST8_MIN	INT32_MIN
#define	INT_FAST16_MIN	INT32_MIN
#define	INT_FAST32_MIN	INT32_MIN
#define	INT_FAST64_MIN	INT64_MIN

/* Maximum values of fastest minimum-width signed integer types. */
#define	INT_FAST8_MAX	INT32_MAX
#define	INT_FAST16_MAX	INT32_MAX
#define	INT_FAST32_MAX	INT32_MAX
#define	INT_FAST64_MAX	INT64_MAX

/* Maximum values of fastest minimum-width unsigned integer types. */
#define	UINT_FAST8_MAX	UINT32_MAX
#define	UINT_FAST16_MAX	UINT32_MAX
#define	UINT_FAST32_MAX	UINT32_MAX
#define	UINT_FAST64_MAX	UINT64_MAX

/*
 * ISO/IEC 9899:1999
 * 7.18.2.4  Limits of integer types capable of holding object pointers
 */
#ifdef	__LP64__
#define	INTPTR_MIN	INT64_MIN
#define	INTPTR_MAX	INT64_MAX
#define	UINTPTR_MAX	UINT64_MAX
#else
# 149 "/usr/include/x86/_stdint.h" 3 4
#define	INTPTR_MIN	INT32_MIN
#define	INTPTR_MAX	INT32_MAX
#define	UINTPTR_MAX	UINT32_MAX
#endif
# 153 "/usr/include/x86/_stdint.h" 3 4

/*
 * ISO/IEC 9899:1999
 * 7.18.2.5  Limits of greatest-width integer types
 */
#define	INTMAX_MIN	INT64_MIN
#define	INTMAX_MAX	INT64_MAX
#define	UINTMAX_MAX	UINT64_MAX

/*
 * ISO/IEC 9899:1999
 * 7.18.3  Limits of other integer types
 */
#ifdef	__LP64__
/* Limits of ptrdiff_t. */
#define	PTRDIFF_MIN	INT64_MIN	
#define	PTRDIFF_MAX	INT64_MAX

/* Limits of sig_atomic_t. */
#define	SIG_ATOMIC_MIN	__LONG_MIN
#define	SIG_ATOMIC_MAX	__LONG_MAX

/* Limit of size_t. */
#define	SIZE_MAX	UINT64_MAX
#else
# 178 "/usr/include/x86/_stdint.h" 3 4
#define	PTRDIFF_MIN	INT32_MIN
#define	PTRDIFF_MAX	INT32_MAX
#define	SIG_ATOMIC_MIN	INT32_MIN
#define	SIG_ATOMIC_MAX	INT32_MAX
#define	SIZE_MAX	UINT32_MAX
#endif
# 184 "/usr/include/x86/_stdint.h" 3 4

/* Limits of wint_t. */
#define	WINT_MIN	INT32_MIN
#define	WINT_MAX	INT32_MAX

#endif /* !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) */
# 190 "/usr/include/x86/_stdint.h" 3 4

#endif /* !_MACHINE__STDINT_H_ */
# 192 "/usr/include/x86/_stdint.h" 3 4
# 7 "/usr/include/machine/_stdint.h" 2 3 4
# 36 "/usr/include/stdint.h" 2 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_stdint.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/sys/_stdint.h" 1 3 4
/*-
 * Copyright (c) 2011 David E. O'Brien <obrien@FreeBSD.org>
 * Copyright (c) 2001 Mike Barcroft <mike@FreeBSD.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/sys/sys/_stdint.h 290492 2015-11-07 12:30:43Z kib $
 */

#ifndef _SYS__STDINT_H_
#define _SYS__STDINT_H_

#ifndef _INT8_T_DECLARED
typedef	__int8_t		int8_t;
#define	_INT8_T_DECLARED
#endif
# 37 "/usr/include/sys/_stdint.h" 3 4

#ifndef _INT16_T_DECLARED
typedef	__int16_t		int16_t;
#define	_INT16_T_DECLARED
#endif
# 42 "/usr/include/sys/_stdint.h" 3 4

#ifndef _INT32_T_DECLARED
typedef	__int32_t		int32_t;
#define	_INT32_T_DECLARED
#endif
# 47 "/usr/include/sys/_stdint.h" 3 4

#ifndef _INT64_T_DECLARED
typedef	__int64_t		int64_t;
#define	_INT64_T_DECLARED
#endif
# 52 "/usr/include/sys/_stdint.h" 3 4

#ifndef _UINT8_T_DECLARED
typedef	__uint8_t		uint8_t;
#define	_UINT8_T_DECLARED
#endif
# 57 "/usr/include/sys/_stdint.h" 3 4

#ifndef _UINT16_T_DECLARED
typedef	__uint16_t		uint16_t;
#define	_UINT16_T_DECLARED
#endif
# 62 "/usr/include/sys/_stdint.h" 3 4

#ifndef _UINT32_T_DECLARED
typedef	__uint32_t		uint32_t;
#define	_UINT32_T_DECLARED
#endif
# 67 "/usr/include/sys/_stdint.h" 3 4

#ifndef _UINT64_T_DECLARED
typedef	__uint64_t		uint64_t;
#define	_UINT64_T_DECLARED
#endif
# 72 "/usr/include/sys/_stdint.h" 3 4

#ifndef _INTPTR_T_DECLARED
typedef	__intptr_t		intptr_t;
#define	_INTPTR_T_DECLARED
#endif
# 77 "/usr/include/sys/_stdint.h" 3 4
#ifndef _UINTPTR_T_DECLARED
typedef	__uintptr_t		uintptr_t;
#define	_UINTPTR_T_DECLARED
#endif
# 81 "/usr/include/sys/_stdint.h" 3 4
#ifndef _INTMAX_T_DECLARED
typedef	__intmax_t		intmax_t;
#define	_INTMAX_T_DECLARED
#endif
# 85 "/usr/include/sys/_stdint.h" 3 4
#ifndef _UINTMAX_T_DECLARED
typedef	__uintmax_t		uintmax_t;
#define	_UINTMAX_T_DECLARED
#endif
# 89 "/usr/include/sys/_stdint.h" 3 4

#endif /* !_SYS__STDINT_H_ */
# 91 "/usr/include/sys/_stdint.h" 3 4
# 37 "/usr/include/stdint.h" 2 3 4

typedef	__int_least8_t		int_least8_t;
typedef	__int_least16_t		int_least16_t;
typedef	__int_least32_t		int_least32_t;
typedef	__int_least64_t		int_least64_t;

typedef	__uint_least8_t		uint_least8_t;
typedef	__uint_least16_t	uint_least16_t;
typedef	__uint_least32_t	uint_least32_t;
typedef	__uint_least64_t	uint_least64_t;

typedef	__int_fast8_t		int_fast8_t;
typedef	__int_fast16_t		int_fast16_t;
typedef	__int_fast32_t		int_fast32_t;
typedef	__int_fast64_t		int_fast64_t;

typedef	__uint_fast8_t		uint_fast8_t;
typedef	__uint_fast16_t		uint_fast16_t;
typedef	__uint_fast32_t		uint_fast32_t;
typedef	__uint_fast64_t		uint_fast64_t;

/* GNU and Darwin define this and people seem to think it's portable */
#if defined(UINTPTR_MAX) && defined(UINT64_MAX) && (UINTPTR_MAX == UINT64_MAX)
#define	__WORDSIZE		64
#else
# 62 "/usr/include/stdint.h" 3 4
#define	__WORDSIZE		32
#endif
# 64 "/usr/include/stdint.h" 3 4

/* Limits of wchar_t. */
#define	WCHAR_MIN	__WCHAR_MIN
#define	WCHAR_MAX	__WCHAR_MAX

#endif /* !_SYS_STDINT_H_ */
# 70 "/usr/include/stdint.h" 3 4
# 210 "include/platform.h" 2
typedef int      bb__aliased_int      FIX_ALIASING;
typedef long     bb__aliased_long     FIX_ALIASING;
typedef uint16_t bb__aliased_uint16_t FIX_ALIASING;
typedef uint32_t bb__aliased_uint32_t FIX_ALIASING;
typedef uint64_t bb__aliased_uint64_t FIX_ALIASING;

/* NB: unaligned parameter should be a pointer, aligned one -
 * a lvalue. This makes it more likely to not swap them by mistake
 */
#if defined(i386) || defined(__x86_64__) || defined(__powerpc__)
# define BB_UNALIGNED_MEMACCESS_OK 1
# define move_from_unaligned_int(v, intp)  ((v) = *(bb__aliased_int*)(intp))
# define move_from_unaligned_long(v, longp) ((v) = *(bb__aliased_long*)(longp))
# define move_from_unaligned16(v, u16p) ((v) = *(bb__aliased_uint16_t*)(u16p))
# define move_from_unaligned32(v, u32p) ((v) = *(bb__aliased_uint32_t*)(u32p))
# define move_to_unaligned16(u16p, v)   (*(bb__aliased_uint16_t*)(u16p) = (v))
# define move_to_unaligned32(u32p, v)   (*(bb__aliased_uint32_t*)(u32p) = (v))
/* #elif ... - add your favorite arch today! */
#else
# 229 "include/platform.h"
# define BB_UNALIGNED_MEMACCESS_OK 0
/* performs reasonably well (gcc usually inlines memcpy here) */
# define move_from_unaligned_int(v, intp) (memcpy(&(v), (intp), sizeof(int)))
# define move_from_unaligned_long(v, longp) (memcpy(&(v), (longp), sizeof(long)))
# define move_from_unaligned16(v, u16p) (memcpy(&(v), (u16p), 2))
# define move_from_unaligned32(v, u32p) (memcpy(&(v), (u32p), 4))
# define move_to_unaligned16(u16p, v) do { \
	uint16_t __t = (v); \
	memcpy((u16p), &__t, 2); \
} while (0)
# define move_to_unaligned32(u32p, v) do { \
	uint32_t __t = (v); \
	memcpy((u32p), &__t, 4); \
} while (0)
#endif
# 244 "include/platform.h"


/* ---- Size-saving "small" ints (arch-dependent) ----------- */

#if defined(i386) || defined(__x86_64__) || defined(__mips__) || defined(__cris__)
/* add other arches which benefit from this... */
typedef signed char smallint;
typedef unsigned char smalluint;
#else
# 253 "include/platform.h"
/* for arches where byte accesses generate larger code: */
typedef int smallint;
typedef unsigned smalluint;
#endif
# 257 "include/platform.h"

/* ISO C Standard:  7.16  Boolean type and values  <stdbool.h> */
#if (defined __digital__ && defined __unix__)
/* old system without (proper) C99 support */
# define bool smalluint
#else
# 263 "include/platform.h"
/* modern system, so use it */
#if 0 /* expanded by -frewrite-includes */
# include <stdbool.h>
#endif /* expanded by -frewrite-includes */
# 264 "include/platform.h"
# 1 "/usr/include/stdbool.h" 1 3 4
/*
 * Copyright (c) 2000 Jeroen Ruigrok van der Werven <asmodai@FreeBSD.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/include/stdbool.h 228878 2011-12-25 20:15:41Z ed $
 */

#ifndef __bool_true_false_are_defined
#define	__bool_true_false_are_defined	1

#ifndef __cplusplus

#define	false	0
#define	true	1

#define	bool	_Bool
#if __STDC_VERSION__ < 199901L && __GNUC__ < 3 && !defined(__INTEL_COMPILER)
typedef	int	_Bool;
#endif
# 41 "/usr/include/stdbool.h" 3 4

#endif /* !__cplusplus */
# 43 "/usr/include/stdbool.h" 3 4
#endif /* __bool_true_false_are_defined */
# 44 "/usr/include/stdbool.h" 3 4
# 265 "include/platform.h" 2
#endif
# 266 "include/platform.h"


/*----- Kernel versioning ------------------------------------*/

#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))

#ifdef __UCLIBC__
# define UCLIBC_VERSION KERNEL_VERSION(__UCLIBC_MAJOR__, __UCLIBC_MINOR__, __UCLIBC_SUBLEVEL__)
#else
# 275 "include/platform.h"
# define UCLIBC_VERSION 0
#endif
# 277 "include/platform.h"


/* ---- Miscellaneous --------------------------------------- */

#if defined __GLIBC__ \
 || defined __UCLIBC__ \
 || defined __dietlibc__ \
 || defined __BIONIC__ \
 || defined _NEWLIB_VERSION
#if 0 /* expanded by -frewrite-includes */
# include <features.h>
#endif /* expanded by -frewrite-includes */
# 286 "include/platform.h"
# 287 "include/platform.h"
#endif
# 288 "include/platform.h"

/* Define bb_setpgrp */
#if defined(__digital__) && defined(__unix__)
/* use legacy setpgrp(pid_t, pid_t) for now.  move to platform.c */
# define bb_setpgrp() do { pid_t __me = getpid(); setpgrp(__me, __me); } while (0)
#else
# 294 "include/platform.h"
# define bb_setpgrp() setpgrp()
#endif
# 296 "include/platform.h"

/* fdprintf is more readable, we used it before dprintf was standardized */
#if 0 /* expanded by -frewrite-includes */
#include <unistd.h>
#endif /* expanded by -frewrite-includes */
# 298 "include/platform.h"
# 1 "/usr/include/unistd.h" 1 3 4
/*-
 * Copyright (c) 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)unistd.h	8.12 (Berkeley) 4/27/95
 * $FreeBSD: releng/11.0/include/unistd.h 296162 2016-02-28 17:52:33Z kib $
 */

#ifndef _UNISTD_H_
#define	_UNISTD_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/unistd.h" 3 4
# 37 "/usr/include/unistd.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/types.h>			/* XXX adds too much pollution. */
#endif /* expanded by -frewrite-includes */
# 37 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/sys/types.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)types.h	8.6 (Berkeley) 2/19/95
 * $FreeBSD: releng/11.0/sys/sys/types.h 299571 2016-05-12 21:18:17Z cem $
 */

#ifndef _SYS_TYPES_H_
#define	_SYS_TYPES_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 41 "/usr/include/sys/types.h" 3 4
# 42 "/usr/include/sys/types.h" 3 4

/* Machine type dependent parameters. */
#if 0 /* expanded by -frewrite-includes */
#include <machine/endian.h>
#endif /* expanded by -frewrite-includes */
# 44 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/machine/endian.h" 1 3 4
/*-
 * This file is in the public domain.
 */
/* $FreeBSD: releng/11.0/sys/amd64/include/endian.h 232266 2012-02-28 19:39:54Z tijl $ */

#if 0 /* expanded by -frewrite-includes */
#include <x86/endian.h>
#endif /* expanded by -frewrite-includes */
# 6 "/usr/include/machine/endian.h" 3 4
# 7 "/usr/include/machine/endian.h" 3 4
# 45 "/usr/include/sys/types.h" 2 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 45 "/usr/include/sys/types.h" 3 4
# 46 "/usr/include/sys/types.h" 3 4

#if 0 /* expanded by -frewrite-includes */
#include <sys/_pthreadtypes.h>
#endif /* expanded by -frewrite-includes */
# 47 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/_pthreadtypes.h" 1 3 4
/*
 * Copyright (c) 1993, 1994 by Chris Provenzano, proven@mit.edu
 * Copyright (c) 1995-1998 by John Birrell <jb@cimlogic.com.au>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *  This product includes software developed by Chris Provenzano.
 * 4. The name of Chris Provenzano may not be used to endorse or promote 
 *	  products derived from this software without specific prior written
 *	  permission.
 *
 * THIS SOFTWARE IS PROVIDED BY CHRIS PROVENZANO ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL CHRIS PROVENZANO BE LIABLE FOR ANY 
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/sys/sys/_pthreadtypes.h 189828 2009-03-14 20:10:14Z das $
 */

#ifndef _SYS__PTHREADTYPES_H_
#define _SYS__PTHREADTYPES_H_

/*
 * Forward structure definitions.
 *
 * These are mostly opaque to the user.
 */
struct pthread;
struct pthread_attr;
struct pthread_cond;
struct pthread_cond_attr;
struct pthread_mutex;
struct pthread_mutex_attr;
struct pthread_once;
struct pthread_rwlock;
struct pthread_rwlockattr;
struct pthread_barrier;
struct pthread_barrier_attr;
struct pthread_spinlock;

/*
 * Primitive system data type definitions required by P1003.1c.
 *
 * Note that P1003.1c specifies that there are no defined comparison
 * or assignment operators for the types pthread_attr_t, pthread_cond_t,
 * pthread_condattr_t, pthread_mutex_t, pthread_mutexattr_t.
 */
#ifndef _PTHREAD_T_DECLARED
typedef struct	pthread			*pthread_t;
#define	_PTHREAD_T_DECLARED
#endif
# 68 "/usr/include/sys/_pthreadtypes.h" 3 4
typedef struct	pthread_attr		*pthread_attr_t;
typedef struct	pthread_mutex		*pthread_mutex_t;
typedef struct	pthread_mutex_attr	*pthread_mutexattr_t;
typedef struct	pthread_cond		*pthread_cond_t;
typedef struct	pthread_cond_attr	*pthread_condattr_t;
typedef int     			pthread_key_t;
typedef struct	pthread_once		pthread_once_t;
typedef struct	pthread_rwlock		*pthread_rwlock_t;
typedef struct	pthread_rwlockattr	*pthread_rwlockattr_t;
typedef struct	pthread_barrier		*pthread_barrier_t;
typedef struct	pthread_barrierattr	*pthread_barrierattr_t;
typedef struct	pthread_spinlock	*pthread_spinlock_t;

/*
 * Additional type definitions:
 *
 * Note that P1003.1c reserves the prefixes pthread_ and PTHREAD_ for
 * use in header symbols.
 */
typedef void	*pthread_addr_t;
typedef void	*(*pthread_startroutine_t)(void *);

/*
 * Once definitions.
 */
struct pthread_once {
	int		state;
	pthread_mutex_t	mutex;
};

#endif /* ! _SYS__PTHREADTYPES_H_ */
# 99 "/usr/include/sys/_pthreadtypes.h" 3 4
# 48 "/usr/include/sys/types.h" 2 3 4

#if __BSD_VISIBLE
typedef	unsigned char	u_char;
typedef	unsigned short	u_short;
typedef	unsigned int	u_int;
typedef	unsigned long	u_long;
#ifndef _KERNEL
typedef	unsigned short	ushort;		/* Sys V compatibility */
typedef	unsigned int	uint;		/* Sys V compatibility */
#endif
# 58 "/usr/include/sys/types.h" 3 4
#endif
# 59 "/usr/include/sys/types.h" 3 4

/*
 * XXX POSIX sized integrals that should appear only in <sys/stdint.h>.
 */
#if 0 /* expanded by -frewrite-includes */
#include <sys/_stdint.h>
#endif /* expanded by -frewrite-includes */
# 63 "/usr/include/sys/types.h" 3 4
# 64 "/usr/include/sys/types.h" 3 4

typedef __uint8_t	u_int8_t;	/* unsigned integrals (deprecated) */
typedef __uint16_t	u_int16_t;
typedef __uint32_t	u_int32_t;
typedef __uint64_t	u_int64_t;

typedef	__uint64_t	u_quad_t;	/* quads (deprecated) */
typedef	__int64_t	quad_t;
typedef	quad_t *	qaddr_t;

typedef	char *		caddr_t;	/* core address */
typedef	const char *	c_caddr_t;	/* core address, pointer to const */

#ifndef _BLKSIZE_T_DECLARED
typedef	__blksize_t	blksize_t;
#define	_BLKSIZE_T_DECLARED
#endif
# 81 "/usr/include/sys/types.h" 3 4

typedef	__cpuwhich_t	cpuwhich_t;
typedef	__cpulevel_t	cpulevel_t;
typedef	__cpusetid_t	cpusetid_t;

#ifndef _BLKCNT_T_DECLARED
typedef	__blkcnt_t	blkcnt_t;
#define	_BLKCNT_T_DECLARED
#endif
# 90 "/usr/include/sys/types.h" 3 4

#ifndef _CLOCK_T_DECLARED
typedef	__clock_t	clock_t;
#define	_CLOCK_T_DECLARED
#endif
# 95 "/usr/include/sys/types.h" 3 4

#ifndef _CLOCKID_T_DECLARED
typedef	__clockid_t	clockid_t;
#define	_CLOCKID_T_DECLARED
#endif
# 100 "/usr/include/sys/types.h" 3 4

typedef	__critical_t	critical_t;	/* Critical section value */
typedef	__int64_t	daddr_t;	/* disk address */

#ifndef _DEV_T_DECLARED
typedef	__dev_t		dev_t;		/* device number or struct cdev */
#define	_DEV_T_DECLARED
#endif
# 108 "/usr/include/sys/types.h" 3 4

#ifndef _FFLAGS_T_DECLARED
typedef	__fflags_t	fflags_t;	/* file flags */
#define	_FFLAGS_T_DECLARED
#endif
# 113 "/usr/include/sys/types.h" 3 4

typedef	__fixpt_t	fixpt_t;	/* fixed point number */

#ifndef _FSBLKCNT_T_DECLARED		/* for statvfs() */
typedef	__fsblkcnt_t	fsblkcnt_t;
typedef	__fsfilcnt_t	fsfilcnt_t;
#define	_FSBLKCNT_T_DECLARED
#endif
# 121 "/usr/include/sys/types.h" 3 4

#ifndef _GID_T_DECLARED
typedef	__gid_t		gid_t;		/* group id */
#define	_GID_T_DECLARED
#endif
# 126 "/usr/include/sys/types.h" 3 4

#ifndef _IN_ADDR_T_DECLARED
typedef	__uint32_t	in_addr_t;	/* base type for internet address */
#define	_IN_ADDR_T_DECLARED
#endif
# 131 "/usr/include/sys/types.h" 3 4

#ifndef _IN_PORT_T_DECLARED
typedef	__uint16_t	in_port_t;
#define	_IN_PORT_T_DECLARED
#endif
# 136 "/usr/include/sys/types.h" 3 4

#ifndef _ID_T_DECLARED
typedef	__id_t		id_t;		/* can hold a uid_t or pid_t */
#define	_ID_T_DECLARED
#endif
# 141 "/usr/include/sys/types.h" 3 4

#ifndef _INO_T_DECLARED
typedef	__ino_t		ino_t;		/* inode number */
#define	_INO_T_DECLARED
#endif
# 146 "/usr/include/sys/types.h" 3 4

#ifndef _KEY_T_DECLARED
typedef	__key_t		key_t;		/* IPC key (for Sys V IPC) */
#define	_KEY_T_DECLARED
#endif
# 151 "/usr/include/sys/types.h" 3 4

#ifndef _LWPID_T_DECLARED
typedef	__lwpid_t	lwpid_t;	/* Thread ID (a.k.a. LWP) */
#define	_LWPID_T_DECLARED
#endif
# 156 "/usr/include/sys/types.h" 3 4

#ifndef _MODE_T_DECLARED
typedef	__mode_t	mode_t;		/* permissions */
#define	_MODE_T_DECLARED
#endif
# 161 "/usr/include/sys/types.h" 3 4

#ifndef _ACCMODE_T_DECLARED
typedef	__accmode_t	accmode_t;	/* access permissions */
#define	_ACCMODE_T_DECLARED
#endif
# 166 "/usr/include/sys/types.h" 3 4

#ifndef _NLINK_T_DECLARED
typedef	__nlink_t	nlink_t;	/* link count */
#define	_NLINK_T_DECLARED
#endif
# 171 "/usr/include/sys/types.h" 3 4

#ifndef _OFF_T_DECLARED
typedef	__off_t		off_t;		/* file offset */
#define	_OFF_T_DECLARED
#endif
# 176 "/usr/include/sys/types.h" 3 4

#ifndef _OFF64_T_DECLARED
typedef	__off64_t	off64_t;	/* file offset (alias) */
#define	_OFF64_T_DECLARED
#endif
# 181 "/usr/include/sys/types.h" 3 4

#ifndef _PID_T_DECLARED
typedef	__pid_t		pid_t;		/* process id */
#define	_PID_T_DECLARED
#endif
# 186 "/usr/include/sys/types.h" 3 4

typedef	__register_t	register_t;

#ifndef _RLIM_T_DECLARED
typedef	__rlim_t	rlim_t;		/* resource limit */
#define	_RLIM_T_DECLARED
#endif
# 193 "/usr/include/sys/types.h" 3 4

typedef	__int64_t	sbintime_t;

typedef	__segsz_t	segsz_t;	/* segment size (in pages) */

#ifndef _SIZE_T_DECLARED
typedef	__size_t	size_t;
#define	_SIZE_T_DECLARED
#endif
# 202 "/usr/include/sys/types.h" 3 4

#ifndef _SSIZE_T_DECLARED
typedef	__ssize_t	ssize_t;
#define	_SSIZE_T_DECLARED
#endif
# 207 "/usr/include/sys/types.h" 3 4

#ifndef _SUSECONDS_T_DECLARED
typedef	__suseconds_t	suseconds_t;	/* microseconds (signed) */
#define	_SUSECONDS_T_DECLARED
#endif
# 212 "/usr/include/sys/types.h" 3 4

#ifndef _TIME_T_DECLARED
typedef	__time_t	time_t;
#define	_TIME_T_DECLARED
#endif
# 217 "/usr/include/sys/types.h" 3 4

#ifndef _TIMER_T_DECLARED
typedef	__timer_t	timer_t;
#define	_TIMER_T_DECLARED
#endif
# 222 "/usr/include/sys/types.h" 3 4

#ifndef _MQD_T_DECLARED
typedef	__mqd_t	mqd_t;
#define	_MQD_T_DECLARED
#endif
# 227 "/usr/include/sys/types.h" 3 4

typedef	__u_register_t	u_register_t;

#ifndef _UID_T_DECLARED
typedef	__uid_t		uid_t;		/* user id */
#define	_UID_T_DECLARED
#endif
# 234 "/usr/include/sys/types.h" 3 4

#ifndef _USECONDS_T_DECLARED
typedef	__useconds_t	useconds_t;	/* microseconds (unsigned) */
#define	_USECONDS_T_DECLARED
#endif
# 239 "/usr/include/sys/types.h" 3 4

#ifndef _CAP_IOCTL_T_DECLARED
#define	_CAP_IOCTL_T_DECLARED
typedef	unsigned long	cap_ioctl_t;
#endif
# 244 "/usr/include/sys/types.h" 3 4

#ifndef _CAP_RIGHTS_T_DECLARED
#define	_CAP_RIGHTS_T_DECLARED
struct cap_rights;

typedef	struct cap_rights	cap_rights_t;
#endif
# 251 "/usr/include/sys/types.h" 3 4

typedef	__vm_offset_t	vm_offset_t;
typedef	__vm_ooffset_t	vm_ooffset_t;
typedef	__vm_paddr_t	vm_paddr_t;
typedef	__vm_pindex_t	vm_pindex_t;
typedef	__vm_size_t	vm_size_t;

typedef __rman_res_t    rman_res_t;

#ifdef _KERNEL
typedef	int		boolean_t;
typedef	struct device	*device_t;
typedef	__intfptr_t	intfptr_t;

/*
 * XXX this is fixed width for historical reasons.  It should have had type
 * __int_fast32_t.  Fixed-width types should not be used unless binary
 * compatibility is essential.  Least-width types should be used even less
 * since they provide smaller benefits.
 *
 * XXX should be MD.
 *
 * XXX this is bogus in -current, but still used for spl*().
 */
typedef	__uint32_t	intrmask_t;	/* Interrupt mask (spl, xxx_imask...) */

typedef	__uintfptr_t	uintfptr_t;
typedef	__uint64_t	uoff_t;
typedef	char		vm_memattr_t;	/* memory attribute codes */
typedef	struct vm_page	*vm_page_t;

#if !defined(__bool_true_false_are_defined) && !defined(__cplusplus)
#define	__bool_true_false_are_defined	1
#define	false	0
#define	true	1
#if __STDC_VERSION__ < 199901L && __GNUC__ < 3 && !defined(__INTEL_COMPILER)
typedef	int	_Bool;
#endif
# 289 "/usr/include/sys/types.h" 3 4
typedef	_Bool	bool;
#endif /* !__bool_true_false_are_defined && !__cplusplus */
# 291 "/usr/include/sys/types.h" 3 4

#define offsetof(type, field) __offsetof(type, field)

#endif /* !_KERNEL */
# 295 "/usr/include/sys/types.h" 3 4

/*
 * The following are all things that really shouldn't exist in this header,
 * since its purpose is to provide typedefs, not miscellaneous doodads.
 */

#ifdef __POPCNT__
#define	__bitcount64(x)	__builtin_popcountll((__uint64_t)(x))
#define	__bitcount32(x)	__builtin_popcount((__uint32_t)(x))
#define	__bitcount16(x)	__builtin_popcount((__uint16_t)(x))
#define	__bitcountl(x)	__builtin_popcountl((unsigned long)(x))
#define	__bitcount(x)	__builtin_popcount((unsigned int)(x))
#else
# 308 "/usr/include/sys/types.h" 3 4
/*
 * Population count algorithm using SWAR approach
 * - "SIMD Within A Register".
 */
static __inline __uint16_t
__bitcount16(__uint16_t _x)
{

	_x = (_x & 0x5555) + ((_x & 0xaaaa) >> 1);
	_x = (_x & 0x3333) + ((_x & 0xcccc) >> 2);
	_x = (_x + (_x >> 4)) & 0x0f0f;
	_x = (_x + (_x >> 8)) & 0x00ff;
	return (_x);
}

static __inline __uint32_t
__bitcount32(__uint32_t _x)
{

	_x = (_x & 0x55555555) + ((_x & 0xaaaaaaaa) >> 1);
	_x = (_x & 0x33333333) + ((_x & 0xcccccccc) >> 2);
	_x = (_x + (_x >> 4)) & 0x0f0f0f0f;
	_x = (_x + (_x >> 8));
	_x = (_x + (_x >> 16)) & 0x000000ff;
	return (_x);
}

#ifdef __LP64__
static __inline __uint64_t
__bitcount64(__uint64_t _x)
{

	_x = (_x & 0x5555555555555555) + ((_x & 0xaaaaaaaaaaaaaaaa) >> 1);
	_x = (_x & 0x3333333333333333) + ((_x & 0xcccccccccccccccc) >> 2);
	_x = (_x + (_x >> 4)) & 0x0f0f0f0f0f0f0f0f;
	_x = (_x + (_x >> 8));
	_x = (_x + (_x >> 16));
	_x = (_x + (_x >> 32)) & 0x000000ff;
	return (_x);
}

#define	__bitcountl(x)	__bitcount64((unsigned long)(x))
#else
# 351 "/usr/include/sys/types.h" 3 4
static __inline __uint64_t
__bitcount64(__uint64_t _x)
{

	return (__bitcount32(_x >> 32) + __bitcount32(_x));
}

#define	__bitcountl(x)	__bitcount32((unsigned long)(x))
#endif
# 360 "/usr/include/sys/types.h" 3 4
#define	__bitcount(x)	__bitcount32((unsigned int)(x))
#endif
# 362 "/usr/include/sys/types.h" 3 4

#if __BSD_VISIBLE

#if 0 /* expanded by -frewrite-includes */
#include <sys/select.h>
#endif /* expanded by -frewrite-includes */
# 365 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/select.h" 1 3 4
/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/sys/sys/select.h 265051 2014-04-28 13:42:41Z emaste $
 */

#ifndef _SYS_SELECT_H_
#define	_SYS_SELECT_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 35 "/usr/include/sys/select.h" 3 4
# 36 "/usr/include/sys/select.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/sys/select.h" 3 4
# 37 "/usr/include/sys/select.h" 3 4

#if 0 /* expanded by -frewrite-includes */
#include <sys/_sigset.h>
#endif /* expanded by -frewrite-includes */
# 38 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/sys/_sigset.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)signal.h	8.4 (Berkeley) 5/4/95
 * $FreeBSD: releng/11.0/sys/sys/_sigset.h 139825 2005-01-07 02:29:27Z imp $
 */

#ifndef _SYS__SIGSET_H_
#define	_SYS__SIGSET_H_

/*
 * sigset_t macros.
 */
#define	_SIG_WORDS	4
#define	_SIG_MAXSIG	128
#define	_SIG_IDX(sig)	((sig) - 1)
#define	_SIG_WORD(sig)	(_SIG_IDX(sig) >> 5)
#define	_SIG_BIT(sig)	(1 << (_SIG_IDX(sig) & 31))
#define	_SIG_VALID(sig)	((sig) <= _SIG_MAXSIG && (sig) > 0)

typedef struct __sigset {
	__uint32_t __bits[_SIG_WORDS];
} __sigset_t;

#if defined(_KERNEL) && defined(COMPAT_43)
typedef unsigned int osigset_t;
#endif
# 58 "/usr/include/sys/_sigset.h" 3 4

#endif /* !_SYS__SIGSET_H_ */
# 60 "/usr/include/sys/_sigset.h" 3 4
# 39 "/usr/include/sys/select.h" 2 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_timeval.h>
#endif /* expanded by -frewrite-includes */
# 39 "/usr/include/sys/select.h" 3 4
# 40 "/usr/include/sys/select.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/timespec.h>
#endif /* expanded by -frewrite-includes */
# 40 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/sys/timespec.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.5 (Berkeley) 5/4/95
 * from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
 *	$FreeBSD: releng/11.0/sys/sys/timespec.h 205792 2010-03-28 13:13:22Z ed $
 */

#ifndef _SYS_TIMESPEC_H_
#define _SYS_TIMESPEC_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 37 "/usr/include/sys/timespec.h" 3 4
# 38 "/usr/include/sys/timespec.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_timespec.h>
#endif /* expanded by -frewrite-includes */
# 38 "/usr/include/sys/timespec.h" 3 4
# 1 "/usr/include/sys/_timespec.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.5 (Berkeley) 5/4/95
 * from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
 *	$FreeBSD: releng/11.0/sys/sys/_timespec.h 205792 2010-03-28 13:13:22Z ed $
 */

#ifndef _SYS__TIMESPEC_H_
#define	_SYS__TIMESPEC_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 37 "/usr/include/sys/_timespec.h" 3 4
# 38 "/usr/include/sys/_timespec.h" 3 4

#ifndef _TIME_T_DECLARED
typedef	__time_t	time_t;
#define	_TIME_T_DECLARED
#endif
# 43 "/usr/include/sys/_timespec.h" 3 4

struct timespec {
	time_t	tv_sec;		/* seconds */
	long	tv_nsec;	/* and nanoseconds */
};

#endif /* !_SYS__TIMESPEC_H_ */
# 50 "/usr/include/sys/_timespec.h" 3 4
# 39 "/usr/include/sys/timespec.h" 2 3 4

#if __BSD_VISIBLE
#define	TIMEVAL_TO_TIMESPEC(tv, ts)					\
	do {								\
		(ts)->tv_sec = (tv)->tv_sec;				\
		(ts)->tv_nsec = (tv)->tv_usec * 1000;			\
	} while (0)
#define	TIMESPEC_TO_TIMEVAL(tv, ts)					\
	do {								\
		(tv)->tv_sec = (ts)->tv_sec;				\
		(tv)->tv_usec = (ts)->tv_nsec / 1000;			\
	} while (0)

#endif /* __BSD_VISIBLE */
# 53 "/usr/include/sys/timespec.h" 3 4

/*
 * Structure defined by POSIX.1b to be like a itimerval, but with
 * timespecs. Used in the timer_*() system calls.
 */
struct itimerspec {
	struct timespec  it_interval;
	struct timespec  it_value;
};

#endif /* _SYS_TIMESPEC_H_ */
# 64 "/usr/include/sys/timespec.h" 3 4
# 41 "/usr/include/sys/select.h" 2 3 4

typedef	unsigned long	__fd_mask;
#if __BSD_VISIBLE
typedef	__fd_mask	fd_mask;
#endif
# 46 "/usr/include/sys/select.h" 3 4

#ifndef _SIGSET_T_DECLARED
#define	_SIGSET_T_DECLARED
typedef	__sigset_t	sigset_t;
#endif
# 51 "/usr/include/sys/select.h" 3 4

/*
 * Select uses bit masks of file descriptors in longs.  These macros
 * manipulate such bit fields (the filesystem macros use chars).
 * FD_SETSIZE may be defined by the user, but the default here should
 * be enough for most uses.
 */
#ifndef	FD_SETSIZE
#define	FD_SETSIZE	1024
#endif
# 61 "/usr/include/sys/select.h" 3 4

#define	_NFDBITS	(sizeof(__fd_mask) * 8)	/* bits per mask */
#if __BSD_VISIBLE
#define	NFDBITS		_NFDBITS
#endif
# 66 "/usr/include/sys/select.h" 3 4

#ifndef _howmany
#define	_howmany(x, y)	(((x) + ((y) - 1)) / (y))
#endif
# 70 "/usr/include/sys/select.h" 3 4

typedef	struct fd_set {
	__fd_mask	__fds_bits[_howmany(FD_SETSIZE, _NFDBITS)];
} fd_set;
#if __BSD_VISIBLE
#define	fds_bits	__fds_bits
#endif
# 77 "/usr/include/sys/select.h" 3 4

#define	__fdset_mask(n)	((__fd_mask)1 << ((n) % _NFDBITS))
#define	FD_CLR(n, p)	((p)->__fds_bits[(n)/_NFDBITS] &= ~__fdset_mask(n))
#if __BSD_VISIBLE
#define	FD_COPY(f, t)	(void)(*(t) = *(f))
#endif
# 83 "/usr/include/sys/select.h" 3 4
#define	FD_ISSET(n, p)	(((p)->__fds_bits[(n)/_NFDBITS] & __fdset_mask(n)) != 0)
#define	FD_SET(n, p)	((p)->__fds_bits[(n)/_NFDBITS] |= __fdset_mask(n))
#define	FD_ZERO(p) do {					\
	fd_set *_p;					\
	__size_t _n;					\
							\
	_p = (p);					\
	_n = _howmany(FD_SETSIZE, _NFDBITS);		\
	while (_n > 0)					\
		_p->__fds_bits[--_n] = 0;		\
} while (0)

#ifndef _KERNEL

__BEGIN_DECLS
int pselect(int, fd_set *__restrict, fd_set *__restrict, fd_set *__restrict,
	const struct timespec *__restrict, const sigset_t *__restrict);
#ifndef _SELECT_DECLARED
#define	_SELECT_DECLARED
/* XXX missing restrict type-qualifier */
int	select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
#endif
# 105 "/usr/include/sys/select.h" 3 4
__END_DECLS
#endif /* !_KERNEL */
# 107 "/usr/include/sys/select.h" 3 4

#endif /* _SYS_SELECT_H_ */
# 109 "/usr/include/sys/select.h" 3 4
# 366 "/usr/include/sys/types.h" 2 3 4

/*
 * minor() gives a cookie instead of an index since we don't want to
 * change the meanings of bits 0-15 or waste time and space shifting
 * bits 16-31 for devices that don't use them.
 */
#define	major(x)	((int)(((u_int)(x) >> 8)&0xff))	/* major number */
#define	minor(x)	((int)((x)&0xffff00ff))		/* minor number */
#define	makedev(x,y)	((dev_t)(((x) << 8) | (y)))	/* create dev_t */

/*
 * These declarations belong elsewhere, but are repeated here and in
 * <stdio.h> to give broken programs a better chance of working with
 * 64-bit off_t's.
 */
#ifndef _KERNEL
__BEGIN_DECLS
#ifndef _FTRUNCATE_DECLARED
#define	_FTRUNCATE_DECLARED
int	 ftruncate(int, off_t);
#endif
# 387 "/usr/include/sys/types.h" 3 4
#ifndef _LSEEK_DECLARED
#define	_LSEEK_DECLARED
off_t	 lseek(int, off_t, int);
#endif
# 391 "/usr/include/sys/types.h" 3 4
#ifndef _MMAP_DECLARED
#define	_MMAP_DECLARED
void *	 mmap(void *, size_t, int, int, int, off_t);
#endif
# 395 "/usr/include/sys/types.h" 3 4
#ifndef _TRUNCATE_DECLARED
#define	_TRUNCATE_DECLARED
int	 truncate(const char *, off_t);
#endif
# 399 "/usr/include/sys/types.h" 3 4
__END_DECLS
#endif /* !_KERNEL */
# 401 "/usr/include/sys/types.h" 3 4

#endif /* __BSD_VISIBLE */
# 403 "/usr/include/sys/types.h" 3 4

#endif /* !_SYS_TYPES_H_ */
# 405 "/usr/include/sys/types.h" 3 4
# 38 "/usr/include/unistd.h" 2 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/unistd.h>
#endif /* expanded by -frewrite-includes */
# 38 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/sys/unistd.h" 1 3 4
/*-
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)unistd.h	8.2 (Berkeley) 1/7/94
 * $FreeBSD: releng/11.0/sys/sys/unistd.h 296572 2016-03-09 19:05:11Z jhb $
 */

#ifndef _SYS_UNISTD_H_
#define	_SYS_UNISTD_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/sys/unistd.h" 3 4
# 37 "/usr/include/sys/unistd.h" 3 4

/*
 * POSIX options and option groups we unconditionally do or don't
 * implement.  Those options which are implemented (or not) entirely
 * in user mode are defined in <unistd.h>.  Please keep this list in
 * alphabetical order.
 *
 * Anything which is defined as zero below **must** have an
 * implementation for the corresponding sysconf() which is able to
 * determine conclusively whether or not the feature is supported.
 * Anything which is defined as other than -1 below **must** have
 * complete headers, types, and function declarations as specified by
 * the POSIX standard; however, if the relevant sysconf() function
 * returns -1, the functions may be stubbed out.
 */
#define	_POSIX_ADVISORY_INFO		200112L
#define	_POSIX_ASYNCHRONOUS_IO		200112L
#define	_POSIX_CHOWN_RESTRICTED		1
#define	_POSIX_CLOCK_SELECTION		(-1)
#define	_POSIX_CPUTIME			200112L
#define	_POSIX_FSYNC			200112L
#define	_POSIX_IPV6			0
#define	_POSIX_JOB_CONTROL		1
#define	_POSIX_MAPPED_FILES		200112L
#define	_POSIX_MEMLOCK			(-1)
#define	_POSIX_MEMLOCK_RANGE		200112L
#define	_POSIX_MEMORY_PROTECTION	200112L
#define	_POSIX_MESSAGE_PASSING		200112L
#define	_POSIX_MONOTONIC_CLOCK		200112L
#define	_POSIX_NO_TRUNC			1
#define	_POSIX_PRIORITIZED_IO		(-1)
#define	_POSIX_PRIORITY_SCHEDULING	200112L
#define	_POSIX_RAW_SOCKETS		200112L
#define	_POSIX_REALTIME_SIGNALS		200112L
#define	_POSIX_SEMAPHORES		200112L
#define	_POSIX_SHARED_MEMORY_OBJECTS	200112L
#define	_POSIX_SPORADIC_SERVER		(-1)
#define	_POSIX_SYNCHRONIZED_IO		(-1)
#define	_POSIX_TIMEOUTS			200112L
#define	_POSIX_TIMERS			200112L
#define	_POSIX_TYPED_MEMORY_OBJECTS	(-1)
#define	_POSIX_VDISABLE			0xff

#if __XSI_VISIBLE
#define	_XOPEN_SHM			1
#define	_XOPEN_STREAMS			(-1)
#endif
# 84 "/usr/include/sys/unistd.h" 3 4

/*
 * Although we have saved user/group IDs, we do not use them in setuid
 * as described in POSIX 1003.1, because the feature does not work for
 * root.  We use the saved IDs in seteuid/setegid, which are not currently
 * part of the POSIX 1003.1 specification.  XXX revisit for 1003.1-2001
 * as this is now mandatory.
 */
#ifdef	_NOT_AVAILABLE
#define	_POSIX_SAVED_IDS	1 /* saved set-user-ID and set-group-ID */
#endif
# 95 "/usr/include/sys/unistd.h" 3 4

/* Define the POSIX.1 version we target for compliance. */
#define	_POSIX_VERSION		200112L

/* access function */
#define	F_OK		0	/* test for existence of file */
#define	X_OK		0x01	/* test for execute or search permission */
#define	W_OK		0x02	/* test for write permission */
#define	R_OK		0x04	/* test for read permission */

/* whence values for lseek(2) */
#ifndef SEEK_SET
#define	SEEK_SET	0	/* set file offset to offset */
#define	SEEK_CUR	1	/* set file offset to current plus offset */
#define	SEEK_END	2	/* set file offset to EOF plus offset */
#endif
# 111 "/usr/include/sys/unistd.h" 3 4
#if __BSD_VISIBLE
#define	SEEK_DATA	3	/* set file offset to next data past offset */
#define	SEEK_HOLE	4	/* set file offset to next hole past offset */
#endif
# 115 "/usr/include/sys/unistd.h" 3 4

#ifndef _POSIX_SOURCE
/* whence values for lseek(2); renamed by POSIX 1003.1 */
#define	L_SET		SEEK_SET
#define	L_INCR		SEEK_CUR
#define	L_XTND		SEEK_END
#endif
# 122 "/usr/include/sys/unistd.h" 3 4

/* configurable pathname variables */
#define	_PC_LINK_MAX		 1
#define	_PC_MAX_CANON		 2
#define	_PC_MAX_INPUT		 3
#define	_PC_NAME_MAX		 4
#define	_PC_PATH_MAX		 5
#define	_PC_PIPE_BUF		 6
#define	_PC_CHOWN_RESTRICTED	 7
#define	_PC_NO_TRUNC		 8
#define	_PC_VDISABLE		 9

#if __POSIX_VISIBLE >= 199309
#define	_PC_ASYNC_IO		53
#define	_PC_PRIO_IO		54
#define	_PC_SYNC_IO		55
#endif
# 139 "/usr/include/sys/unistd.h" 3 4

#if __POSIX_VISIBLE >= 200112
#define	_PC_ALLOC_SIZE_MIN	10
#define	_PC_FILESIZEBITS	12
#define	_PC_REC_INCR_XFER_SIZE	14
#define	_PC_REC_MAX_XFER_SIZE	15
#define	_PC_REC_MIN_XFER_SIZE	16
#define	_PC_REC_XFER_ALIGN	17
#define	_PC_SYMLINK_MAX		18
#endif
# 149 "/usr/include/sys/unistd.h" 3 4

#if __BSD_VISIBLE
#define	_PC_ACL_EXTENDED	59
#define	_PC_ACL_PATH_MAX	60
#define	_PC_CAP_PRESENT		61
#define	_PC_INF_PRESENT		62
#define	_PC_MAC_PRESENT		63
#define	_PC_ACL_NFS4		64
#endif
# 158 "/usr/include/sys/unistd.h" 3 4

/* From OpenSolaris, used by SEEK_DATA/SEEK_HOLE. */
#define	_PC_MIN_HOLE_SIZE	21

#if __BSD_VISIBLE
/*
 * rfork() options.
 *
 * XXX currently, some operations without RFPROC set are not supported.
 */
#define	RFNAMEG		(1<<0)	/* UNIMPL new plan9 `name space' */
#define	RFENVG		(1<<1)	/* UNIMPL copy plan9 `env space' */
#define	RFFDG		(1<<2)	/* copy fd table */
#define	RFNOTEG		(1<<3)	/* UNIMPL create new plan9 `note group' */
#define	RFPROC		(1<<4)	/* change child (else changes curproc) */
#define	RFMEM		(1<<5)	/* share `address space' */
#define	RFNOWAIT	(1<<6)	/* give child to init */
#define	RFCNAMEG	(1<<10)	/* UNIMPL zero plan9 `name space' */
#define	RFCENVG		(1<<11)	/* UNIMPL zero plan9 `env space' */
#define	RFCFDG		(1<<12)	/* close all fds, zero fd table */
#define	RFTHREAD	(1<<13)	/* enable kernel thread support */
#define	RFSIGSHARE	(1<<14)	/* share signal handlers */
#define	RFLINUXTHPN	(1<<16)	/* do linux clone exit parent notification */
#define	RFSTOPPED	(1<<17)	/* leave child in a stopped state */
#define	RFHIGHPID	(1<<18)	/* use a pid higher than 10 (idleproc) */
#define	RFTSIGZMB	(1<<19)	/* select signal for exit parent notification */
#define	RFTSIGSHIFT	20	/* selected signal number is in bits 20-27  */
#define	RFTSIGMASK	0xFF
#define	RFTSIGNUM(flags)	(((flags) >> RFTSIGSHIFT) & RFTSIGMASK)
#define	RFTSIGFLAGS(signum)	((signum) << RFTSIGSHIFT)
#define	RFPROCDESC	(1<<28)	/* return a process descriptor */
#define	RFPPWAIT	(1<<31)	/* parent sleeps until child exits (vfork) */
#define	RFFLAGS		(RFFDG | RFPROC | RFMEM | RFNOWAIT | RFCFDG | \
    RFTHREAD | RFSIGSHARE | RFLINUXTHPN | RFSTOPPED | RFHIGHPID | RFTSIGZMB | \
    RFPROCDESC | RFPPWAIT)
#define	RFKERNELONLY	(RFSTOPPED | RFHIGHPID | RFPPWAIT | RFPROCDESC)

#endif /* __BSD_VISIBLE */
# 196 "/usr/include/sys/unistd.h" 3 4

#endif /* !_SYS_UNISTD_H_ */
# 198 "/usr/include/sys/unistd.h" 3 4
# 39 "/usr/include/unistd.h" 2 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_null.h>
#endif /* expanded by -frewrite-includes */
# 39 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/sys/_null.h" 1 3 4
/*-
 * Copyright (c) 2003 Marcel Moolenaar
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/sys/sys/_null.h 228918 2011-12-27 21:36:31Z theraven $
 */

#ifndef NULL

#if !defined(__cplusplus)
#define	NULL	((void *)0)
#else
# 34 "/usr/include/sys/_null.h" 3 4
#if __cplusplus >= 201103L
#define	NULL	nullptr
#elif defined(__GNUG__) && defined(__GNUC__) && __GNUC__ >= 4
# 37 "/usr/include/sys/_null.h" 3 4
#define	NULL	__null
#else
# 39 "/usr/include/sys/_null.h" 3 4
#if defined(__LP64__)
#define	NULL	(0L)
#else
# 42 "/usr/include/sys/_null.h" 3 4
#define	NULL	0
#endif	/* __LP64__ */
# 44 "/usr/include/sys/_null.h" 3 4
#endif	/* __GNUG__ */
# 45 "/usr/include/sys/_null.h" 3 4
#endif	/* !__cplusplus */
# 46 "/usr/include/sys/_null.h" 3 4

#endif
# 48 "/usr/include/sys/_null.h" 3 4
# 40 "/usr/include/unistd.h" 2 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 40 "/usr/include/unistd.h" 3 4
# 41 "/usr/include/unistd.h" 3 4

#ifndef _GID_T_DECLARED
typedef	__gid_t		gid_t;
#define	_GID_T_DECLARED
#endif
# 46 "/usr/include/unistd.h" 3 4

#ifndef _OFF_T_DECLARED
typedef	__off_t		off_t;
#define	_OFF_T_DECLARED
#endif
# 51 "/usr/include/unistd.h" 3 4

#ifndef _PID_T_DECLARED
typedef	__pid_t		pid_t;
#define	_PID_T_DECLARED
#endif
# 56 "/usr/include/unistd.h" 3 4

#ifndef _SIZE_T_DECLARED
typedef	__size_t	size_t;
#define	_SIZE_T_DECLARED
#endif
# 61 "/usr/include/unistd.h" 3 4

#ifndef _SSIZE_T_DECLARED
typedef	__ssize_t	ssize_t;
#define	_SSIZE_T_DECLARED
#endif
# 66 "/usr/include/unistd.h" 3 4

#ifndef _UID_T_DECLARED
typedef	__uid_t		uid_t;
#define	_UID_T_DECLARED
#endif
# 71 "/usr/include/unistd.h" 3 4

#ifndef _USECONDS_T_DECLARED
typedef	__useconds_t	useconds_t;
#define	_USECONDS_T_DECLARED
#endif
# 76 "/usr/include/unistd.h" 3 4

#define	STDIN_FILENO	0	/* standard input file descriptor */
#define	STDOUT_FILENO	1	/* standard output file descriptor */
#define	STDERR_FILENO	2	/* standard error file descriptor */

#if __XSI_VISIBLE || __POSIX_VISIBLE >= 200112
#define	F_ULOCK		0	/* unlock locked section */
#define	F_LOCK		1	/* lock a section for exclusive use */
#define	F_TLOCK		2	/* test and lock a section for exclusive use */
#define	F_TEST		3	/* test a section for locks by other procs */
#endif
# 87 "/usr/include/unistd.h" 3 4

/*
 * POSIX options and option groups we unconditionally do or don't
 * implement.  This list includes those options which are exclusively
 * implemented (or not) in user mode.  Please keep this list in
 * alphabetical order.
 *
 * Anything which is defined as zero below **must** have an
 * implementation for the corresponding sysconf() which is able to
 * determine conclusively whether or not the feature is supported.
 * Anything which is defined as other than -1 below **must** have
 * complete headers, types, and function declarations as specified by
 * the POSIX standard; however, if the relevant sysconf() function
 * returns -1, the functions may be stubbed out.
 */
#define	_POSIX_BARRIERS			200112L
#define	_POSIX_CPUTIME			200112L
#define	_POSIX_READER_WRITER_LOCKS	200112L
#define	_POSIX_REGEXP			1
#define	_POSIX_SHELL			1
#define	_POSIX_SPAWN			200112L
#define	_POSIX_SPIN_LOCKS		200112L
#define	_POSIX_THREAD_ATTR_STACKADDR	200112L
#define	_POSIX_THREAD_ATTR_STACKSIZE	200112L
#define	_POSIX_THREAD_CPUTIME		200112L
#define	_POSIX_THREAD_PRIO_INHERIT	200112L
#define	_POSIX_THREAD_PRIO_PROTECT	200112L
#define	_POSIX_THREAD_PRIORITY_SCHEDULING 200112L
#define	_POSIX_THREAD_PROCESS_SHARED	200112L
#define	_POSIX_THREAD_SAFE_FUNCTIONS	-1
#define	_POSIX_THREAD_SPORADIC_SERVER	-1
#define	_POSIX_THREADS			200112L
#define	_POSIX_TRACE			-1
#define	_POSIX_TRACE_EVENT_FILTER	-1
#define	_POSIX_TRACE_INHERIT		-1
#define	_POSIX_TRACE_LOG		-1
#define	_POSIX2_C_BIND			200112L	/* mandatory */
#define	_POSIX2_C_DEV			-1 /* need c99 utility */
#define	_POSIX2_CHAR_TERM		1
#define	_POSIX2_FORT_DEV		-1 /* need fort77 utility */
#define	_POSIX2_FORT_RUN		200112L
#define	_POSIX2_LOCALEDEF		-1
#define	_POSIX2_PBS			-1
#define	_POSIX2_PBS_ACCOUNTING		-1
#define	_POSIX2_PBS_CHECKPOINT		-1
#define	_POSIX2_PBS_LOCATE		-1
#define	_POSIX2_PBS_MESSAGE		-1
#define	_POSIX2_PBS_TRACK		-1
#define	_POSIX2_SW_DEV			-1 /* XXX ??? */
#define	_POSIX2_UPE			200112L
#define	_V6_ILP32_OFF32			-1
#define	_V6_ILP32_OFFBIG		0
#define	_V6_LP64_OFF64			0
#define	_V6_LPBIG_OFFBIG		-1

#if __XSI_VISIBLE
#define	_XOPEN_CRYPT			-1 /* XXX ??? */
#define	_XOPEN_ENH_I18N			-1 /* mandatory in XSI */
#define	_XOPEN_LEGACY			-1
#define	_XOPEN_REALTIME			-1
#define	_XOPEN_REALTIME_THREADS		-1
#define	_XOPEN_UNIX			-1
#endif
# 150 "/usr/include/unistd.h" 3 4

/* Define the POSIX.2 version we target for compliance. */
#define	_POSIX2_VERSION		199212L

/*
 * POSIX-style system configuration variable accessors (for the
 * sysconf function).  The kernel does not directly implement the
 * sysconf() interface; rather, a C library stub translates references
 * to sysconf() into calls to sysctl() using a giant switch statement.
 * Those that are marked `user' are implemented entirely in the C
 * library and never query the kernel.  pathconf() is implemented
 * directly by the kernel so those are not defined here.
 */
#define	_SC_ARG_MAX		 1
#define	_SC_CHILD_MAX		 2
#define	_SC_CLK_TCK		 3
#define	_SC_NGROUPS_MAX		 4
#define	_SC_OPEN_MAX		 5
#define	_SC_JOB_CONTROL		 6
#define	_SC_SAVED_IDS		 7
#define	_SC_VERSION		 8
#define	_SC_BC_BASE_MAX		 9 /* user */
#define	_SC_BC_DIM_MAX		10 /* user */
#define	_SC_BC_SCALE_MAX	11 /* user */
#define	_SC_BC_STRING_MAX	12 /* user */
#define	_SC_COLL_WEIGHTS_MAX	13 /* user */
#define	_SC_EXPR_NEST_MAX	14 /* user */
#define	_SC_LINE_MAX		15 /* user */
#define	_SC_RE_DUP_MAX		16 /* user */
#define	_SC_2_VERSION		17 /* user */
#define	_SC_2_C_BIND		18 /* user */
#define	_SC_2_C_DEV		19 /* user */
#define	_SC_2_CHAR_TERM		20 /* user */
#define	_SC_2_FORT_DEV		21 /* user */
#define	_SC_2_FORT_RUN		22 /* user */
#define	_SC_2_LOCALEDEF		23 /* user */
#define	_SC_2_SW_DEV		24 /* user */
#define	_SC_2_UPE		25 /* user */
#define	_SC_STREAM_MAX		26 /* user */
#define	_SC_TZNAME_MAX		27 /* user */

#if __POSIX_VISIBLE >= 199309
#define	_SC_ASYNCHRONOUS_IO	28
#define	_SC_MAPPED_FILES	29
#define	_SC_MEMLOCK		30
#define	_SC_MEMLOCK_RANGE	31
#define	_SC_MEMORY_PROTECTION	32
#define	_SC_MESSAGE_PASSING	33
#define	_SC_PRIORITIZED_IO	34
#define	_SC_PRIORITY_SCHEDULING	35
#define	_SC_REALTIME_SIGNALS	36
#define	_SC_SEMAPHORES		37
#define	_SC_FSYNC		38
#define	_SC_SHARED_MEMORY_OBJECTS 39
#define	_SC_SYNCHRONIZED_IO	40
#define	_SC_TIMERS		41
#define	_SC_AIO_LISTIO_MAX	42
#define	_SC_AIO_MAX		43
#define	_SC_AIO_PRIO_DELTA_MAX	44
#define	_SC_DELAYTIMER_MAX	45
#define	_SC_MQ_OPEN_MAX		46
#define	_SC_PAGESIZE		47
#define	_SC_RTSIG_MAX		48
#define	_SC_SEM_NSEMS_MAX	49
#define	_SC_SEM_VALUE_MAX	50
#define	_SC_SIGQUEUE_MAX	51
#define	_SC_TIMER_MAX		52
#endif
# 218 "/usr/include/unistd.h" 3 4

#if __POSIX_VISIBLE >= 200112
#define	_SC_2_PBS		59 /* user */
#define	_SC_2_PBS_ACCOUNTING	60 /* user */
#define	_SC_2_PBS_CHECKPOINT	61 /* user */
#define	_SC_2_PBS_LOCATE	62 /* user */
#define	_SC_2_PBS_MESSAGE	63 /* user */
#define	_SC_2_PBS_TRACK		64 /* user */
#define	_SC_ADVISORY_INFO	65
#define	_SC_BARRIERS		66 /* user */
#define	_SC_CLOCK_SELECTION	67
#define	_SC_CPUTIME		68
#define	_SC_FILE_LOCKING	69
#define	_SC_GETGR_R_SIZE_MAX	70 /* user */
#define	_SC_GETPW_R_SIZE_MAX	71 /* user */
#define	_SC_HOST_NAME_MAX	72
#define	_SC_LOGIN_NAME_MAX	73
#define	_SC_MONOTONIC_CLOCK	74
#define	_SC_MQ_PRIO_MAX		75
#define	_SC_READER_WRITER_LOCKS	76 /* user */
#define	_SC_REGEXP		77 /* user */
#define	_SC_SHELL		78 /* user */
#define	_SC_SPAWN		79 /* user */
#define	_SC_SPIN_LOCKS		80 /* user */
#define	_SC_SPORADIC_SERVER	81
#define	_SC_THREAD_ATTR_STACKADDR 82 /* user */
#define	_SC_THREAD_ATTR_STACKSIZE 83 /* user */
#define	_SC_THREAD_CPUTIME	84 /* user */
#define	_SC_THREAD_DESTRUCTOR_ITERATIONS 85 /* user */
#define	_SC_THREAD_KEYS_MAX	86 /* user */
#define	_SC_THREAD_PRIO_INHERIT	87 /* user */
#define	_SC_THREAD_PRIO_PROTECT	88 /* user */
#define	_SC_THREAD_PRIORITY_SCHEDULING 89 /* user */
#define	_SC_THREAD_PROCESS_SHARED 90 /* user */
#define	_SC_THREAD_SAFE_FUNCTIONS 91 /* user */
#define	_SC_THREAD_SPORADIC_SERVER 92 /* user */
#define	_SC_THREAD_STACK_MIN	93 /* user */
#define	_SC_THREAD_THREADS_MAX	94 /* user */
#define	_SC_TIMEOUTS		95 /* user */
#define	_SC_THREADS		96 /* user */
#define	_SC_TRACE		97 /* user */
#define	_SC_TRACE_EVENT_FILTER	98 /* user */
#define	_SC_TRACE_INHERIT	99 /* user */
#define	_SC_TRACE_LOG		100 /* user */
#define	_SC_TTY_NAME_MAX	101 /* user */
#define	_SC_TYPED_MEMORY_OBJECTS 102
#define	_SC_V6_ILP32_OFF32	103 /* user */
#define	_SC_V6_ILP32_OFFBIG	104 /* user */
#define	_SC_V6_LP64_OFF64	105 /* user */
#define	_SC_V6_LPBIG_OFFBIG	106 /* user */
#define	_SC_IPV6		118
#define	_SC_RAW_SOCKETS		119
#define	_SC_SYMLOOP_MAX		120
#endif
# 272 "/usr/include/unistd.h" 3 4

#if __XSI_VISIBLE
#define	_SC_ATEXIT_MAX		107 /* user */
#define	_SC_IOV_MAX		56
#define	_SC_PAGE_SIZE		_SC_PAGESIZE
#define	_SC_XOPEN_CRYPT		108 /* user */
#define	_SC_XOPEN_ENH_I18N	109 /* user */
#define	_SC_XOPEN_LEGACY	110 /* user */
#define	_SC_XOPEN_REALTIME	111
#define	_SC_XOPEN_REALTIME_THREADS 112
#define	_SC_XOPEN_SHM		113
#define	_SC_XOPEN_STREAMS	114
#define	_SC_XOPEN_UNIX		115
#define	_SC_XOPEN_VERSION	116
#define	_SC_XOPEN_XCU_VERSION	117 /* user */
#endif
# 288 "/usr/include/unistd.h" 3 4

#if __BSD_VISIBLE
#define	_SC_NPROCESSORS_CONF	57
#define	_SC_NPROCESSORS_ONLN	58
#define	_SC_CPUSET_SIZE		122
#endif
# 294 "/usr/include/unistd.h" 3 4

/* Extensions found in Solaris and Linux. */
#define	_SC_PHYS_PAGES		121

/* Keys for the confstr(3) function. */
#if __POSIX_VISIBLE >= 199209
#define	_CS_PATH		1	/* default value of PATH */
#endif
# 302 "/usr/include/unistd.h" 3 4

#if __POSIX_VISIBLE >= 200112
#define	_CS_POSIX_V6_ILP32_OFF32_CFLAGS		2
#define	_CS_POSIX_V6_ILP32_OFF32_LDFLAGS	3
#define	_CS_POSIX_V6_ILP32_OFF32_LIBS		4
#define	_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS	5
#define	_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS	6
#define	_CS_POSIX_V6_ILP32_OFFBIG_LIBS		7
#define	_CS_POSIX_V6_LP64_OFF64_CFLAGS		8
#define	_CS_POSIX_V6_LP64_OFF64_LDFLAGS		9
#define	_CS_POSIX_V6_LP64_OFF64_LIBS		10
#define	_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS	11
#define	_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS	12
#define	_CS_POSIX_V6_LPBIG_OFFBIG_LIBS		13
#define	_CS_POSIX_V6_WIDTH_RESTRICTED_ENVS	14
#endif
# 318 "/usr/include/unistd.h" 3 4

__BEGIN_DECLS
/* 1003.1-1990 */
void	 _exit(int) __dead2;
int	 access(const char *, int);
unsigned int	 alarm(unsigned int);
int	 chdir(const char *);
int	 chown(const char *, uid_t, gid_t);
int	 close(int);
void	 closefrom(int);
int	 dup(int);
int	 dup2(int, int);
int	 execl(const char *, const char *, ...) __null_sentinel;
int	 execle(const char *, const char *, ...);
int	 execlp(const char *, const char *, ...) __null_sentinel;
int	 execv(const char *, char * const *);
int	 execve(const char *, char * const *, char * const *);
int	 execvp(const char *, char * const *);
pid_t	 fork(void);
long	 fpathconf(int, int);
char	*getcwd(char *, size_t);
gid_t	 getegid(void);
uid_t	 geteuid(void);
gid_t	 getgid(void);
int	 getgroups(int, gid_t []);
char	*getlogin(void);
pid_t	 getpgrp(void);
pid_t	 getpid(void);
pid_t	 getppid(void);
uid_t	 getuid(void);
int	 isatty(int);
int	 link(const char *, const char *);
#ifndef _LSEEK_DECLARED
#define	_LSEEK_DECLARED
off_t	 lseek(int, off_t, int);
#endif
# 354 "/usr/include/unistd.h" 3 4
long	 pathconf(const char *, int);
int	 pause(void);
int	 pipe(int *);
ssize_t	 read(int, void *, size_t);
int	 rmdir(const char *);
int	 setgid(gid_t);
int	 setpgid(pid_t, pid_t);
pid_t	 setsid(void);
int	 setuid(uid_t);
unsigned int	 sleep(unsigned int);
long	 sysconf(int);
pid_t	 tcgetpgrp(int);
int	 tcsetpgrp(int, pid_t);
char	*ttyname(int);
int	ttyname_r(int, char *, size_t);
int	 unlink(const char *);
ssize_t	 write(int, const void *, size_t);

/* 1003.2-1992 */
#if __POSIX_VISIBLE >= 199209 || __XSI_VISIBLE
size_t	 confstr(int, char *, size_t);
#ifndef _GETOPT_DECLARED
#define	_GETOPT_DECLARED
int	 getopt(int, char * const [], const char *);

extern char *optarg;			/* getopt(3) external variables */
extern int optind, opterr, optopt;
#endif /* _GETOPT_DECLARED */
# 382 "/usr/include/unistd.h" 3 4
#endif
# 383 "/usr/include/unistd.h" 3 4

/* ISO/IEC 9945-1: 1996 */
#if __POSIX_VISIBLE >= 199506 || __XSI_VISIBLE
int	 fsync(int);

/*
 * ftruncate() was in the POSIX Realtime Extension (it's used for shared
 * memory), but truncate() was not.
 */
#ifndef _FTRUNCATE_DECLARED
#define	_FTRUNCATE_DECLARED
int	 ftruncate(int, off_t);
#endif
# 396 "/usr/include/unistd.h" 3 4
#endif
# 397 "/usr/include/unistd.h" 3 4

#if __POSIX_VISIBLE >= 199506
int	 getlogin_r(char *, int);
#endif
# 401 "/usr/include/unistd.h" 3 4

/* 1003.1-2001 */
#if __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE
int	 fchown(int, uid_t, gid_t);
ssize_t	 readlink(const char * __restrict, char * __restrict, size_t);
#endif
# 407 "/usr/include/unistd.h" 3 4
#if __POSIX_VISIBLE >= 200112
int	 gethostname(char *, size_t);
int	 setegid(gid_t);
int	 seteuid(uid_t);
#endif
# 412 "/usr/include/unistd.h" 3 4

/* 1003.1-2008 */
#if __POSIX_VISIBLE >= 200809 || __XSI_VISIBLE
int	 getsid(pid_t _pid);
int	 fchdir(int);
int	 getpgid(pid_t _pid);
int	 lchown(const char *, uid_t, gid_t);
ssize_t	 pread(int, void *, size_t, off_t);
ssize_t	 pwrite(int, const void *, size_t, off_t);

/* See comment at ftruncate() above. */
#ifndef _TRUNCATE_DECLARED
#define	_TRUNCATE_DECLARED
int	 truncate(const char *, off_t);
#endif
# 427 "/usr/include/unistd.h" 3 4
#endif /* __POSIX_VISIBLE >= 200809 || __XSI_VISIBLE */
# 428 "/usr/include/unistd.h" 3 4

#if __POSIX_VISIBLE >= 200809
int	faccessat(int, const char *, int, int);
int	fchownat(int, const char *, uid_t, gid_t, int);
int	fexecve(int, char *const [], char *const []);
int	linkat(int, const char *, int, const char *, int);
ssize_t	readlinkat(int, const char * __restrict, char * __restrict, size_t);
int	symlinkat(const char *, int, const char *);
int	unlinkat(int, const char *, int);
#endif /* __POSIX_VISIBLE >= 200809 */
# 438 "/usr/include/unistd.h" 3 4

/*
 * symlink() was originally in POSIX.1a, which was withdrawn after
 * being overtaken by events (1003.1-2001).  It was in XPG4.2, and of
 * course has been in BSD since 4.2.
 */
#if __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE >= 402
int	 symlink(const char * __restrict, const char * __restrict);
#endif
# 447 "/usr/include/unistd.h" 3 4

/* X/Open System Interfaces */
#if __XSI_VISIBLE
char	*crypt(const char *, const char *);
/* char	*ctermid(char *); */		/* XXX ??? */
int	 encrypt(char *, int);
long	 gethostid(void);
int	 lockf(int, int, off_t);
int	 nice(int);
int	 setregid(gid_t, gid_t);
int	 setreuid(uid_t, uid_t);

#ifndef _SWAB_DECLARED
#define _SWAB_DECLARED
void	 swab(const void * __restrict, void * __restrict, ssize_t);
#endif /* _SWAB_DECLARED */
# 463 "/usr/include/unistd.h" 3 4

void	 sync(void);

#endif /* __XSI_VISIBLE */
# 467 "/usr/include/unistd.h" 3 4

#if (__XSI_VISIBLE && __XSI_VISIBLE <= 500) || __BSD_VISIBLE
int	 brk(const void *);
int	 chroot(const char *);
int	 getdtablesize(void);
int	 getpagesize(void) __pure2;
char	*getpass(const char *);
void	*sbrk(intptr_t);
#endif
# 476 "/usr/include/unistd.h" 3 4

#if (__XSI_VISIBLE && __XSI_VISIBLE <= 600) || __BSD_VISIBLE
char	*getwd(char *);			/* obsoleted by getcwd() */
useconds_t
	 ualarm(useconds_t, useconds_t);
int	 usleep(useconds_t);
pid_t	 vfork(void) __returns_twice;
#endif
# 484 "/usr/include/unistd.h" 3 4

#if __BSD_VISIBLE
struct timeval;				/* select(2) */
int	 acct(const char *);
int	 async_daemon(void);
int	 check_utility_compat(const char *);
const char *
	 crypt_get_format(void);
int	 crypt_set_format(const char *);
int	 des_cipher(const char *, char *, long, int);
int	 des_setkey(const char *key);
int	 dup3(int, int, int);
int	 eaccess(const char *, int);
void	 endusershell(void);
int	 exect(const char *, char * const *, char * const *);
int	 execvP(const char *, const char *, char * const *);
int	 feature_present(const char *);
char	*fflagstostr(u_long);
int	 getdomainname(char *, int);
int	 getgrouplist(const char *, gid_t, gid_t *, int *);
int	 getloginclass(char *, size_t);
mode_t	 getmode(const void *, mode_t);
int	 getosreldate(void);
int	 getpeereid(int, uid_t *, gid_t *);
int	 getresgid(gid_t *, gid_t *, gid_t *);
int	 getresuid(uid_t *, uid_t *, uid_t *);
char	*getusershell(void);
int	 initgroups(const char *, gid_t);
int	 iruserok(unsigned long, int, const char *, const char *);
int	 iruserok_sa(const void *, int, int, const char *, const char *);
int	 issetugid(void);
void	__FreeBSD_libc_enter_restricted_mode(void);
long	 lpathconf(const char *, int);
#ifndef _MKDTEMP_DECLARED
char	*mkdtemp(char *);
#define	_MKDTEMP_DECLARED
#endif
# 521 "/usr/include/unistd.h" 3 4
#ifndef	_MKNOD_DECLARED
int	 mknod(const char *, mode_t, dev_t);
#define	_MKNOD_DECLARED
#endif
# 525 "/usr/include/unistd.h" 3 4
#ifndef _MKSTEMP_DECLARED
int	 mkstemp(char *);
#define	_MKSTEMP_DECLARED
#endif
# 529 "/usr/include/unistd.h" 3 4
int	 mkstemps(char *, int);
#ifndef _MKTEMP_DECLARED
char	*mktemp(char *);
#define	_MKTEMP_DECLARED
#endif
# 534 "/usr/include/unistd.h" 3 4
int	 nfssvc(int, void *);
int	 nlm_syscall(int, int, int, char **);
int	 pipe2(int *, int);
int	 profil(char *, size_t, vm_offset_t, int);
int	 rcmd(char **, int, const char *, const char *, const char *, int *);
int	 rcmd_af(char **, int, const char *,
		const char *, const char *, int *, int);
int	 rcmdsh(char **, int, const char *,
		const char *, const char *, const char *);
char	*re_comp(const char *);
int	 re_exec(const char *);
int	 reboot(int);
int	 revoke(const char *);
pid_t	 rfork(int);
pid_t	 rfork_thread(int, void *, int (*)(void *), void *);
int	 rresvport(int *);
int	 rresvport_af(int *, int);
int	 ruserok(const char *, int, const char *, const char *);
#if __BSD_VISIBLE
#ifndef _SELECT_DECLARED
#define	_SELECT_DECLARED
int	 select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
#endif
# 557 "/usr/include/unistd.h" 3 4
#endif
# 558 "/usr/include/unistd.h" 3 4
int	 setdomainname(const char *, int);
int	 setgroups(int, const gid_t *);
void	 sethostid(long);
int	 sethostname(const char *, int);
#ifndef _SETKEY_DECLARED
int	 setkey(const char *);
#define	_SETKEY_DECLARED
#endif
# 566 "/usr/include/unistd.h" 3 4
int	 setlogin(const char *);
int	 setloginclass(const char *);
void	*setmode(const char *);
int	 setpgrp(pid_t, pid_t);			/* obsoleted by setpgid() */
void	 setproctitle(const char *_fmt, ...) __printf0like(1, 2);
int	 setresgid(gid_t, gid_t, gid_t);
int	 setresuid(uid_t, uid_t, uid_t);
int	 setrgid(gid_t);
int	 setruid(uid_t);
void	 setusershell(void);
int	 strtofflags(char **, u_long *, u_long *);
int	 swapon(const char *);
int	 swapoff(const char *);
int	 syscall(int, ...);
off_t	 __syscall(quad_t, ...);
int	 undelete(const char *);
int	 unwhiteout(const char *);
void	*valloc(size_t);			/* obsoleted by malloc() */

#ifndef _OPTRESET_DECLARED
#define	_OPTRESET_DECLARED
extern int optreset;			/* getopt(3) external variable */
#endif
# 589 "/usr/include/unistd.h" 3 4
#endif /* __BSD_VISIBLE */
# 590 "/usr/include/unistd.h" 3 4
__END_DECLS

#endif /* !_UNISTD_H_ */
# 593 "/usr/include/unistd.h" 3 4
# 299 "include/platform.h" 2
#define fdprintf dprintf

/* Useful for defeating gcc's alignment of "char message[]"-like data */
#if !defined(__s390__)
    /* on s390[x], non-word-aligned data accesses require larger code */
# define ALIGN1 __attribute__((aligned(1)))
# define ALIGN2 __attribute__((aligned(2)))
# define ALIGN4 __attribute__((aligned(4)))
#else
# 308 "include/platform.h"
/* Arches which MUST have 2 or 4 byte alignment for everything are here */
# define ALIGN1
# define ALIGN2
# define ALIGN4
#endif
# 313 "include/platform.h"

/*
 * For 0.9.29 and svn, __ARCH_USE_MMU__ indicates no-mmu reliably.
 * For earlier versions there is no reliable way to check if we are building
 * for a mmu-less system.
 */
#if ENABLE_NOMMU || \
    (defined __UCLIBC__ && \
     UCLIBC_VERSION > KERNEL_VERSION(0, 9, 28) && \
     !defined __ARCH_USE_MMU__)
# define BB_MMU 0
# define USE_FOR_NOMMU(...) __VA_ARGS__
# define USE_FOR_MMU(...)
#else
# 327 "include/platform.h"
# define BB_MMU 1
# define USE_FOR_NOMMU(...)
# define USE_FOR_MMU(...) __VA_ARGS__
#endif
# 331 "include/platform.h"

#if defined(__digital__) && defined(__unix__)
#if 0 /* expanded by -frewrite-includes */
# include <standards.h>
#endif /* expanded by -frewrite-includes */
# 333 "include/platform.h"
# 334 "include/platform.h"
#if 0 /* expanded by -frewrite-includes */
# include <inttypes.h>
#endif /* expanded by -frewrite-includes */
# 334 "include/platform.h"
# 335 "include/platform.h"
# define PRIu32 "u"
# if !defined ADJ_OFFSET_SINGLESHOT && defined MOD_CLKA && defined MOD_OFFSET
#  define ADJ_OFFSET_SINGLESHOT (MOD_CLKA | MOD_OFFSET)
# endif
# 339 "include/platform.h"
# if !defined ADJ_FREQUENCY && defined MOD_FREQUENCY
#  define ADJ_FREQUENCY MOD_FREQUENCY
# endif
# 342 "include/platform.h"
# if !defined ADJ_TIMECONST && defined MOD_TIMECONST
#  define ADJ_TIMECONST MOD_TIMECONST
# endif
# 345 "include/platform.h"
# if !defined ADJ_TICK && defined MOD_CLKB
#  define ADJ_TICK MOD_CLKB
# endif
# 348 "include/platform.h"
#endif
# 349 "include/platform.h"

#if defined(__CYGWIN__)
# define MAXSYMLINKS SYMLOOP_MAX
#endif
# 353 "include/platform.h"

#if defined(ANDROID) || defined(__ANDROID__)
# define BB_ADDITIONAL_PATH ":/system/sbin:/system/bin:/system/xbin"
# define SYS_ioprio_set __NR_ioprio_set
# define SYS_ioprio_get __NR_ioprio_get
#endif
# 359 "include/platform.h"


/* ---- Who misses what? ------------------------------------ */

/* Assume all these functions and header files exist by default.
 * Platforms where it is not true will #undef them below.
 */
#define HAVE_CLEARENV 1
#define HAVE_FDATASYNC 1
#define HAVE_DPRINTF 1
#define HAVE_MEMRCHR 1
#define HAVE_MKDTEMP 1
#define HAVE_TTYNAME_R 1
#define HAVE_PTSNAME_R 1
#define HAVE_SETBIT 1
#define HAVE_SIGHANDLER_T 1
#define HAVE_STPCPY 1
#define HAVE_MEMPCPY 1
#define HAVE_STRCASESTR 1
#define HAVE_STRCHRNUL 1
#define HAVE_STRSEP 1
#define HAVE_STRSIGNAL 1
#define HAVE_STRVERSCMP 1
#define HAVE_VASPRINTF 1
#define HAVE_USLEEP 1
#define HAVE_UNLOCKED_STDIO 1
#define HAVE_UNLOCKED_LINE_OPS 1
#define HAVE_GETLINE 1
#define HAVE_XTABS 1
#define HAVE_MNTENT_H 1
#define HAVE_NET_ETHERNET_H 1
#define HAVE_SYS_STATFS_H 1

#if defined(__UCLIBC__)
# if UCLIBC_VERSION < KERNEL_VERSION(0, 9, 32)
#  undef HAVE_STRVERSCMP
# endif
# 396 "include/platform.h"
# if UCLIBC_VERSION >= KERNEL_VERSION(0, 9, 30)
#  ifndef __UCLIBC_SUSV3_LEGACY__
#   undef HAVE_USLEEP
#  endif
# 400 "include/platform.h"
# endif
# 401 "include/platform.h"
#endif
# 402 "include/platform.h"

#if defined(__WATCOMC__)
# undef HAVE_DPRINTF
# undef HAVE_GETLINE
# undef HAVE_MEMRCHR
# undef HAVE_MKDTEMP
# undef HAVE_SETBIT
# undef HAVE_STPCPY
# undef HAVE_STRCASESTR
# undef HAVE_STRCHRNUL
# undef HAVE_STRSEP
# undef HAVE_STRSIGNAL
# undef HAVE_STRVERSCMP
# undef HAVE_VASPRINTF
# undef HAVE_UNLOCKED_STDIO
# undef HAVE_UNLOCKED_LINE_OPS
# undef HAVE_NET_ETHERNET_H
#endif
# 420 "include/platform.h"

#if defined(__CYGWIN__)
# undef HAVE_CLEARENV
# undef HAVE_FDPRINTF
# undef HAVE_MEMRCHR
# undef HAVE_PTSNAME_R
# undef HAVE_STRVERSCMP
# undef HAVE_UNLOCKED_LINE_OPS
#endif
# 429 "include/platform.h"

/* These BSD-derived OSes share many similarities */
#if (defined __digital__ && defined __unix__) \
 || defined __APPLE__ \
 || defined __OpenBSD__ || defined __NetBSD__
# undef HAVE_CLEARENV
# undef HAVE_FDATASYNC
# undef HAVE_GETLINE
# undef HAVE_MNTENT_H
# undef HAVE_PTSNAME_R
# undef HAVE_SYS_STATFS_H
# undef HAVE_SIGHANDLER_T
# undef HAVE_STRVERSCMP
# undef HAVE_XTABS
# undef HAVE_DPRINTF
# undef HAVE_UNLOCKED_STDIO
# undef HAVE_UNLOCKED_LINE_OPS
#endif
# 447 "include/platform.h"

#if defined(__dietlibc__)
# undef HAVE_STRCHRNUL
#endif
# 451 "include/platform.h"

#if defined(__APPLE__)
# undef HAVE_STRCHRNUL
#endif
# 455 "include/platform.h"

#if defined(__FreeBSD__)
/* users say mempcpy is not present in FreeBSD 9.x */
# undef HAVE_MEMPCPY
# undef HAVE_CLEARENV
# undef HAVE_FDATASYNC
# undef HAVE_MNTENT_H
# undef HAVE_PTSNAME_R
# undef HAVE_SYS_STATFS_H
# undef HAVE_SIGHANDLER_T
# undef HAVE_STRVERSCMP
# undef HAVE_XTABS
# undef HAVE_UNLOCKED_LINE_OPS
#if 0 /* expanded by -frewrite-includes */
# include <osreldate.h>
#endif /* expanded by -frewrite-includes */
# 468 "include/platform.h"
# 1 "/usr/include/osreldate.h" 1 3 4
/*-
 * Copyright (c) 1992-2016 The FreeBSD Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#ifdef _KERNEL
#error "<osreldate.h> cannot be used in the kernel, use <sys/param.h>"
#else
# 31 "/usr/include/osreldate.h" 3 4
#undef __FreeBSD_version
#define __FreeBSD_version 1100122
#endif
# 34 "/usr/include/osreldate.h" 3 4
# 469 "include/platform.h" 2
# if __FreeBSD_version < 1000029
#  undef HAVE_STRCHRNUL /* FreeBSD added strchrnul() between 1000028 and 1000029 */
# endif
# 472 "include/platform.h"
#endif
# 473 "include/platform.h"

#if defined(__NetBSD__)
# define HAVE_GETLINE 1  /* Recent NetBSD versions have getline() */
#endif
# 477 "include/platform.h"

#if defined(__digital__) && defined(__unix__)
# undef HAVE_STPCPY
#endif
# 481 "include/platform.h"

#if defined(ANDROID) || defined(__ANDROID__)
# if __ANDROID_API__ < 8
   /* ANDROID < 8 has no [f]dprintf at all */
#  undef HAVE_DPRINTF
# elif __ANDROID_API__ < 21
# 487 "include/platform.h"
   /* ANDROID < 21 has fdprintf */
#  define dprintf fdprintf
# else
# 490 "include/platform.h"
   /* ANDROID >= 21 has standard dprintf */
# endif
# 492 "include/platform.h"
# if __ANDROID_API__ < 21
#  undef HAVE_TTYNAME_R
#  undef HAVE_GETLINE
#  undef HAVE_STPCPY
# endif
# 497 "include/platform.h"
# undef HAVE_MEMPCPY
# undef HAVE_STRCHRNUL
# undef HAVE_STRVERSCMP
# undef HAVE_UNLOCKED_LINE_OPS
# undef HAVE_NET_ETHERNET_H
#endif
# 503 "include/platform.h"

/*
 * Now, define prototypes for all the functions defined in platform.c
 * These must come after all the HAVE_* macros are defined (or not)
 */

#ifndef HAVE_DPRINTF
extern int dprintf(int fd, const char *format, ...);
#endif
# 512 "include/platform.h"

#ifndef HAVE_MEMRCHR
extern void *memrchr(const void *s, int c, size_t n) FAST_FUNC;
#endif
# 516 "include/platform.h"

#ifndef HAVE_MKDTEMP
extern char *mkdtemp(char *template) FAST_FUNC;
#endif
# 520 "include/platform.h"

#ifndef HAVE_TTYNAME_R
#define ttyname_r bb_ttyname_r
extern int ttyname_r(int fd, char *buf, size_t buflen);
#endif
# 525 "include/platform.h"

#ifndef HAVE_SETBIT
# define setbit(a, b)  ((a)[(b) >> 3] |= 1 << ((b) & 7))
# define clrbit(a, b)  ((a)[(b) >> 3] &= ~(1 << ((b) & 7)))
#endif
# 530 "include/platform.h"

#ifndef HAVE_SIGHANDLER_T
typedef void (*sighandler_t)(int);
#endif
# 534 "include/platform.h"

#ifndef HAVE_STPCPY
extern char *stpcpy(char *p, const char *to_add) FAST_FUNC;
#endif
# 538 "include/platform.h"

#ifndef HAVE_MEMPCPY
#if 0 /* expanded by -frewrite-includes */
#include <string.h>
#endif /* expanded by -frewrite-includes */
# 540 "include/platform.h"
# 1 "/usr/include/string.h" 1 3 4
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)string.h	8.1 (Berkeley) 6/2/93
 * $FreeBSD: releng/11.0/include/string.h 265878 2014-05-11 13:48:21Z jilles $
 */

#ifndef _STRING_H_
#define	_STRING_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/string.h" 3 4
# 37 "/usr/include/string.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_null.h>
#endif /* expanded by -frewrite-includes */
# 37 "/usr/include/string.h" 3 4
# 38 "/usr/include/string.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 38 "/usr/include/string.h" 3 4
# 39 "/usr/include/string.h" 3 4

/*
 * Prototype functions which were historically defined in <string.h>, but
 * are required by POSIX to be prototyped in <strings.h>.
 */
#if __BSD_VISIBLE
#if 0 /* expanded by -frewrite-includes */
#include <strings.h>
#endif /* expanded by -frewrite-includes */
# 45 "/usr/include/string.h" 3 4
# 1 "/usr/include/strings.h" 1 3 4
/*-
 * Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/include/strings.h 272673 2014-10-07 04:54:11Z delphij $
 */

#ifndef _STRINGS_H_
#define	_STRINGS_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 32 "/usr/include/strings.h" 3 4
# 33 "/usr/include/strings.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 33 "/usr/include/strings.h" 3 4
# 34 "/usr/include/strings.h" 3 4

#ifndef _SIZE_T_DECLARED
typedef	__size_t	size_t;
#define	_SIZE_T_DECLARED
#endif
# 39 "/usr/include/strings.h" 3 4

__BEGIN_DECLS
#if __BSD_VISIBLE || __POSIX_VISIBLE <= 200112
int	 bcmp(const void *, const void *, size_t) __pure;	/* LEGACY */
void	 bcopy(const void *, void *, size_t);			/* LEGACY */
void	 bzero(void *, size_t);					/* LEGACY */
#endif
# 46 "/usr/include/strings.h" 3 4
#if __BSD_VISIBLE
void	 explicit_bzero(void *, size_t);
#endif
# 49 "/usr/include/strings.h" 3 4
#if __XSI_VISIBLE
int	 ffs(int) __pure2;
#endif
# 52 "/usr/include/strings.h" 3 4
#if __BSD_VISIBLE
int	 ffsl(long) __pure2;
int	 ffsll(long long) __pure2;
int	 fls(int) __pure2;
int	 flsl(long) __pure2;
int	 flsll(long long) __pure2;
#endif
# 59 "/usr/include/strings.h" 3 4
#if __BSD_VISIBLE || __POSIX_VISIBLE <= 200112
char	*index(const char *, int) __pure;			/* LEGACY */
char	*rindex(const char *, int) __pure;			/* LEGACY */
#endif
# 63 "/usr/include/strings.h" 3 4
int	 strcasecmp(const char *, const char *) __pure;
int	 strncasecmp(const char *, const char *, size_t) __pure;

#if __POSIX_VISIBLE >= 200809 || defined(_XLOCALE_H_)
#if 0 /* expanded by -frewrite-includes */
#include <xlocale/_strings.h>
#endif /* expanded by -frewrite-includes */
# 67 "/usr/include/strings.h" 3 4
# 1 "/usr/include/xlocale/_strings.h" 1 3 4
/*-
 * Copyright (c) 2011, 2012 The FreeBSD Foundation
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/include/xlocale/_strings.h 266865 2014-05-30 01:09:07Z pfg $
 */

#ifndef _LOCALE_T_DEFINED
#define _LOCALE_T_DEFINED
typedef struct	_xlocale *locale_t;
#endif
# 33 "/usr/include/xlocale/_strings.h" 3 4

/*
 * This file is included from both strings.h and xlocale.h.  We need to expose
 * the declarations unconditionally if we are included from xlocale.h, but only
 * if we are in POSIX2008 mode if included from string.h.
 */

#ifndef _XLOCALE_STRINGS1_H
#define _XLOCALE_STRINGS1_H

/*
 * POSIX2008 functions
 */
int	 strcasecmp_l(const char *, const char *, locale_t);
int	 strncasecmp_l(const char *, const char *, size_t, locale_t);
#endif /* _XLOCALE_STRINGS1_H */
# 49 "/usr/include/xlocale/_strings.h" 3 4
# 68 "/usr/include/strings.h" 2 3 4
#endif
# 69 "/usr/include/strings.h" 3 4
__END_DECLS

#endif /* _STRINGS_H_ */
# 72 "/usr/include/strings.h" 3 4
# 46 "/usr/include/string.h" 2 3 4
#endif
# 47 "/usr/include/string.h" 3 4

#ifndef _SIZE_T_DECLARED
typedef	__size_t	size_t;
#define	_SIZE_T_DECLARED
#endif
# 52 "/usr/include/string.h" 3 4

__BEGIN_DECLS
#if __XSI_VISIBLE >= 600
void	*memccpy(void * __restrict, const void * __restrict, int, size_t);
#endif
# 57 "/usr/include/string.h" 3 4
void	*memchr(const void *, int, size_t) __pure;
#if __BSD_VISIBLE
void	*memrchr(const void *, int, size_t) __pure;
#endif
# 61 "/usr/include/string.h" 3 4
int	 memcmp(const void *, const void *, size_t) __pure;
void	*memcpy(void * __restrict, const void * __restrict, size_t);
#if __BSD_VISIBLE
void	*memmem(const void *, size_t, const void *, size_t) __pure;
#endif
# 66 "/usr/include/string.h" 3 4
void	*memmove(void *, const void *, size_t);
void	*memset(void *, int, size_t);
#if __POSIX_VISIBLE >= 200809
char	*stpcpy(char * __restrict, const char * __restrict);
char	*stpncpy(char * __restrict, const char * __restrict, size_t);
#endif
# 72 "/usr/include/string.h" 3 4
#if __BSD_VISIBLE
char	*strcasestr(const char *, const char *) __pure;
#endif
# 75 "/usr/include/string.h" 3 4
char	*strcat(char * __restrict, const char * __restrict);
char	*strchr(const char *, int) __pure;
#if __BSD_VISIBLE
char	*strchrnul(const char*, int) __pure;
#endif
# 80 "/usr/include/string.h" 3 4
int	 strcmp(const char *, const char *) __pure;
int	 strcoll(const char *, const char *);
char	*strcpy(char * __restrict, const char * __restrict);
size_t	 strcspn(const char *, const char *) __pure;
#if __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE
char	*strdup(const char *) __malloc_like;
#endif
# 87 "/usr/include/string.h" 3 4
char	*strerror(int);
#if __POSIX_VISIBLE >= 200112
int	 strerror_r(int, char *, size_t);
#endif
# 91 "/usr/include/string.h" 3 4
#if __BSD_VISIBLE
size_t	 strlcat(char * __restrict, const char * __restrict, size_t);
size_t	 strlcpy(char * __restrict, const char * __restrict, size_t);
#endif
# 95 "/usr/include/string.h" 3 4
size_t	 strlen(const char *) __pure;
#if __BSD_VISIBLE
void	 strmode(int, char *);
#endif
# 99 "/usr/include/string.h" 3 4
char	*strncat(char * __restrict, const char * __restrict, size_t);
int	 strncmp(const char *, const char *, size_t) __pure;
char	*strncpy(char * __restrict, const char * __restrict, size_t);
#if __POSIX_VISIBLE >= 200809
char	*strndup(const char *, size_t) __malloc_like;
size_t	 strnlen(const char *, size_t) __pure;
#endif
# 106 "/usr/include/string.h" 3 4
#if __BSD_VISIBLE
char	*strnstr(const char *, const char *, size_t) __pure;
#endif
# 109 "/usr/include/string.h" 3 4
char	*strpbrk(const char *, const char *) __pure;
char	*strrchr(const char *, int) __pure;
#if __BSD_VISIBLE
char	*strsep(char **, const char *);
#endif
# 114 "/usr/include/string.h" 3 4
#if __POSIX_VISIBLE >= 200809
char	*strsignal(int);
#endif
# 117 "/usr/include/string.h" 3 4
size_t	 strspn(const char *, const char *) __pure;
char	*strstr(const char *, const char *) __pure;
char	*strtok(char * __restrict, const char * __restrict);
#if __POSIX_VISIBLE >= 199506 || __XSI_VISIBLE >= 500
char	*strtok_r(char *, const char *, char **);
#endif
# 123 "/usr/include/string.h" 3 4
size_t	 strxfrm(char * __restrict, const char * __restrict, size_t);
#if __BSD_VISIBLE

#ifndef _SWAB_DECLARED
#define _SWAB_DECLARED

#ifndef _SSIZE_T_DECLARED
typedef	__ssize_t	ssize_t;
#define	_SSIZE_T_DECLARED
#endif /* _SIZE_T_DECLARED */
# 133 "/usr/include/string.h" 3 4

void	 swab(const void * __restrict, void * __restrict, ssize_t);
#endif /* _SWAB_DECLARED */
# 136 "/usr/include/string.h" 3 4

#endif /* __BSD_VISIBLE */
# 138 "/usr/include/string.h" 3 4

#if __POSIX_VISIBLE >= 200809 || defined(_XLOCALE_H_)
#if 0 /* expanded by -frewrite-includes */
#include <xlocale/_string.h>
#endif /* expanded by -frewrite-includes */
# 140 "/usr/include/string.h" 3 4
# 1 "/usr/include/xlocale/_string.h" 1 3 4
/*-
 * Copyright (c) 2011, 2012 The FreeBSD Foundation
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/include/xlocale/_string.h 266865 2014-05-30 01:09:07Z pfg $
 */

#ifndef _LOCALE_T_DEFINED
#define _LOCALE_T_DEFINED
typedef struct	_xlocale *locale_t;
#endif
# 33 "/usr/include/xlocale/_string.h" 3 4

/*
 * This file is included from both string.h and xlocale.h.  We need to expose
 * the declarations unconditionally if we are included from xlocale.h, but only
 * if we are in POSIX2008 mode if included from string.h.
 */

#ifndef _XLOCALE_STRING1_H
#define _XLOCALE_STRING1_H

/*
 * POSIX2008 functions
 */
int	 strcoll_l(const char *, const char *, locale_t);
size_t	 strxfrm_l(char *, const char *, size_t, locale_t);
#endif /* _XLOCALE_STRING1_H */
# 49 "/usr/include/xlocale/_string.h" 3 4

/*
 * xlocale extensions
 */
#ifdef _XLOCALE_H_
#ifndef _XLOCALE_STRING2_H
#define _XLOCALE_STRING2_H
char	*strcasestr_l(const char *, const char *, locale_t);

#endif /* _XLOCALE_STRING2_H */
# 59 "/usr/include/xlocale/_string.h" 3 4
#endif /* _XLOCALE_H_ */
# 60 "/usr/include/xlocale/_string.h" 3 4
# 141 "/usr/include/string.h" 2 3 4
#endif
# 142 "/usr/include/string.h" 3 4
__END_DECLS

#endif /* _STRING_H_ */
# 145 "/usr/include/string.h" 3 4
# 541 "include/platform.h" 2
/* In case we are wrong about !HAVE_MEMPCPY, and toolchain _does_ have
 * mempcpy(), avoid colliding with it:
 */
#define mempcpy bb__mempcpy
static ALWAYS_INLINE void *mempcpy(void *dest, const void *src, size_t len)
{
	return memcpy(dest, src, len) + len;
}
#endif
# 550 "include/platform.h"

#ifndef HAVE_STRCASESTR
extern char *strcasestr(const char *s, const char *pattern) FAST_FUNC;
#endif
# 554 "include/platform.h"

#ifndef HAVE_STRCHRNUL
extern char *strchrnul(const char *s, int c) FAST_FUNC;
#endif
# 558 "include/platform.h"

#ifndef HAVE_STRSEP
extern char *strsep(char **stringp, const char *delim) FAST_FUNC;
#endif
# 562 "include/platform.h"

#ifndef HAVE_STRSIGNAL
/* Not exactly the same: instead of "Stopped" it shows "STOP" etc */
# define strsignal(sig) get_signame(sig)
#endif
# 567 "include/platform.h"

#ifndef HAVE_USLEEP
extern int usleep(unsigned) FAST_FUNC;
#endif
# 571 "include/platform.h"

#ifndef HAVE_VASPRINTF
extern int vasprintf(char **string_ptr, const char *format, va_list p) FAST_FUNC;
#endif
# 575 "include/platform.h"

#ifndef HAVE_GETLINE
#if 0 /* expanded by -frewrite-includes */
# include <stdio.h> /* for FILE */
#endif /* expanded by -frewrite-includes */
# 577 "include/platform.h"
# 578 "include/platform.h"
#if 0 /* expanded by -frewrite-includes */
# include <sys/types.h> /* size_t */
#endif /* expanded by -frewrite-includes */
# 578 "include/platform.h"
# 579 "include/platform.h"
extern ssize_t getline(char **lineptr, size_t *n, FILE *stream) FAST_FUNC;
#endif
# 581 "include/platform.h"

#endif
# 583 "include/platform.h"
# 14 "include/libbb.h" 2

#if 0 /* expanded by -frewrite-includes */
#include <ctype.h>
#endif /* expanded by -frewrite-includes */
# 15 "include/libbb.h"
# 1 "/usr/include/ctype.h" 1 3 4
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * This code is derived from software contributed to Berkeley by
 * Paul Borman at Krystal Technologies.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ctype.h	8.4 (Berkeley) 1/21/94
 *      $FreeBSD: releng/11.0/include/ctype.h 290494 2015-11-07 12:43:35Z bapt $
 */

#ifndef _CTYPE_H_
#define	_CTYPE_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 44 "/usr/include/ctype.h" 3 4
# 45 "/usr/include/ctype.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 45 "/usr/include/ctype.h" 3 4
# 46 "/usr/include/ctype.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <_ctype.h>
#endif /* expanded by -frewrite-includes */
# 46 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/_ctype.h" 1 3 4
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * This code is derived from software contributed to Berkeley by
 * Paul Borman at Krystal Technologies.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * From @(#)ctype.h	8.4 (Berkeley) 1/21/94
 * From FreeBSD: src/include/ctype.h,v 1.27 2004/06/23 07:11:39 tjr Exp
 * $FreeBSD: releng/11.0/include/_ctype.h 290494 2015-11-07 12:43:35Z bapt $
 */

#ifndef __CTYPE_H_
#define	__CTYPE_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 45 "/usr/include/_ctype.h" 3 4
# 46 "/usr/include/_ctype.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 46 "/usr/include/_ctype.h" 3 4
# 47 "/usr/include/_ctype.h" 3 4

#define	_CTYPE_A	0x00000100L		/* Alpha */
#define	_CTYPE_C	0x00000200L		/* Control */
#define	_CTYPE_D	0x00000400L		/* Digit */
#define	_CTYPE_G	0x00000800L		/* Graph */
#define	_CTYPE_L	0x00001000L		/* Lower */
#define	_CTYPE_P	0x00002000L		/* Punct */
#define	_CTYPE_S	0x00004000L		/* Space */
#define	_CTYPE_U	0x00008000L		/* Upper */
#define	_CTYPE_X	0x00010000L		/* X digit */
#define	_CTYPE_B	0x00020000L		/* Blank */
#define	_CTYPE_R	0x00040000L		/* Print */
#define	_CTYPE_I	0x00080000L		/* Ideogram */
#define	_CTYPE_T	0x00100000L		/* Special */
#define	_CTYPE_Q	0x00200000L		/* Phonogram */
#define	_CTYPE_N 	0x00400000L		/* Number (superset of digit) */
#define	_CTYPE_SW0	0x20000000L		/* 0 width character */
#define	_CTYPE_SW1	0x40000000L		/* 1 width character */
#define	_CTYPE_SW2	0x80000000L		/* 2 width character */
#define	_CTYPE_SW3	0xc0000000L		/* 3 width character */
#define	_CTYPE_SWM	0xe0000000L		/* Mask for screen width data */
#define	_CTYPE_SWS	30			/* Bits to shift to get width */

/* See comments in <sys/_types.h> about __ct_rune_t. */
__BEGIN_DECLS
unsigned long	___runetype(__ct_rune_t) __pure;
__ct_rune_t	___tolower(__ct_rune_t) __pure;
__ct_rune_t	___toupper(__ct_rune_t) __pure;
__END_DECLS

/*
 * _EXTERNALIZE_CTYPE_INLINES_ is defined in locale/nomacros.c to tell us
 * to generate code for extern versions of all our inline functions.
 */
#ifdef _EXTERNALIZE_CTYPE_INLINES_
#define	_USE_CTYPE_INLINE_
#define	static
#define	__inline
#endif
# 86 "/usr/include/_ctype.h" 3 4

extern int __mb_sb_limit;

/*
 * Use inline functions if we are allowed to and the compiler supports them.
 */
#if !defined(_DONT_USE_CTYPE_INLINE_) && \
    (defined(_USE_CTYPE_INLINE_) || defined(__GNUC__) || defined(__cplusplus))

#if 0 /* expanded by -frewrite-includes */
#include <runetype.h>
#endif /* expanded by -frewrite-includes */
# 95 "/usr/include/_ctype.h" 3 4
# 1 "/usr/include/runetype.h" 1 3 4
/*-
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Paul Borman at Krystal Technologies.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)runetype.h	8.1 (Berkeley) 6/2/93
 * $FreeBSD: releng/11.0/include/runetype.h 232620 2012-03-06 20:15:23Z dim $
 */

#ifndef	_RUNETYPE_H_
#define	_RUNETYPE_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 39 "/usr/include/runetype.h" 3 4
# 40 "/usr/include/runetype.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 40 "/usr/include/runetype.h" 3 4
# 41 "/usr/include/runetype.h" 3 4

#define	_CACHED_RUNES	(1 <<8 )	/* Must be a power of 2 */
#define	_CRMASK		(~(_CACHED_RUNES - 1))

/*
 * The lower 8 bits of runetype[] contain the digit value of the rune.
 */
typedef struct {
	__rune_t	__min;		/* First rune of the range */
	__rune_t	__max;		/* Last rune (inclusive) of the range */
	__rune_t	__map;		/* What first maps to in maps */
	unsigned long	*__types;	/* Array of types in range */
} _RuneEntry;

typedef struct {
	int		__nranges;	/* Number of ranges stored */
	_RuneEntry	*__ranges;	/* Pointer to the ranges */
} _RuneRange;

typedef struct {
	char		__magic[8];	/* Magic saying what version we are */
	char		__encoding[32];	/* ASCII name of this encoding */

	__rune_t	(*__sgetrune)(const char *, __size_t, char const **);
	int		(*__sputrune)(__rune_t, char *, __size_t, char **);
	__rune_t	__invalid_rune;

	unsigned long	__runetype[_CACHED_RUNES];
	__rune_t	__maplower[_CACHED_RUNES];
	__rune_t	__mapupper[_CACHED_RUNES];

	/*
	 * The following are to deal with Runes larger than _CACHED_RUNES - 1.
	 * Their data is actually contiguous with this structure so as to make
	 * it easier to read/write from/to disk.
	 */
	_RuneRange	__runetype_ext;
	_RuneRange	__maplower_ext;
	_RuneRange	__mapupper_ext;

	void		*__variable;	/* Data which depends on the encoding */
	int		__variable_len;	/* how long that data is */
} _RuneLocale;

#define	_RUNE_MAGIC_1	"RuneMagi"	/* Indicates version 0 of RuneLocale */
__BEGIN_DECLS
extern const _RuneLocale _DefaultRuneLocale;
extern const _RuneLocale *_CurrentRuneLocale;
#if defined(__NO_TLS) || defined(__RUNETYPE_INTERNAL)
extern const _RuneLocale *__getCurrentRuneLocale(void);
#else
# 92 "/usr/include/runetype.h" 3 4
extern _Thread_local const _RuneLocale *_ThreadRuneLocale;
static __inline const _RuneLocale *__getCurrentRuneLocale(void)
{

	if (_ThreadRuneLocale) 
		return _ThreadRuneLocale;
	if (_CurrentRuneLocale) 
		return _CurrentRuneLocale;
	return &_DefaultRuneLocale;
}
#endif /* __NO_TLS || __RUNETYPE_INTERNAL */
# 103 "/usr/include/runetype.h" 3 4
#define _CurrentRuneLocale (__getCurrentRuneLocale())
__END_DECLS

#endif	/* !_RUNETYPE_H_ */
# 107 "/usr/include/runetype.h" 3 4
# 96 "/usr/include/_ctype.h" 2 3 4

static __inline int
__maskrune(__ct_rune_t _c, unsigned long _f)
{
	return ((_c < 0 || _c >= _CACHED_RUNES) ? ___runetype(_c) :
		_CurrentRuneLocale->__runetype[_c]) & _f;
}

static __inline int
__sbmaskrune(__ct_rune_t _c, unsigned long _f)
{
	return (_c < 0 || _c >= __mb_sb_limit) ? 0 :
	       _CurrentRuneLocale->__runetype[_c] & _f;
}

static __inline int
__istype(__ct_rune_t _c, unsigned long _f)
{
	return (!!__maskrune(_c, _f));
}

static __inline int
__sbistype(__ct_rune_t _c, unsigned long _f)
{
	return (!!__sbmaskrune(_c, _f));
}

static __inline int
__isctype(__ct_rune_t _c, unsigned long _f)
{
	return (_c < 0 || _c >= 128) ? 0 :
	       !!(_DefaultRuneLocale.__runetype[_c] & _f);
}

static __inline __ct_rune_t
__toupper(__ct_rune_t _c)
{
	return (_c < 0 || _c >= _CACHED_RUNES) ? ___toupper(_c) :
	       _CurrentRuneLocale->__mapupper[_c];
}

static __inline __ct_rune_t
__sbtoupper(__ct_rune_t _c)
{
	return (_c < 0 || _c >= __mb_sb_limit) ? _c :
	       _CurrentRuneLocale->__mapupper[_c];
}

static __inline __ct_rune_t
__tolower(__ct_rune_t _c)
{
	return (_c < 0 || _c >= _CACHED_RUNES) ? ___tolower(_c) :
	       _CurrentRuneLocale->__maplower[_c];
}

static __inline __ct_rune_t
__sbtolower(__ct_rune_t _c)
{
	return (_c < 0 || _c >= __mb_sb_limit) ? _c :
	       _CurrentRuneLocale->__maplower[_c];
}

static __inline int
__wcwidth(__ct_rune_t _c)
{
	unsigned int _x;

	if (_c == 0)
		return (0);
	_x = (unsigned int)__maskrune(_c, _CTYPE_SWM|_CTYPE_R);
	if ((_x & _CTYPE_SWM) != 0)
		return ((_x & _CTYPE_SWM) >> _CTYPE_SWS);
	return ((_x & _CTYPE_R) != 0 ? 1 : -1);
}

#else /* not using inlines */
# 172 "/usr/include/_ctype.h" 3 4

__BEGIN_DECLS
int		__maskrune(__ct_rune_t, unsigned long);
int		__sbmaskrune(__ct_rune_t, unsigned long);
int		__istype(__ct_rune_t, unsigned long);
int		__sbistype(__ct_rune_t, unsigned long);
int		__isctype(__ct_rune_t, unsigned long);
__ct_rune_t	__toupper(__ct_rune_t);
__ct_rune_t	__sbtoupper(__ct_rune_t);
__ct_rune_t	__tolower(__ct_rune_t);
__ct_rune_t	__sbtolower(__ct_rune_t);
int		__wcwidth(__ct_rune_t);
__END_DECLS
#endif /* using inlines */
# 186 "/usr/include/_ctype.h" 3 4

#endif /* !__CTYPE_H_ */
# 188 "/usr/include/_ctype.h" 3 4
# 47 "/usr/include/ctype.h" 2 3 4

__BEGIN_DECLS
int	isalnum(int);
int	isalpha(int);
int	iscntrl(int);
int	isdigit(int);
int	isgraph(int);
int	islower(int);
int	isprint(int);
int	ispunct(int);
int	isspace(int);
int	isupper(int);
int	isxdigit(int);
int	tolower(int);
int	toupper(int);

#if __XSI_VISIBLE
int	isascii(int);
int	toascii(int);
#endif
# 67 "/usr/include/ctype.h" 3 4

#if __ISO_C_VISIBLE >= 1999
int	isblank(int);
#endif
# 71 "/usr/include/ctype.h" 3 4

#if __BSD_VISIBLE
int	digittoint(int);
int	ishexnumber(int);
int	isideogram(int);
int	isnumber(int);
int	isphonogram(int);
int	isrune(int);
int	isspecial(int);
#endif
# 81 "/usr/include/ctype.h" 3 4

#if __POSIX_VISIBLE >= 200809 || defined(_XLOCALE_H_)
#if 0 /* expanded by -frewrite-includes */
#include <xlocale/_ctype.h>
#endif /* expanded by -frewrite-includes */
# 83 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/xlocale/_ctype.h" 1 3 4
/*-
 * Copyright (c) 2011 The FreeBSD Foundation
 * All rights reserved.
 *
 * This software was developed by David Chisnall under sponsorship from
 * the FreeBSD Foundation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/include/xlocale/_ctype.h 290494 2015-11-07 12:43:35Z bapt $
 */


#if	(defined(_XLOCALE_WCTYPES) && !defined(_XLOCALE_WCTYPE_H)) || \
	(!defined(_XLOCALE_WCTYPES) && !defined(_XLOCALE_CTYPE_H))

#ifdef _XLOCALE_WCTYPES
#define _XLOCALE_WCTYPE_H
#else
# 39 "/usr/include/xlocale/_ctype.h" 3 4
#define _XLOCALE_CTYPE_H
#endif
# 41 "/usr/include/xlocale/_ctype.h" 3 4

#ifndef _LOCALE_T_DEFINED
#define _LOCALE_T_DEFINED
typedef struct	_xlocale *locale_t;
#endif
# 46 "/usr/include/xlocale/_ctype.h" 3 4

#ifndef _XLOCALE_RUN_FUNCTIONS_DEFINED
#define _XLOCALE_RUN_FUNCTIONS_DEFINED 1
unsigned long	 ___runetype_l(__ct_rune_t, locale_t) __pure;
__ct_rune_t	 ___tolower_l(__ct_rune_t, locale_t) __pure;
__ct_rune_t	 ___toupper_l(__ct_rune_t, locale_t) __pure;
_RuneLocale	*__runes_for_locale(locale_t, int*);
#endif
# 54 "/usr/include/xlocale/_ctype.h" 3 4

#ifndef _XLOCALE_INLINE
#if defined(__GNUC__) && !defined(__GNUC_STDC_INLINE__)
/* GNU89 inline has nonstandard semantics. */
#define _XLOCALE_INLINE extern __inline
#else
# 60 "/usr/include/xlocale/_ctype.h" 3 4
/* Hack to work around people who define inline away */
#ifdef inline
#define _XLOCALE_INLINE static __inline
#else
# 64 "/usr/include/xlocale/_ctype.h" 3 4
/* Define with C++ / C99 compatible semantics */
#define _XLOCALE_INLINE inline
#endif
# 67 "/usr/include/xlocale/_ctype.h" 3 4
#endif
# 68 "/usr/include/xlocale/_ctype.h" 3 4
#endif /* _XLOCALE_INLINE */
# 69 "/usr/include/xlocale/_ctype.h" 3 4

#ifdef _XLOCALE_WCTYPES
_XLOCALE_INLINE int
__maskrune_l(__ct_rune_t __c, unsigned long __f, locale_t __loc);
_XLOCALE_INLINE int
__istype_l(__ct_rune_t __c, unsigned long __f, locale_t __loc);

_XLOCALE_INLINE int
__maskrune_l(__ct_rune_t __c, unsigned long __f, locale_t __loc)
{
	int __limit;
	_RuneLocale *runes = __runes_for_locale(__loc, &__limit);
	return ((__c < 0 || __c >= _CACHED_RUNES) ? ___runetype_l(__c, __loc) :
	        runes->__runetype[__c]) & __f;
}

_XLOCALE_INLINE int
__istype_l(__ct_rune_t __c, unsigned long __f, locale_t __loc)
{
	return (!!__maskrune_l(__c, __f, __loc));
}

#define XLOCALE_ISCTYPE(fname, cat) \
		_XLOCALE_INLINE int isw##fname##_l(int, locale_t);\
		_XLOCALE_INLINE int isw##fname##_l(int __c, locale_t __l)\
		{ return __istype_l(__c, cat, __l); }
#else
# 96 "/usr/include/xlocale/_ctype.h" 3 4
_XLOCALE_INLINE int
__sbmaskrune_l(__ct_rune_t __c, unsigned long __f, locale_t __loc);
_XLOCALE_INLINE int
__sbistype_l(__ct_rune_t __c, unsigned long __f, locale_t __loc);

_XLOCALE_INLINE int
__sbmaskrune_l(__ct_rune_t __c, unsigned long __f, locale_t __loc)
{
	int __limit;
	_RuneLocale *runes = __runes_for_locale(__loc, &__limit);
	return (__c < 0 || __c >= __limit) ? 0 :
	       runes->__runetype[__c] & __f;
}

_XLOCALE_INLINE int
__sbistype_l(__ct_rune_t __c, unsigned long __f, locale_t __loc)
{
	return (!!__sbmaskrune_l(__c, __f, __loc));
}

#define XLOCALE_ISCTYPE(__fname, __cat) \
		_XLOCALE_INLINE int is##__fname##_l(int, locale_t); \
		_XLOCALE_INLINE int is##__fname##_l(int __c, locale_t __l)\
		{ return __sbistype_l(__c, __cat, __l); }
#endif
# 121 "/usr/include/xlocale/_ctype.h" 3 4

XLOCALE_ISCTYPE(alnum, _CTYPE_A|_CTYPE_D|_CTYPE_N)
XLOCALE_ISCTYPE(alpha, _CTYPE_A)
XLOCALE_ISCTYPE(blank, _CTYPE_B)
XLOCALE_ISCTYPE(cntrl, _CTYPE_C)
XLOCALE_ISCTYPE(digit, _CTYPE_D)
XLOCALE_ISCTYPE(graph, _CTYPE_G)
XLOCALE_ISCTYPE(hexnumber, _CTYPE_X)
XLOCALE_ISCTYPE(ideogram, _CTYPE_I)
XLOCALE_ISCTYPE(lower, _CTYPE_L)
XLOCALE_ISCTYPE(number, _CTYPE_D|_CTYPE_N)
XLOCALE_ISCTYPE(phonogram, _CTYPE_Q)
XLOCALE_ISCTYPE(print, _CTYPE_R)
XLOCALE_ISCTYPE(punct, _CTYPE_P)
XLOCALE_ISCTYPE(rune, 0xFFFFFF00L)
XLOCALE_ISCTYPE(space, _CTYPE_S)
XLOCALE_ISCTYPE(special, _CTYPE_T)
XLOCALE_ISCTYPE(upper, _CTYPE_U)
XLOCALE_ISCTYPE(xdigit, _CTYPE_X)
#undef XLOCALE_ISCTYPE

#ifdef _XLOCALE_WCTYPES
_XLOCALE_INLINE int towlower_l(int, locale_t);
_XLOCALE_INLINE int __wcwidth_l(__ct_rune_t, locale_t);
_XLOCALE_INLINE int towupper_l(int, locale_t);

_XLOCALE_INLINE int towlower_l(int __c, locale_t __l)
{
	int __limit;
	_RuneLocale *__runes = __runes_for_locale(__l, &__limit);
	return (__c < 0 || __c >= _CACHED_RUNES) ? ___tolower_l(__c, __l) :
	       __runes->__maplower[__c];
}
_XLOCALE_INLINE int towupper_l(int __c, locale_t __l)
{
	int __limit;
	_RuneLocale *__runes = __runes_for_locale(__l, &__limit);
	return (__c < 0 || __c >= _CACHED_RUNES) ? ___toupper_l(__c, __l) :
	       __runes->__mapupper[__c];
}
_XLOCALE_INLINE int
__wcwidth_l(__ct_rune_t _c, locale_t __l)
{
	unsigned int _x;

	if (_c == 0)
		return (0);
	_x = (unsigned int)__maskrune_l(_c, _CTYPE_SWM|_CTYPE_R, __l);
	if ((_x & _CTYPE_SWM) != 0)
		return ((_x & _CTYPE_SWM) >> _CTYPE_SWS);
	return ((_x & _CTYPE_R) != 0 ? 1 : -1);
}
int iswctype_l(wint_t __wc, wctype_t __charclass, locale_t __l);
wctype_t wctype_l(const char *property, locale_t __l);
wint_t towctrans_l(wint_t __wc, wctrans_t desc, locale_t __l);
wint_t nextwctype_l(wint_t __wc, wctype_t wct, locale_t __l);
wctrans_t wctrans_l(const char *__charclass, locale_t __l);
#undef _XLOCALE_WCTYPES
#else
# 180 "/usr/include/xlocale/_ctype.h" 3 4
_XLOCALE_INLINE int digittoint_l(int, locale_t);
_XLOCALE_INLINE int tolower_l(int, locale_t);
_XLOCALE_INLINE int toupper_l(int, locale_t);

_XLOCALE_INLINE int digittoint_l(int __c, locale_t __l)
{ return __sbmaskrune_l((__c), 0xFF, __l); }

_XLOCALE_INLINE int tolower_l(int __c, locale_t __l)
{
	int __limit;
	_RuneLocale *__runes = __runes_for_locale(__l, &__limit);
	return (__c < 0 || __c >= __limit) ? __c :
	       __runes->__maplower[__c];
}
_XLOCALE_INLINE int toupper_l(int __c, locale_t __l)
{
	int __limit;
	_RuneLocale *__runes = __runes_for_locale(__l, &__limit);
	return (__c < 0 || __c >= __limit) ? __c :
	       __runes->__mapupper[__c];
}
#endif
# 202 "/usr/include/xlocale/_ctype.h" 3 4
#endif /* (defined(_XLOCALE_WCTYPES) && !defined(_XLOCALE_WCTYPE_H)) || \
	(!defined(_XLOCALE_WCTYPES) && !defined(_XLOCALE_CTYPE_H)) */
# 204 "/usr/include/xlocale/_ctype.h" 3 4
# 84 "/usr/include/ctype.h" 2 3 4
#endif
# 85 "/usr/include/ctype.h" 3 4
__END_DECLS

#ifndef __cplusplus
#define	isalnum(c)	__sbistype((c), _CTYPE_A|_CTYPE_D|_CTYPE_N)
#define	isalpha(c)	__sbistype((c), _CTYPE_A)
#define	iscntrl(c)	__sbistype((c), _CTYPE_C)
#define	isdigit(c)	__sbistype((c), _CTYPE_D)
#define	isgraph(c)	__sbistype((c), _CTYPE_G)
#define	islower(c)	__sbistype((c), _CTYPE_L)
#define	isprint(c)	__sbistype((c), _CTYPE_R)
#define	ispunct(c)	__sbistype((c), _CTYPE_P)
#define	isspace(c)	__sbistype((c), _CTYPE_S)
#define	isupper(c)	__sbistype((c), _CTYPE_U)
#define	isxdigit(c)	__sbistype((c), _CTYPE_X)
#define	tolower(c)	__sbtolower(c)
#define	toupper(c)	__sbtoupper(c)
#endif /* !__cplusplus */
# 102 "/usr/include/ctype.h" 3 4

#if __XSI_VISIBLE
/*
 * POSIX.1-2001 specifies _tolower() and _toupper() to be macros equivalent to
 * tolower() and toupper() respectively, minus extra checking to ensure that
 * the argument is a lower or uppercase letter respectively.  We've chosen to
 * implement these macros with the same error checking as tolower() and
 * toupper() since this doesn't violate the specification itself, only its
 * intent.  We purposely leave _tolower() and _toupper() undocumented to
 * discourage their use.
 *
 * XXX isascii() and toascii() should similarly be undocumented.
 */
#define	_tolower(c)	__sbtolower(c)
#define	_toupper(c)	__sbtoupper(c)
#define	isascii(c)	(((c) & ~0x7F) == 0)
#define	toascii(c)	((c) & 0x7F)
#endif
# 120 "/usr/include/ctype.h" 3 4

#if __ISO_C_VISIBLE >= 1999 && !defined(__cplusplus)
#define	isblank(c)	__sbistype((c), _CTYPE_B)
#endif
# 124 "/usr/include/ctype.h" 3 4

#if __BSD_VISIBLE
#define	digittoint(c)	__sbmaskrune((c), 0xFF)
#define	ishexnumber(c)	__sbistype((c), _CTYPE_X)
#define	isideogram(c)	__sbistype((c), _CTYPE_I)
#define	isnumber(c)	__sbistype((c), _CTYPE_D|_CTYPE_N)
#define	isphonogram(c)	__sbistype((c), _CTYPE_Q)
#define	isrune(c)	__sbistype((c), 0xFFFFFF00L)
#define	isspecial(c)	__sbistype((c), _CTYPE_T)
#endif
# 134 "/usr/include/ctype.h" 3 4

#endif /* !_CTYPE_H_ */
# 136 "/usr/include/ctype.h" 3 4
# 16 "include/libbb.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <dirent.h>
#endif /* expanded by -frewrite-includes */
# 16 "include/libbb.h"
# 1 "/usr/include/dirent.h" 1 3 4
/*-
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)dirent.h	8.2 (Berkeley) 7/28/94
 * $FreeBSD: releng/11.0/include/dirent.h 300986 2016-05-30 07:50:57Z ed $
 */

#ifndef _DIRENT_H_
#define _DIRENT_H_

/*
 * The kernel defines the format of directory entries returned by
 * the getdirentries(2) system call.
 */
#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 40 "/usr/include/dirent.h" 3 4
# 41 "/usr/include/dirent.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 41 "/usr/include/dirent.h" 3 4
# 42 "/usr/include/dirent.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/dirent.h>
#endif /* expanded by -frewrite-includes */
# 42 "/usr/include/dirent.h" 3 4
# 1 "/usr/include/sys/dirent.h" 1 3 4
/*-
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)dirent.h	8.3 (Berkeley) 8/10/94
 * $FreeBSD: releng/11.0/sys/sys/dirent.h 161347 2006-08-16 09:34:56Z maxim $
 */

#ifndef	_SYS_DIRENT_H_
#define	_SYS_DIRENT_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/sys/dirent.h" 3 4
# 37 "/usr/include/sys/dirent.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 37 "/usr/include/sys/dirent.h" 3 4
# 38 "/usr/include/sys/dirent.h" 3 4

/*
 * The dirent structure defines the format of directory entries returned by
 * the getdirentries(2) system call.
 *
 * A directory entry has a struct dirent at the front of it, containing its
 * inode number, the length of the entry, and the length of the name
 * contained in the entry.  These are followed by the name padded to a 4
 * byte boundary with null bytes.  All names are guaranteed null terminated.
 * The maximum length of a name in a directory is MAXNAMLEN.
 */

struct dirent {
	__uint32_t d_fileno;		/* file number of entry */
	__uint16_t d_reclen;		/* length of this record */
	__uint8_t  d_type; 		/* file type, see below */
	__uint8_t  d_namlen;		/* length of string in d_name */
#if __BSD_VISIBLE
#define	MAXNAMLEN	255
	char	d_name[MAXNAMLEN + 1];	/* name must be no longer than this */
#else
# 59 "/usr/include/sys/dirent.h" 3 4
	char	d_name[255 + 1];	/* name must be no longer than this */
#endif
# 61 "/usr/include/sys/dirent.h" 3 4
};

#if __BSD_VISIBLE
/*
 * File types
 */
#define	DT_UNKNOWN	 0
#define	DT_FIFO		 1
#define	DT_CHR		 2
#define	DT_DIR		 4
#define	DT_BLK		 6
#define	DT_REG		 8
#define	DT_LNK		10
#define	DT_SOCK		12
#define	DT_WHT		14

/*
 * Convert between stat structure types and directory types.
 */
#define	IFTODT(mode)	(((mode) & 0170000) >> 12)
#define	DTTOIF(dirtype)	((dirtype) << 12)

/*
 * The _GENERIC_DIRSIZ macro gives the minimum record length which will hold
 * the directory entry.  This returns the amount of space in struct direct
 * without the d_name field, plus enough space for the name with a terminating
 * null byte (dp->d_namlen+1), rounded up to a 4 byte boundary.
 *
 * XXX although this macro is in the implementation namespace, it requires
 * a manifest constant that is not.
 */
#define	_GENERIC_DIRSIZ(dp) \
    ((sizeof (struct dirent) - (MAXNAMLEN+1)) + (((dp)->d_namlen+1 + 3) &~ 3))
#endif /* __BSD_VISIBLE */
# 95 "/usr/include/sys/dirent.h" 3 4

#ifdef _KERNEL
#define	GENERIC_DIRSIZ(dp)	_GENERIC_DIRSIZ(dp)
#endif
# 99 "/usr/include/sys/dirent.h" 3 4

#endif /* !_SYS_DIRENT_H_ */
# 101 "/usr/include/sys/dirent.h" 3 4
# 43 "/usr/include/dirent.h" 2 3 4

#if __XSI_VISIBLE

#ifndef _INO_T_DECLARED
typedef	__ino_t		ino_t;
#define	_INO_T_DECLARED
#endif
# 50 "/usr/include/dirent.h" 3 4

/*
 * XXX this is probably illegal in the __XSI_VISIBLE case, but brings us closer
 * to the specification.
 */
#define	d_ino		d_fileno	/* backward and XSI compatibility */

#endif /* __XSI_VISIBLE */
# 58 "/usr/include/dirent.h" 3 4

#if __BSD_VISIBLE

#if 0 /* expanded by -frewrite-includes */
#include <sys/_null.h>
#endif /* expanded by -frewrite-includes */
# 61 "/usr/include/dirent.h" 3 4
# 62 "/usr/include/dirent.h" 3 4

/* definitions for library routines operating on directories. */
#define	DIRBLKSIZ	1024

struct _dirdesc;
typedef struct _dirdesc DIR;

/* flags for opendir2 */
#define DTF_HIDEW	0x0001	/* hide whiteout entries */
#define DTF_NODUP	0x0002	/* don't return duplicate names */
#define DTF_REWIND	0x0004	/* rewind after reading union stack */
#define __DTF_READALL	0x0008	/* everything has been read */
#define	__DTF_SKIPREAD	0x0010  /* assume internal buffer is populated */

#else /* !__BSD_VISIBLE */
# 77 "/usr/include/dirent.h" 3 4

typedef	void *	DIR;

#endif /* __BSD_VISIBLE */
# 81 "/usr/include/dirent.h" 3 4

#ifndef _KERNEL

__BEGIN_DECLS
#if __POSIX_VISIBLE >= 200809 || __XSI_VISIBLE >= 700
int	 alphasort(const struct dirent **, const struct dirent **);
int	 dirfd(DIR *);
#endif
# 89 "/usr/include/dirent.h" 3 4
#if __BSD_VISIBLE
DIR	*__opendir2(const char *, int);
int	 fdclosedir(DIR *);
int	 getdents(int, char *, int);
int	 getdirentries(int, char *, int, long *);
#endif
# 95 "/usr/include/dirent.h" 3 4
DIR	*opendir(const char *);
DIR	*fdopendir(int);
struct dirent *
	 readdir(DIR *);
#if __POSIX_VISIBLE >= 199506 || __XSI_VISIBLE >= 500
int	 readdir_r(DIR *, struct dirent *, struct dirent **);
#endif
# 102 "/usr/include/dirent.h" 3 4
void	 rewinddir(DIR *);
#if __POSIX_VISIBLE >= 200809 || __XSI_VISIBLE >= 700
int	 scandir(const char *, struct dirent ***,
	    int (*)(const struct dirent *), int (*)(const struct dirent **,
	    const struct dirent **));
#ifdef __BLOCKS__
int	 scandir_b(const char *, struct dirent ***,
	    int (^)(const struct dirent *),
	    int (^)(const struct dirent **, const struct dirent **));
#endif
# 112 "/usr/include/dirent.h" 3 4
#endif
# 113 "/usr/include/dirent.h" 3 4
#if __XSI_VISIBLE
void	 seekdir(DIR *, long);
long	 telldir(DIR *);
#endif
# 117 "/usr/include/dirent.h" 3 4
int	 closedir(DIR *);
__END_DECLS

#endif /* !_KERNEL */
# 121 "/usr/include/dirent.h" 3 4

#endif /* !_DIRENT_H_ */
# 123 "/usr/include/dirent.h" 3 4
# 17 "include/libbb.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <errno.h>
#endif /* expanded by -frewrite-includes */
# 17 "include/libbb.h"
# 1 "/usr/include/errno.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)errno.h	8.5 (Berkeley) 1/21/94
 * $FreeBSD: releng/11.0/sys/sys/errno.h 296715 2016-03-12 07:54:42Z trasz $
 */

#ifndef _SYS_ERRNO_H_
#define _SYS_ERRNO_H_

#ifndef _KERNEL
#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 42 "/usr/include/errno.h" 3 4
# 43 "/usr/include/errno.h" 3 4
__BEGIN_DECLS
int *	__error(void);
__END_DECLS
#define	errno		(* __error())
#endif
# 48 "/usr/include/errno.h" 3 4

#define	EPERM		1		/* Operation not permitted */
#define	ENOENT		2		/* No such file or directory */
#define	ESRCH		3		/* No such process */
#define	EINTR		4		/* Interrupted system call */
#define	EIO		5		/* Input/output error */
#define	ENXIO		6		/* Device not configured */
#define	E2BIG		7		/* Argument list too long */
#define	ENOEXEC		8		/* Exec format error */
#define	EBADF		9		/* Bad file descriptor */
#define	ECHILD		10		/* No child processes */
#define	EDEADLK		11		/* Resource deadlock avoided */
					/* 11 was EAGAIN */
#define	ENOMEM		12		/* Cannot allocate memory */
#define	EACCES		13		/* Permission denied */
#define	EFAULT		14		/* Bad address */
#ifndef _POSIX_SOURCE
#define	ENOTBLK		15		/* Block device required */
#endif
# 67 "/usr/include/errno.h" 3 4
#define	EBUSY		16		/* Device busy */
#define	EEXIST		17		/* File exists */
#define	EXDEV		18		/* Cross-device link */
#define	ENODEV		19		/* Operation not supported by device */
#define	ENOTDIR		20		/* Not a directory */
#define	EISDIR		21		/* Is a directory */
#define	EINVAL		22		/* Invalid argument */
#define	ENFILE		23		/* Too many open files in system */
#define	EMFILE		24		/* Too many open files */
#define	ENOTTY		25		/* Inappropriate ioctl for device */
#ifndef _POSIX_SOURCE
#define	ETXTBSY		26		/* Text file busy */
#endif
# 80 "/usr/include/errno.h" 3 4
#define	EFBIG		27		/* File too large */
#define	ENOSPC		28		/* No space left on device */
#define	ESPIPE		29		/* Illegal seek */
#define	EROFS		30		/* Read-only filesystem */
#define	EMLINK		31		/* Too many links */
#define	EPIPE		32		/* Broken pipe */

/* math software */
#define	EDOM		33		/* Numerical argument out of domain */
#define	ERANGE		34		/* Result too large */

/* non-blocking and interrupt i/o */
#define	EAGAIN		35		/* Resource temporarily unavailable */
#ifndef _POSIX_SOURCE
#define	EWOULDBLOCK	EAGAIN		/* Operation would block */
#define	EINPROGRESS	36		/* Operation now in progress */
#define	EALREADY	37		/* Operation already in progress */

/* ipc/network software -- argument errors */
#define	ENOTSOCK	38		/* Socket operation on non-socket */
#define	EDESTADDRREQ	39		/* Destination address required */
#define	EMSGSIZE	40		/* Message too long */
#define	EPROTOTYPE	41		/* Protocol wrong type for socket */
#define	ENOPROTOOPT	42		/* Protocol not available */
#define	EPROTONOSUPPORT	43		/* Protocol not supported */
#define	ESOCKTNOSUPPORT	44		/* Socket type not supported */
#define	EOPNOTSUPP	45		/* Operation not supported */
#define	ENOTSUP		EOPNOTSUPP	/* Operation not supported */
#define	EPFNOSUPPORT	46		/* Protocol family not supported */
#define	EAFNOSUPPORT	47		/* Address family not supported by protocol family */
#define	EADDRINUSE	48		/* Address already in use */
#define	EADDRNOTAVAIL	49		/* Can't assign requested address */

/* ipc/network software -- operational errors */
#define	ENETDOWN	50		/* Network is down */
#define	ENETUNREACH	51		/* Network is unreachable */
#define	ENETRESET	52		/* Network dropped connection on reset */
#define	ECONNABORTED	53		/* Software caused connection abort */
#define	ECONNRESET	54		/* Connection reset by peer */
#define	ENOBUFS		55		/* No buffer space available */
#define	EISCONN		56		/* Socket is already connected */
#define	ENOTCONN	57		/* Socket is not connected */
#define	ESHUTDOWN	58		/* Can't send after socket shutdown */
#define	ETOOMANYREFS	59		/* Too many references: can't splice */
#define	ETIMEDOUT	60		/* Operation timed out */
#define	ECONNREFUSED	61		/* Connection refused */

#define	ELOOP		62		/* Too many levels of symbolic links */
#endif /* _POSIX_SOURCE */
# 129 "/usr/include/errno.h" 3 4
#define	ENAMETOOLONG	63		/* File name too long */

/* should be rearranged */
#ifndef _POSIX_SOURCE
#define	EHOSTDOWN	64		/* Host is down */
#define	EHOSTUNREACH	65		/* No route to host */
#endif /* _POSIX_SOURCE */
# 136 "/usr/include/errno.h" 3 4
#define	ENOTEMPTY	66		/* Directory not empty */

/* quotas & mush */
#ifndef _POSIX_SOURCE
#define	EPROCLIM	67		/* Too many processes */
#define	EUSERS		68		/* Too many users */
#define	EDQUOT		69		/* Disc quota exceeded */

/* Network File System */
#define	ESTALE		70		/* Stale NFS file handle */
#define	EREMOTE		71		/* Too many levels of remote in path */
#define	EBADRPC		72		/* RPC struct is bad */
#define	ERPCMISMATCH	73		/* RPC version wrong */
#define	EPROGUNAVAIL	74		/* RPC prog. not avail */
#define	EPROGMISMATCH	75		/* Program version wrong */
#define	EPROCUNAVAIL	76		/* Bad procedure for program */
#endif /* _POSIX_SOURCE */
# 153 "/usr/include/errno.h" 3 4

#define	ENOLCK		77		/* No locks available */
#define	ENOSYS		78		/* Function not implemented */

#ifndef _POSIX_SOURCE
#define	EFTYPE		79		/* Inappropriate file type or format */
#define	EAUTH		80		/* Authentication error */
#define	ENEEDAUTH	81		/* Need authenticator */
#define	EIDRM		82		/* Identifier removed */
#define	ENOMSG		83		/* No message of desired type */
#define	EOVERFLOW	84		/* Value too large to be stored in data type */
#define	ECANCELED	85		/* Operation canceled */
#define	EILSEQ		86		/* Illegal byte sequence */
#define	ENOATTR		87		/* Attribute not found */

#define	EDOOFUS		88		/* Programming error */
#endif /* _POSIX_SOURCE */
# 170 "/usr/include/errno.h" 3 4

#define	EBADMSG		89		/* Bad message */
#define	EMULTIHOP	90		/* Multihop attempted */
#define	ENOLINK		91		/* Link has been severed */
#define	EPROTO		92		/* Protocol error */

#ifndef _POSIX_SOURCE
#define	ENOTCAPABLE	93		/* Capabilities insufficient */
#define	ECAPMODE	94		/* Not permitted in capability mode */
#define	ENOTRECOVERABLE	95		/* State not recoverable */
#define	EOWNERDEAD	96		/* Previous owner died */
#endif /* _POSIX_SOURCE */
# 182 "/usr/include/errno.h" 3 4

#ifndef _POSIX_SOURCE
#define	ELAST		96		/* Must be equal largest errno */
#endif /* _POSIX_SOURCE */
# 186 "/usr/include/errno.h" 3 4

#ifdef _KERNEL
/* pseudo-errors returned inside kernel to modify return to process */
#define	ERESTART	(-1)		/* restart syscall */
#define	EJUSTRETURN	(-2)		/* don't modify regs, just return */
#define	ENOIOCTL	(-3)		/* ioctl not handled by this layer */
#define	EDIRIOCTL	(-4)		/* do direct ioctl in GEOM */
#define	ERELOOKUP	(-5)		/* retry the directory lookup */
#endif
# 195 "/usr/include/errno.h" 3 4

#endif
# 197 "/usr/include/errno.h" 3 4
# 18 "include/libbb.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <fcntl.h>
#endif /* expanded by -frewrite-includes */
# 18 "include/libbb.h"
# 1 "/usr/include/fcntl.h" 1 3 4
/*-
 * Copyright (c) 1983, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)fcntl.h	8.3 (Berkeley) 1/21/94
 * $FreeBSD: releng/11.0/sys/sys/fcntl.h 294205 2016-01-17 08:40:51Z kib $
 */

#ifndef _SYS_FCNTL_H_
#define	_SYS_FCNTL_H_

/*
 * This file includes the definitions for open and fcntl
 * described by POSIX for <fcntl.h>; it also includes
 * related kernel definitions.
 */

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 47 "/usr/include/fcntl.h" 3 4
# 48 "/usr/include/fcntl.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 48 "/usr/include/fcntl.h" 3 4
# 49 "/usr/include/fcntl.h" 3 4

#ifndef _MODE_T_DECLARED
typedef	__mode_t	mode_t;
#define	_MODE_T_DECLARED
#endif
# 54 "/usr/include/fcntl.h" 3 4

#ifndef _OFF_T_DECLARED
typedef	__off_t		off_t;
#define	_OFF_T_DECLARED
#endif
# 59 "/usr/include/fcntl.h" 3 4

#ifndef _PID_T_DECLARED
typedef	__pid_t		pid_t;
#define	_PID_T_DECLARED
#endif
# 64 "/usr/include/fcntl.h" 3 4

/*
 * File status flags: these are used by open(2), fcntl(2).
 * They are also used (indirectly) in the kernel file structure f_flags,
 * which is a superset of the open/fcntl flags.  Open flags and f_flags
 * are inter-convertible using OFLAGS(fflags) and FFLAGS(oflags).
 * Open/fcntl flags begin with O_; kernel-internal flags begin with F.
 */
/* open-only flags */
#define	O_RDONLY	0x0000		/* open for reading only */
#define	O_WRONLY	0x0001		/* open for writing only */
#define	O_RDWR		0x0002		/* open for reading and writing */
#define	O_ACCMODE	0x0003		/* mask for above modes */

/*
 * Kernel encoding of open mode; separate read and write bits that are
 * independently testable: 1 greater than the above.
 *
 * XXX
 * FREAD and FWRITE are excluded from the #ifdef _KERNEL so that TIOCFLUSH,
 * which was documented to use FREAD/FWRITE, continues to work.
 */
#if __BSD_VISIBLE
#define	FREAD		0x0001
#define	FWRITE		0x0002
#endif
# 90 "/usr/include/fcntl.h" 3 4
#define	O_NONBLOCK	0x0004		/* no delay */
#define	O_APPEND	0x0008		/* set append mode */
#if __BSD_VISIBLE
#define	O_SHLOCK	0x0010		/* open with shared file lock */
#define	O_EXLOCK	0x0020		/* open with exclusive file lock */
#define	O_ASYNC		0x0040		/* signal pgrp when data ready */
#define	O_FSYNC		0x0080		/* synchronous writes */
#endif
# 98 "/usr/include/fcntl.h" 3 4
#define	O_SYNC		0x0080		/* POSIX synonym for O_FSYNC */
#if __POSIX_VISIBLE >= 200809
#define	O_NOFOLLOW	0x0100		/* don't follow symlinks */
#endif
# 102 "/usr/include/fcntl.h" 3 4
#define	O_CREAT		0x0200		/* create if nonexistent */
#define	O_TRUNC		0x0400		/* truncate to zero length */
#define	O_EXCL		0x0800		/* error if already exists */
#ifdef _KERNEL
#define	FHASLOCK	0x4000		/* descriptor holds advisory lock */
#endif
# 108 "/usr/include/fcntl.h" 3 4

/* Defined by POSIX 1003.1; BSD default, but must be distinct from O_RDONLY. */
#define	O_NOCTTY	0x8000		/* don't assign controlling terminal */

#if __BSD_VISIBLE
/* Attempt to bypass buffer cache */
#define	O_DIRECT	0x00010000
#endif
# 116 "/usr/include/fcntl.h" 3 4

#if __POSIX_VISIBLE >= 200809
#define	O_DIRECTORY	0x00020000	/* Fail if not directory */
#define	O_EXEC		0x00040000	/* Open for execute only */
#endif
# 121 "/usr/include/fcntl.h" 3 4
#ifdef	_KERNEL
#define	FEXEC		O_EXEC
#endif
# 124 "/usr/include/fcntl.h" 3 4

#if __POSIX_VISIBLE >= 200809
/* Defined by POSIX 1003.1-2008; BSD default, but reserve for future use. */
#define	O_TTY_INIT	0x00080000	/* Restore default termios attributes */

#define	O_CLOEXEC	0x00100000
#endif
# 131 "/usr/include/fcntl.h" 3 4

#if __BSD_VISIBLE
#define	O_VERIFY	0x00200000	/* open only after verification */
#endif
# 135 "/usr/include/fcntl.h" 3 4

/*
 * XXX missing O_DSYNC, O_RSYNC.
 */

#ifdef _KERNEL

/* Only for devfs d_close() flags. */
#define	FLASTCLOSE	O_DIRECTORY
#define	FREVOKE		O_VERIFY
/* Only for fo_close() from half-succeeded open */
#define	FOPENFAILED	O_TTY_INIT

/* convert from open() flags to/from fflags; convert O_RD/WR to FREAD/FWRITE */
#define	FFLAGS(oflags)	((oflags) & O_EXEC ? (oflags) : (oflags) + 1)
#define	OFLAGS(fflags)	((fflags) & O_EXEC ? (fflags) : (fflags) - 1)

/* bits to save after open */
#define	FMASK	(FREAD|FWRITE|FAPPEND|FASYNC|FFSYNC|FNONBLOCK|O_DIRECT|FEXEC)
/* bits settable by fcntl(F_SETFL, ...) */
#define	FCNTLFLAGS	(FAPPEND|FASYNC|FFSYNC|FNONBLOCK|FRDAHEAD|O_DIRECT)

#if defined(COMPAT_FREEBSD7) || defined(COMPAT_FREEBSD6) || \
    defined(COMPAT_FREEBSD5) || defined(COMPAT_FREEBSD4)
/*
 * Set by shm_open(3) in older libc's to get automatic MAP_ASYNC
 * behavior for POSIX shared memory objects (which are otherwise
 * implemented as plain files).
 */
#define	FPOSIXSHM	O_NOFOLLOW
#undef FCNTLFLAGS
#define	FCNTLFLAGS	(FAPPEND|FASYNC|FFSYNC|FNONBLOCK|FPOSIXSHM|FRDAHEAD| \
			 O_DIRECT)
#endif
# 169 "/usr/include/fcntl.h" 3 4
#endif
# 170 "/usr/include/fcntl.h" 3 4

/*
 * The O_* flags used to have only F* names, which were used in the kernel
 * and by fcntl.  We retain the F* names for the kernel f_flag field
 * and for backward compatibility for fcntl.  These flags are deprecated.
 */
#if __BSD_VISIBLE
#define	FAPPEND		O_APPEND	/* kernel/compat */
#define	FASYNC		O_ASYNC		/* kernel/compat */
#define	FFSYNC		O_FSYNC		/* kernel */
#define	FNONBLOCK	O_NONBLOCK	/* kernel */
#define	FNDELAY		O_NONBLOCK	/* compat */
#define	O_NDELAY	O_NONBLOCK	/* compat */
#endif
# 184 "/usr/include/fcntl.h" 3 4

/*
 * We are out of bits in f_flag (which is a short).  However,
 * the flag bits not set in FMASK are only meaningful in the
 * initial open syscall.  Those bits can thus be given a
 * different meaning for fcntl(2).
 */
#if __BSD_VISIBLE
/* Read ahead */
#define	FRDAHEAD	O_CREAT
#endif
# 195 "/usr/include/fcntl.h" 3 4

#if __POSIX_VISIBLE >= 200809
/*
 * Magic value that specify the use of the current working directory
 * to determine the target of relative file paths in the openat() and
 * similar syscalls.
 */
#define	AT_FDCWD		-100

/*
 * Miscellaneous flags for the *at() syscalls.
 */
#define	AT_EACCESS		0x100	/* Check access using effective user and group ID */
#define	AT_SYMLINK_NOFOLLOW	0x200   /* Do not follow symbolic links */
#define	AT_SYMLINK_FOLLOW	0x400	/* Follow symbolic link */
#define	AT_REMOVEDIR		0x800	/* Remove directory instead of file */
#endif
# 212 "/usr/include/fcntl.h" 3 4

/*
 * Constants used for fcntl(2)
 */

/* command values */
#define	F_DUPFD		0		/* duplicate file descriptor */
#define	F_GETFD		1		/* get file descriptor flags */
#define	F_SETFD		2		/* set file descriptor flags */
#define	F_GETFL		3		/* get file status flags */
#define	F_SETFL		4		/* set file status flags */
#if __XSI_VISIBLE || __POSIX_VISIBLE >= 200112
#define	F_GETOWN	5		/* get SIGIO/SIGURG proc/pgrp */
#define	F_SETOWN	6		/* set SIGIO/SIGURG proc/pgrp */
#endif
# 227 "/usr/include/fcntl.h" 3 4
#if __BSD_VISIBLE
#define	F_OGETLK	7		/* get record locking information */
#define	F_OSETLK	8		/* set record locking information */
#define	F_OSETLKW	9		/* F_SETLK; wait if blocked */
#define	F_DUP2FD	10		/* duplicate file descriptor to arg */
#endif
# 233 "/usr/include/fcntl.h" 3 4
#define	F_GETLK		11		/* get record locking information */
#define	F_SETLK		12		/* set record locking information */
#define	F_SETLKW	13		/* F_SETLK; wait if blocked */
#if __BSD_VISIBLE
#define	F_SETLK_REMOTE	14		/* debugging support for remote locks */
#define	F_READAHEAD	15		/* read ahead */
#define	F_RDAHEAD	16		/* Darwin compatible read ahead */
#endif
# 241 "/usr/include/fcntl.h" 3 4
#if __POSIX_VISIBLE >= 200809
#define	F_DUPFD_CLOEXEC	17		/* Like F_DUPFD, but FD_CLOEXEC is set */
#endif
# 244 "/usr/include/fcntl.h" 3 4
#if __BSD_VISIBLE
#define	F_DUP2FD_CLOEXEC 18		/* Like F_DUP2FD, but FD_CLOEXEC is set */
#endif
# 247 "/usr/include/fcntl.h" 3 4

/* file descriptor flags (F_GETFD, F_SETFD) */
#define	FD_CLOEXEC	1		/* close-on-exec flag */

/* record locking flags (F_GETLK, F_SETLK, F_SETLKW) */
#define	F_RDLCK		1		/* shared or read lock */
#define	F_UNLCK		2		/* unlock */
#define	F_WRLCK		3		/* exclusive or write lock */
#if __BSD_VISIBLE
#define	F_UNLCKSYS	4		/* purge locks for a given system ID */ 
#define	F_CANCEL	5		/* cancel an async lock request */
#endif
# 259 "/usr/include/fcntl.h" 3 4
#ifdef _KERNEL
#define	F_WAIT		0x010		/* Wait until lock is granted */
#define	F_FLOCK		0x020	 	/* Use flock(2) semantics for lock */
#define	F_POSIX		0x040	 	/* Use POSIX semantics for lock */
#define	F_REMOTE	0x080		/* Lock owner is remote NFS client */
#define	F_NOINTR	0x100		/* Ignore signals when waiting */
#endif
# 266 "/usr/include/fcntl.h" 3 4

/*
 * Advisory file segment locking data type -
 * information passed to system by user
 */
struct flock {
	off_t	l_start;	/* starting offset */
	off_t	l_len;		/* len = 0 means until end of file */
	pid_t	l_pid;		/* lock owner */
	short	l_type;		/* lock type: read/write, etc. */
	short	l_whence;	/* type of l_start */
	int	l_sysid;	/* remote system id or zero for local */
};

#if __BSD_VISIBLE
/*
 * Old advisory file segment locking data type,
 * before adding l_sysid.
 */
struct __oflock {
	off_t	l_start;	/* starting offset */
	off_t	l_len;		/* len = 0 means until end of file */
	pid_t	l_pid;		/* lock owner */
	short	l_type;		/* lock type: read/write, etc. */
	short	l_whence;	/* type of l_start */
};
#endif
# 293 "/usr/include/fcntl.h" 3 4

#if __BSD_VISIBLE
/* lock operations for flock(2) */
#define	LOCK_SH		0x01		/* shared file lock */
#define	LOCK_EX		0x02		/* exclusive file lock */
#define	LOCK_NB		0x04		/* don't block when locking */
#define	LOCK_UN		0x08		/* unlock file */
#endif
# 301 "/usr/include/fcntl.h" 3 4

#if __POSIX_VISIBLE >= 200112
/*
 * Advice to posix_fadvise
 */
#define	POSIX_FADV_NORMAL	0	/* no special treatment */
#define	POSIX_FADV_RANDOM	1	/* expect random page references */
#define	POSIX_FADV_SEQUENTIAL	2	/* expect sequential page references */
#define	POSIX_FADV_WILLNEED	3	/* will need these pages */
#define	POSIX_FADV_DONTNEED	4	/* dont need these pages */
#define	POSIX_FADV_NOREUSE	5	/* access data only once */
#endif
# 313 "/usr/include/fcntl.h" 3 4

#ifndef _KERNEL
__BEGIN_DECLS
int	open(const char *, int, ...);
int	creat(const char *, mode_t);
int	fcntl(int, int, ...);
#if __BSD_VISIBLE
int	flock(int, int);
#endif
# 322 "/usr/include/fcntl.h" 3 4
#if __POSIX_VISIBLE >= 200809
int	openat(int, const char *, int, ...);
#endif
# 325 "/usr/include/fcntl.h" 3 4
#if __POSIX_VISIBLE >= 200112
int	posix_fadvise(int, off_t, off_t, int);
int	posix_fallocate(int, off_t, off_t);
#endif
# 329 "/usr/include/fcntl.h" 3 4
__END_DECLS
#endif
# 331 "/usr/include/fcntl.h" 3 4

#endif /* !_SYS_FCNTL_H_ */
# 333 "/usr/include/fcntl.h" 3 4
# 19 "include/libbb.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <inttypes.h>
#endif /* expanded by -frewrite-includes */
# 19 "include/libbb.h"
# 1 "/usr/include/inttypes.h" 1 3 4
/*-
 * Copyright (c) 2001 Mike Barcroft <mike@FreeBSD.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/include/inttypes.h 263998 2014-04-01 14:46:11Z tijl $
 */

#ifndef _INTTYPES_H_
#define	_INTTYPES_H_

#if 0 /* expanded by -frewrite-includes */
#include <machine/_inttypes.h>
#endif /* expanded by -frewrite-includes */
# 32 "/usr/include/inttypes.h" 3 4
# 1 "/usr/include/machine/_inttypes.h" 1 3 4
/*-
 * This file is in the public domain.
 */
/* $FreeBSD: releng/11.0/sys/amd64/include/_inttypes.h 217157 2011-01-08 18:09:48Z tijl $ */

#if 0 /* expanded by -frewrite-includes */
#include <x86/_inttypes.h>
#endif /* expanded by -frewrite-includes */
# 6 "/usr/include/machine/_inttypes.h" 3 4
# 1 "/usr/include/x86/_inttypes.h" 1 3 4
/*-
 * Copyright (c) 2001 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Klaus Klein.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *	From: $NetBSD: int_fmtio.h,v 1.2 2001/04/26 16:25:21 kleink Exp $
 * $FreeBSD: releng/11.0/sys/x86/include/_inttypes.h 217157 2011-01-08 18:09:48Z tijl $
 */

#ifndef _MACHINE_INTTYPES_H_
#define	_MACHINE_INTTYPES_H_

/*
 * Macros for format specifiers.
 */

#ifdef __LP64__
#define	__PRI64		"l"
#define	__PRIptr	"l"
#else
# 44 "/usr/include/x86/_inttypes.h" 3 4
#define	__PRI64		"ll"
#define	__PRIptr
#endif
# 47 "/usr/include/x86/_inttypes.h" 3 4

/* fprintf(3) macros for signed integers. */

#define	PRId8		"d"		/* int8_t */
#define	PRId16		"d"		/* int16_t */
#define	PRId32		"d"		/* int32_t */
#define	PRId64		__PRI64"d"	/* int64_t */
#define	PRIdLEAST8	"d"		/* int_least8_t */
#define	PRIdLEAST16	"d"		/* int_least16_t */
#define	PRIdLEAST32	"d"		/* int_least32_t */
#define	PRIdLEAST64	__PRI64"d"	/* int_least64_t */
#define	PRIdFAST8	"d"		/* int_fast8_t */
#define	PRIdFAST16	"d"		/* int_fast16_t */
#define	PRIdFAST32	"d"		/* int_fast32_t */
#define	PRIdFAST64	__PRI64"d"	/* int_fast64_t */
#define	PRIdMAX		"jd"		/* intmax_t */
#define	PRIdPTR		__PRIptr"d"	/* intptr_t */

#define	PRIi8		"i"		/* int8_t */
#define	PRIi16		"i"		/* int16_t */
#define	PRIi32		"i"		/* int32_t */
#define	PRIi64		__PRI64"i"	/* int64_t */
#define	PRIiLEAST8	"i"		/* int_least8_t  */
#define	PRIiLEAST16	"i"		/* int_least16_t */
#define	PRIiLEAST32	"i"		/* int_least32_t */
#define	PRIiLEAST64	__PRI64"i"	/* int_least64_t */
#define	PRIiFAST8	"i"		/* int_fast8_t */
#define	PRIiFAST16	"i"		/* int_fast16_t */
#define	PRIiFAST32	"i"		/* int_fast32_t */
#define	PRIiFAST64	__PRI64"i"	/* int_fast64_t */
#define	PRIiMAX		"ji"		/* intmax_t */
#define	PRIiPTR		__PRIptr"i"	/* intptr_t */

/* fprintf(3) macros for unsigned integers. */

#define	PRIo8		"o"		/* uint8_t */
#define	PRIo16		"o"		/* uint16_t */
#define	PRIo32		"o"		/* uint32_t */
#define	PRIo64		__PRI64"o"	/* uint64_t */
#define	PRIoLEAST8	"o"		/* uint_least8_t */
#define	PRIoLEAST16	"o"		/* uint_least16_t */
#define	PRIoLEAST32	"o"		/* uint_least32_t */
#define	PRIoLEAST64	__PRI64"o"	/* uint_least64_t */
#define	PRIoFAST8	"o"		/* uint_fast8_t */
#define	PRIoFAST16	"o"		/* uint_fast16_t */
#define	PRIoFAST32	"o"		/* uint_fast32_t */
#define	PRIoFAST64	__PRI64"o"	/* uint_fast64_t */
#define	PRIoMAX		"jo"		/* uintmax_t */
#define	PRIoPTR		__PRIptr"o"	/* uintptr_t */

#define	PRIu8		"u"		/* uint8_t */
#define	PRIu16		"u"		/* uint16_t */
#define	PRIu32		"u"		/* uint32_t */
#define	PRIu64		__PRI64"u"	/* uint64_t */
#define	PRIuLEAST8	"u"		/* uint_least8_t */
#define	PRIuLEAST16	"u"		/* uint_least16_t */
#define	PRIuLEAST32	"u"		/* uint_least32_t */
#define	PRIuLEAST64	__PRI64"u"	/* uint_least64_t */
#define	PRIuFAST8	"u"		/* uint_fast8_t */
#define	PRIuFAST16	"u"		/* uint_fast16_t */
#define	PRIuFAST32	"u"		/* uint_fast32_t */
#define	PRIuFAST64	__PRI64"u"	/* uint_fast64_t */
#define	PRIuMAX		"ju"		/* uintmax_t */
#define	PRIuPTR		__PRIptr"u"	/* uintptr_t */

#define	PRIx8		"x"		/* uint8_t */
#define	PRIx16		"x"		/* uint16_t */
#define	PRIx32		"x"		/* uint32_t */
#define	PRIx64		__PRI64"x"	/* uint64_t */
#define	PRIxLEAST8	"x"		/* uint_least8_t */
#define	PRIxLEAST16	"x"		/* uint_least16_t */
#define	PRIxLEAST32	"x"		/* uint_least32_t */
#define	PRIxLEAST64	__PRI64"x"	/* uint_least64_t */
#define	PRIxFAST8	"x"		/* uint_fast8_t */
#define	PRIxFAST16	"x"		/* uint_fast16_t */
#define	PRIxFAST32	"x"		/* uint_fast32_t */
#define	PRIxFAST64	__PRI64"x"	/* uint_fast64_t */
#define	PRIxMAX		"jx"		/* uintmax_t */
#define	PRIxPTR		__PRIptr"x"	/* uintptr_t */

#define	PRIX8		"X"		/* uint8_t */
#define	PRIX16		"X"		/* uint16_t */
#define	PRIX32		"X"		/* uint32_t */
#define	PRIX64		__PRI64"X"	/* uint64_t */
#define	PRIXLEAST8	"X"		/* uint_least8_t */
#define	PRIXLEAST16	"X"		/* uint_least16_t */
#define	PRIXLEAST32	"X"		/* uint_least32_t */
#define	PRIXLEAST64	__PRI64"X"	/* uint_least64_t */
#define	PRIXFAST8	"X"		/* uint_fast8_t */
#define	PRIXFAST16	"X"		/* uint_fast16_t */
#define	PRIXFAST32	"X"		/* uint_fast32_t */
#define	PRIXFAST64	__PRI64"X"	/* uint_fast64_t */
#define	PRIXMAX		"jX"		/* uintmax_t */
#define	PRIXPTR		__PRIptr"X"	/* uintptr_t */

/* fscanf(3) macros for signed integers. */

#define	SCNd8		"hhd"		/* int8_t */
#define	SCNd16		"hd"		/* int16_t */
#define	SCNd32		"d"		/* int32_t */
#define	SCNd64		__PRI64"d"	/* int64_t */
#define	SCNdLEAST8	"hhd"		/* int_least8_t */
#define	SCNdLEAST16	"hd"		/* int_least16_t */
#define	SCNdLEAST32	"d"		/* int_least32_t */
#define	SCNdLEAST64	__PRI64"d"	/* int_least64_t */
#define	SCNdFAST8	"d"		/* int_fast8_t */
#define	SCNdFAST16	"d"		/* int_fast16_t */
#define	SCNdFAST32	"d"		/* int_fast32_t */
#define	SCNdFAST64	__PRI64"d"	/* int_fast64_t */
#define	SCNdMAX		"jd"		/* intmax_t */
#define	SCNdPTR		__PRIptr"d"	/* intptr_t */

#define	SCNi8		"hhi"		/* int8_t */
#define	SCNi16		"hi"		/* int16_t */
#define	SCNi32		"i"		/* int32_t */
#define	SCNi64		__PRI64"i"	/* int64_t */
#define	SCNiLEAST8	"hhi"		/* int_least8_t */
#define	SCNiLEAST16	"hi"		/* int_least16_t */
#define	SCNiLEAST32	"i"		/* int_least32_t */
#define	SCNiLEAST64	__PRI64"i"	/* int_least64_t */
#define	SCNiFAST8	"i"		/* int_fast8_t */
#define	SCNiFAST16	"i"		/* int_fast16_t */
#define	SCNiFAST32	"i"		/* int_fast32_t */
#define	SCNiFAST64	__PRI64"i"	/* int_fast64_t */
#define	SCNiMAX		"ji"		/* intmax_t */
#define	SCNiPTR		__PRIptr"i"	/* intptr_t */

/* fscanf(3) macros for unsigned integers. */

#define	SCNo8		"hho"		/* uint8_t */
#define	SCNo16		"ho"		/* uint16_t */
#define	SCNo32		"o"		/* uint32_t */
#define	SCNo64		__PRI64"o"	/* uint64_t */
#define	SCNoLEAST8	"hho"		/* uint_least8_t */
#define	SCNoLEAST16	"ho"		/* uint_least16_t */
#define	SCNoLEAST32	"o"		/* uint_least32_t */
#define	SCNoLEAST64	__PRI64"o"	/* uint_least64_t */
#define	SCNoFAST8	"o"		/* uint_fast8_t */
#define	SCNoFAST16	"o"		/* uint_fast16_t */
#define	SCNoFAST32	"o"		/* uint_fast32_t */
#define	SCNoFAST64	__PRI64"o"	/* uint_fast64_t */
#define	SCNoMAX		"jo"		/* uintmax_t */
#define	SCNoPTR		__PRIptr"o"	/* uintptr_t */

#define	SCNu8		"hhu"		/* uint8_t */
#define	SCNu16		"hu"		/* uint16_t */
#define	SCNu32		"u"		/* uint32_t */
#define	SCNu64		__PRI64"u"	/* uint64_t */
#define	SCNuLEAST8	"hhu"		/* uint_least8_t */
#define	SCNuLEAST16	"hu"		/* uint_least16_t */
#define	SCNuLEAST32	"u"		/* uint_least32_t */
#define	SCNuLEAST64	__PRI64"u"	/* uint_least64_t */
#define	SCNuFAST8	"u"		/* uint_fast8_t */
#define	SCNuFAST16	"u"		/* uint_fast16_t */
#define	SCNuFAST32	"u"		/* uint_fast32_t */
#define	SCNuFAST64	__PRI64"u"	/* uint_fast64_t */
#define	SCNuMAX		"ju"		/* uintmax_t */
#define	SCNuPTR		__PRIptr"u"	/* uintptr_t */

#define	SCNx8		"hhx"		/* uint8_t */
#define	SCNx16		"hx"		/* uint16_t */
#define	SCNx32		"x"		/* uint32_t */
#define	SCNx64		__PRI64"x"	/* uint64_t */
#define	SCNxLEAST8	"hhx"		/* uint_least8_t */
#define	SCNxLEAST16	"hx"		/* uint_least16_t */
#define	SCNxLEAST32	"x"		/* uint_least32_t */
#define	SCNxLEAST64	__PRI64"x"	/* uint_least64_t */
#define	SCNxFAST8	"x"		/* uint_fast8_t */
#define	SCNxFAST16	"x"		/* uint_fast16_t */
#define	SCNxFAST32	"x"		/* uint_fast32_t */
#define	SCNxFAST64	__PRI64"x"	/* uint_fast64_t */
#define	SCNxMAX		"jx"		/* uintmax_t */
#define	SCNxPTR		__PRIptr"x"	/* uintptr_t */

#endif /* !_MACHINE_INTTYPES_H_ */
# 222 "/usr/include/x86/_inttypes.h" 3 4
# 7 "/usr/include/machine/_inttypes.h" 2 3 4
# 33 "/usr/include/inttypes.h" 2 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/stdint.h>
#endif /* expanded by -frewrite-includes */
# 33 "/usr/include/inttypes.h" 3 4
# 34 "/usr/include/inttypes.h" 3 4

#ifndef	__cplusplus
#ifndef _WCHAR_T_DECLARED
typedef	___wchar_t	wchar_t;
#define	_WCHAR_T_DECLARED
#endif
# 40 "/usr/include/inttypes.h" 3 4
#endif
# 41 "/usr/include/inttypes.h" 3 4

typedef struct {
	intmax_t	quot;		/* Quotient. */
	intmax_t	rem;		/* Remainder. */
} imaxdiv_t;

__BEGIN_DECLS
#ifdef _XLOCALE_H_
#if 0 /* expanded by -frewrite-includes */
#include <xlocale/_inttypes.h>
#endif /* expanded by -frewrite-includes */
# 49 "/usr/include/inttypes.h" 3 4
# 50 "/usr/include/inttypes.h" 3 4
#endif
# 51 "/usr/include/inttypes.h" 3 4
intmax_t	imaxabs(intmax_t) __pure2;
imaxdiv_t	imaxdiv(intmax_t, intmax_t) __pure2;

intmax_t	strtoimax(const char * __restrict, char ** __restrict, int);
uintmax_t	strtoumax(const char * __restrict, char ** __restrict, int);
intmax_t	wcstoimax(const wchar_t * __restrict,
		    wchar_t ** __restrict, int);
uintmax_t	wcstoumax(const wchar_t * __restrict,
		    wchar_t ** __restrict, int);
__END_DECLS

#endif /* !_INTTYPES_H_ */
# 63 "/usr/include/inttypes.h" 3 4
# 20 "include/libbb.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <netdb.h>
#endif /* expanded by -frewrite-includes */
# 20 "include/libbb.h"
# 1 "/usr/include/netdb.h" 1 3 4
/*-
 * Copyright (c) 1980, 1983, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * -
 * Portions Copyright (c) 1993 by Digital Equipment Corporation.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies, and that
 * the name of Digital Equipment Corporation not be used in advertising or
 * publicity pertaining to distribution of the document or software without
 * specific, written prior permission.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT
 * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 * -
 * --Copyright--
 */

/*
 *      @(#)netdb.h	8.1 (Berkeley) 6/2/93
 *      From: Id: netdb.h,v 8.9 1996/11/19 08:39:29 vixie Exp $
 * $FreeBSD: releng/11.0/include/netdb.h 301711 2016-06-09 01:28:44Z markj $
 */

#ifndef _NETDB_H_
#define _NETDB_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 60 "/usr/include/netdb.h" 3 4
# 61 "/usr/include/netdb.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 61 "/usr/include/netdb.h" 3 4
# 62 "/usr/include/netdb.h" 3 4

#ifndef _IN_ADDR_T_DECLARED
typedef	__uint32_t	in_addr_t;
#define	_IN_ADDR_T_DECLARED
#endif
# 67 "/usr/include/netdb.h" 3 4

#ifndef _IN_PORT_T_DECLARED
typedef	__uint16_t	in_port_t;
#define	_IN_PORT_T_DECLARED
#endif
# 72 "/usr/include/netdb.h" 3 4

#ifndef _SIZE_T_DECLARED
typedef	__size_t	size_t;
#define	_SIZE_T_DECLARED
#endif
# 77 "/usr/include/netdb.h" 3 4

#ifndef _SOCKLEN_T_DECLARED
typedef	__socklen_t	socklen_t;
#define	_SOCKLEN_T_DECLARED
#endif
# 82 "/usr/include/netdb.h" 3 4

#ifndef _UINT32_T_DECLARED
typedef	__uint32_t	uint32_t;
#define	_UINT32_T_DECLARED
#endif
# 87 "/usr/include/netdb.h" 3 4

#ifndef _PATH_HEQUIV
# define	_PATH_HEQUIV	"/etc/hosts.equiv"
#endif
# 91 "/usr/include/netdb.h" 3 4
#define	_PATH_HOSTS	"/etc/hosts"
#define	_PATH_NETWORKS	"/etc/networks"
#define	_PATH_PROTOCOLS	"/etc/protocols"
#define	_PATH_SERVICES	"/etc/services"
#define	_PATH_SERVICES_DB "/var/db/services.db"

#define	h_errno (*__h_errno())

/*
 * Structures returned by network data base library.  All addresses are
 * supplied in host order, and returned in network order (suitable for
 * use in system calls).
 */
struct hostent {
	char	*h_name;	/* official name of host */
	char	**h_aliases;	/* alias list */
	int	h_addrtype;	/* host address type */
	int	h_length;	/* length of address */
	char	**h_addr_list;	/* list of addresses from name server */
#define	h_addr	h_addr_list[0]	/* address, for backward compatibility */
};

struct netent {
	char		*n_name;	/* official name of net */
	char		**n_aliases;	/* alias list */
	int		n_addrtype;	/* net address type */
	uint32_t	n_net;		/* network # */
};

struct servent {
	char	*s_name;	/* official service name */
	char	**s_aliases;	/* alias list */
	int	s_port;		/* port # */
	char	*s_proto;	/* protocol to use */
};

struct protoent {
	char	*p_name;	/* official protocol name */
	char	**p_aliases;	/* alias list */
	int	p_proto;	/* protocol # */
};

struct addrinfo {
	int	ai_flags;	/* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */
	int	ai_family;	/* AF_xxx */
	int	ai_socktype;	/* SOCK_xxx */
	int	ai_protocol;	/* 0 or IPPROTO_xxx for IPv4 and IPv6 */
	socklen_t ai_addrlen;	/* length of ai_addr */
	char	*ai_canonname;	/* canonical name for hostname */
	struct	sockaddr *ai_addr;	/* binary address */
	struct	addrinfo *ai_next;	/* next structure in linked list */
};

#define	IPPORT_RESERVED	1024

/*
 * Error return codes from gethostbyname() and gethostbyaddr()
 * (left in h_errno).
 */

#define	NETDB_INTERNAL	-1	/* see errno */
#define	NETDB_SUCCESS	0	/* no problem */
#define	HOST_NOT_FOUND	1 /* Authoritative Answer Host not found */
#define	TRY_AGAIN	2 /* Non-Authoritative Host not found, or SERVERFAIL */
#define	NO_RECOVERY	3 /* Non recoverable errors, FORMERR, REFUSED, NOTIMP */
#define	NO_DATA		4 /* Valid name, no data record of requested type */
#define	NO_ADDRESS	NO_DATA		/* no address, look for MX record */

/*
 * Error return codes from getaddrinfo()
 */
#if 0
/* obsoleted */
#define	EAI_ADDRFAMILY	 1	/* address family for hostname not supported */
#endif
# 166 "/usr/include/netdb.h" 3 4
#define	EAI_AGAIN	 2	/* temporary failure in name resolution */
#define	EAI_BADFLAGS	 3	/* invalid value for ai_flags */
#define	EAI_FAIL	 4	/* non-recoverable failure in name resolution */
#define	EAI_FAMILY	 5	/* ai_family not supported */
#define	EAI_MEMORY	 6	/* memory allocation failure */
#if 0
/* obsoleted */
#define	EAI_NODATA	 7	/* no address associated with hostname */
#endif
# 175 "/usr/include/netdb.h" 3 4
#define	EAI_NONAME	 8	/* hostname nor servname provided, or not known */
#define	EAI_SERVICE	 9	/* servname not supported for ai_socktype */
#define	EAI_SOCKTYPE	10	/* ai_socktype not supported */
#define	EAI_SYSTEM	11	/* system error returned in errno */
#define	EAI_BADHINTS	12	/* invalid value for hints */
#define	EAI_PROTOCOL	13	/* resolved protocol is unknown */
#define	EAI_OVERFLOW	14	/* argument buffer overflow */
#define	EAI_MAX		15

/*
 * Flag values for getaddrinfo()
 */
#define	AI_PASSIVE	0x00000001 /* get address to use bind() */
#define	AI_CANONNAME	0x00000002 /* fill ai_canonname */
#define	AI_NUMERICHOST	0x00000004 /* prevent host name resolution */
#define	AI_NUMERICSERV	0x00000008 /* prevent service name resolution */
/* valid flags for addrinfo (not a standard def, apps should not use it) */
#define AI_MASK \
    (AI_PASSIVE | AI_CANONNAME | AI_NUMERICHOST | AI_NUMERICSERV | \
    AI_ADDRCONFIG | AI_ALL | AI_V4MAPPED)

#define	AI_ALL		0x00000100 /* IPv6 and IPv4-mapped (with AI_V4MAPPED) */
#define	AI_V4MAPPED_CFG	0x00000200 /* accept IPv4-mapped if kernel supports */
#define	AI_ADDRCONFIG	0x00000400 /* only if any address is assigned */
#define	AI_V4MAPPED	0x00000800 /* accept IPv4-mapped IPv6 address */
/* special recommended flags for getipnodebyname */
#define	AI_DEFAULT	(AI_V4MAPPED_CFG | AI_ADDRCONFIG)

/*
 * Constants for getnameinfo()
 */
#define	NI_MAXHOST	1025
#define	NI_MAXSERV	32

/*
 * Flag values for getnameinfo()
 */
#define	NI_NOFQDN	0x00000001
#define	NI_NUMERICHOST	0x00000002
#define	NI_NAMEREQD	0x00000004
#define	NI_NUMERICSERV	0x00000008
#define	NI_DGRAM	0x00000010
#if 0 /* obsolete */
#define NI_WITHSCOPEID	0x00000020
#endif
# 220 "/usr/include/netdb.h" 3 4

/*
 * Scope delimit character
 */
#define	SCOPE_DELIMITER	'%'

__BEGIN_DECLS
void		endhostent(void);
void		endnetent(void);
void		endprotoent(void);
void		endservent(void);
#if __BSD_VISIBLE || (__POSIX_VISIBLE && __POSIX_VISIBLE <= 200112)
struct hostent	*gethostbyaddr(const void *, socklen_t, int);
struct hostent	*gethostbyname(const char *);
#endif
# 235 "/usr/include/netdb.h" 3 4
struct hostent	*gethostent(void);
struct netent	*getnetbyaddr(uint32_t, int);
struct netent	*getnetbyname(const char *);
struct netent	*getnetent(void);
struct protoent	*getprotobyname(const char *);
struct protoent	*getprotobynumber(int);
struct protoent	*getprotoent(void);
struct servent	*getservbyname(const char *, const char *);
struct servent	*getservbyport(int, const char *);
struct servent	*getservent(void);
void		sethostent(int);
/* void		sethostfile(const char *); */
void		setnetent(int);
void		setprotoent(int);
int		getaddrinfo(const char *, const char *,
			    const struct addrinfo *, struct addrinfo **);
int		getnameinfo(const struct sockaddr *, socklen_t, char *,
			    size_t, char *, size_t, int);
void		freeaddrinfo(struct addrinfo *);
const char	*gai_strerror(int);
void		setservent(int);

#if __BSD_VISIBLE
void		endnetgrent(void);
void		freehostent(struct hostent *);
int		gethostbyaddr_r(const void *, socklen_t, int, struct hostent *,
    char *, size_t, struct hostent **, int *);
int		gethostbyname_r(const char *, struct hostent *, char *, size_t,
    struct hostent **, int *);
struct hostent	*gethostbyname2(const char *, int);
int		gethostbyname2_r(const char *, int, struct hostent *, char *,
    size_t, struct hostent **, int *);
int		gethostent_r(struct hostent *, char *, size_t,
    struct hostent **, int *);
struct hostent	*getipnodebyaddr(const void *, size_t, int, int *);
struct hostent	*getipnodebyname(const char *, int, int, int *);
int		getnetbyaddr_r(uint32_t, int, struct netent *, char *, size_t,
    struct netent**, int *);
int		getnetbyname_r(const char *, struct netent *, char *, size_t,
    struct netent **, int *);
int		getnetent_r(struct netent *, char *, size_t, struct netent **,
    int *);
int		getnetgrent(char **, char **, char **);
int		getnetgrent_r(char **, char **, char **, char *, size_t);
int		getprotobyname_r(const char *, struct protoent *, char *,
    size_t, struct protoent **);
int		getprotobynumber_r(int, struct protoent *, char *, size_t,
    struct protoent **);
int		getprotoent_r(struct protoent *, char *, size_t,
    struct protoent **);
int		getservbyname_r(const char *, const char *, struct servent *,
    char *, size_t, struct servent **);
int		getservbyport_r(int, const char *, struct servent *, char *,
    size_t, struct servent **);
int		getservent_r(struct servent *, char *, size_t,
    struct servent **);
void		herror(const char *);
const char	*hstrerror(int);
int		innetgr(const char *, const char *, const char *, const char *);
void		setnetgrent(const char *);
#endif
# 296 "/usr/include/netdb.h" 3 4


/*
 * PRIVATE functions specific to the FreeBSD implementation
 */

/* DO NOT USE THESE, THEY ARE SUBJECT TO CHANGE AND ARE NOT PORTABLE!!! */
int	* __h_errno(void);
__END_DECLS

#endif /* !_NETDB_H_ */
# 307 "/usr/include/netdb.h" 3 4
# 21 "include/libbb.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <setjmp.h>
#endif /* expanded by -frewrite-includes */
# 21 "include/libbb.h"
# 22 "include/libbb.h"
#if 0 /* expanded by -frewrite-includes */
#include <signal.h>
#endif /* expanded by -frewrite-includes */
# 22 "include/libbb.h"
# 1 "/usr/include/signal.h" 1 3 4
/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)signal.h	8.3 (Berkeley) 3/30/94
 * $FreeBSD: releng/11.0/include/signal.h 300997 2016-05-30 13:51:27Z ed $
 */

#ifndef _SIGNAL_H_
#define	_SIGNAL_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/signal.h" 3 4
# 37 "/usr/include/signal.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 37 "/usr/include/signal.h" 3 4
# 38 "/usr/include/signal.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/signal.h>
#endif /* expanded by -frewrite-includes */
# 38 "/usr/include/signal.h" 3 4
# 1 "/usr/include/sys/signal.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)signal.h	8.4 (Berkeley) 5/4/95
 * $FreeBSD: releng/11.0/sys/sys/signal.h 301071 2016-05-31 19:05:41Z ed $
 */

#ifndef _SYS_SIGNAL_H_
#define	_SYS_SIGNAL_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 41 "/usr/include/sys/signal.h" 3 4
# 42 "/usr/include/sys/signal.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 42 "/usr/include/sys/signal.h" 3 4
# 43 "/usr/include/sys/signal.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_sigset.h>
#endif /* expanded by -frewrite-includes */
# 43 "/usr/include/sys/signal.h" 3 4
# 44 "/usr/include/sys/signal.h" 3 4

#if 0 /* expanded by -frewrite-includes */
#include <machine/_limits.h>	/* __MINSIGSTKSZ */
#endif /* expanded by -frewrite-includes */
# 45 "/usr/include/sys/signal.h" 3 4
# 1 "/usr/include/machine/_limits.h" 1 3 4
/*-
 * This file is in the public domain.
 */
/* $FreeBSD: releng/11.0/sys/amd64/include/_limits.h 232262 2012-02-28 18:24:28Z tijl $ */

#if 0 /* expanded by -frewrite-includes */
#include <x86/_limits.h>
#endif /* expanded by -frewrite-includes */
# 6 "/usr/include/machine/_limits.h" 3 4
# 7 "/usr/include/machine/_limits.h" 3 4
# 46 "/usr/include/sys/signal.h" 2 3 4
#if 0 /* expanded by -frewrite-includes */
#include <machine/signal.h>	/* sig_atomic_t; trap codes; sigcontext */
#endif /* expanded by -frewrite-includes */
# 46 "/usr/include/sys/signal.h" 3 4
# 1 "/usr/include/machine/signal.h" 1 3 4
/*-
 * This file is in the public domain.
 */
/* $FreeBSD: releng/11.0/sys/amd64/include/signal.h 247047 2013-02-20 17:39:52Z kib $ */

#if 0 /* expanded by -frewrite-includes */
#include <x86/signal.h>
#endif /* expanded by -frewrite-includes */
# 6 "/usr/include/machine/signal.h" 3 4
# 1 "/usr/include/x86/signal.h" 1 3 4
/*-
 * Copyright (c) 1986, 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 2003 Peter Wemm.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)signal.h	8.1 (Berkeley) 6/11/93
 * $FreeBSD: releng/11.0/sys/x86/include/signal.h 247047 2013-02-20 17:39:52Z kib $
 */

#ifndef _X86_SIGNAL_H
#define	_X86_SIGNAL_H 1

/*
 * Machine-dependent signal definitions
 */

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 41 "/usr/include/x86/signal.h" 3 4
# 42 "/usr/include/x86/signal.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_sigset.h>
#endif /* expanded by -frewrite-includes */
# 42 "/usr/include/x86/signal.h" 3 4
# 43 "/usr/include/x86/signal.h" 3 4

#if __BSD_VISIBLE
#if 0 /* expanded by -frewrite-includes */
#include <machine/trap.h>	/* codes for SIGILL, SIGFPE */
#endif /* expanded by -frewrite-includes */
# 45 "/usr/include/x86/signal.h" 3 4
# 1 "/usr/include/machine/trap.h" 1 3 4
/*-
 * This file is in the public domain.
 */
/* $FreeBSD: releng/11.0/sys/amd64/include/trap.h 232492 2012-03-04 14:12:57Z tijl $ */

#if 0 /* expanded by -frewrite-includes */
#include <x86/trap.h>
#endif /* expanded by -frewrite-includes */
# 6 "/usr/include/machine/trap.h" 3 4
# 1 "/usr/include/x86/trap.h" 1 3 4
/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @(#)trap.h	5.4 (Berkeley) 5/9/91
 * $FreeBSD: releng/11.0/sys/x86/include/trap.h 257417 2013-10-31 02:35:00Z markj $
 */

#ifndef _MACHINE_TRAP_H_
#define	_MACHINE_TRAP_H_

/*
 * Trap type values
 * also known in trap.c for name strings
 */

#define	T_PRIVINFLT	1	/* privileged instruction */
#define	T_BPTFLT	3	/* breakpoint instruction */
#define	T_ARITHTRAP	6	/* arithmetic trap */
#define	T_PROTFLT	9	/* protection fault */
#define	T_TRCTRAP	10	/* debug exception (sic) */
#define	T_PAGEFLT	12	/* page fault */
#define	T_ALIGNFLT	14	/* alignment fault */

#define	T_DIVIDE	18	/* integer divide fault */
#define	T_NMI		19	/* non-maskable trap */
#define	T_OFLOW		20	/* overflow trap */
#define	T_BOUND		21	/* bound instruction fault */
#define	T_DNA		22	/* device not available fault */
#define	T_DOUBLEFLT	23	/* double fault */
#define	T_FPOPFLT	24	/* fp coprocessor operand fetch fault */
#define	T_TSSFLT	25	/* invalid tss fault */
#define	T_SEGNPFLT	26	/* segment not present fault */
#define	T_STKFLT	27	/* stack fault */
#define	T_MCHK		28	/* machine check trap */
#define	T_XMMFLT	29	/* SIMD floating-point exception */
#define	T_RESERVED	30	/* reserved (unknown) */
#define	T_DTRACE_RET	32	/* DTrace pid return */

/* XXX most of the following codes aren't used, but could be. */

/* definitions for <sys/signal.h> */
#define	    ILL_RESAD_FAULT	T_RESADFLT
#define	    ILL_PRIVIN_FAULT	T_PRIVINFLT
#define	    ILL_RESOP_FAULT	T_RESOPFLT
#define	    ILL_ALIGN_FAULT	T_ALIGNFLT
#define	    ILL_FPOP_FAULT	T_FPOPFLT	/* coprocessor operand fault */

/* old FreeBSD macros, deprecated */
#define	FPE_INTOVF_TRAP	0x1	/* integer overflow */
#define	FPE_INTDIV_TRAP	0x2	/* integer divide by zero */
#define	FPE_FLTDIV_TRAP	0x3	/* floating/decimal divide by zero */
#define	FPE_FLTOVF_TRAP	0x4	/* floating overflow */
#define	FPE_FLTUND_TRAP	0x5	/* floating underflow */
#define	FPE_FPU_NP_TRAP	0x6	/* floating point unit not present  */
#define	FPE_SUBRNG_TRAP	0x7	/* subrange out of bounds */

/* codes for SIGBUS */
#define	    BUS_PAGE_FAULT	T_PAGEFLT	/* page fault protection base */
#define	    BUS_SEGNP_FAULT	T_SEGNPFLT	/* segment not present */
#define	    BUS_STK_FAULT	T_STKFLT	/* stack segment */
#define	    BUS_SEGM_FAULT	T_RESERVED	/* segment protection base */

/* Trap's coming from user mode */
#define	T_USER	0x100

#endif /* !_MACHINE_TRAP_H_ */
# 95 "/usr/include/x86/trap.h" 3 4
# 7 "/usr/include/machine/trap.h" 2 3 4
# 46 "/usr/include/x86/signal.h" 2 3 4
#endif
# 47 "/usr/include/x86/signal.h" 3 4

#ifdef __i386__
typedef int sig_atomic_t;

#if __BSD_VISIBLE
struct sigcontext {
	struct __sigset sc_mask;	/* signal mask to restore */
	int	sc_onstack;		/* sigstack state to restore */
	int	sc_gs;			/* machine state (struct trapframe) */
	int	sc_fs;
	int	sc_es;
	int	sc_ds;
	int	sc_edi;
	int	sc_esi;
	int	sc_ebp;
	int	sc_isp;
	int	sc_ebx;
	int	sc_edx;
	int	sc_ecx;
	int	sc_eax;
	int	sc_trapno;
	int	sc_err;
	int	sc_eip;
	int	sc_cs;
	int	sc_efl;
	int	sc_esp;
	int	sc_ss;
	int	sc_len;			/* sizeof(mcontext_t) */
	/*
	 * See <machine/ucontext.h> and <machine/npx.h> for
	 * the following fields.
	 */
	int	sc_fpformat;
	int	sc_ownedfp;
	int	sc_flags;
	int	sc_fpstate[128] __aligned(16);

	int	sc_fsbase;
	int	sc_gsbase;

	int	sc_xfpustate;
	int	sc_xfpustate_len;

	int	sc_spare2[4];
};

#define	sc_sp		sc_esp
#define	sc_fp		sc_ebp
#define	sc_pc		sc_eip
#define	sc_ps		sc_efl
#define	sc_eflags	sc_efl

#endif /* __BSD_VISIBLE */
# 100 "/usr/include/x86/signal.h" 3 4
#endif /* __i386__ */
# 101 "/usr/include/x86/signal.h" 3 4

#ifdef __amd64__
typedef long sig_atomic_t;

#if __BSD_VISIBLE
/*
 * Information pushed on stack when a signal is delivered.
 * This is used by the kernel to restore state following
 * execution of the signal handler.  It is also made available
 * to the handler to allow it to restore state properly if
 * a non-standard exit is performed.
 *
 * The sequence of the fields/registers after sc_mask in struct
 * sigcontext must match those in mcontext_t and struct trapframe.
 */
struct sigcontext {
	struct __sigset sc_mask;	/* signal mask to restore */
	long	sc_onstack;		/* sigstack state to restore */
	long	sc_rdi;		/* machine state (struct trapframe) */
	long	sc_rsi;
	long	sc_rdx;
	long	sc_rcx;
	long	sc_r8;
	long	sc_r9;
	long	sc_rax;
	long	sc_rbx;
	long	sc_rbp;
	long	sc_r10;
	long	sc_r11;
	long	sc_r12;
	long	sc_r13;
	long	sc_r14;
	long	sc_r15;
	int	sc_trapno;
	short	sc_fs;
	short	sc_gs;
	long	sc_addr;
	int	sc_flags;
	short	sc_es;
	short	sc_ds;
	long	sc_err;
	long	sc_rip;
	long	sc_cs;
	long	sc_rflags;
	long	sc_rsp;
	long	sc_ss;
	long	sc_len;			/* sizeof(mcontext_t) */
	/*
	 * See <machine/ucontext.h> and <machine/fpu.h> for the following
	 * fields.
	 */
	long	sc_fpformat;
	long	sc_ownedfp;
	long	sc_fpstate[64] __aligned(16);

	long	sc_fsbase;
	long	sc_gsbase;

	long	sc_xfpustate;
	long	sc_xfpustate_len;

	long	sc_spare[4];
};
#endif /* __BSD_VISIBLE */
# 165 "/usr/include/x86/signal.h" 3 4
#endif /* __amd64__ */
# 166 "/usr/include/x86/signal.h" 3 4

#endif
# 168 "/usr/include/x86/signal.h" 3 4
# 7 "/usr/include/machine/signal.h" 2 3 4
# 47 "/usr/include/sys/signal.h" 2 3 4

#if __POSIX_VISIBLE >= 200809

#if 0 /* expanded by -frewrite-includes */
#include <sys/_pthreadtypes.h>
#endif /* expanded by -frewrite-includes */
# 50 "/usr/include/sys/signal.h" 3 4
# 51 "/usr/include/sys/signal.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_timespec.h>
#endif /* expanded by -frewrite-includes */
# 51 "/usr/include/sys/signal.h" 3 4
# 52 "/usr/include/sys/signal.h" 3 4

#ifndef _SIZE_T_DECLARED
typedef	__size_t	size_t;
#define	_SIZE_T_DECLARED
#endif
# 57 "/usr/include/sys/signal.h" 3 4

#ifndef _UID_T_DECLARED
typedef	__uid_t		uid_t;
#define	_UID_T_DECLARED
#endif
# 62 "/usr/include/sys/signal.h" 3 4

#endif /* __POSIX_VISIBLE >= 200809 */
# 64 "/usr/include/sys/signal.h" 3 4

/*
 * System defined signals.
 */
#if __POSIX_VISIBLE || __XSI_VISIBLE
#define	SIGHUP		1	/* hangup */
#endif
# 71 "/usr/include/sys/signal.h" 3 4
#define	SIGINT		2	/* interrupt */
#if __POSIX_VISIBLE || __XSI_VISIBLE
#define	SIGQUIT		3	/* quit */
#endif
# 75 "/usr/include/sys/signal.h" 3 4
#define	SIGILL		4	/* illegal instr. (not reset when caught) */
#if __XSI_VISIBLE
#define	SIGTRAP		5	/* trace trap (not reset when caught) */
#endif
# 79 "/usr/include/sys/signal.h" 3 4
#define	SIGABRT		6	/* abort() */
#if __BSD_VISIBLE
#define	SIGIOT		SIGABRT	/* compatibility */
#define	SIGEMT		7	/* EMT instruction */
#endif
# 84 "/usr/include/sys/signal.h" 3 4
#define	SIGFPE		8	/* floating point exception */
#if __POSIX_VISIBLE || __XSI_VISIBLE
#define	SIGKILL		9	/* kill (cannot be caught or ignored) */
#endif
# 88 "/usr/include/sys/signal.h" 3 4
#if __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE
#define	SIGBUS		10	/* bus error */
#endif
# 91 "/usr/include/sys/signal.h" 3 4
#define	SIGSEGV		11	/* segmentation violation */
#if __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE
#define	SIGSYS		12	/* non-existent system call invoked */
#endif
# 95 "/usr/include/sys/signal.h" 3 4
#if __POSIX_VISIBLE || __XSI_VISIBLE
#define	SIGPIPE		13	/* write on a pipe with no one to read it */
#define	SIGALRM		14	/* alarm clock */
#endif
# 99 "/usr/include/sys/signal.h" 3 4
#define	SIGTERM		15	/* software termination signal from kill */
#if __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE
#define	SIGURG		16	/* urgent condition on IO channel */
#endif
# 103 "/usr/include/sys/signal.h" 3 4
#if __POSIX_VISIBLE || __XSI_VISIBLE
#define	SIGSTOP		17	/* sendable stop signal not from tty */
#define	SIGTSTP		18	/* stop signal from tty */
#define	SIGCONT		19	/* continue a stopped process */
#define	SIGCHLD		20	/* to parent on child stop or exit */
#define	SIGTTIN		21	/* to readers pgrp upon background tty read */
#define	SIGTTOU		22	/* like TTIN if (tp->t_local&LTOSTOP) */
#endif
# 111 "/usr/include/sys/signal.h" 3 4
#if __BSD_VISIBLE
#define	SIGIO		23	/* input/output possible signal */
#endif
# 114 "/usr/include/sys/signal.h" 3 4
#if __XSI_VISIBLE
#define	SIGXCPU		24	/* exceeded CPU time limit */
#define	SIGXFSZ		25	/* exceeded file size limit */
#define	SIGVTALRM	26	/* virtual time alarm */
#define	SIGPROF		27	/* profiling time alarm */
#endif
# 120 "/usr/include/sys/signal.h" 3 4
#if __BSD_VISIBLE
#define	SIGWINCH	28	/* window size changes */
#define	SIGINFO		29	/* information request */
#endif
# 124 "/usr/include/sys/signal.h" 3 4
#if __POSIX_VISIBLE || __XSI_VISIBLE
#define	SIGUSR1		30	/* user defined signal 1 */
#define	SIGUSR2		31	/* user defined signal 2 */
#endif
# 128 "/usr/include/sys/signal.h" 3 4
#if __BSD_VISIBLE
#define	SIGTHR		32	/* reserved by thread library. */
#define	SIGLWP		SIGTHR
#define	SIGLIBRT	33	/* reserved by real-time library. */
#endif
# 133 "/usr/include/sys/signal.h" 3 4

#define	SIGRTMIN	65
#define	SIGRTMAX	126

#define	SIG_DFL		((__sighandler_t *)0)
#define	SIG_IGN		((__sighandler_t *)1)
#define	SIG_ERR		((__sighandler_t *)-1)
/* #define	SIG_CATCH	((__sighandler_t *)2) See signalvar.h */
#define SIG_HOLD        ((__sighandler_t *)3)

/*
 * Type of a signal handling function.
 *
 * Language spec sez signal handlers take exactly one arg, even though we
 * actually supply three.  Ugh!
 *
 * We don't try to hide the difference by leaving out the args because
 * that would cause warnings about conformant programs.  Nonconformant
 * programs can avoid the warnings by casting to (__sighandler_t *) or
 * sig_t before calling signal() or assigning to sa_handler or sv_handler.
 *
 * The kernel should reverse the cast before calling the function.  It
 * has no way to do this, but on most machines 1-arg and 3-arg functions
 * have the same calling protocol so there is no problem in practice.
 * A bit in sa_flags could be used to specify the number of args.
 */
typedef	void __sighandler_t(int);

#if __POSIX_VISIBLE || __XSI_VISIBLE
#ifndef _SIGSET_T_DECLARED
#define	_SIGSET_T_DECLARED
typedef	__sigset_t	sigset_t;
#endif
# 166 "/usr/include/sys/signal.h" 3 4
#endif
# 167 "/usr/include/sys/signal.h" 3 4

#if __POSIX_VISIBLE >= 199309 || __XSI_VISIBLE >= 500
union sigval {
	/* Members as suggested by Annex C of POSIX 1003.1b. */
	int	sival_int;
	void	*sival_ptr;
	/* 6.0 compatibility */
	int     sigval_int;
	void    *sigval_ptr;
};
#endif
# 178 "/usr/include/sys/signal.h" 3 4

#if __POSIX_VISIBLE >= 199309

struct pthread_attr;

struct sigevent {
	int	sigev_notify;		/* Notification type */
	int	sigev_signo;		/* Signal number */
	union sigval sigev_value;	/* Signal value */
	union {
		__lwpid_t	_threadid;
		struct {
			void (*_function)(union sigval);
			struct pthread_attr **_attribute;
		} _sigev_thread;
		unsigned short _kevent_flags;
		long __spare__[8];
	} _sigev_un;
};

#if __BSD_VISIBLE
#define	sigev_notify_kqueue		sigev_signo
#define	sigev_notify_kevent_flags	_sigev_un._kevent_flags
#define	sigev_notify_thread_id		_sigev_un._threadid
#endif
# 203 "/usr/include/sys/signal.h" 3 4
#define	sigev_notify_function		_sigev_un._sigev_thread._function
#define	sigev_notify_attributes		_sigev_un._sigev_thread._attribute

#define	SIGEV_NONE	0		/* No async notification. */
#define	SIGEV_SIGNAL	1		/* Generate a queued signal. */
#define	SIGEV_THREAD	2		/* Call back from another pthread. */
#if __BSD_VISIBLE
#define	SIGEV_KEVENT	3		/* Generate a kevent. */
#define	SIGEV_THREAD_ID	4		/* Send signal to a kernel thread. */
#endif
# 213 "/usr/include/sys/signal.h" 3 4

#endif /* __POSIX_VISIBLE >= 199309 */
# 215 "/usr/include/sys/signal.h" 3 4

#if __POSIX_VISIBLE >= 199309 || __XSI_VISIBLE
typedef	struct __siginfo {
	int	si_signo;		/* signal number */
	int	si_errno;		/* errno association */
	/*
	 * Cause of signal, one of the SI_ macros or signal-specific
	 * values, i.e. one of the FPE_... values for SIGFPE.  This
	 * value is equivalent to the second argument to an old-style
	 * FreeBSD signal handler.
	 */
	int	si_code;		/* signal code */
	__pid_t	si_pid;			/* sending process */
	__uid_t	si_uid;			/* sender's ruid */
	int	si_status;		/* exit value */
	void	*si_addr;		/* faulting instruction */
	union sigval si_value;		/* signal value */
	union	{
		struct {
			int	_trapno;/* machine specific trap code */
		} _fault;
		struct {
			int	_timerid;
			int	_overrun;
		} _timer;
		struct {
			int	_mqd;
		} _mesgq;
		struct {
			long	_band;		/* band event for SIGPOLL */
		} _poll;			/* was this ever used ? */
		struct {
			long	__spare1__;
			int	__spare2__[7];
		} __spare__;
	} _reason;
} siginfo_t;

#define si_trapno	_reason._fault._trapno
#define si_timerid	_reason._timer._timerid
#define si_overrun	_reason._timer._overrun
#define si_mqd		_reason._mesgq._mqd
#define si_band		_reason._poll._band

/** si_code **/
/* codes for SIGILL */
#define ILL_ILLOPC 	1	/* Illegal opcode.			*/
#define ILL_ILLOPN 	2	/* Illegal operand.			*/
#define ILL_ILLADR 	3	/* Illegal addressing mode.		*/
#define ILL_ILLTRP 	4	/* Illegal trap.			*/
#define ILL_PRVOPC 	5	/* Privileged opcode.			*/
#define ILL_PRVREG 	6	/* Privileged register.			*/
#define ILL_COPROC 	7	/* Coprocessor error.			*/
#define ILL_BADSTK 	8	/* Internal stack error.		*/

/* codes for SIGBUS */
#define BUS_ADRALN	1	/* Invalid address alignment.		*/
#define BUS_ADRERR	2	/* Nonexistent physical address.	*/
#define BUS_OBJERR	3	/* Object-specific hardware error.	*/

/* codes for SIGSEGV */
#define SEGV_MAPERR	1	/* Address not mapped to object.	*/
#define SEGV_ACCERR	2	/* Invalid permissions for mapped	*/
				/* object.				*/

/* codes for SIGFPE */
#define FPE_INTOVF	1	/* Integer overflow.			*/
#define FPE_INTDIV	2	/* Integer divide by zero.		*/
#define FPE_FLTDIV	3	/* Floating point divide by zero.	*/
#define FPE_FLTOVF	4	/* Floating point overflow.		*/
#define FPE_FLTUND	5	/* Floating point underflow.		*/
#define FPE_FLTRES	6	/* Floating point inexact result.	*/
#define FPE_FLTINV	7	/* Invalid floating point operation.	*/
#define FPE_FLTSUB	8	/* Subscript out of range.		*/

/* codes for SIGTRAP */
#define TRAP_BRKPT	1	/* Process breakpoint.			*/
#define TRAP_TRACE	2	/* Process trace trap.			*/
#define	TRAP_DTRACE	3	/* DTrace induced trap.			*/

/* codes for SIGCHLD */
#define CLD_EXITED	1	/* Child has exited			*/
#define CLD_KILLED	2	/* Child has terminated abnormally but	*/
				/* did not create a core file		*/
#define CLD_DUMPED	3	/* Child has terminated abnormally and	*/
				/* created a core file			*/
#define CLD_TRAPPED	4	/* Traced child has trapped		*/
#define CLD_STOPPED	5	/* Child has stopped			*/
#define CLD_CONTINUED	6	/* Stopped child has continued		*/

/* codes for SIGPOLL */
#define POLL_IN		1	/* Data input available			*/
#define POLL_OUT	2	/* Output buffers available		*/
#define POLL_MSG	3	/* Input message available		*/
#define POLL_ERR	4	/* I/O Error				*/
#define POLL_PRI	5	/* High priority input available	*/
#define POLL_HUP	6	/* Device disconnected			*/

#endif
# 314 "/usr/include/sys/signal.h" 3 4

#if __POSIX_VISIBLE || __XSI_VISIBLE
struct __siginfo;

/*
 * Signal vector "template" used in sigaction call.
 */
struct sigaction {
	union {
		void    (*__sa_handler)(int);
		void    (*__sa_sigaction)(int, struct __siginfo *, void *);
	} __sigaction_u;		/* signal handler */
	int	sa_flags;		/* see signal options below */
	sigset_t sa_mask;		/* signal mask to apply */
};

#define	sa_handler	__sigaction_u.__sa_handler
#endif
# 332 "/usr/include/sys/signal.h" 3 4

#if __XSI_VISIBLE
/* If SA_SIGINFO is set, sa_sigaction must be used instead of sa_handler. */
#define	sa_sigaction	__sigaction_u.__sa_sigaction
#endif
# 337 "/usr/include/sys/signal.h" 3 4

#if __POSIX_VISIBLE || __XSI_VISIBLE
#define	SA_NOCLDSTOP	0x0008	/* do not generate SIGCHLD on child stop */
#endif /* __POSIX_VISIBLE || __XSI_VISIBLE */
# 341 "/usr/include/sys/signal.h" 3 4

#if __XSI_VISIBLE
#define	SA_ONSTACK	0x0001	/* take signal on signal stack */
#define	SA_RESTART	0x0002	/* restart system call on signal return */
#define	SA_RESETHAND	0x0004	/* reset to SIG_DFL when taking signal */
#define	SA_NODEFER	0x0010	/* don't mask the signal we're delivering */
#define	SA_NOCLDWAIT	0x0020	/* don't keep zombies around */
#define	SA_SIGINFO	0x0040	/* signal handler with SA_SIGINFO args */
#endif
# 350 "/usr/include/sys/signal.h" 3 4

#if __BSD_VISIBLE
#define	NSIG		32	/* number of old signals (counting 0) */
#endif
# 354 "/usr/include/sys/signal.h" 3 4

#if __POSIX_VISIBLE || __XSI_VISIBLE
#define	SI_NOINFO	0		/* No signal info besides si_signo. */
#define	SI_USER		0x10001		/* Signal sent by kill(). */
#define	SI_QUEUE	0x10002		/* Signal sent by the sigqueue(). */
#define	SI_TIMER	0x10003		/* Signal generated by expiration of */
					/* a timer set by timer_settime(). */
#define	SI_ASYNCIO	0x10004		/* Signal generated by completion of */
					/* an asynchronous I/O request.*/
#define	SI_MESGQ	0x10005		/* Signal generated by arrival of a */
					/* message on an empty message queue. */
#define	SI_KERNEL	0x10006
#define	SI_LWP		0x10007		/* Signal sent by thr_kill */
#endif
# 368 "/usr/include/sys/signal.h" 3 4
#if __BSD_VISIBLE
#define	SI_UNDEFINED	0
#endif
# 371 "/usr/include/sys/signal.h" 3 4

#if __BSD_VISIBLE
typedef	__sighandler_t	*sig_t;	/* type of pointer to a signal function */
typedef	void __siginfohandler_t(int, struct __siginfo *, void *);
#endif
# 376 "/usr/include/sys/signal.h" 3 4

#if __XSI_VISIBLE
#if __BSD_VISIBLE
#define	__stack_t sigaltstack
#endif
# 381 "/usr/include/sys/signal.h" 3 4
typedef	struct __stack_t stack_t;

#define	SS_ONSTACK	0x0001	/* take signal on alternate stack */
#define	SS_DISABLE	0x0004	/* disable taking signals on alternate stack */
#define	MINSIGSTKSZ	__MINSIGSTKSZ		/* minimum stack size */
#define	SIGSTKSZ	(MINSIGSTKSZ + 32768)	/* recommended stack size */
#endif
# 388 "/usr/include/sys/signal.h" 3 4

/*
 * Structure used in sigaltstack call.  Its definition is always
 * needed for __ucontext.  If __BSD_VISIBLE is defined, the structure
 * tag is actually sigaltstack.
 */
struct __stack_t {
	void	*ss_sp;			/* signal stack base */
	__size_t ss_size;		/* signal stack length */
	int	ss_flags;		/* SS_DISABLE and/or SS_ONSTACK */
};

#if __BSD_VISIBLE
/*
 * 4.3 compatibility:
 * Signal vector "template" used in sigvec call.
 */
struct sigvec {
	__sighandler_t *sv_handler;	/* signal handler */
	int	sv_mask;		/* signal mask to apply */
	int	sv_flags;		/* see signal options below */
};

#define	SV_ONSTACK	SA_ONSTACK
#define	SV_INTERRUPT	SA_RESTART	/* same bit, opposite sense */
#define	SV_RESETHAND	SA_RESETHAND
#define	SV_NODEFER	SA_NODEFER
#define	SV_NOCLDSTOP	SA_NOCLDSTOP
#define	SV_SIGINFO	SA_SIGINFO
#define	sv_onstack	sv_flags	/* isn't compatibility wonderful! */
#endif
# 419 "/usr/include/sys/signal.h" 3 4

/* Keep this in one place only */
#if defined(_KERNEL) && defined(COMPAT_43) && \
    !defined(__i386__)
struct osigcontext {
	int _not_used;
};
#endif
# 427 "/usr/include/sys/signal.h" 3 4

#if __XSI_VISIBLE
/*
 * Structure used in sigstack call.
 */
struct sigstack {
	void	*ss_sp;			/* signal stack pointer */
	int	ss_onstack;		/* current status */
};
#endif
# 437 "/usr/include/sys/signal.h" 3 4

#if __BSD_VISIBLE || __POSIX_VISIBLE > 0 && __POSIX_VISIBLE <= 200112
/*
 * Macro for converting signal number to a mask suitable for
 * sigblock().
 */
#define	sigmask(m)	(1 << ((m)-1))
#endif
# 445 "/usr/include/sys/signal.h" 3 4

#if __BSD_VISIBLE
#define	BADSIG		SIG_ERR
#endif
# 449 "/usr/include/sys/signal.h" 3 4

#if __POSIX_VISIBLE || __XSI_VISIBLE
/*
 * Flags for sigprocmask:
 */
#define	SIG_BLOCK	1	/* block specified signal set */
#define	SIG_UNBLOCK	2	/* unblock specified signal set */
#define	SIG_SETMASK	3	/* set specified signal set */
#endif
# 458 "/usr/include/sys/signal.h" 3 4

/*
 * For historical reasons; programs expect signal's return value to be
 * defined by <sys/signal.h>.
 */
__BEGIN_DECLS
__sighandler_t *signal(int, __sighandler_t *);
__END_DECLS

#endif /* !_SYS_SIGNAL_H_ */
# 468 "/usr/include/sys/signal.h" 3 4
# 39 "/usr/include/signal.h" 2 3 4
#if __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE
#if 0 /* expanded by -frewrite-includes */
#include <machine/ucontext.h>
#endif /* expanded by -frewrite-includes */
# 40 "/usr/include/signal.h" 3 4
# 1 "/usr/include/machine/ucontext.h" 1 3 4
/*-
 * This file is in the public domain.
 */
/* $FreeBSD: releng/11.0/sys/amd64/include/ucontext.h 247047 2013-02-20 17:39:52Z kib $ */

#if 0 /* expanded by -frewrite-includes */
#include <x86/ucontext.h>
#endif /* expanded by -frewrite-includes */
# 6 "/usr/include/machine/ucontext.h" 3 4
# 1 "/usr/include/x86/ucontext.h" 1 3 4
/*-
 * Copyright (c) 2003 Peter Wemm
 * Copyright (c) 1999 Marcel Moolenaar
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer 
 *    in this position and unchanged.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/sys/x86/include/ucontext.h 295561 2016-02-12 07:38:19Z kib $
 */

#ifndef _X86_UCONTEXT_H_
#define	_X86_UCONTEXT_H_

#ifdef __i386__
/* Keep _MC_* values similar to amd64 */
#define	_MC_HASSEGS	0x1
#define	_MC_HASBASES	0x2
#define	_MC_HASFPXSTATE	0x4
#define	_MC_FLAG_MASK	(_MC_HASSEGS | _MC_HASBASES | _MC_HASFPXSTATE)

typedef struct __mcontext {
	/*
	 * The definition of mcontext_t must match the layout of
	 * struct sigcontext after the sc_mask member.  This is so
	 * that we can support sigcontext and ucontext_t at the same
	 * time.
	 */
	__register_t	mc_onstack;	/* XXX - sigcontext compat. */
	__register_t	mc_gs;		/* machine state (struct trapframe) */
	__register_t	mc_fs;
	__register_t	mc_es;
	__register_t	mc_ds;
	__register_t	mc_edi;
	__register_t	mc_esi;
	__register_t	mc_ebp;
	__register_t	mc_isp;
	__register_t	mc_ebx;
	__register_t	mc_edx;
	__register_t	mc_ecx;
	__register_t	mc_eax;
	__register_t	mc_trapno;
	__register_t	mc_err;
	__register_t	mc_eip;
	__register_t	mc_cs;
	__register_t	mc_eflags;
	__register_t	mc_esp;
	__register_t	mc_ss;

	int	mc_len;			/* sizeof(mcontext_t) */
#define	_MC_FPFMT_NODEV		0x10000	/* device not present or configured */
#define	_MC_FPFMT_387		0x10001
#define	_MC_FPFMT_XMM		0x10002
	int	mc_fpformat;
#define	_MC_FPOWNED_NONE	0x20000	/* FP state not used */
#define	_MC_FPOWNED_FPU		0x20001	/* FP state came from FPU */
#define	_MC_FPOWNED_PCB		0x20002	/* FP state came from PCB */
	int	mc_ownedfp;
	__register_t mc_flags;
	/*
	 * See <machine/npx.h> for the internals of mc_fpstate[].
	 */
	int	mc_fpstate[128] __aligned(16);

	__register_t mc_fsbase;
	__register_t mc_gsbase;

	__register_t mc_xfpustate;
	__register_t mc_xfpustate_len;

	int	mc_spare2[4];
} mcontext_t;
#endif /* __i386__ */
# 94 "/usr/include/x86/ucontext.h" 3 4

#ifdef __amd64__
/*
 * mc_trapno bits. Shall be in sync with TF_XXX.
 */
#define	_MC_HASSEGS	0x1
#define	_MC_HASBASES	0x2
#define	_MC_HASFPXSTATE	0x4
#define	_MC_FLAG_MASK	(_MC_HASSEGS | _MC_HASBASES | _MC_HASFPXSTATE)

typedef struct __mcontext {
	/*
	 * The definition of mcontext_t must match the layout of
	 * struct sigcontext after the sc_mask member.  This is so
	 * that we can support sigcontext and ucontext_t at the same
	 * time.
	 */
	__register_t	mc_onstack;	/* XXX - sigcontext compat. */
	__register_t	mc_rdi;		/* machine state (struct trapframe) */
	__register_t	mc_rsi;
	__register_t	mc_rdx;
	__register_t	mc_rcx;
	__register_t	mc_r8;
	__register_t	mc_r9;
	__register_t	mc_rax;
	__register_t	mc_rbx;
	__register_t	mc_rbp;
	__register_t	mc_r10;
	__register_t	mc_r11;
	__register_t	mc_r12;
	__register_t	mc_r13;
	__register_t	mc_r14;
	__register_t	mc_r15;
	__uint32_t	mc_trapno;
	__uint16_t	mc_fs;
	__uint16_t	mc_gs;
	__register_t	mc_addr;
	__uint32_t	mc_flags;
	__uint16_t	mc_es;
	__uint16_t	mc_ds;
	__register_t	mc_err;
	__register_t	mc_rip;
	__register_t	mc_cs;
	__register_t	mc_rflags;
	__register_t	mc_rsp;
	__register_t	mc_ss;

	long	mc_len;			/* sizeof(mcontext_t) */

#define	_MC_FPFMT_NODEV		0x10000	/* device not present or configured */
#define	_MC_FPFMT_XMM		0x10002
	long	mc_fpformat;
#define	_MC_FPOWNED_NONE	0x20000	/* FP state not used */
#define	_MC_FPOWNED_FPU		0x20001	/* FP state came from FPU */
#define	_MC_FPOWNED_PCB		0x20002	/* FP state came from PCB */
	long	mc_ownedfp;
	/*
	 * See <machine/fpu.h> for the internals of mc_fpstate[].
	 */
	long	mc_fpstate[64] __aligned(16);

	__register_t	mc_fsbase;
	__register_t	mc_gsbase;

	__register_t	mc_xfpustate;
	__register_t	mc_xfpustate_len;

	long	mc_spare[4];
} mcontext_t;
#endif /* __amd64__ */
# 164 "/usr/include/x86/ucontext.h" 3 4

#ifdef __LINT__
typedef struct __mcontext {
} mcontext_t;
#endif /* __LINT__ */
# 169 "/usr/include/x86/ucontext.h" 3 4

#endif /* !_X86_UCONTEXT_H_ */
# 171 "/usr/include/x86/ucontext.h" 3 4
# 7 "/usr/include/machine/ucontext.h" 2 3 4
# 41 "/usr/include/signal.h" 2 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_ucontext.h>
#endif /* expanded by -frewrite-includes */
# 41 "/usr/include/signal.h" 3 4
# 1 "/usr/include/sys/_ucontext.h" 1 3 4
/*-
 * Copyright (c) 1999 Marcel Moolenaar
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer 
 *    in this position and unchanged.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/sys/sys/_ucontext.h 295561 2016-02-12 07:38:19Z kib $
 */

#ifndef _SYS__UCONTEXT_H_
#define	_SYS__UCONTEXT_H_

typedef struct __ucontext {
	/*
	 * Keep the order of the first two fields. Also,
	 * keep them the first two fields in the structure.
	 * This way we can have a union with struct
	 * sigcontext and ucontext_t. This allows us to
	 * support them both at the same time.
	 * note: the union is not defined, though.
	 */
	__sigset_t	uc_sigmask;
	mcontext_t	uc_mcontext;

	struct __ucontext *uc_link;
	struct __stack_t uc_stack;
	int		uc_flags;
	int		__spare__[4];
} ucontext_t;

#endif /* _SYS__UCONTEXT_H */
# 53 "/usr/include/sys/_ucontext.h" 3 4
# 42 "/usr/include/signal.h" 2 3 4
#endif
# 43 "/usr/include/signal.h" 3 4

#if __BSD_VISIBLE
/*
 * XXX should enlarge these, if only to give empty names instead of bounds
 * errors for large signal numbers.
 */
extern const char * const sys_signame[NSIG];
extern const char * const sys_siglist[NSIG];
extern const int sys_nsig;
#endif
# 53 "/usr/include/signal.h" 3 4

#if __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE
#ifndef _PID_T_DECLARED
typedef	__pid_t		pid_t;
#define	_PID_T_DECLARED
#endif
# 59 "/usr/include/signal.h" 3 4
#endif
# 60 "/usr/include/signal.h" 3 4

#if __POSIX_VISIBLE || __XSI_VISIBLE
struct pthread;		/* XXX */
typedef struct pthread *__pthread_t;
#if !defined(_PTHREAD_T_DECLARED) && __POSIX_VISIBLE >= 200809
typedef __pthread_t pthread_t;
#define	_PTHREAD_T_DECLARED
#endif
# 68 "/usr/include/signal.h" 3 4
#endif /* __POSIX_VISIBLE || __XSI_VISIBLE */
# 69 "/usr/include/signal.h" 3 4

__BEGIN_DECLS
int	raise(int);

#if __POSIX_VISIBLE || __XSI_VISIBLE
int	kill(__pid_t, int);
int	pthread_kill(__pthread_t, int);
int	pthread_sigmask(int, const __sigset_t * __restrict,
	    __sigset_t * __restrict);
int	sigaction(int, const struct sigaction * __restrict,
	    struct sigaction * __restrict);
int	sigaddset(sigset_t *, int);
int	sigdelset(sigset_t *, int);
int	sigemptyset(sigset_t *);
int	sigfillset(sigset_t *);
int	sigismember(const sigset_t *, int);
int	sigpending(sigset_t *) __nonnull(1);
int	sigprocmask(int, const sigset_t * __restrict, sigset_t * __restrict);
int	sigsuspend(const sigset_t *) __nonnull(1);
int	sigwait(const sigset_t * __restrict, int * __restrict) __nonnull_all;
#endif
# 90 "/usr/include/signal.h" 3 4

#if __POSIX_VISIBLE >= 199506 || __XSI_VISIBLE >= 600
int	sigqueue(__pid_t, int, const union sigval);

struct timespec;
int	sigtimedwait(const sigset_t * __restrict, siginfo_t * __restrict,
	    const struct timespec * __restrict);
int	sigwaitinfo(const sigset_t * __restrict, siginfo_t * __restrict);
#endif
# 99 "/usr/include/signal.h" 3 4

#if __XSI_VISIBLE
int	killpg(__pid_t, int);
int	sigaltstack(const stack_t * __restrict, stack_t * __restrict); 
int	sighold(int);
int	sigignore(int);
int	sigpause(int);
int	sigrelse(int);
void	(*sigset(int, void (*)(int)))(int);
int	xsi_sigpause(int);
#endif
# 110 "/usr/include/signal.h" 3 4

#if __XSI_VISIBLE >= 600
int	siginterrupt(int, int);
#endif
# 114 "/usr/include/signal.h" 3 4

#if __POSIX_VISIBLE >= 200809
void	psignal(int, const char *);
#endif
# 118 "/usr/include/signal.h" 3 4

#if __BSD_VISIBLE
int	sigblock(int);
int	sigreturn(const struct __ucontext *);
int	sigsetmask(int);
int	sigstack(const struct sigstack *, struct sigstack *);
int	sigvec(int, struct sigvec *, struct sigvec *);
#endif
# 126 "/usr/include/signal.h" 3 4
__END_DECLS

#endif /* !_SIGNAL_H_ */
# 129 "/usr/include/signal.h" 3 4
# 23 "include/libbb.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <paths.h>
#endif /* expanded by -frewrite-includes */
# 23 "include/libbb.h"
# 1 "/usr/include/paths.h" 1 3 4
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)paths.h	8.1 (Berkeley) 6/2/93
 * $FreeBSD: releng/11.0/include/paths.h 297205 2016-03-23 04:18:57Z imp $
 */

#ifndef _PATHS_H_
#define	_PATHS_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/paths.h" 3 4
# 37 "/usr/include/paths.h" 3 4

/* Default search path. */
#define	_PATH_DEFPATH	"/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin"
/* All standard utilities path. */
#define	_PATH_STDPATH	"/usr/bin:/bin:/usr/sbin:/sbin"
/* Locate system binaries. */
#define	_PATH_SYSPATH	"/sbin:/usr/sbin"

#define	_PATH_BSHELL	"/bin/sh"
#define	_PATH_CAPABILITY	"/etc/capability"
#define	_PATH_CAPABILITY_DB	"/etc/capability.db"
#define	_PATH_CONSOLE	"/dev/console"
#define	_PATH_CP	"/bin/cp"
#define	_PATH_CSHELL	"/bin/csh"
#define	_PATH_CSMAPPER	"/usr/share/i18n/csmapper"
#define	_PATH_DEFTAPE	"/dev/sa0"
#define	_PATH_DEVGPIOC	"/dev/gpioc"
#define	_PATH_DEVNULL	"/dev/null"
#define	_PATH_DEVZERO	"/dev/zero"
#define	_PATH_DRUM	"/dev/drum"
#define	_PATH_ESDB	"/usr/share/i18n/esdb"
#define	_PATH_ETC	"/etc"
#define	_PATH_FIRMWARE	"/usr/share/firmware"
#define	_PATH_FTPUSERS	"/etc/ftpusers"
#define	_PATH_FWMEM	"/dev/fwmem"
#define	_PATH_GBDE	"/sbin/gbde"
#define	_PATH_GELI	"/sbin/geli"
#define	_PATH_HALT	"/sbin/halt"
#ifdef COMPAT_32BIT
#define	_PATH_I18NMODULE	"/usr/lib32/i18n"
#else
# 68 "/usr/include/paths.h" 3 4
#define	_PATH_I18NMODULE	"/usr/lib/i18n"
#endif
# 70 "/usr/include/paths.h" 3 4
#define	_PATH_IFCONFIG	"/sbin/ifconfig"
#define	_PATH_KMEM	"/dev/kmem"
#define	_PATH_LIBMAP_CONF	"/etc/libmap.conf"
#define	_PATH_LOCALE	"/usr/share/locale"
#define	_PATH_LOGIN	"/usr/bin/login"
#define	_PATH_MAILDIR	"/var/mail"
#define	_PATH_MAN	"/usr/share/man"
#define	_PATH_MDCONFIG	"/sbin/mdconfig"
#define	_PATH_MEM	"/dev/mem"
#define	_PATH_MKSNAP_FFS	"/sbin/mksnap_ffs"
#define	_PATH_MOUNT	"/sbin/mount"
#define	_PATH_NEWFS	"/sbin/newfs"
#define	_PATH_NOLOGIN	"/var/run/nologin"
#define	_PATH_RCP	"/bin/rcp"
#define	_PATH_REBOOT	"/sbin/reboot"
#define	_PATH_RLOGIN	"/usr/bin/rlogin"
#define	_PATH_RM	"/bin/rm"
#define	_PATH_RSH	"/usr/bin/rsh"
#define	_PATH_SENDMAIL	"/usr/sbin/sendmail"
#define	_PATH_SHELLS	"/etc/shells"
#define	_PATH_TTY	"/dev/tty"
#define	_PATH_UNIX	"don't use _PATH_UNIX"
#define	_PATH_UFSSUSPEND	"/dev/ufssuspend"
#define	_PATH_VI	"/usr/bin/vi"
#define	_PATH_WALL	"/usr/bin/wall"

/* Provide trailing slash, since mostly used for building pathnames. */
#define	_PATH_DEV	"/dev/"
#define	_PATH_TMP	"/tmp/"
#define	_PATH_VARDB	"/var/db/"
#define	_PATH_VARRUN	"/var/run/"
#define	_PATH_VARTMP	"/var/tmp/"
#define	_PATH_YP	"/var/yp/"
#define	_PATH_UUCPLOCK	"/var/spool/lock/"

/* How to get the correct name of the kernel. */
__BEGIN_DECLS
const char *getbootfile(void);
__END_DECLS

#ifdef RESCUE
#undef	_PATH_DEFPATH
#define	_PATH_DEFPATH	"/rescue:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin"
#undef	_PATH_STDPATH
#define	_PATH_STDPATH	"/rescue:/usr/bin:/bin:/usr/sbin:/sbin"
#undef	_PATH_SYSPATH
#define	_PATH_SYSPATH	"/rescue:/sbin:/usr/sbin"
#undef	_PATH_BSHELL
#define	_PATH_BSHELL	"/rescue/sh"
#undef	_PATH_CP
#define	_PATH_CP	"/rescue/cp"
#undef	_PATH_CSHELL
#define	_PATH_CSHELL	"/rescue/csh"
#undef	_PATH_HALT
#define	_PATH_HALT	"/rescue/halt"
#undef	_PATH_IFCONFIG
#define	_PATH_IFCONFIG	"/rescue/ifconfig"
#undef	_PATH_MDCONFIG
#define	_PATH_MDCONFIG	"/rescue/mdconfig"
#undef	_PATH_MOUNT
#define	_PATH_MOUNT	"/rescue/mount"
#undef	_PATH_NEWFS
#define	_PATH_NEWFS	"/rescue/newfs"
#undef	_PATH_RCP
#define	_PATH_RCP	"/rescue/rcp"
#undef	_PATH_REBOOT
#define	_PATH_REBOOT	"/rescue/reboot"
#undef	_PATH_RM
#define	_PATH_RM	"/rescue/rm"
#undef	_PATH_VI
#define	_PATH_VI	"/rescue/vi"
#undef	_PATH_WALL
#define	_PATH_WALL	"/rescue/wall"
#endif /* RESCUE */
# 144 "/usr/include/paths.h" 3 4

#endif /* !_PATHS_H_ */
# 146 "/usr/include/paths.h" 3 4
# 24 "include/libbb.h" 2
#if defined __UCLIBC__ /* TODO: and glibc? */
/* use inlined versions of these: */
# define sigfillset(s)    __sigfillset(s)
# define sigemptyset(s)   __sigemptyset(s)
# define sigisemptyset(s) __sigisemptyset(s)
#endif
# 30 "include/libbb.h"
#if 0 /* expanded by -frewrite-includes */
#include <stdint.h>
#endif /* expanded by -frewrite-includes */
# 30 "include/libbb.h"
# 31 "include/libbb.h"
#if 0 /* expanded by -frewrite-includes */
#include <stdio.h>
#endif /* expanded by -frewrite-includes */
# 31 "include/libbb.h"
# 1 "/usr/include/stdio.h" 1 3 4
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdio.h	8.5 (Berkeley) 4/29/95
 * $FreeBSD: releng/11.0/include/stdio.h 299574 2016-05-12 22:13:12Z cem $
 */

#ifndef	_STDIO_H_
#define	_STDIO_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 39 "/usr/include/stdio.h" 3 4
# 40 "/usr/include/stdio.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_null.h>
#endif /* expanded by -frewrite-includes */
# 40 "/usr/include/stdio.h" 3 4
# 41 "/usr/include/stdio.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 41 "/usr/include/stdio.h" 3 4
# 42 "/usr/include/stdio.h" 3 4

typedef	__off_t		fpos_t;

#ifndef _SIZE_T_DECLARED
typedef	__size_t	size_t;
#define	_SIZE_T_DECLARED
#endif
# 49 "/usr/include/stdio.h" 3 4

#if __POSIX_VISIBLE >= 200809
#ifndef _OFF_T_DECLARED
#define	_OFF_T_DECLARED
typedef	__off_t		off_t;
#endif
# 55 "/usr/include/stdio.h" 3 4
#ifndef _SSIZE_T_DECLARED
#define	_SSIZE_T_DECLARED
typedef	__ssize_t	ssize_t;
#endif
# 59 "/usr/include/stdio.h" 3 4
#endif
# 60 "/usr/include/stdio.h" 3 4

#ifndef _OFF64_T_DECLARED
#define	_OFF64_T_DECLARED
typedef	__off64_t	off64_t;
#endif
# 65 "/usr/include/stdio.h" 3 4

#if __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE
#ifndef _VA_LIST_DECLARED
typedef	__va_list	va_list;
#define	_VA_LIST_DECLARED
#endif
# 71 "/usr/include/stdio.h" 3 4
#endif
# 72 "/usr/include/stdio.h" 3 4

#define	_FSTDIO			/* Define for new stdio with functions. */

/*
 * NB: to fit things in six character monocase externals, the stdio
 * code uses the prefix `__s' for stdio objects, typically followed
 * by a three-character attempt at a mnemonic.
 */

/* stdio buffers */
struct __sbuf {
	unsigned char *_base;
	int	_size;
};

/*
 * stdio state variables.
 *
 * The following always hold:
 *
 *	if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
 *		_lbfsize is -_bf._size, else _lbfsize is 0
 *	if _flags&__SRD, _w is 0
 *	if _flags&__SWR, _r is 0
 *
 * This ensures that the getc and putc macros (or inline functions) never
 * try to write or read from a file that is in `read' or `write' mode.
 * (Moreover, they can, and do, automatically switch from read mode to
 * write mode, and back, on "r+" and "w+" files.)
 *
 * _lbfsize is used only to make the inline line-buffered output stream
 * code as compact as possible.
 *
 * _ub, _up, and _ur are used when ungetc() pushes back more characters
 * than fit in the current _bf, or when ungetc() pushes back a character
 * that does not match the previous one in _bf.  When this happens,
 * _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
 * _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
 *
 * Certain members of __sFILE are accessed directly via macros or
 * inline functions.  To preserve ABI compat, these members must not
 * be disturbed.  These members are marked below with (*).
 */
struct __sFILE {
	unsigned char *_p;	/* (*) current position in (some) buffer */
	int	_r;		/* (*) read space left for getc() */
	int	_w;		/* (*) write space left for putc() */
	short	_flags;		/* (*) flags, below; this FILE is free if 0 */
	short	_file;		/* (*) fileno, if Unix descriptor, else -1 */
	struct	__sbuf _bf;	/* (*) the buffer (at least 1 byte, if !NULL) */
	int	_lbfsize;	/* (*) 0 or -_bf._size, for inline putc */

	/* operations */
	void	*_cookie;	/* (*) cookie passed to io functions */
	int	(*_close)(void *);
	int	(*_read)(void *, char *, int);
	fpos_t	(*_seek)(void *, fpos_t, int);
	int	(*_write)(void *, const char *, int);

	/* separate buffer for long sequences of ungetc() */
	struct	__sbuf _ub;	/* ungetc buffer */
	unsigned char	*_up;	/* saved _p when _p is doing ungetc data */
	int	_ur;		/* saved _r when _r is counting ungetc data */

	/* tricks to meet minimum requirements even when malloc() fails */
	unsigned char _ubuf[3];	/* guarantee an ungetc() buffer */
	unsigned char _nbuf[1];	/* guarantee a getc() buffer */

	/* separate buffer for fgetln() when line crosses buffer boundary */
	struct	__sbuf _lb;	/* buffer for fgetln() */

	/* Unix stdio files get aligned to block boundaries on fseek() */
	int	_blksize;	/* stat.st_blksize (may be != _bf._size) */
	fpos_t	_offset;	/* current lseek offset */

	struct pthread_mutex *_fl_mutex;	/* used for MT-safety */
	struct pthread *_fl_owner;	/* current owner */
	int	_fl_count;	/* recursive lock count */
	int	_orientation;	/* orientation for fwide() */
	__mbstate_t _mbstate;	/* multibyte conversion state */
	int	_flags2;	/* additional flags */
};
#ifndef _STDFILE_DECLARED
#define _STDFILE_DECLARED
typedef struct __sFILE FILE;
#endif
# 158 "/usr/include/stdio.h" 3 4
#ifndef _STDSTREAM_DECLARED
__BEGIN_DECLS
extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;
__END_DECLS
#define	_STDSTREAM_DECLARED
#endif
# 166 "/usr/include/stdio.h" 3 4

#define	__SLBF	0x0001		/* line buffered */
#define	__SNBF	0x0002		/* unbuffered */
#define	__SRD	0x0004		/* OK to read */
#define	__SWR	0x0008		/* OK to write */
	/* RD and WR are never simultaneously asserted */
#define	__SRW	0x0010		/* open for reading & writing */
#define	__SEOF	0x0020		/* found EOF */
#define	__SERR	0x0040		/* found error */
#define	__SMBF	0x0080		/* _bf._base is from malloc */
#define	__SAPP	0x0100		/* fdopen()ed in append mode */
#define	__SSTR	0x0200		/* this is an sprintf/snprintf string */
#define	__SOPT	0x0400		/* do fseek() optimization */
#define	__SNPT	0x0800		/* do not do fseek() optimization */
#define	__SOFF	0x1000		/* set iff _offset is in fact correct */
#define	__SMOD	0x2000		/* true => fgetln modified _p text */
#define	__SALC	0x4000		/* allocate string space dynamically */
#define	__SIGN	0x8000		/* ignore this file in _fwalk */

#define	__S2OAP	0x0001		/* O_APPEND mode is set */

/*
 * The following three definitions are for ANSI C, which took them
 * from System V, which brilliantly took internal interface macros and
 * made them official arguments to setvbuf(), without renaming them.
 * Hence, these ugly _IOxxx names are *supposed* to appear in user code.
 *
 * Although numbered as their counterparts above, the implementation
 * does not rely on this.
 */
#define	_IOFBF	0		/* setvbuf should set fully buffered */
#define	_IOLBF	1		/* setvbuf should set line buffered */
#define	_IONBF	2		/* setvbuf should set unbuffered */

#define	BUFSIZ	1024		/* size of buffer used by setbuf */
#define	EOF	(-1)

/*
 * FOPEN_MAX is a minimum maximum, and is the number of streams that
 * stdio can provide without attempting to allocate further resources
 * (which could fail).  Do not use this for anything.
 */
				/* must be == _POSIX_STREAM_MAX <limits.h> */
#ifndef FOPEN_MAX
#define	FOPEN_MAX	20	/* must be <= OPEN_MAX <sys/syslimits.h> */
#endif
# 212 "/usr/include/stdio.h" 3 4
#define	FILENAME_MAX	1024	/* must be <= PATH_MAX <sys/syslimits.h> */

/* System V/ANSI C; this is the wrong way to do this, do *not* use these. */
#if __XSI_VISIBLE
#define	P_tmpdir	"/tmp/"
#endif
# 218 "/usr/include/stdio.h" 3 4
#define	L_tmpnam	1024	/* XXX must be == PATH_MAX */
#define	TMP_MAX		308915776

#ifndef SEEK_SET
#define	SEEK_SET	0	/* set file offset to offset */
#endif
# 224 "/usr/include/stdio.h" 3 4
#ifndef SEEK_CUR
#define	SEEK_CUR	1	/* set file offset to current plus offset */
#endif
# 227 "/usr/include/stdio.h" 3 4
#ifndef SEEK_END
#define	SEEK_END	2	/* set file offset to EOF plus offset */
#endif
# 230 "/usr/include/stdio.h" 3 4

#define	stdin	__stdinp
#define	stdout	__stdoutp
#define	stderr	__stderrp

__BEGIN_DECLS
#ifdef _XLOCALE_H_
#if 0 /* expanded by -frewrite-includes */
#include <xlocale/_stdio.h>
#endif /* expanded by -frewrite-includes */
# 237 "/usr/include/stdio.h" 3 4
# 238 "/usr/include/stdio.h" 3 4
#endif
# 239 "/usr/include/stdio.h" 3 4
/*
 * Functions defined in ANSI C standard.
 */
void	 clearerr(FILE *);
int	 fclose(FILE *);
int	 feof(FILE *);
int	 ferror(FILE *);
int	 fflush(FILE *);
int	 fgetc(FILE *);
int	 fgetpos(FILE * __restrict, fpos_t * __restrict);
char	*fgets(char * __restrict, int, FILE * __restrict);
FILE	*fopen(const char * __restrict, const char * __restrict);
int	 fprintf(FILE * __restrict, const char * __restrict, ...);
int	 fputc(int, FILE *);
int	 fputs(const char * __restrict, FILE * __restrict);
size_t	 fread(void * __restrict, size_t, size_t, FILE * __restrict);
FILE	*freopen(const char * __restrict, const char * __restrict, FILE * __restrict);
int	 fscanf(FILE * __restrict, const char * __restrict, ...);
int	 fseek(FILE *, long, int);
int	 fsetpos(FILE *, const fpos_t *);
long	 ftell(FILE *);
size_t	 fwrite(const void * __restrict, size_t, size_t, FILE * __restrict);
int	 getc(FILE *);
int	 getchar(void);
char	*gets(char *);
void	 perror(const char *);
int	 printf(const char * __restrict, ...);
int	 putc(int, FILE *);
int	 putchar(int);
int	 puts(const char *);
int	 remove(const char *);
int	 rename(const char *, const char *);
void	 rewind(FILE *);
int	 scanf(const char * __restrict, ...);
void	 setbuf(FILE * __restrict, char * __restrict);
int	 setvbuf(FILE * __restrict, char * __restrict, int, size_t);
int	 sprintf(char * __restrict, const char * __restrict, ...);
int	 sscanf(const char * __restrict, const char * __restrict, ...);
FILE	*tmpfile(void);
char	*tmpnam(char *);
int	 ungetc(int, FILE *);
int	 vfprintf(FILE * __restrict, const char * __restrict,
	    __va_list);
int	 vprintf(const char * __restrict, __va_list);
int	 vsprintf(char * __restrict, const char * __restrict,
	    __va_list);

#if __ISO_C_VISIBLE >= 1999
int	 snprintf(char * __restrict, size_t, const char * __restrict,
	    ...) __printflike(3, 4);
int	 vfscanf(FILE * __restrict, const char * __restrict, __va_list)
	    __scanflike(2, 0);
int	 vscanf(const char * __restrict, __va_list) __scanflike(1, 0);
int	 vsnprintf(char * __restrict, size_t, const char * __restrict,
	    __va_list) __printflike(3, 0);
int	 vsscanf(const char * __restrict, const char * __restrict, __va_list)
	    __scanflike(2, 0);
#endif
# 297 "/usr/include/stdio.h" 3 4

/*
 * Functions defined in all versions of POSIX 1003.1.
 */
#if __BSD_VISIBLE || (__POSIX_VISIBLE && __POSIX_VISIBLE <= 199506)
#define	L_cuserid	17	/* size for cuserid(3); MAXLOGNAME, legacy */
#endif
# 304 "/usr/include/stdio.h" 3 4

#if __POSIX_VISIBLE
#define	L_ctermid	1024	/* size for ctermid(3); PATH_MAX */

char	*ctermid(char *);
FILE	*fdopen(int, const char *);
int	 fileno(FILE *);
#endif /* __POSIX_VISIBLE */
# 312 "/usr/include/stdio.h" 3 4

#if __POSIX_VISIBLE >= 199209
int	 pclose(FILE *);
FILE	*popen(const char *, const char *);
#endif
# 317 "/usr/include/stdio.h" 3 4

#if __POSIX_VISIBLE >= 199506
int	 ftrylockfile(FILE *);
void	 flockfile(FILE *);
void	 funlockfile(FILE *);

/*
 * These are normally used through macros as defined below, but POSIX
 * requires functions as well.
 */
int	 getc_unlocked(FILE *);
int	 getchar_unlocked(void);
int	 putc_unlocked(int, FILE *);
int	 putchar_unlocked(int);
#endif
# 332 "/usr/include/stdio.h" 3 4
#if __BSD_VISIBLE
void	 clearerr_unlocked(FILE *);
int	 feof_unlocked(FILE *);
int	 ferror_unlocked(FILE *);
int	 fileno_unlocked(FILE *);
#endif
# 338 "/usr/include/stdio.h" 3 4

#if __POSIX_VISIBLE >= 200112
int	 fseeko(FILE *, __off_t, int);
__off_t	 ftello(FILE *);
#endif
# 343 "/usr/include/stdio.h" 3 4

#if __BSD_VISIBLE || __XSI_VISIBLE > 0 && __XSI_VISIBLE < 600
int	 getw(FILE *);
int	 putw(int, FILE *);
#endif /* BSD or X/Open before issue 6 */
# 348 "/usr/include/stdio.h" 3 4

#if __XSI_VISIBLE
char	*tempnam(const char *, const char *);
#endif
# 352 "/usr/include/stdio.h" 3 4

#if __POSIX_VISIBLE >= 200809
FILE	*fmemopen(void * __restrict, size_t, const char * __restrict);
ssize_t	 getdelim(char ** __restrict, size_t * __restrict, int,
	    FILE * __restrict);
FILE	*open_memstream(char **, size_t *);
int	 renameat(int, const char *, int, const char *);
int	 vdprintf(int, const char * __restrict, __va_list);

/*
 * Every programmer and his dog wrote functions called getline() and dprintf()
 * before POSIX.1-2008 came along and decided to usurp the names, so we
 * don't prototype them by default unless one of the following is true:
 *   a) the app has requested them specifically by defining _WITH_GETLINE or
 *      _WITH_DPRINTF, respectively
 *   b) the app has requested a POSIX.1-2008 environment via _POSIX_C_SOURCE
 *   c) the app defines a GNUism such as _BSD_SOURCE or _GNU_SOURCE
 */
#ifndef _WITH_GETLINE
#if defined(_BSD_SOURCE) || defined(_GNU_SOURCE)
#define	_WITH_GETLINE
#elif defined(_POSIX_C_SOURCE)
# 374 "/usr/include/stdio.h" 3 4
#if _POSIX_C_SOURCE >= 200809
#define	_WITH_GETLINE
#endif
# 377 "/usr/include/stdio.h" 3 4
#endif
# 378 "/usr/include/stdio.h" 3 4
#endif
# 379 "/usr/include/stdio.h" 3 4

#ifdef _WITH_GETLINE
ssize_t	 getline(char ** __restrict, size_t * __restrict, FILE * __restrict);
#endif
# 383 "/usr/include/stdio.h" 3 4

#ifndef _WITH_DPRINTF
#if defined(_BSD_SOURCE) || defined(_GNU_SOURCE)
#define	_WITH_DPRINTF
#elif defined(_POSIX_C_SOURCE)
# 388 "/usr/include/stdio.h" 3 4
#if _POSIX_C_SOURCE >= 200809
#define	_WITH_DPRINTF
#endif
# 391 "/usr/include/stdio.h" 3 4
#endif
# 392 "/usr/include/stdio.h" 3 4
#endif
# 393 "/usr/include/stdio.h" 3 4

#ifdef _WITH_DPRINTF
int	 (dprintf)(int, const char * __restrict, ...);
#endif
# 397 "/usr/include/stdio.h" 3 4

#endif /* __POSIX_VISIBLE >= 200809 */
# 399 "/usr/include/stdio.h" 3 4

/*
 * Routines that are purely local.
 */
#if __BSD_VISIBLE
int	 asprintf(char **, const char *, ...) __printflike(2, 3);
char	*ctermid_r(char *);
void	 fcloseall(void);
int	 fdclose(FILE *, int *);
char	*fgetln(FILE *, size_t *);
const char *fmtcheck(const char *, const char *) __format_arg(2);
int	 fpurge(FILE *);
void	 setbuffer(FILE *, char *, int);
int	 setlinebuf(FILE *);
int	 vasprintf(char **, const char *, __va_list)
	    __printflike(2, 0);

/*
 * The system error table contains messages for the first sys_nerr
 * positive errno values.  Use strerror() or strerror_r() from <string.h>
 * instead.
 */
extern const int sys_nerr;
extern const char * const sys_errlist[];

/*
 * Stdio function-access interface.
 */
FILE	*funopen(const void *,
	    int (*)(void *, char *, int),
	    int (*)(void *, const char *, int),
	    fpos_t (*)(void *, fpos_t, int),
	    int (*)(void *));
#define	fropen(cookie, fn) funopen(cookie, fn, 0, 0, 0)
#define	fwopen(cookie, fn) funopen(cookie, 0, fn, 0, 0)

typedef __ssize_t cookie_read_function_t(void *, char *, size_t);
typedef __ssize_t cookie_write_function_t(void *, const char *, size_t);
typedef int cookie_seek_function_t(void *, off64_t *, int);
typedef int cookie_close_function_t(void *);
typedef struct {
	cookie_read_function_t	*read;
	cookie_write_function_t	*write;
	cookie_seek_function_t	*seek;
	cookie_close_function_t	*close;
} cookie_io_functions_t;
FILE	*fopencookie(void *, const char *, cookie_io_functions_t);

/*
 * Portability hacks.  See <sys/types.h>.
 */
#ifndef _FTRUNCATE_DECLARED
#define	_FTRUNCATE_DECLARED
int	 ftruncate(int, __off_t);
#endif
# 454 "/usr/include/stdio.h" 3 4
#ifndef _LSEEK_DECLARED
#define	_LSEEK_DECLARED
__off_t	 lseek(int, __off_t, int);
#endif
# 458 "/usr/include/stdio.h" 3 4
#ifndef _MMAP_DECLARED
#define	_MMAP_DECLARED
void	*mmap(void *, size_t, int, int, int, __off_t);
#endif
# 462 "/usr/include/stdio.h" 3 4
#ifndef _TRUNCATE_DECLARED
#define	_TRUNCATE_DECLARED
int	 truncate(const char *, __off_t);
#endif
# 466 "/usr/include/stdio.h" 3 4
#endif /* __BSD_VISIBLE */
# 467 "/usr/include/stdio.h" 3 4

/*
 * Functions internal to the implementation.
 */
int	__srget(FILE *);
int	__swbuf(int, FILE *);

/*
 * The __sfoo macros are here so that we can
 * define function versions in the C library.
 */
#define	__sgetc(p) (--(p)->_r < 0 ? __srget(p) : (int)(*(p)->_p++))
#if defined(__GNUC__) && defined(__STDC__)
static __inline int __sputc(int _c, FILE *_p) {
	if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
		return (*_p->_p++ = _c);
	else
		return (__swbuf(_c, _p));
}
#else
# 487 "/usr/include/stdio.h" 3 4
/*
 * This has been tuned to generate reasonable code on the vax using pcc.
 */
#define	__sputc(c, p) \
	(--(p)->_w < 0 ? \
		(p)->_w >= (p)->_lbfsize ? \
			(*(p)->_p = (c)), *(p)->_p != '\n' ? \
				(int)*(p)->_p++ : \
				__swbuf('\n', p) : \
			__swbuf((int)(c), p) : \
		(*(p)->_p = (c), (int)*(p)->_p++))
#endif
# 499 "/usr/include/stdio.h" 3 4

extern int __isthreaded;

#ifndef __cplusplus

#define	__sfeof(p)	(((p)->_flags & __SEOF) != 0)
#define	__sferror(p)	(((p)->_flags & __SERR) != 0)
#define	__sclearerr(p)	((void)((p)->_flags &= ~(__SERR|__SEOF)))
#define	__sfileno(p)	((p)->_file)


#define	feof(p)		(!__isthreaded ? __sfeof(p) : (feof)(p))
#define	ferror(p)	(!__isthreaded ? __sferror(p) : (ferror)(p))
#define	clearerr(p)	(!__isthreaded ? __sclearerr(p) : (clearerr)(p))

#if __POSIX_VISIBLE
#define	fileno(p)	(!__isthreaded ? __sfileno(p) : (fileno)(p))
#endif
# 517 "/usr/include/stdio.h" 3 4

#define	getc(fp)	(!__isthreaded ? __sgetc(fp) : (getc)(fp))
#define	putc(x, fp)	(!__isthreaded ? __sputc(x, fp) : (putc)(x, fp))

#define	getchar()	getc(stdin)
#define	putchar(x)	putc(x, stdout)

#if __BSD_VISIBLE
/*
 * See ISO/IEC 9945-1 ANSI/IEEE Std 1003.1 Second Edition 1996-07-12
 * B.8.2.7 for the rationale behind the *_unlocked() macros.
 */
#define	feof_unlocked(p)	__sfeof(p)
#define	ferror_unlocked(p)	__sferror(p)
#define	clearerr_unlocked(p)	__sclearerr(p)
#define	fileno_unlocked(p)	__sfileno(p)
#endif
# 534 "/usr/include/stdio.h" 3 4
#if __POSIX_VISIBLE >= 199506
#define	getc_unlocked(fp)	__sgetc(fp)
#define	putc_unlocked(x, fp)	__sputc(x, fp)

#define	getchar_unlocked()	getc_unlocked(stdin)
#define	putchar_unlocked(x)	putc_unlocked(x, stdout)
#endif
# 541 "/usr/include/stdio.h" 3 4
#endif /* __cplusplus */
# 542 "/usr/include/stdio.h" 3 4

__END_DECLS
#endif /* !_STDIO_H_ */
# 545 "/usr/include/stdio.h" 3 4
# 32 "include/libbb.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <stdlib.h>
#endif /* expanded by -frewrite-includes */
# 32 "include/libbb.h"
# 1 "/usr/include/stdlib.h" 1 3 4
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 * $FreeBSD: releng/11.0/include/stdlib.h 302358 2016-07-05 22:30:29Z pfg $
 */

#ifndef _STDLIB_H_
#define	_STDLIB_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/stdlib.h" 3 4
# 37 "/usr/include/stdlib.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_null.h>
#endif /* expanded by -frewrite-includes */
# 37 "/usr/include/stdlib.h" 3 4
# 38 "/usr/include/stdlib.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 38 "/usr/include/stdlib.h" 3 4
# 39 "/usr/include/stdlib.h" 3 4

#if __BSD_VISIBLE
#ifndef _RUNE_T_DECLARED
typedef	__rune_t	rune_t;
#define	_RUNE_T_DECLARED
#endif
# 45 "/usr/include/stdlib.h" 3 4
#endif
# 46 "/usr/include/stdlib.h" 3 4

#ifndef _SIZE_T_DECLARED
typedef	__size_t	size_t;
#define	_SIZE_T_DECLARED
#endif
# 51 "/usr/include/stdlib.h" 3 4

#ifndef	__cplusplus
#ifndef _WCHAR_T_DECLARED
typedef	___wchar_t	wchar_t;
#define	_WCHAR_T_DECLARED
#endif
# 57 "/usr/include/stdlib.h" 3 4
#endif
# 58 "/usr/include/stdlib.h" 3 4

typedef struct {
	int	quot;		/* quotient */
	int	rem;		/* remainder */
} div_t;

typedef struct {
	long	quot;
	long	rem;
} ldiv_t;

#define	EXIT_FAILURE	1
#define	EXIT_SUCCESS	0

#define	RAND_MAX	0x7ffffffd

__BEGIN_DECLS
#ifdef _XLOCALE_H_
#if 0 /* expanded by -frewrite-includes */
#include <xlocale/_stdlib.h>
#endif /* expanded by -frewrite-includes */
# 76 "/usr/include/stdlib.h" 3 4
# 77 "/usr/include/stdlib.h" 3 4
#endif
# 78 "/usr/include/stdlib.h" 3 4
extern int __mb_cur_max;
extern int ___mb_cur_max(void);
#define	MB_CUR_MAX	(___mb_cur_max())

_Noreturn void	 abort(void);
int	 abs(int) __pure2;
int	 atexit(void (*)(void));
double	 atof(const char *);
int	 atoi(const char *);
long	 atol(const char *);
void	*bsearch(const void *, const void *, size_t,
	    size_t, int (*)(const void *, const void *));
void	*calloc(size_t, size_t) __malloc_like __result_use_check
	     __alloc_size(1) __alloc_size(2);
div_t	 div(int, int) __pure2;
_Noreturn void	 exit(int);
void	 free(void *);
char	*getenv(const char *);
long	 labs(long) __pure2;
ldiv_t	 ldiv(long, long) __pure2;
void	*malloc(size_t) __malloc_like __result_use_check __alloc_size(1);
int	 mblen(const char *, size_t);
size_t	 mbstowcs(wchar_t * __restrict , const char * __restrict, size_t);
int	 mbtowc(wchar_t * __restrict, const char * __restrict, size_t);
void	 qsort(void *, size_t, size_t,
	    int (*)(const void *, const void *));
int	 rand(void);
void	*realloc(void *, size_t) __result_use_check __alloc_size(2);
void	 srand(unsigned);
double	 strtod(const char * __restrict, char ** __restrict);
float	 strtof(const char * __restrict, char ** __restrict);
long	 strtol(const char * __restrict, char ** __restrict, int);
long double
	 strtold(const char * __restrict, char ** __restrict);
unsigned long
	 strtoul(const char * __restrict, char ** __restrict, int);
int	 system(const char *);
int	 wctomb(char *, wchar_t);
size_t	 wcstombs(char * __restrict, const wchar_t * __restrict, size_t);

/*
 * Functions added in C99 which we make conditionally available in the
 * BSD^C89 namespace if the compiler supports `long long'.
 * The #if test is more complicated than it ought to be because
 * __BSD_VISIBLE implies __ISO_C_VISIBLE == 1999 *even if* `long long'
 * is not supported in the compilation environment (which therefore means
 * that it can't really be ISO C99).
 *
 * (The only other extension made by C99 in thie header is _Exit().)
 */
#if __ISO_C_VISIBLE >= 1999 || defined(__cplusplus)
#ifdef __LONG_LONG_SUPPORTED
/* LONGLONG */
typedef struct {
	long long quot;
	long long rem;
} lldiv_t;

/* LONGLONG */
long long
	 atoll(const char *);
/* LONGLONG */
long long
	 llabs(long long) __pure2;
/* LONGLONG */
lldiv_t	 lldiv(long long, long long) __pure2;
/* LONGLONG */
long long
	 strtoll(const char * __restrict, char ** __restrict, int);
/* LONGLONG */
unsigned long long
	 strtoull(const char * __restrict, char ** __restrict, int);
#endif /* __LONG_LONG_SUPPORTED */
# 151 "/usr/include/stdlib.h" 3 4

_Noreturn void	 _Exit(int);
#endif /* __ISO_C_VISIBLE >= 1999 */
# 154 "/usr/include/stdlib.h" 3 4

/*
 * If we're in a mode greater than C99, expose C11 functions.
 */
#if __ISO_C_VISIBLE >= 2011 || __cplusplus >= 201103L
void *	aligned_alloc(size_t, size_t) __malloc_like __alloc_align(1)
	    __alloc_size(2);
int	at_quick_exit(void (*)(void));
_Noreturn void
	quick_exit(int);
#endif /* __ISO_C_VISIBLE >= 2011 */
# 165 "/usr/include/stdlib.h" 3 4
/*
 * Extensions made by POSIX relative to C.
 */
#if __POSIX_VISIBLE >= 199506 || __XSI_VISIBLE
char	*realpath(const char * __restrict, char * __restrict);
#endif
# 171 "/usr/include/stdlib.h" 3 4
#if __POSIX_VISIBLE >= 199506
int	 rand_r(unsigned *);			/* (TSF) */
#endif
# 174 "/usr/include/stdlib.h" 3 4
#if __POSIX_VISIBLE >= 200112
int	 posix_memalign(void **, size_t, size_t) __nonnull(1); /* (ADV) */
int	 setenv(const char *, const char *, int);
int	 unsetenv(const char *);
#endif
# 179 "/usr/include/stdlib.h" 3 4

#if __POSIX_VISIBLE >= 200809 || __XSI_VISIBLE
int	 getsubopt(char **, char *const *, char **);
#ifndef _MKDTEMP_DECLARED
char	*mkdtemp(char *);
#define	_MKDTEMP_DECLARED
#endif
# 186 "/usr/include/stdlib.h" 3 4
#ifndef _MKSTEMP_DECLARED
int	 mkstemp(char *);
#define	_MKSTEMP_DECLARED
#endif
# 190 "/usr/include/stdlib.h" 3 4
#endif /* __POSIX_VISIBLE >= 200809 || __XSI_VISIBLE */
# 191 "/usr/include/stdlib.h" 3 4

/*
 * The only changes to the XSI namespace in revision 6 were the deletion
 * of the ttyslot() and valloc() functions, which FreeBSD never declared
 * in this header.  For revision 7, ecvt(), fcvt(), and gcvt(), which
 * FreeBSD also does not have, and mktemp(), are to be deleted.
 */
#if __XSI_VISIBLE
/* XXX XSI requires pollution from <sys/wait.h> here.  We'd rather not. */
long	 a64l(const char *);
double	 drand48(void);
/* char	*ecvt(double, int, int * __restrict, int * __restrict); */
double	 erand48(unsigned short[3]);
/* char	*fcvt(double, int, int * __restrict, int * __restrict); */
/* char	*gcvt(double, int, int * __restrict, int * __restrict); */
int	 grantpt(int);
char	*initstate(unsigned long /* XSI requires u_int */, char *, long);
long	 jrand48(unsigned short[3]);
char	*l64a(long);
void	 lcong48(unsigned short[7]);
long	 lrand48(void);
#if !defined(_MKTEMP_DECLARED) && (__BSD_VISIBLE || __XSI_VISIBLE <= 600)
char	*mktemp(char *);
#define	_MKTEMP_DECLARED
#endif
# 216 "/usr/include/stdlib.h" 3 4
long	 mrand48(void);
long	 nrand48(unsigned short[3]);
int	 posix_openpt(int);
char	*ptsname(int);
int	 putenv(char *);
long	 random(void);
unsigned short
	*seed48(unsigned short[3]);
#ifndef _SETKEY_DECLARED
int	 setkey(const char *);
#define	_SETKEY_DECLARED
#endif
# 228 "/usr/include/stdlib.h" 3 4
char	*setstate(/* const */ char *);
void	 srand48(long);
void	 srandom(unsigned long);
int	 unlockpt(int);
#endif /* __XSI_VISIBLE */
# 233 "/usr/include/stdlib.h" 3 4

#if __BSD_VISIBLE
extern const char *malloc_conf;
extern void (*malloc_message)(void *, const char *);

/*
 * The alloca() function can't be implemented in C, and on some
 * platforms it can't be implemented at all as a callable function.
 * The GNU C compiler provides a built-in alloca() which we can use;
 * in all other cases, provide a prototype, mainly to pacify various
 * incarnations of lint.  On platforms where alloca() is not in libc,
 * programs which use it will fail to link when compiled with non-GNU
 * compilers.
 */
#if __GNUC__ >= 2 || defined(__INTEL_COMPILER)
#undef  alloca	/* some GNU bits try to get cute and define this on their own */
#define alloca(sz) __builtin_alloca(sz)
#elif defined(lint)
# 251 "/usr/include/stdlib.h" 3 4
void	*alloca(size_t);
#endif
# 253 "/usr/include/stdlib.h" 3 4

void	 abort2(const char *, int, void **) __dead2;
__uint32_t
	 arc4random(void);
void	 arc4random_addrandom(unsigned char *, int);
void	 arc4random_buf(void *, size_t);
void	 arc4random_stir(void);
__uint32_t 
	 arc4random_uniform(__uint32_t);
#ifdef __BLOCKS__
int	 atexit_b(void (^)(void));
void	*bsearch_b(const void *, const void *, size_t,
	    size_t, int (^)(const void *, const void *));
#endif
# 267 "/usr/include/stdlib.h" 3 4
char	*getbsize(int *, long *);
					/* getcap(3) functions */
char	*cgetcap(char *, const char *, int);
int	 cgetclose(void);
int	 cgetent(char **, char **, const char *);
int	 cgetfirst(char **, char **);
int	 cgetmatch(const char *, const char *);
int	 cgetnext(char **, char **);
int	 cgetnum(char *, const char *, long *);
int	 cgetset(const char *);
int	 cgetstr(char *, const char *, char **);
int	 cgetustr(char *, const char *, char **);

int	 daemon(int, int);
char	*devname(__dev_t, __mode_t);
char	*devname_r(__dev_t, __mode_t, char *, int);
char	*fdevname(int);
char	*fdevname_r(int, char *, int);
int	 getloadavg(double [], int);
const char *
	 getprogname(void);

int	 heapsort(void *, size_t, size_t, int (*)(const void *, const void *));
#ifdef __BLOCKS__
int	 heapsort_b(void *, size_t, size_t, int (^)(const void *, const void *));
void	 qsort_b(void *, size_t, size_t,
	    int (^)(const void *, const void *));
#endif
# 295 "/usr/include/stdlib.h" 3 4
int	 l64a_r(long, char *, int);
int	 mergesort(void *, size_t, size_t, int (*)(const void *, const void *));
#ifdef __BLOCKS__
int	 mergesort_b(void *, size_t, size_t, int (^)(const void *, const void *));
#endif
# 300 "/usr/include/stdlib.h" 3 4
int	 mkostemp(char *, int);
int	 mkostemps(char *, int, int);
void	 qsort_r(void *, size_t, size_t, void *,
	    int (*)(void *, const void *, const void *));
int	 radixsort(const unsigned char **, int, const unsigned char *,
	    unsigned);
void	*reallocarray(void *, size_t, size_t) __result_use_check __alloc_size(2)
	    __alloc_size(3);
void	*reallocf(void *, size_t) __alloc_size(2);
int	 rpmatch(const char *);
void	 setprogname(const char *);
int	 sradixsort(const unsigned char **, int, const unsigned char *,
	    unsigned);
void	 sranddev(void);
void	 srandomdev(void);
long long
	strtonum(const char *, long long, long long, const char **);

/* Deprecated interfaces, to be removed in FreeBSD 6.0. */
__int64_t
	 strtoq(const char *, char **, int);
__uint64_t
	 strtouq(const char *, char **, int);

extern char *suboptarg;			/* getsubopt(3) external variable */
#endif /* __BSD_VISIBLE */
# 326 "/usr/include/stdlib.h" 3 4
__END_DECLS

#endif /* !_STDLIB_H_ */
# 329 "/usr/include/stdlib.h" 3 4
# 33 "include/libbb.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <stdarg.h>
#endif /* expanded by -frewrite-includes */
# 33 "include/libbb.h"
# 1 "/usr/include/stdarg.h" 1 3 4
/*-
 * This file is in the public domain.
 */
/* $FreeBSD: releng/11.0/sys/amd64/include/stdarg.h 232276 2012-02-28 22:30:58Z tijl $ */

#if 0 /* expanded by -frewrite-includes */
#include <x86/stdarg.h>
#endif /* expanded by -frewrite-includes */
# 6 "/usr/include/stdarg.h" 3 4
# 1 "/usr/include/x86/stdarg.h" 1 3 4
/*-
 * Copyright (c) 2002 David E. O'Brien.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/sys/x86/include/stdarg.h 256105 2013-10-07 10:01:23Z phk $
 */

#ifndef _MACHINE_STDARG_H_
#define	_MACHINE_STDARG_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 34 "/usr/include/x86/stdarg.h" 3 4
# 35 "/usr/include/x86/stdarg.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 35 "/usr/include/x86/stdarg.h" 3 4
# 36 "/usr/include/x86/stdarg.h" 3 4

#ifndef _VA_LIST_DECLARED
#define	_VA_LIST_DECLARED
typedef	__va_list	va_list;
#endif
# 41 "/usr/include/x86/stdarg.h" 3 4

#ifdef __GNUCLIKE_BUILTIN_STDARG

#define	va_start(ap, last) \
	__builtin_va_start((ap), (last))

#define	va_arg(ap, type) \
	__builtin_va_arg((ap), type)

#define	__va_copy(dest, src) \
	__builtin_va_copy((dest), (src))

#if __ISO_C_VISIBLE >= 1999
#define	va_copy(dest, src) \
	__va_copy(dest, src)
#endif
# 57 "/usr/include/x86/stdarg.h" 3 4

#define	va_end(ap) \
	__builtin_va_end(ap)

#elif defined(lint)
# 62 "/usr/include/x86/stdarg.h" 3 4
/* Provide a fake implementation for lint's benefit */
#define	__va_size(type) \
	(((sizeof(type) + sizeof(long) - 1) / sizeof(long)) * sizeof(long))
#define	va_start(ap, last) \
	((ap) = (va_list)&(last) + __va_size(last))
#define va_copy(dst, src) \
	((dst) = (src))
#define	va_arg(ap, type) \
	(*(type *)((ap) += __va_size(type), (ap) - __va_size(type)))
#define	va_end(ap)

#else
# 74 "/usr/include/x86/stdarg.h" 3 4
#error this file needs to be ported to your compiler
#endif
# 76 "/usr/include/x86/stdarg.h" 3 4

#endif /* !_MACHINE_STDARG_H_ */
# 78 "/usr/include/x86/stdarg.h" 3 4
# 7 "/usr/include/stdarg.h" 2 3 4
# 34 "include/libbb.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <stddef.h>
#endif /* expanded by -frewrite-includes */
# 34 "include/libbb.h"
# 1 "/usr/include/stddef.h" 1 3 4
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stddef.h	8.1 (Berkeley) 6/2/93
 *
 * $FreeBSD: releng/11.0/include/stddef.h 270277 2014-08-21 15:10:10Z kan $
 */

#ifndef _STDDEF_H_
#define _STDDEF_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 37 "/usr/include/stddef.h" 3 4
# 38 "/usr/include/stddef.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_null.h>
#endif /* expanded by -frewrite-includes */
# 38 "/usr/include/stddef.h" 3 4
# 39 "/usr/include/stddef.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 39 "/usr/include/stddef.h" 3 4
# 40 "/usr/include/stddef.h" 3 4

#ifndef _PTRDIFF_T_DECLARED
typedef	__ptrdiff_t	ptrdiff_t;
#define	_PTRDIFF_T_DECLARED
#endif
# 45 "/usr/include/stddef.h" 3 4

#if __BSD_VISIBLE
#ifndef _RUNE_T_DECLARED
typedef	__rune_t	rune_t;
#define	_RUNE_T_DECLARED
#endif
# 51 "/usr/include/stddef.h" 3 4
#endif
# 52 "/usr/include/stddef.h" 3 4

#ifndef _SIZE_T_DECLARED
typedef	__size_t	size_t;
#define	_SIZE_T_DECLARED
#endif
# 57 "/usr/include/stddef.h" 3 4

#ifndef	__cplusplus
#ifndef _WCHAR_T_DECLARED
typedef	___wchar_t	wchar_t;
#define	_WCHAR_T_DECLARED
#endif
# 63 "/usr/include/stddef.h" 3 4
#endif
# 64 "/usr/include/stddef.h" 3 4

#define	offsetof(type, member)	__offsetof(type, member)

#endif /* _STDDEF_H_ */
# 68 "/usr/include/stddef.h" 3 4
# 35 "include/libbb.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <string.h>
#endif /* expanded by -frewrite-includes */
# 35 "include/libbb.h"
# 36 "include/libbb.h"
/* There are two incompatible basename's, let's not use them! */
/* See the dirname/basename man page for details */
#if 0 /* expanded by -frewrite-includes */
#include <libgen.h> /* dirname,basename */
#endif /* expanded by -frewrite-includes */
# 38 "include/libbb.h"
# 1 "/usr/include/libgen.h" 1 3 4
/*	$OpenBSD: libgen.h,v 1.4 1999/05/28 22:00:22 espie Exp $	*/
/*	$FreeBSD: releng/11.0/include/libgen.h 300955 2016-05-29 12:21:54Z ed $	*/

/*
 * Copyright (c) 1997 Todd C. Miller <Todd.Miller@courtesan.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _LIBGEN_H_
#define	_LIBGEN_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 34 "/usr/include/libgen.h" 3 4
# 35 "/usr/include/libgen.h" 3 4

__BEGIN_DECLS
char	*basename(const char *);
char	*basename_r(const char *, char *);
char	*dirname(const char *);
__END_DECLS

#endif /* !_LIBGEN_H_ */
# 43 "/usr/include/libgen.h" 3 4
# 39 "include/libbb.h" 2
#undef basename
#define basename dont_use_basename
#if 0 /* expanded by -frewrite-includes */
#include <poll.h>
#endif /* expanded by -frewrite-includes */
# 41 "include/libbb.h"
# 1 "/usr/include/poll.h" 1 3 4
/*-
 * Copyright (c) 1997 Peter Wemm <peter@freebsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/sys/sys/poll.h 274462 2014-11-13 05:26:14Z dchagin $
 */

#ifndef _SYS_POLL_H_
#define	_SYS_POLL_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 34 "/usr/include/poll.h" 3 4
# 35 "/usr/include/poll.h" 3 4

/*
 * This file is intended to be compatible with the traditional poll.h.
 */

typedef	unsigned int	nfds_t;

/*
 * This structure is passed as an array to poll(2).
 */
struct pollfd {
	int	fd;		/* which file descriptor to poll */
	short	events;		/* events we are interested in */
	short	revents;	/* events found on return */
};

/*
 * Requestable events.  If poll(2) finds any of these set, they are
 * copied to revents on return.
 * XXX Note that FreeBSD doesn't make much distinction between POLLPRI
 * and POLLRDBAND since none of the file types have distinct priority
 * bands - and only some have an urgent "mode".
 * XXX Note POLLIN isn't really supported in true SVSV terms.  Under SYSV
 * POLLIN includes all of normal, band and urgent data.  Most poll handlers
 * on FreeBSD only treat it as "normal" data.
 */
#define	POLLIN		0x0001		/* any readable data available */
#define	POLLPRI		0x0002		/* OOB/Urgent readable data */
#define	POLLOUT		0x0004		/* file descriptor is writeable */
#define	POLLRDNORM	0x0040		/* non-OOB/URG data available */
#define	POLLWRNORM	POLLOUT		/* no write type differentiation */
#define	POLLRDBAND	0x0080		/* OOB/Urgent readable data */
#define	POLLWRBAND	0x0100		/* OOB/Urgent data can be written */

#if __BSD_VISIBLE
/* General FreeBSD extension (currently only supported for sockets): */
#define	POLLINIGNEOF	0x2000		/* like POLLIN, except ignore EOF */
#endif
# 73 "/usr/include/poll.h" 3 4

/*
 * These events are set if they occur regardless of whether they were
 * requested.
 */
#define	POLLERR		0x0008		/* some poll error occurred */
#define	POLLHUP		0x0010		/* file descriptor was "hung up" */
#define	POLLNVAL	0x0020		/* requested events "invalid" */

#if __BSD_VISIBLE

#define	POLLSTANDARD	(POLLIN|POLLPRI|POLLOUT|POLLRDNORM|POLLRDBAND|\
			 POLLWRBAND|POLLERR|POLLHUP|POLLNVAL)

/*
 * Request that poll() wait forever.
 * XXX in SYSV, this is defined in stropts.h, which is not included
 * by poll.h.
 */
#define	INFTIM		(-1)

#endif
# 95 "/usr/include/poll.h" 3 4

#ifndef _KERNEL

#if __BSD_VISIBLE
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 99 "/usr/include/poll.h" 3 4
# 100 "/usr/include/poll.h" 3 4

#if 0 /* expanded by -frewrite-includes */
#include <sys/_sigset.h>
#endif /* expanded by -frewrite-includes */
# 101 "/usr/include/poll.h" 3 4
# 102 "/usr/include/poll.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/timespec.h>
#endif /* expanded by -frewrite-includes */
# 102 "/usr/include/poll.h" 3 4
# 103 "/usr/include/poll.h" 3 4

#ifndef _SIGSET_T_DECLARED
#define	_SIGSET_T_DECLARED
typedef	__sigset_t	sigset_t;
#endif
# 108 "/usr/include/poll.h" 3 4

#endif
# 110 "/usr/include/poll.h" 3 4

__BEGIN_DECLS
int	poll(struct pollfd _pfd[], nfds_t _nfds, int _timeout);
#if __BSD_VISIBLE
int	ppoll(struct pollfd _pfd[], nfds_t _nfds,
	    const struct timespec *__restrict _timeout,
	    const sigset_t *__restrict _newsigmask);
#endif
# 118 "/usr/include/poll.h" 3 4
__END_DECLS

#endif /* !_KERNEL */
# 121 "/usr/include/poll.h" 3 4

#endif /* !_SYS_POLL_H_ */
# 123 "/usr/include/poll.h" 3 4
# 42 "include/libbb.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <sys/ioctl.h>
#endif /* expanded by -frewrite-includes */
# 42 "include/libbb.h"
# 1 "/usr/include/sys/ioctl.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ioctl.h	8.6 (Berkeley) 3/28/94
 * $FreeBSD: releng/11.0/sys/sys/ioctl.h 191947 2009-05-09 19:01:24Z ed $
 */

#ifndef	_SYS_IOCTL_H_
#define	_SYS_IOCTL_H_

#ifdef _KERNEL
#error "Don't #include ioctl.h in the kernel.  Include xxxio.h instead."
#endif /* _KERNEL */
# 44 "/usr/include/sys/ioctl.h" 3 4

#if 0 /* expanded by -frewrite-includes */
#include <sys/ioccom.h>
#endif /* expanded by -frewrite-includes */
# 45 "/usr/include/sys/ioctl.h" 3 4
# 1 "/usr/include/sys/ioccom.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ioccom.h	8.2 (Berkeley) 3/28/94
 * $FreeBSD: releng/11.0/sys/sys/ioccom.h 206051 2010-04-01 16:21:35Z pjd $
 */

#ifndef	_SYS_IOCCOM_H_
#define	_SYS_IOCCOM_H_

/*
 * Ioctl's have the command encoded in the lower word, and the size of
 * any in or out parameters in the upper word.  The high 3 bits of the
 * upper word are used to encode the in/out status of the parameter.
 */
#define	IOCPARM_SHIFT	13		/* number of bits for ioctl size */
#define	IOCPARM_MASK	((1 << IOCPARM_SHIFT) - 1) /* parameter length mask */
#define	IOCPARM_LEN(x)	(((x) >> 16) & IOCPARM_MASK)
#define	IOCBASECMD(x)	((x) & ~(IOCPARM_MASK << 16))
#define	IOCGROUP(x)	(((x) >> 8) & 0xff)

#define	IOCPARM_MAX	(1 << IOCPARM_SHIFT) /* max size of ioctl */
#define	IOC_VOID	0x20000000	/* no parameters */
#define	IOC_OUT		0x40000000	/* copy out parameters */
#define	IOC_IN		0x80000000	/* copy in parameters */
#define	IOC_INOUT	(IOC_IN|IOC_OUT)
#define	IOC_DIRMASK	(IOC_VOID|IOC_OUT|IOC_IN)

#define	_IOC(inout,group,num,len)	((unsigned long) \
	((inout) | (((len) & IOCPARM_MASK) << 16) | ((group) << 8) | (num)))
#define	_IO(g,n)	_IOC(IOC_VOID,	(g), (n), 0)
#define	_IOWINT(g,n)	_IOC(IOC_VOID,	(g), (n), sizeof(int))
#define	_IOR(g,n,t)	_IOC(IOC_OUT,	(g), (n), sizeof(t))
#define	_IOW(g,n,t)	_IOC(IOC_IN,	(g), (n), sizeof(t))
/* this should be _IORW, but stdio got there first */
#define	_IOWR(g,n,t)	_IOC(IOC_INOUT,	(g), (n), sizeof(t))

#ifdef _KERNEL

#if defined(COMPAT_FREEBSD6) || defined(COMPAT_FREEBSD5) || \
    defined(COMPAT_FREEBSD4) || defined(COMPAT_43)
#define	IOCPARM_IVAL(x)	((int)(intptr_t)(void *)*(caddr_t *)(void *)(x))
#endif
# 69 "/usr/include/sys/ioccom.h" 3 4

#else
# 71 "/usr/include/sys/ioccom.h" 3 4

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 72 "/usr/include/sys/ioccom.h" 3 4
# 73 "/usr/include/sys/ioccom.h" 3 4

__BEGIN_DECLS
int	ioctl(int, unsigned long, ...);
__END_DECLS

#endif
# 79 "/usr/include/sys/ioccom.h" 3 4

#endif /* !_SYS_IOCCOM_H_ */
# 81 "/usr/include/sys/ioccom.h" 3 4
# 46 "/usr/include/sys/ioctl.h" 2 3 4

#if 0 /* expanded by -frewrite-includes */
#include <sys/filio.h>
#endif /* expanded by -frewrite-includes */
# 47 "/usr/include/sys/ioctl.h" 3 4
# 1 "/usr/include/sys/filio.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)filio.h	8.1 (Berkeley) 3/28/94
 * $FreeBSD: releng/11.0/sys/sys/filio.h 195191 2009-06-30 13:38:49Z emaste $
 */

#ifndef	_SYS_FILIO_H_
#define	_SYS_FILIO_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/ioccom.h>
#endif /* expanded by -frewrite-includes */
# 41 "/usr/include/sys/filio.h" 3 4
# 42 "/usr/include/sys/filio.h" 3 4

/* Generic file-descriptor ioctl's. */
#define	FIOCLEX		 _IO('f', 1)		/* set close on exec on fd */
#define	FIONCLEX	 _IO('f', 2)		/* remove close on exec */
#define	FIONREAD	_IOR('f', 127, int)	/* get # bytes to read */
#define	FIONBIO		_IOW('f', 126, int)	/* set/clear non-blocking i/o */
#define	FIOASYNC	_IOW('f', 125, int)	/* set/clear async i/o */
#define	FIOSETOWN	_IOW('f', 124, int)	/* set owner */
#define	FIOGETOWN	_IOR('f', 123, int)	/* get owner */
#define	FIODTYPE	_IOR('f', 122, int)	/* get d_flags type part */
#define	FIOGETLBA	_IOR('f', 121, int)	/* get start blk # */
struct fiodgname_arg {
	int	len;
	void	*buf;
};
#define	FIODGNAME	_IOW('f', 120, struct fiodgname_arg) /* get dev. name */
#define	FIONWRITE	_IOR('f', 119, int)	/* get # bytes (yet) to write */
#define	FIONSPACE	_IOR('f', 118, int)	/* get space in send queue */
/* Handle lseek SEEK_DATA and SEEK_HOLE for holey file knowledge. */
#define	FIOSEEKDATA	_IOWR('f', 97, off_t)	/* SEEK_DATA */
#define	FIOSEEKHOLE	_IOWR('f', 98, off_t)	/* SEEK_HOLE */

#endif /* !_SYS_FILIO_H_ */
# 65 "/usr/include/sys/filio.h" 3 4
# 48 "/usr/include/sys/ioctl.h" 2 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/sockio.h>
#endif /* expanded by -frewrite-includes */
# 48 "/usr/include/sys/ioctl.h" 3 4
# 1 "/usr/include/sys/sockio.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)sockio.h	8.1 (Berkeley) 3/28/94
 * $FreeBSD: releng/11.0/sys/sys/sockio.h 298981 2016-05-03 15:14:17Z pfg $
 */

#ifndef _SYS_SOCKIO_H_
#define	_SYS_SOCKIO_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/ioccom.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/sys/sockio.h" 3 4
# 37 "/usr/include/sys/sockio.h" 3 4

/* Socket ioctl's. */
#define	SIOCSHIWAT	 _IOW('s',  0, int)		/* set high watermark */
#define	SIOCGHIWAT	 _IOR('s',  1, int)		/* get high watermark */
#define	SIOCSLOWAT	 _IOW('s',  2, int)		/* set low watermark */
#define	SIOCGLOWAT	 _IOR('s',  3, int)		/* get low watermark */
#define	SIOCATMARK	 _IOR('s',  7, int)		/* at oob mark? */
#define	SIOCSPGRP	 _IOW('s',  8, int)		/* set process group */
#define	SIOCGPGRP	 _IOR('s',  9, int)		/* get process group */

/*	SIOCADDRT	 _IOW('r', 10, struct ortentry)	4.3BSD */
/*	SIOCDELRT	 _IOW('r', 11, struct ortentry)	4.3BSD */
#define	SIOCGETVIFCNT	_IOWR('r', 15, struct sioc_vif_req)/* get vif pkt cnt */
#define	SIOCGETSGCNT	_IOWR('r', 16, struct sioc_sg_req) /* get s,g pkt cnt */

#define	SIOCSIFADDR	 _IOW('i', 12, struct ifreq)	/* set ifnet address */
/*	OSIOCGIFADDR	_IOWR('i', 13, struct ifreq)	4.3BSD */
#define	SIOCGIFADDR	_IOWR('i', 33, struct ifreq)	/* get ifnet address */
#define	SIOCSIFDSTADDR	 _IOW('i', 14, struct ifreq)	/* set p-p address */
/*	OSIOCGIFDSTADDR	_IOWR('i', 15, struct ifreq)	4.3BSD */
#define	SIOCGIFDSTADDR	_IOWR('i', 34, struct ifreq)	/* get p-p address */
#define	SIOCSIFFLAGS	 _IOW('i', 16, struct ifreq)	/* set ifnet flags */
#define	SIOCGIFFLAGS	_IOWR('i', 17, struct ifreq)	/* get ifnet flags */
/*	OSIOCGIFBRDADDR	_IOWR('i', 18, struct ifreq)	4.3BSD */
#define	SIOCGIFBRDADDR	_IOWR('i', 35, struct ifreq)	/* get broadcast addr */
#define	SIOCSIFBRDADDR	 _IOW('i', 19, struct ifreq)	/* set broadcast addr */
/*	OSIOCGIFCONF	_IOWR('i', 20, struct ifconf)	4.3BSD */
#define	SIOCGIFCONF	_IOWR('i', 36, struct ifconf)	/* get ifnet list */
/*	OSIOCGIFNETMASK	_IOWR('i', 21, struct ifreq)	4.3BSD */
#define	SIOCGIFNETMASK	_IOWR('i', 37, struct ifreq)	/* get net addr mask */
#define	SIOCSIFNETMASK	 _IOW('i', 22, struct ifreq)	/* set net addr mask */
#define	SIOCGIFMETRIC	_IOWR('i', 23, struct ifreq)	/* get IF metric */
#define	SIOCSIFMETRIC	 _IOW('i', 24, struct ifreq)	/* set IF metric */
#define	SIOCDIFADDR	 _IOW('i', 25, struct ifreq)	/* delete IF addr */
#define	OSIOCAIFADDR	 _IOW('i', 26, struct oifaliasreq) /* FreeBSD 9.x */
/*	SIOCALIFADDR	 _IOW('i', 27, struct if_laddrreq) KAME */
/*	SIOCGLIFADDR	_IOWR('i', 28, struct if_laddrreq) KAME */
/*	SIOCDLIFADDR	 _IOW('i', 29, struct if_laddrreq) KAME */
#define	SIOCSIFCAP	 _IOW('i', 30, struct ifreq)	/* set IF features */
#define	SIOCGIFCAP	_IOWR('i', 31, struct ifreq)	/* get IF features */
#define	SIOCGIFINDEX	_IOWR('i', 32, struct ifreq)	/* get IF index */
#define	SIOCGIFMAC	_IOWR('i', 38, struct ifreq)	/* get IF MAC label */
#define	SIOCSIFMAC	 _IOW('i', 39, struct ifreq)	/* set IF MAC label */
#define	SIOCSIFNAME	 _IOW('i', 40, struct ifreq)	/* set IF name */
#define	SIOCSIFDESCR	 _IOW('i', 41, struct ifreq)	/* set ifnet descr */ 
#define	SIOCGIFDESCR	_IOWR('i', 42, struct ifreq)	/* get ifnet descr */ 
#define	SIOCAIFADDR	 _IOW('i', 43, struct ifaliasreq)/* add/chg IF alias */

#define	SIOCADDMULTI	 _IOW('i', 49, struct ifreq)	/* add m'cast addr */
#define	SIOCDELMULTI	 _IOW('i', 50, struct ifreq)	/* del m'cast addr */
#define	SIOCGIFMTU	_IOWR('i', 51, struct ifreq)	/* get IF mtu */
#define	SIOCSIFMTU	 _IOW('i', 52, struct ifreq)	/* set IF mtu */
#define	SIOCGIFPHYS	_IOWR('i', 53, struct ifreq)	/* get IF wire */
#define	SIOCSIFPHYS	 _IOW('i', 54, struct ifreq)	/* set IF wire */
#define	SIOCSIFMEDIA	_IOWR('i', 55, struct ifreq)	/* set net media */
#define	SIOCGIFMEDIA	_IOWR('i', 56, struct ifmediareq) /* get net media */

#define	SIOCSIFGENERIC	 _IOW('i', 57, struct ifreq)	/* generic IF set op */
#define	SIOCGIFGENERIC	_IOWR('i', 58, struct ifreq)	/* generic IF get op */

#define	SIOCGIFSTATUS	_IOWR('i', 59, struct ifstat)	/* get IF status */
#define	SIOCSIFLLADDR	 _IOW('i', 60, struct ifreq)	/* set linklevel addr */
#define	SIOCGI2C	_IOWR('i', 61, struct ifreq)	/* get I2C data  */

#define	SIOCSIFPHYADDR	 _IOW('i', 70, struct ifaliasreq) /* set gif address */
#define	SIOCGIFPSRCADDR	_IOWR('i', 71, struct ifreq)	/* get gif psrc addr */
#define	SIOCGIFPDSTADDR	_IOWR('i', 72, struct ifreq)	/* get gif pdst addr */
#define	SIOCDIFPHYADDR	 _IOW('i', 73, struct ifreq)	/* delete gif addrs */
/*	SIOCSLIFPHYADDR	 _IOW('i', 74, struct if_laddrreq) KAME */
/*	SIOCGLIFPHYADDR	_IOWR('i', 75, struct if_laddrreq) KAME */

#define	SIOCGPRIVATE_0	_IOWR('i', 80, struct ifreq)	/* device private 0 */
#define	SIOCGPRIVATE_1	_IOWR('i', 81, struct ifreq)	/* device private 1 */

#define	SIOCSIFVNET	_IOWR('i', 90, struct ifreq)	/* move IF jail/vnet */
#define	SIOCSIFRVNET	_IOWR('i', 91, struct ifreq)	/* reclaim vnet IF */

#define	SIOCGIFFIB	_IOWR('i', 92, struct ifreq)	/* get IF fib */
#define	SIOCSIFFIB	 _IOW('i', 93, struct ifreq)	/* set IF fib */

#define	SIOCGTUNFIB	_IOWR('i', 94, struct ifreq)	/* get tunnel fib */
#define	SIOCSTUNFIB	 _IOW('i', 95, struct ifreq)	/* set tunnel fib */

#define	SIOCSDRVSPEC	_IOW('i', 123, struct ifdrv)	/* set driver-specific
								  parameters */
#define	SIOCGDRVSPEC	_IOWR('i', 123, struct ifdrv)	/* get driver-specific
								  parameters */

#define	SIOCIFCREATE	_IOWR('i', 122, struct ifreq)	/* create clone if */
#define	SIOCIFCREATE2	_IOWR('i', 124, struct ifreq)	/* create clone if */
#define	SIOCIFDESTROY	 _IOW('i', 121, struct ifreq)	/* destroy clone if */
#define	SIOCIFGCLONERS	_IOWR('i', 120, struct if_clonereq) /* get cloners */

#define	SIOCAIFGROUP	 _IOW('i', 135, struct ifgroupreq) /* add an ifgroup */
#define	SIOCGIFGROUP	_IOWR('i', 136, struct ifgroupreq) /* get ifgroups */
#define	SIOCDIFGROUP	 _IOW('i', 137, struct ifgroupreq) /* delete ifgroup */
#define	SIOCGIFGMEMB	_IOWR('i', 138, struct ifgroupreq) /* get members */
#define	SIOCGIFXMEDIA	_IOWR('i', 139, struct ifmediareq) /* get net xmedia */

#endif /* !_SYS_SOCKIO_H_ */
# 137 "/usr/include/sys/sockio.h" 3 4
# 49 "/usr/include/sys/ioctl.h" 2 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/ttycom.h>
#endif /* expanded by -frewrite-includes */
# 49 "/usr/include/sys/ioctl.h" 3 4
# 1 "/usr/include/sys/ttycom.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ttycom.h	8.1 (Berkeley) 3/28/94
 * $FreeBSD: releng/11.0/sys/sys/ttycom.h 231095 2012-02-06 18:15:46Z ed $
 */

#ifndef	_SYS_TTYCOM_H_
#define	_SYS_TTYCOM_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/ioccom.h>
#endif /* expanded by -frewrite-includes */
# 41 "/usr/include/sys/ttycom.h" 3 4
# 42 "/usr/include/sys/ttycom.h" 3 4

/*
 * Tty ioctl's except for those supported only for backwards compatibility
 * with the old tty driver.
 */

/*
 * Window/terminal size structure.  This information is stored by the kernel
 * in order to provide a consistent interface, but is not used by the kernel.
 */
struct winsize {
	unsigned short	ws_row;		/* rows, in characters */
	unsigned short	ws_col;		/* columns, in characters */
	unsigned short	ws_xpixel;	/* horizontal size, pixels */
	unsigned short	ws_ypixel;	/* vertical size, pixels */
};

						/* 0-2 compat */
						/* 3-7 unused */
						/* 8-10 compat */
						/* 11-12 unused */
#define	TIOCEXCL	 _IO('t', 13)		/* set exclusive use of tty */
#define	TIOCNXCL	 _IO('t', 14)		/* reset exclusive use of tty */
#define	TIOCGPTN	_IOR('t', 15, int)	/* Get pts number. */
#define	TIOCFLUSH	_IOW('t', 16, int)	/* flush buffers */
						/* 17-18 compat */
#define	TIOCGETA	_IOR('t', 19, struct termios) /* get termios struct */
#define	TIOCSETA	_IOW('t', 20, struct termios) /* set termios struct */
#define	TIOCSETAW	_IOW('t', 21, struct termios) /* drain output, set */
#define	TIOCSETAF	_IOW('t', 22, struct termios) /* drn out, fls in, set */
						/* 23-25 unused */
#define	TIOCGETD	_IOR('t', 26, int)	/* get line discipline */
#define	TIOCSETD	_IOW('t', 27, int)	/* set line discipline */
#define	TIOCPTMASTER	 _IO('t', 28)		/* pts master validation */
						/* 29-85 unused */
#define	TIOCGDRAINWAIT	_IOR('t', 86, int)	/* get ttywait timeout */
#define	TIOCSDRAINWAIT	_IOW('t', 87, int)	/* set ttywait timeout */
						/* 88 unused */
						/* 89-91 conflicts: tun and tap */
#define	TIOCTIMESTAMP	_IOR('t', 89, struct timeval)	/* enable/get timestamp
						 * of last input event */
#define	TIOCMGDTRWAIT	_IOR('t', 90, int)	/* modem: get wait on close */
#define	TIOCMSDTRWAIT	_IOW('t', 91, int)	/* modem: set wait on close */
						/* 92-93 tun and tap */
						/* 94-97 conflicts: tun and tap */
#define	TIOCDRAIN	 _IO('t', 94)		/* wait till output drained */
#define	TIOCSIG		_IOWINT('t', 95)	/* pty: generate signal */
#define	TIOCEXT		_IOW('t', 96, int)	/* pty: external processing */
#define	TIOCSCTTY	 _IO('t', 97)		/* become controlling tty */
#define	TIOCCONS	_IOW('t', 98, int)	/* become virtual console */
#define	TIOCGSID	_IOR('t', 99, int)	/* get session id */
						/* 100 unused */
#define	TIOCSTAT	 _IO('t', 101)		/* simulate ^T status message */
#define	TIOCUCNTL	_IOW('t', 102, int)	/* pty: set/clr usr cntl mode */
#define		UIOCCMD(n)	_IO('u', n)	/* usr cntl op "n" */
#define	TIOCSWINSZ	_IOW('t', 103, struct winsize)	/* set window size */
#define	TIOCGWINSZ	_IOR('t', 104, struct winsize)	/* get window size */
						/* 105 unused */
#define	TIOCMGET	_IOR('t', 106, int)	/* get all modem bits */
#define		TIOCM_LE	0001		/* line enable */
#define		TIOCM_DTR	0002		/* data terminal ready */
#define		TIOCM_RTS	0004		/* request to send */
#define		TIOCM_ST	0010		/* secondary transmit */
#define		TIOCM_SR	0020		/* secondary receive */
#define		TIOCM_CTS	0040		/* clear to send */
#define		TIOCM_DCD	0100		/* data carrier detect */
#define		TIOCM_RI	0200		/* ring indicate */
#define		TIOCM_DSR	0400		/* data set ready */
#define		TIOCM_CD	TIOCM_DCD
#define		TIOCM_CAR	TIOCM_DCD
#define		TIOCM_RNG	TIOCM_RI
#define	TIOCMBIC	_IOW('t', 107, int)	/* bic modem bits */
#define	TIOCMBIS	_IOW('t', 108, int)	/* bis modem bits */
#define	TIOCMSET	_IOW('t', 109, int)	/* set all modem bits */
#define	TIOCSTART	 _IO('t', 110)		/* start output, like ^Q */
#define	TIOCSTOP	 _IO('t', 111)		/* stop output, like ^S */
#define	TIOCPKT		_IOW('t', 112, int)	/* pty: set/clear packet mode */
#define		TIOCPKT_DATA		0x00	/* data packet */
#define		TIOCPKT_FLUSHREAD	0x01	/* flush packet */
#define		TIOCPKT_FLUSHWRITE	0x02	/* flush packet */
#define		TIOCPKT_STOP		0x04	/* stop output */
#define		TIOCPKT_START		0x08	/* start output */
#define		TIOCPKT_NOSTOP		0x10	/* no more ^S, ^Q */
#define		TIOCPKT_DOSTOP		0x20	/* now do ^S ^Q */
#define		TIOCPKT_IOCTL		0x40	/* state change of pty driver */
#define	TIOCNOTTY	 _IO('t', 113)		/* void tty association */
#define	TIOCSTI		_IOW('t', 114, char)	/* simulate terminal input */
#define	TIOCOUTQ	_IOR('t', 115, int)	/* output queue size */
						/* 116-117 compat */
#define	TIOCSPGRP	_IOW('t', 118, int)	/* set pgrp of tty */
#define	TIOCGPGRP	_IOR('t', 119, int)	/* get pgrp of tty */
#define	TIOCCDTR	 _IO('t', 120)		/* clear data terminal ready */
#define	TIOCSDTR	 _IO('t', 121)		/* set data terminal ready */
#define	TIOCCBRK	 _IO('t', 122)		/* clear break bit */
#define	TIOCSBRK	 _IO('t', 123)		/* set break bit */
						/* 124-127 compat */

#define	TTYDISC		0		/* termios tty line discipline */
#define	SLIPDISC	4		/* serial IP discipline */
#define	PPPDISC		5		/* PPP discipline */
#define	NETGRAPHDISC	6		/* Netgraph tty node discipline */
#define	H4DISC		7		/* Netgraph Bluetooth H4 discipline */

#endif /* !_SYS_TTYCOM_H_ */
# 146 "/usr/include/sys/ttycom.h" 3 4
# 50 "/usr/include/sys/ioctl.h" 2 3 4

#endif /* !_SYS_IOCTL_H_ */
# 52 "/usr/include/sys/ioctl.h" 3 4
# 43 "include/libbb.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <sys/mman.h>
#endif /* expanded by -frewrite-includes */
# 43 "include/libbb.h"
# 1 "/usr/include/sys/mman.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)mman.h	8.2 (Berkeley) 1/9/95
 * $FreeBSD: releng/11.0/sys/sys/mman.h 296162 2016-02-28 17:52:33Z kib $
 */

#ifndef _SYS_MMAN_H_
#define _SYS_MMAN_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/sys/mman.h" 3 4
# 37 "/usr/include/sys/mman.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 37 "/usr/include/sys/mman.h" 3 4
# 38 "/usr/include/sys/mman.h" 3 4

#if __BSD_VISIBLE
/*
 * Inheritance for minherit()
 */
#define INHERIT_SHARE	0
#define INHERIT_COPY	1
#define INHERIT_NONE	2
#endif
# 47 "/usr/include/sys/mman.h" 3 4

/*
 * Protections are chosen from these bits, or-ed together
 */
#define	PROT_NONE	0x00	/* no permissions */
#define	PROT_READ	0x01	/* pages can be read */
#define	PROT_WRITE	0x02	/* pages can be written */
#define	PROT_EXEC	0x04	/* pages can be executed */

/*
 * Flags contain sharing type and options.
 * Sharing types; choose one.
 */
#define	MAP_SHARED	0x0001		/* share changes */
#define	MAP_PRIVATE	0x0002		/* changes are private */
#if __BSD_VISIBLE
#define	MAP_COPY	MAP_PRIVATE	/* Obsolete */
#endif
# 65 "/usr/include/sys/mman.h" 3 4

/*
 * Other flags
 */
#define	MAP_FIXED	 0x0010	/* map addr must be exactly as requested */

#if __BSD_VISIBLE
#define	MAP_RESERVED0020 0x0020	/* previously unimplemented MAP_RENAME */
#define	MAP_RESERVED0040 0x0040	/* previously unimplemented MAP_NORESERVE */
#define	MAP_RESERVED0080 0x0080	/* previously misimplemented MAP_INHERIT */
#define	MAP_RESERVED0100 0x0100	/* previously unimplemented MAP_NOEXTEND */
#define	MAP_HASSEMAPHORE 0x0200	/* region may contain semaphores */
#define	MAP_STACK	 0x0400	/* region grows down, like a stack */
#define	MAP_NOSYNC	 0x0800 /* page to but do not sync underlying file */

/*
 * Mapping type
 */
#define	MAP_FILE	 0x0000	/* map from file (default) */
#define	MAP_ANON	 0x1000	/* allocated from memory, swap space */
#ifndef _KERNEL
#define	MAP_ANONYMOUS	 MAP_ANON /* For compatibility. */
#endif /* !_KERNEL */
# 88 "/usr/include/sys/mman.h" 3 4

/*
 * Extended flags
 */
#define	MAP_EXCL	 0x00004000 /* for MAP_FIXED, fail if address is used */
#define	MAP_NOCORE	 0x00020000 /* dont include these pages in a coredump */
#define	MAP_PREFAULT_READ 0x00040000 /* prefault mapping for reading */
#ifdef __LP64__
#define	MAP_32BIT	 0x00080000 /* map in the low 2GB of address space */
#endif
# 98 "/usr/include/sys/mman.h" 3 4

/*
 * Request specific alignment (n == log2 of the desired alignment).
 *
 * MAP_ALIGNED_SUPER requests optimal superpage alignment, but does
 * not enforce a specific alignment.
 */
#define	MAP_ALIGNED(n)	 ((n) << MAP_ALIGNMENT_SHIFT)
#define	MAP_ALIGNMENT_SHIFT	24
#define	MAP_ALIGNMENT_MASK	MAP_ALIGNED(0xff)
#define	MAP_ALIGNED_SUPER	MAP_ALIGNED(1) /* align on a superpage */
#endif /* __BSD_VISIBLE */
# 110 "/usr/include/sys/mman.h" 3 4

#if __POSIX_VISIBLE >= 199309
/*
 * Process memory locking
 */
#define MCL_CURRENT	0x0001	/* Lock only current memory */
#define MCL_FUTURE	0x0002	/* Lock all future memory as well */
#endif
# 118 "/usr/include/sys/mman.h" 3 4

/*
 * Error return from mmap()
 */
#define MAP_FAILED	((void *)-1)

/*
 * msync() flags
 */
#define	MS_SYNC		0x0000	/* msync synchronously */
#define MS_ASYNC	0x0001	/* return immediately */
#define MS_INVALIDATE	0x0002	/* invalidate all cached data */

/*
 * Advice to madvise
 */
#define	_MADV_NORMAL	0	/* no further special treatment */
#define	_MADV_RANDOM	1	/* expect random page references */
#define	_MADV_SEQUENTIAL 2	/* expect sequential page references */
#define	_MADV_WILLNEED	3	/* will need these pages */
#define	_MADV_DONTNEED	4	/* dont need these pages */

#if __BSD_VISIBLE
#define	MADV_NORMAL	_MADV_NORMAL
#define	MADV_RANDOM	_MADV_RANDOM
#define	MADV_SEQUENTIAL _MADV_SEQUENTIAL
#define	MADV_WILLNEED	_MADV_WILLNEED
#define	MADV_DONTNEED	_MADV_DONTNEED
#define	MADV_FREE	5	/* dont need these pages, and junk contents */
#define	MADV_NOSYNC	6	/* try to avoid flushes to physical media */
#define	MADV_AUTOSYNC	7	/* revert to default flushing strategy */
#define	MADV_NOCORE	8	/* do not include these pages in a core file */
#define	MADV_CORE	9	/* revert to including pages in a core file */
#define	MADV_PROTECT	10	/* protect process from pageout kill */

/*
 * Return bits from mincore
 */
#define	MINCORE_INCORE	 	 0x1 /* Page is incore */
#define	MINCORE_REFERENCED	 0x2 /* Page has been referenced by us */
#define	MINCORE_MODIFIED	 0x4 /* Page has been modified by us */
#define	MINCORE_REFERENCED_OTHER 0x8 /* Page has been referenced */
#define	MINCORE_MODIFIED_OTHER	0x10 /* Page has been modified */
#define	MINCORE_SUPER		0x20 /* Page is a "super" page */

/*
 * Anonymous object constant for shm_open().
 */
#define	SHM_ANON		((char *)1)
#endif /* __BSD_VISIBLE */
# 168 "/usr/include/sys/mman.h" 3 4

/*
 * XXX missing POSIX_TYPED_MEM_* macros and
 * posix_typed_mem_info structure.
 */
#if __POSIX_VISIBLE >= 200112
#define	POSIX_MADV_NORMAL	_MADV_NORMAL
#define	POSIX_MADV_RANDOM	_MADV_RANDOM
#define	POSIX_MADV_SEQUENTIAL	_MADV_SEQUENTIAL
#define	POSIX_MADV_WILLNEED	_MADV_WILLNEED
#define	POSIX_MADV_DONTNEED	_MADV_DONTNEED
#endif
# 180 "/usr/include/sys/mman.h" 3 4

#ifndef _MODE_T_DECLARED
typedef	__mode_t	mode_t;
#define	_MODE_T_DECLARED
#endif
# 185 "/usr/include/sys/mman.h" 3 4

#ifndef _OFF_T_DECLARED
typedef	__off_t		off_t;
#define	_OFF_T_DECLARED
#endif
# 190 "/usr/include/sys/mman.h" 3 4

#ifndef _SIZE_T_DECLARED
typedef	__size_t	size_t;
#define	_SIZE_T_DECLARED
#endif
# 195 "/usr/include/sys/mman.h" 3 4

#if defined(_KERNEL) || defined(_WANT_FILE)
#if 0 /* expanded by -frewrite-includes */
#include <sys/lock.h>
#endif /* expanded by -frewrite-includes */
# 197 "/usr/include/sys/mman.h" 3 4
# 198 "/usr/include/sys/mman.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/mutex.h>
#endif /* expanded by -frewrite-includes */
# 198 "/usr/include/sys/mman.h" 3 4
# 199 "/usr/include/sys/mman.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/queue.h>
#endif /* expanded by -frewrite-includes */
# 199 "/usr/include/sys/mman.h" 3 4
# 200 "/usr/include/sys/mman.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/rangelock.h>
#endif /* expanded by -frewrite-includes */
# 200 "/usr/include/sys/mman.h" 3 4
# 201 "/usr/include/sys/mman.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <vm/vm.h>
#endif /* expanded by -frewrite-includes */
# 201 "/usr/include/sys/mman.h" 3 4
# 202 "/usr/include/sys/mman.h" 3 4

struct file;

struct shmfd {
	size_t		shm_size;
	vm_object_t	shm_object;
	int		shm_refs;
	uid_t		shm_uid;
	gid_t		shm_gid;
	mode_t		shm_mode;
	int		shm_kmappings;

	/*
	 * Values maintained solely to make this a better-behaved file
	 * descriptor for fstat() to run on.
	 */
	struct timespec	shm_atime;
	struct timespec	shm_mtime;
	struct timespec	shm_ctime;
	struct timespec	shm_birthtime;
	ino_t		shm_ino;

	struct label	*shm_label;		/* MAC label */
	const char	*shm_path;

	struct rangelock shm_rl;
	struct mtx	shm_mtx;
};
#endif
# 231 "/usr/include/sys/mman.h" 3 4

#ifdef _KERNEL
int	shm_map(struct file *fp, size_t size, off_t offset, void **memp);
int	shm_unmap(struct file *fp, void *mem, size_t size);

int	shm_access(struct shmfd *shmfd, struct ucred *ucred, int flags);
struct shmfd *shm_alloc(struct ucred *ucred, mode_t mode);
struct shmfd *shm_hold(struct shmfd *shmfd);
void	shm_drop(struct shmfd *shmfd);
int	shm_dotruncate(struct shmfd *shmfd, off_t length);

extern struct fileops shm_ops;
#else /* !_KERNEL */
# 244 "/usr/include/sys/mman.h" 3 4

__BEGIN_DECLS
/*
 * XXX not yet implemented: posix_mem_offset(), posix_typed_mem_get_info(),
 * posix_typed_mem_open().
 */
#if __BSD_VISIBLE
int	getpagesizes(size_t *, int);
int	madvise(void *, size_t, int);
int	mincore(const void *, size_t, char *);
int	minherit(void *, size_t, int);
#endif
# 256 "/usr/include/sys/mman.h" 3 4
int	mlock(const void *, size_t);
#ifndef _MMAP_DECLARED
#define	_MMAP_DECLARED
void *	mmap(void *, size_t, int, int, int, off_t);
#endif
# 261 "/usr/include/sys/mman.h" 3 4
int	mprotect(const void *, size_t, int);
int	msync(void *, size_t, int);
int	munlock(const void *, size_t);
int	munmap(void *, size_t);
#if __POSIX_VISIBLE >= 200112
int	posix_madvise(void *, size_t, int);
#endif
# 268 "/usr/include/sys/mman.h" 3 4
#if __POSIX_VISIBLE >= 199309
int	mlockall(int);
int	munlockall(void);
int	shm_open(const char *, int, mode_t);
int	shm_unlink(const char *);
#endif
# 274 "/usr/include/sys/mman.h" 3 4
__END_DECLS

#endif /* !_KERNEL */
# 277 "/usr/include/sys/mman.h" 3 4

#endif /* !_SYS_MMAN_H_ */
# 279 "/usr/include/sys/mman.h" 3 4
# 44 "include/libbb.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <sys/socket.h>
#endif /* expanded by -frewrite-includes */
# 44 "include/libbb.h"
# 1 "/usr/include/sys/socket.h" 1 3 4
/*-
 * Copyright (c) 1982, 1985, 1986, 1988, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)socket.h	8.4 (Berkeley) 2/21/94
 * $FreeBSD: releng/11.0/sys/sys/socket.h 301038 2016-05-31 13:32:33Z ed $
 */

#ifndef _SYS_SOCKET_H_
#define	_SYS_SOCKET_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/sys/socket.h" 3 4
# 37 "/usr/include/sys/socket.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 37 "/usr/include/sys/socket.h" 3 4
# 38 "/usr/include/sys/socket.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_iovec.h>
#endif /* expanded by -frewrite-includes */
# 38 "/usr/include/sys/socket.h" 3 4
# 1 "/usr/include/sys/_iovec.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)uio.h	8.5 (Berkeley) 2/22/94
 * $FreeBSD: releng/11.0/sys/sys/_iovec.h 139825 2005-01-07 02:29:27Z imp $
 */

#ifndef _SYS__IOVEC_H_
#define	_SYS__IOVEC_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/sys/_iovec.h" 3 4
# 37 "/usr/include/sys/_iovec.h" 3 4

#ifndef _SIZE_T_DECLARED
typedef	__size_t	size_t;
#define	_SIZE_T_DECLARED
#endif
# 42 "/usr/include/sys/_iovec.h" 3 4

struct iovec {
	void	*iov_base;	/* Base address. */
	size_t	 iov_len;	/* Length. */
};

#endif /* !_SYS__IOVEC_H_ */
# 49 "/usr/include/sys/_iovec.h" 3 4
# 39 "/usr/include/sys/socket.h" 2 3 4
#if 0 /* expanded by -frewrite-includes */
#include <machine/_align.h>
#endif /* expanded by -frewrite-includes */
# 39 "/usr/include/sys/socket.h" 3 4
# 1 "/usr/include/machine/_align.h" 1 3 4
/*-
 * This file is in the public domain.
 */
/* $FreeBSD: releng/11.0/sys/amd64/include/_align.h 215856 2010-11-26 10:59:20Z tijl $ */

#if 0 /* expanded by -frewrite-includes */
#include <x86/_align.h>
#endif /* expanded by -frewrite-includes */
# 6 "/usr/include/machine/_align.h" 3 4
# 1 "/usr/include/x86/_align.h" 1 3 4
/*-
 * Copyright (c) 2001 David E. O'Brien
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @(#)param.h	5.8 (Berkeley) 6/28/91
 * $FreeBSD: releng/11.0/sys/x86/include/_align.h 301037 2016-05-31 13:31:19Z ed $
 */

#ifndef _X86_INCLUDE__ALIGN_H_
#define	_X86_INCLUDE__ALIGN_H_

/*
 * Round p (pointer or byte index) up to a correctly-aligned value
 * for all data types (int, long, ...).   The result is unsigned int
 * and must be cast to any desired pointer type.
 */
#define	_ALIGNBYTES	(sizeof(__register_t) - 1)
#define	_ALIGN(p)	(((__uintptr_t)(p) + _ALIGNBYTES) & ~_ALIGNBYTES)

#endif /* !_X86_INCLUDE__ALIGN_H_ */
# 53 "/usr/include/x86/_align.h" 3 4
# 7 "/usr/include/machine/_align.h" 2 3 4
# 40 "/usr/include/sys/socket.h" 2 3 4

/*
 * Definitions related to sockets: types, address families, options.
 */

/*
 * Data types.
 */
#if __BSD_VISIBLE
#ifndef _GID_T_DECLARED
typedef	__gid_t		gid_t;
#define	_GID_T_DECLARED
#endif
# 53 "/usr/include/sys/socket.h" 3 4

#ifndef _OFF_T_DECLARED
typedef	__off_t		off_t;
#define	_OFF_T_DECLARED
#endif
# 58 "/usr/include/sys/socket.h" 3 4

#ifndef _PID_T_DECLARED
typedef	__pid_t		pid_t;
#define	_PID_T_DECLARED
#endif
# 63 "/usr/include/sys/socket.h" 3 4
#endif
# 64 "/usr/include/sys/socket.h" 3 4

#ifndef _SA_FAMILY_T_DECLARED
typedef	__sa_family_t	sa_family_t;
#define	_SA_FAMILY_T_DECLARED
#endif
# 69 "/usr/include/sys/socket.h" 3 4

#ifndef _SOCKLEN_T_DECLARED
typedef	__socklen_t	socklen_t;
#define	_SOCKLEN_T_DECLARED
#endif
# 74 "/usr/include/sys/socket.h" 3 4
 
#ifndef _SSIZE_T_DECLARED
typedef	__ssize_t	ssize_t;
#define	_SSIZE_T_DECLARED
#endif
# 79 "/usr/include/sys/socket.h" 3 4

#if __BSD_VISIBLE 
#ifndef _UID_T_DECLARED
typedef	__uid_t		uid_t;
#define	_UID_T_DECLARED
#endif
# 85 "/usr/include/sys/socket.h" 3 4
#endif
# 86 "/usr/include/sys/socket.h" 3 4

#ifndef _UINT32_T_DECLARED
typedef	__uint32_t	uint32_t;
#define	_UINT32_T_DECLARED
#endif
# 91 "/usr/include/sys/socket.h" 3 4

#ifndef _UINTPTR_T_DECLARED
typedef	__uintptr_t	uintptr_t;
#define	_UINTPTR_T_DECLARED
#endif
# 96 "/usr/include/sys/socket.h" 3 4

/*
 * Types
 */
#define	SOCK_STREAM	1		/* stream socket */
#define	SOCK_DGRAM	2		/* datagram socket */
#define	SOCK_RAW	3		/* raw-protocol interface */
#if __BSD_VISIBLE
#define	SOCK_RDM	4		/* reliably-delivered message */
#endif
# 106 "/usr/include/sys/socket.h" 3 4
#define	SOCK_SEQPACKET	5		/* sequenced packet stream */

#if __BSD_VISIBLE
/*
 * Creation flags, OR'ed into socket() and socketpair() type argument.
 */
#define	SOCK_CLOEXEC	0x10000000
#define	SOCK_NONBLOCK	0x20000000
#endif
# 115 "/usr/include/sys/socket.h" 3 4

/*
 * Option flags per-socket.
 */
#define	SO_DEBUG	0x0001		/* turn on debugging info recording */
#define	SO_ACCEPTCONN	0x0002		/* socket has had listen() */
#define	SO_REUSEADDR	0x0004		/* allow local address reuse */
#define	SO_KEEPALIVE	0x0008		/* keep connections alive */
#define	SO_DONTROUTE	0x0010		/* just use interface addresses */
#define	SO_BROADCAST	0x0020		/* permit sending of broadcast msgs */
#if __BSD_VISIBLE
#define	SO_USELOOPBACK	0x0040		/* bypass hardware when possible */
#endif
# 128 "/usr/include/sys/socket.h" 3 4
#define	SO_LINGER	0x0080		/* linger on close if data present */
#define	SO_OOBINLINE	0x0100		/* leave received OOB data in line */
#if __BSD_VISIBLE
#define	SO_REUSEPORT	0x0200		/* allow local address & port reuse */
#define	SO_TIMESTAMP	0x0400		/* timestamp received dgram traffic */
#define	SO_NOSIGPIPE	0x0800		/* no SIGPIPE from EPIPE */
#define	SO_ACCEPTFILTER	0x1000		/* there is an accept filter */
#define	SO_BINTIME	0x2000		/* timestamp received dgram traffic */
#endif
# 137 "/usr/include/sys/socket.h" 3 4
#define	SO_NO_OFFLOAD	0x4000		/* socket cannot be offloaded */
#define	SO_NO_DDP	0x8000		/* disable direct data placement */

/*
 * Additional options, not kept in so_options.
 */
#define	SO_SNDBUF	0x1001		/* send buffer size */
#define	SO_RCVBUF	0x1002		/* receive buffer size */
#define	SO_SNDLOWAT	0x1003		/* send low-water mark */
#define	SO_RCVLOWAT	0x1004		/* receive low-water mark */
#define	SO_SNDTIMEO	0x1005		/* send timeout */
#define	SO_RCVTIMEO	0x1006		/* receive timeout */
#define	SO_ERROR	0x1007		/* get error status and clear */
#define	SO_TYPE		0x1008		/* get socket type */
#if __BSD_VISIBLE
#define	SO_LABEL	0x1009		/* socket's MAC label */
#define	SO_PEERLABEL	0x1010		/* socket's peer's MAC label */
#define	SO_LISTENQLIMIT	0x1011		/* socket's backlog limit */
#define	SO_LISTENQLEN	0x1012		/* socket's complete queue length */
#define	SO_LISTENINCQLEN	0x1013	/* socket's incomplete queue length */
#define	SO_SETFIB	0x1014		/* use this FIB to route */
#define	SO_USER_COOKIE	0x1015		/* user cookie (dummynet etc.) */
#define	SO_PROTOCOL	0x1016		/* get socket protocol (Linux name) */
#define	SO_PROTOTYPE	SO_PROTOCOL	/* alias for SO_PROTOCOL (SunOS name) */
#endif
# 162 "/usr/include/sys/socket.h" 3 4

/*
 * Space reserved for new socket options added by third-party vendors.
 * This range applies to all socket option levels.  New socket options
 * in FreeBSD should always use an option value less than SO_VENDOR.
 */
#if __BSD_VISIBLE
#define	SO_VENDOR	0x80000000
#endif
# 171 "/usr/include/sys/socket.h" 3 4

/*
 * Structure used for manipulating linger option.
 */
struct linger {
	int	l_onoff;		/* option on/off */
	int	l_linger;		/* linger time */
};

#if __BSD_VISIBLE
struct accept_filter_arg {
	char	af_name[16];
	char	af_arg[256-16];
};
#endif
# 186 "/usr/include/sys/socket.h" 3 4

/*
 * Level number for (get/set)sockopt() to apply to socket itself.
 */
#define	SOL_SOCKET	0xffff		/* options for socket level */

/*
 * Address families.
 */
#define	AF_UNSPEC	0		/* unspecified */
#if __BSD_VISIBLE
#define	AF_LOCAL	AF_UNIX		/* local to host (pipes, portals) */
#endif
# 199 "/usr/include/sys/socket.h" 3 4
#define	AF_UNIX		1		/* standardized name for AF_LOCAL */
#define	AF_INET		2		/* internetwork: UDP, TCP, etc. */
#if __BSD_VISIBLE
#define	AF_IMPLINK	3		/* arpanet imp addresses */
#define	AF_PUP		4		/* pup protocols: e.g. BSP */
#define	AF_CHAOS	5		/* mit CHAOS protocols */
#define	AF_NETBIOS	6		/* SMB protocols */
#define	AF_ISO		7		/* ISO protocols */
#define	AF_OSI		AF_ISO
#define	AF_ECMA		8		/* European computer manufacturers */
#define	AF_DATAKIT	9		/* datakit protocols */
#define	AF_CCITT	10		/* CCITT protocols, X.25 etc */
#define	AF_SNA		11		/* IBM SNA */
#define AF_DECnet	12		/* DECnet */
#define AF_DLI		13		/* DEC Direct data link interface */
#define AF_LAT		14		/* LAT */
#define	AF_HYLINK	15		/* NSC Hyperchannel */
#define	AF_APPLETALK	16		/* Apple Talk */
#define	AF_ROUTE	17		/* Internal Routing Protocol */
#define	AF_LINK		18		/* Link layer interface */
#define	pseudo_AF_XTP	19		/* eXpress Transfer Protocol (no AF) */
#define	AF_COIP		20		/* connection-oriented IP, aka ST II */
#define	AF_CNT		21		/* Computer Network Technology */
#define pseudo_AF_RTIP	22		/* Help Identify RTIP packets */
#define	AF_IPX		23		/* Novell Internet Protocol */
#define	AF_SIP		24		/* Simple Internet Protocol */
#define	pseudo_AF_PIP	25		/* Help Identify PIP packets */
#define	AF_ISDN		26		/* Integrated Services Digital Network*/
#define	AF_E164		AF_ISDN		/* CCITT E.164 recommendation */
#define	pseudo_AF_KEY	27		/* Internal key-management function */
#endif
# 230 "/usr/include/sys/socket.h" 3 4
#define	AF_INET6	28		/* IPv6 */
#if __BSD_VISIBLE
#define	AF_NATM		29		/* native ATM access */
#define	AF_ATM		30		/* ATM */
#define pseudo_AF_HDRCMPLT 31		/* Used by BPF to not rewrite headers
					 * in interface output routine
					 */
#define	AF_NETGRAPH	32		/* Netgraph sockets */
#define	AF_SLOW		33		/* 802.3ad slow protocol */
#define	AF_SCLUSTER	34		/* Sitara cluster protocol */
#define	AF_ARP		35
#define	AF_BLUETOOTH	36		/* Bluetooth sockets */
#define	AF_IEEE80211	37		/* IEEE 802.11 protocol */
#define	AF_INET_SDP	40		/* OFED Socket Direct Protocol ipv4 */
#define	AF_INET6_SDP	42		/* OFED Socket Direct Protocol ipv6 */
#define	AF_MAX		42
/*
 * When allocating a new AF_ constant, please only allocate
 * even numbered constants for FreeBSD until 134 as odd numbered AF_
 * constants 39-133 are now reserved for vendors.
 */
#define AF_VENDOR00 39
#define AF_VENDOR01 41
#define AF_VENDOR02 43
#define AF_VENDOR03 45
#define AF_VENDOR04 47
#define AF_VENDOR05 49
#define AF_VENDOR06 51
#define AF_VENDOR07 53
#define AF_VENDOR08 55
#define AF_VENDOR09 57
#define AF_VENDOR10 59
#define AF_VENDOR11 61
#define AF_VENDOR12 63
#define AF_VENDOR13 65
#define AF_VENDOR14 67
#define AF_VENDOR15 69
#define AF_VENDOR16 71
#define AF_VENDOR17 73
#define AF_VENDOR18 75
#define AF_VENDOR19 77
#define AF_VENDOR20 79
#define AF_VENDOR21 81
#define AF_VENDOR22 83
#define AF_VENDOR23 85
#define AF_VENDOR24 87
#define AF_VENDOR25 89
#define AF_VENDOR26 91
#define AF_VENDOR27 93
#define AF_VENDOR28 95
#define AF_VENDOR29 97
#define AF_VENDOR30 99
#define AF_VENDOR31 101
#define AF_VENDOR32 103
#define AF_VENDOR33 105
#define AF_VENDOR34 107
#define AF_VENDOR35 109
#define AF_VENDOR36 111
#define AF_VENDOR37 113
#define AF_VENDOR38 115
#define AF_VENDOR39 117
#define AF_VENDOR40 119
#define AF_VENDOR41 121
#define AF_VENDOR42 123
#define AF_VENDOR43 125
#define AF_VENDOR44 127
#define AF_VENDOR45 129
#define AF_VENDOR46 131
#define AF_VENDOR47 133
#endif
# 300 "/usr/include/sys/socket.h" 3 4

/*
 * Structure used by kernel to store most
 * addresses.
 */
struct sockaddr {
	unsigned char	sa_len;		/* total length */
	sa_family_t	sa_family;	/* address family */
	char		sa_data[14];	/* actually longer; address value */
};
#if __BSD_VISIBLE
#define	SOCK_MAXADDRLEN	255		/* longest possible addresses */

/*
 * Structure used by kernel to pass protocol
 * information in raw sockets.
 */
struct sockproto {
	unsigned short	sp_family;		/* address family */
	unsigned short	sp_protocol;		/* protocol */
};
#endif
# 322 "/usr/include/sys/socket.h" 3 4

#if 0 /* expanded by -frewrite-includes */
#include <sys/_sockaddr_storage.h>
#endif /* expanded by -frewrite-includes */
# 323 "/usr/include/sys/socket.h" 3 4
# 1 "/usr/include/sys/_sockaddr_storage.h" 1 3 4
/*-
 * Copyright (c) 1982, 1985, 1986, 1988, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)socket.h	8.4 (Berkeley) 2/21/94
 * $FreeBSD: releng/11.0/sys/sys/_sockaddr_storage.h 196967 2009-09-08 10:39:38Z phk $
 */

#ifndef _SYS__SOCKADDR_STORAGE_H_
#define	_SYS__SOCKADDR_STORAGE_H_

/*
 * RFC 2553: protocol-independent placeholder for socket addresses
 */
#define	_SS_MAXSIZE	128U
#define	_SS_ALIGNSIZE	(sizeof(__int64_t))
#define	_SS_PAD1SIZE	(_SS_ALIGNSIZE - sizeof(unsigned char) - \
			    sizeof(sa_family_t))
#define	_SS_PAD2SIZE	(_SS_MAXSIZE - sizeof(unsigned char) - \
			    sizeof(sa_family_t) - _SS_PAD1SIZE - _SS_ALIGNSIZE)

struct sockaddr_storage {
	unsigned char	ss_len;		/* address length */
	sa_family_t	ss_family;	/* address family */
	char		__ss_pad1[_SS_PAD1SIZE];
	__int64_t	__ss_align;	/* force desired struct alignment */
	char		__ss_pad2[_SS_PAD2SIZE];
};

#endif /* !_SYS__SOCKADDR_STORAGE_H_ */
# 55 "/usr/include/sys/_sockaddr_storage.h" 3 4
# 324 "/usr/include/sys/socket.h" 2 3 4

#if __BSD_VISIBLE
/*
 * Protocol families, same as address families for now.
 */
#define	PF_UNSPEC	AF_UNSPEC
#define	PF_LOCAL	AF_LOCAL
#define	PF_UNIX		PF_LOCAL	/* backward compatibility */
#define	PF_INET		AF_INET
#define	PF_IMPLINK	AF_IMPLINK
#define	PF_PUP		AF_PUP
#define	PF_CHAOS	AF_CHAOS
#define	PF_NETBIOS	AF_NETBIOS
#define	PF_ISO		AF_ISO
#define	PF_OSI		AF_ISO
#define	PF_ECMA		AF_ECMA
#define	PF_DATAKIT	AF_DATAKIT
#define	PF_CCITT	AF_CCITT
#define	PF_SNA		AF_SNA
#define PF_DECnet	AF_DECnet
#define PF_DLI		AF_DLI
#define PF_LAT		AF_LAT
#define	PF_HYLINK	AF_HYLINK
#define	PF_APPLETALK	AF_APPLETALK
#define	PF_ROUTE	AF_ROUTE
#define	PF_LINK		AF_LINK
#define	PF_XTP		pseudo_AF_XTP	/* really just proto family, no AF */
#define	PF_COIP		AF_COIP
#define	PF_CNT		AF_CNT
#define	PF_SIP		AF_SIP
#define	PF_IPX		AF_IPX
#define PF_RTIP		pseudo_AF_RTIP	/* same format as AF_INET */
#define PF_PIP		pseudo_AF_PIP
#define	PF_ISDN		AF_ISDN
#define	PF_KEY		pseudo_AF_KEY
#define	PF_INET6	AF_INET6
#define	PF_NATM		AF_NATM
#define	PF_ATM		AF_ATM
#define	PF_NETGRAPH	AF_NETGRAPH
#define	PF_SLOW		AF_SLOW
#define PF_SCLUSTER	AF_SCLUSTER
#define	PF_ARP		AF_ARP
#define	PF_BLUETOOTH	AF_BLUETOOTH
#define	PF_IEEE80211	AF_IEEE80211
#define	PF_INET_SDP	AF_INET_SDP
#define	PF_INET6_SDP	AF_INET6_SDP

#define	PF_MAX		AF_MAX

/*
 * Definitions for network related sysctl, CTL_NET.
 *
 * Second level is protocol family.
 * Third level is protocol number.
 *
 * Further levels are defined by the individual families.
 */

/*
 * PF_ROUTE - Routing table
 *
 * Three additional levels are defined:
 *	Fourth: address family, 0 is wildcard
 *	Fifth: type of info, defined below
 *	Sixth: flag(s) to mask with for NET_RT_FLAGS
 */
#define NET_RT_DUMP	1		/* dump; may limit to a.f. */
#define NET_RT_FLAGS	2		/* by flags, e.g. RESOLVING */
#define NET_RT_IFLIST	3		/* survey interface list */
#define	NET_RT_IFMALIST	4		/* return multicast address list */
#define	NET_RT_IFLISTL	5		/* Survey interface list, using 'l'en
					 * versions of msghdr structs. */
#endif /* __BSD_VISIBLE */
# 397 "/usr/include/sys/socket.h" 3 4

/*
 * Maximum queue length specifiable by listen.
 */
#define	SOMAXCONN	128

/*
 * Message header for recvmsg and sendmsg calls.
 * Used value-result for recvmsg, value only for sendmsg.
 */
struct msghdr {
	void		*msg_name;		/* optional address */
	socklen_t	 msg_namelen;		/* size of address */
	struct iovec	*msg_iov;		/* scatter/gather array */
	int		 msg_iovlen;		/* # elements in msg_iov */
	void		*msg_control;		/* ancillary data, see below */
	socklen_t	 msg_controllen;	/* ancillary data buffer len */
	int		 msg_flags;		/* flags on received message */
};

#define	MSG_OOB		0x1		/* process out-of-band data */
#define	MSG_PEEK	0x2		/* peek at incoming message */
#define	MSG_DONTROUTE	0x4		/* send without using routing tables */
#define	MSG_EOR		0x8		/* data completes record */
#define	MSG_TRUNC	0x10		/* data discarded before delivery */
#define	MSG_CTRUNC	0x20		/* control data lost before delivery */
#define	MSG_WAITALL	0x40		/* wait for full request or error */
#if __POSIX_VISIBLE >= 200809
#define	MSG_NOSIGNAL	0x20000		/* do not generate SIGPIPE on EOF */
#endif
# 427 "/usr/include/sys/socket.h" 3 4
#if __BSD_VISIBLE
#define	MSG_DONTWAIT	0x80		/* this message should be nonblocking */
#define	MSG_EOF		0x100		/* data completes connection */
#define	MSG_NOTIFICATION 0x2000         /* SCTP notification */
#define	MSG_NBIO	0x4000		/* FIONBIO mode, used by fifofs */
#define	MSG_COMPAT      0x8000		/* used in sendit() */
#define	MSG_CMSG_CLOEXEC 0x40000	/* make received fds close-on-exec */
#define	MSG_WAITFORONE	0x80000		/* for recvmmsg() */
#endif
# 436 "/usr/include/sys/socket.h" 3 4
#ifdef _KERNEL
#define	MSG_SOCALLBCK   0x10000		/* for use by socket callbacks - soreceive (TCP) */
#endif
# 439 "/usr/include/sys/socket.h" 3 4

/*
 * Header for ancillary data objects in msg_control buffer.
 * Used for additional information with/about a datagram
 * not expressible by flags.  The format is a sequence
 * of message elements headed by cmsghdr structures.
 */
struct cmsghdr {
	socklen_t	cmsg_len;		/* data byte count, including hdr */
	int		cmsg_level;		/* originating protocol */
	int		cmsg_type;		/* protocol-specific type */
/* followed by	u_char  cmsg_data[]; */
};

#if __BSD_VISIBLE
/*
 * While we may have more groups than this, the cmsgcred struct must
 * be able to fit in an mbuf and we have historically supported a
 * maximum of 16 groups.
*/
#define CMGROUP_MAX 16

/*
 * Credentials structure, used to verify the identity of a peer
 * process that has sent us a message. This is allocated by the
 * peer process but filled in by the kernel. This prevents the
 * peer from lying about its identity. (Note that cmcred_groups[0]
 * is the effective GID.)
 */
struct cmsgcred {
	pid_t	cmcred_pid;		/* PID of sending process */
	uid_t	cmcred_uid;		/* real UID of sending process */
	uid_t	cmcred_euid;		/* effective UID of sending process */
	gid_t	cmcred_gid;		/* real GID of sending process */
	short	cmcred_ngroups;		/* number or groups */
	gid_t	cmcred_groups[CMGROUP_MAX];	/* groups */
};

/*
 * Socket credentials.
 */
struct sockcred {
	uid_t	sc_uid;			/* real user id */
	uid_t	sc_euid;		/* effective user id */
	gid_t	sc_gid;			/* real group id */
	gid_t	sc_egid;		/* effective group id */
	int	sc_ngroups;		/* number of supplemental groups */
	gid_t	sc_groups[1];		/* variable length */
};

/*
 * Compute size of a sockcred structure with groups.
 */
#define	SOCKCREDSIZE(ngrps) \
	(sizeof(struct sockcred) + (sizeof(gid_t) * ((ngrps) - 1)))

#endif /* __BSD_VISIBLE */
# 496 "/usr/include/sys/socket.h" 3 4

/* given pointer to struct cmsghdr, return pointer to data */
#define	CMSG_DATA(cmsg)		((unsigned char *)(cmsg) + \
				 _ALIGN(sizeof(struct cmsghdr)))

/* given pointer to struct cmsghdr, return pointer to next cmsghdr */
#define	CMSG_NXTHDR(mhdr, cmsg)	\
	((char *)(cmsg) == (char *)0 ? CMSG_FIRSTHDR(mhdr) : \
	    ((char *)(cmsg) + _ALIGN(((struct cmsghdr *)(cmsg))->cmsg_len) + \
	  _ALIGN(sizeof(struct cmsghdr)) > \
	    (char *)(mhdr)->msg_control + (mhdr)->msg_controllen) ? \
	    (struct cmsghdr *)0 : \
	    (struct cmsghdr *)(void *)((char *)(cmsg) + \
	    _ALIGN(((struct cmsghdr *)(cmsg))->cmsg_len)))

/*
 * RFC 2292 requires to check msg_controllen, in case that the kernel returns
 * an empty list for some reasons.
 */
#define	CMSG_FIRSTHDR(mhdr) \
	((mhdr)->msg_controllen >= sizeof(struct cmsghdr) ? \
	 (struct cmsghdr *)(mhdr)->msg_control : \
	 (struct cmsghdr *)0)

#if __BSD_VISIBLE
/* RFC 2292 additions */
#define	CMSG_SPACE(l)		(_ALIGN(sizeof(struct cmsghdr)) + _ALIGN(l))
#define	CMSG_LEN(l)		(_ALIGN(sizeof(struct cmsghdr)) + (l))
#endif
# 525 "/usr/include/sys/socket.h" 3 4

#ifdef _KERNEL
#define	CMSG_ALIGN(n)	_ALIGN(n)
#endif
# 529 "/usr/include/sys/socket.h" 3 4

/* "Socket"-level control message types: */
#define	SCM_RIGHTS	0x01		/* access rights (array of int) */
#if __BSD_VISIBLE
#define	SCM_TIMESTAMP	0x02		/* timestamp (struct timeval) */
#define	SCM_CREDS	0x03		/* process creds (struct cmsgcred) */
#define	SCM_BINTIME	0x04		/* timestamp (struct bintime) */
#endif
# 537 "/usr/include/sys/socket.h" 3 4

#if __BSD_VISIBLE
/*
 * 4.3 compat sockaddr, move to compat file later
 */
struct osockaddr {
	unsigned short sa_family;	/* address family */
	char	sa_data[14];		/* up to 14 bytes of direct address */
};

/*
 * 4.3-compat message header (move to compat file later).
 */
struct omsghdr {
	char	*msg_name;		/* optional address */
	int	msg_namelen;		/* size of address */
	struct	iovec *msg_iov;		/* scatter/gather array */
	int	msg_iovlen;		/* # elements in msg_iov */
	char	*msg_accrights;		/* access rights sent/received */
	int	msg_accrightslen;
};
#endif
# 559 "/usr/include/sys/socket.h" 3 4

/*
 * howto arguments for shutdown(2), specified by Posix.1g.
 */
#define	SHUT_RD		0		/* shut down the reading side */
#define	SHUT_WR		1		/* shut down the writing side */
#define	SHUT_RDWR	2		/* shut down both sides */

#if __BSD_VISIBLE
/* for SCTP */
/* we cheat and use the SHUT_XX defines for these */
#define PRU_FLUSH_RD     SHUT_RD
#define PRU_FLUSH_WR     SHUT_WR
#define PRU_FLUSH_RDWR   SHUT_RDWR
#endif
# 574 "/usr/include/sys/socket.h" 3 4


#if __BSD_VISIBLE
/*
 * sendfile(2) header/trailer struct
 */
struct sf_hdtr {
	struct iovec *headers;	/* pointer to an array of header struct iovec's */
	int hdr_cnt;		/* number of header iovec's */
	struct iovec *trailers;	/* pointer to an array of trailer struct iovec's */
	int trl_cnt;		/* number of trailer iovec's */
};

/*
 * Sendfile-specific flag(s)
 */
#define	SF_NODISKIO     0x00000001
#define	SF_MNOWAIT	0x00000002	/* obsolete */
#define	SF_SYNC		0x00000004
#define	SF_NOCACHE	0x00000010
#define	SF_FLAGS(rh, flags)	(((rh) << 16) | (flags))

#ifdef _KERNEL
#define	SF_READAHEAD(flags)	((flags) >> 16)
#endif /* _KERNEL */
# 599 "/usr/include/sys/socket.h" 3 4

/*
 * Sendmmsg/recvmmsg specific structure(s)
 */
struct mmsghdr {
	struct msghdr	msg_hdr;		/* message header */
	ssize_t		msg_len;		/* message length */
};
#endif /* __BSD_VISIBLE */
# 608 "/usr/include/sys/socket.h" 3 4

#ifndef	_KERNEL

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 611 "/usr/include/sys/socket.h" 3 4
# 612 "/usr/include/sys/socket.h" 3 4

__BEGIN_DECLS
int	accept(int, struct sockaddr * __restrict, socklen_t * __restrict);
int	bind(int, const struct sockaddr *, socklen_t);
int	connect(int, const struct sockaddr *, socklen_t);
#if __BSD_VISIBLE
int	accept4(int, struct sockaddr * __restrict, socklen_t * __restrict, int);
int	bindat(int, int, const struct sockaddr *, socklen_t);
int	connectat(int, int, const struct sockaddr *, socklen_t);
#endif
# 622 "/usr/include/sys/socket.h" 3 4
int	getpeername(int, struct sockaddr * __restrict, socklen_t * __restrict);
int	getsockname(int, struct sockaddr * __restrict, socklen_t * __restrict);
int	getsockopt(int, int, int, void * __restrict, socklen_t * __restrict);
int	listen(int, int);
ssize_t	recv(int, void *, size_t, int);
ssize_t	recvfrom(int, void *, size_t, int, struct sockaddr * __restrict, socklen_t * __restrict);
ssize_t	recvmsg(int, struct msghdr *, int);
#if __BSD_VISIBLE
struct timespec;
ssize_t	recvmmsg(int, struct mmsghdr * __restrict, size_t, int,
    const struct timespec * __restrict);
#endif
# 634 "/usr/include/sys/socket.h" 3 4
ssize_t	send(int, const void *, size_t, int);
ssize_t	sendto(int, const void *,
	    size_t, int, const struct sockaddr *, socklen_t);
ssize_t	sendmsg(int, const struct msghdr *, int);
#if __BSD_VISIBLE
int	sendfile(int, int, off_t, size_t, struct sf_hdtr *, off_t *, int);
ssize_t	sendmmsg(int, struct mmsghdr * __restrict, size_t, int);
int	setfib(int);
#endif
# 643 "/usr/include/sys/socket.h" 3 4
int	setsockopt(int, int, int, const void *, socklen_t);
int	shutdown(int, int);
int	sockatmark(int);
int	socket(int, int, int);
int	socketpair(int, int, int, int *);
__END_DECLS

#endif /* !_KERNEL */
# 651 "/usr/include/sys/socket.h" 3 4

#ifdef _KERNEL
struct socket;

struct tcpcb *so_sototcpcb(struct socket *so);
struct inpcb *so_sotoinpcb(struct socket *so);
struct sockbuf *so_sockbuf_snd(struct socket *);
struct sockbuf *so_sockbuf_rcv(struct socket *);

int so_state_get(const struct socket *);
void so_state_set(struct socket *, int);

int so_options_get(const struct socket *);
void so_options_set(struct socket *, int);

int so_error_get(const struct socket *);
void so_error_set(struct socket *, int);

int so_linger_get(const struct socket *);
void so_linger_set(struct socket *, int);

struct protosw *so_protosw_get(const struct socket *);
void so_protosw_set(struct socket *, struct protosw *);

void so_sorwakeup_locked(struct socket *so);
void so_sowwakeup_locked(struct socket *so);

void so_sorwakeup(struct socket *so);
void so_sowwakeup(struct socket *so);

void so_lock(struct socket *so);
void so_unlock(struct socket *so);

void so_listeners_apply_all(struct socket *so, void (*func)(struct socket *, void *), void *arg);

#endif
# 687 "/usr/include/sys/socket.h" 3 4


#endif /* !_SYS_SOCKET_H_ */
# 690 "/usr/include/sys/socket.h" 3 4
# 45 "include/libbb.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <sys/stat.h>
#endif /* expanded by -frewrite-includes */
# 45 "include/libbb.h"
# 1 "/usr/include/sys/stat.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stat.h	8.12 (Berkeley) 6/16/95
 * $FreeBSD: releng/11.0/sys/sys/stat.h 277610 2015-01-23 21:07:08Z jilles $
 */

#ifndef _SYS_STAT_H_
#define	_SYS_STAT_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 41 "/usr/include/sys/stat.h" 3 4
# 42 "/usr/include/sys/stat.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_timespec.h>
#endif /* expanded by -frewrite-includes */
# 42 "/usr/include/sys/stat.h" 3 4
# 43 "/usr/include/sys/stat.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 43 "/usr/include/sys/stat.h" 3 4
# 44 "/usr/include/sys/stat.h" 3 4

#ifndef _BLKSIZE_T_DECLARED
typedef	__blksize_t	blksize_t;
#define	_BLKSIZE_T_DECLARED
#endif
# 49 "/usr/include/sys/stat.h" 3 4

#ifndef _BLKCNT_T_DECLARED
typedef	__blkcnt_t	blkcnt_t;
#define	_BLKCNT_T_DECLARED
#endif
# 54 "/usr/include/sys/stat.h" 3 4

#ifndef _DEV_T_DECLARED
typedef	__dev_t		dev_t;
#define	_DEV_T_DECLARED
#endif
# 59 "/usr/include/sys/stat.h" 3 4

#ifndef _FFLAGS_T_DECLARED
typedef	__fflags_t	fflags_t;
#define	_FFLAGS_T_DECLARED
#endif
# 64 "/usr/include/sys/stat.h" 3 4

#ifndef _GID_T_DECLARED
typedef	__gid_t		gid_t;
#define	_GID_T_DECLARED
#endif
# 69 "/usr/include/sys/stat.h" 3 4

#ifndef _INO_T_DECLARED
typedef	__ino_t		ino_t;
#define	_INO_T_DECLARED
#endif
# 74 "/usr/include/sys/stat.h" 3 4

#ifndef _MODE_T_DECLARED
typedef	__mode_t	mode_t;
#define	_MODE_T_DECLARED
#endif
# 79 "/usr/include/sys/stat.h" 3 4

#ifndef _NLINK_T_DECLARED
typedef	__nlink_t	nlink_t;
#define	_NLINK_T_DECLARED
#endif
# 84 "/usr/include/sys/stat.h" 3 4

#ifndef _OFF_T_DECLARED
typedef	__off_t		off_t;
#define	_OFF_T_DECLARED
#endif
# 89 "/usr/include/sys/stat.h" 3 4

#ifndef _UID_T_DECLARED
typedef	__uid_t		uid_t;
#define	_UID_T_DECLARED
#endif
# 94 "/usr/include/sys/stat.h" 3 4

#if !defined(_KERNEL) && __BSD_VISIBLE
/*
 * XXX We get miscellaneous namespace pollution with this.
 */
#if 0 /* expanded by -frewrite-includes */
#include <sys/time.h>
#endif /* expanded by -frewrite-includes */
# 99 "/usr/include/sys/stat.h" 3 4
# 1 "/usr/include/sys/time.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.5 (Berkeley) 5/4/95
 * $FreeBSD: releng/11.0/sys/sys/time.h 275985 2014-12-21 05:07:11Z imp $
 */

#ifndef _SYS_TIME_H_
#define	_SYS_TIME_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/_timeval.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/sys/time.h" 3 4
# 37 "/usr/include/sys/time.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/types.h>
#endif /* expanded by -frewrite-includes */
# 37 "/usr/include/sys/time.h" 3 4
# 38 "/usr/include/sys/time.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/timespec.h>
#endif /* expanded by -frewrite-includes */
# 38 "/usr/include/sys/time.h" 3 4
# 39 "/usr/include/sys/time.h" 3 4

struct timezone {
	int	tz_minuteswest;	/* minutes west of Greenwich */
	int	tz_dsttime;	/* type of dst correction */
};
#define	DST_NONE	0	/* not on dst */
#define	DST_USA		1	/* USA style dst */
#define	DST_AUST	2	/* Australian style dst */
#define	DST_WET		3	/* Western European dst */
#define	DST_MET		4	/* Middle European dst */
#define	DST_EET		5	/* Eastern European dst */
#define	DST_CAN		6	/* Canada */

#if __BSD_VISIBLE
struct bintime {
	time_t	sec;
	uint64_t frac;
};

static __inline void
bintime_addx(struct bintime *_bt, uint64_t _x)
{
	uint64_t _u;

	_u = _bt->frac;
	_bt->frac += _x;
	if (_u > _bt->frac)
		_bt->sec++;
}

static __inline void
bintime_add(struct bintime *_bt, const struct bintime *_bt2)
{
	uint64_t _u;

	_u = _bt->frac;
	_bt->frac += _bt2->frac;
	if (_u > _bt->frac)
		_bt->sec++;
	_bt->sec += _bt2->sec;
}

static __inline void
bintime_sub(struct bintime *_bt, const struct bintime *_bt2)
{
	uint64_t _u;

	_u = _bt->frac;
	_bt->frac -= _bt2->frac;
	if (_u < _bt->frac)
		_bt->sec--;
	_bt->sec -= _bt2->sec;
}

static __inline void
bintime_mul(struct bintime *_bt, u_int _x)
{
	uint64_t _p1, _p2;

	_p1 = (_bt->frac & 0xffffffffull) * _x;
	_p2 = (_bt->frac >> 32) * _x + (_p1 >> 32);
	_bt->sec *= _x;
	_bt->sec += (_p2 >> 32);
	_bt->frac = (_p2 << 32) | (_p1 & 0xffffffffull);
}

static __inline void
bintime_shift(struct bintime *_bt, int _exp)
{

	if (_exp > 0) {
		_bt->sec <<= _exp;
		_bt->sec |= _bt->frac >> (64 - _exp);
		_bt->frac <<= _exp;
	} else if (_exp < 0) {
		_bt->frac >>= -_exp;
		_bt->frac |= (uint64_t)_bt->sec << (64 + _exp);
		_bt->sec >>= -_exp;
	}
}

#define	bintime_clear(a)	((a)->sec = (a)->frac = 0)
#define	bintime_isset(a)	((a)->sec || (a)->frac)
#define	bintime_cmp(a, b, cmp)						\
	(((a)->sec == (b)->sec) ?					\
	    ((a)->frac cmp (b)->frac) :					\
	    ((a)->sec cmp (b)->sec))

#define	SBT_1S	((sbintime_t)1 << 32)
#define	SBT_1M	(SBT_1S * 60)
#define	SBT_1MS	(SBT_1S / 1000)
#define	SBT_1US	(SBT_1S / 1000000)
#define	SBT_1NS	(SBT_1S / 1000000000)
#define	SBT_MAX	0x7fffffffffffffffLL

static __inline int
sbintime_getsec(sbintime_t _sbt)
{

	return (_sbt >> 32);
}

static __inline sbintime_t
bttosbt(const struct bintime _bt)
{

	return (((sbintime_t)_bt.sec << 32) + (_bt.frac >> 32));
}

static __inline struct bintime
sbttobt(sbintime_t _sbt)
{
	struct bintime _bt;

	_bt.sec = _sbt >> 32;
	_bt.frac = _sbt << 32;
	return (_bt);
}

/*-
 * Background information:
 *
 * When converting between timestamps on parallel timescales of differing
 * resolutions it is historical and scientific practice to round down rather
 * than doing 4/5 rounding.
 *
 *   The date changes at midnight, not at noon.
 *
 *   Even at 15:59:59.999999999 it's not four'o'clock.
 *
 *   time_second ticks after N.999999999 not after N.4999999999
 */

static __inline void
bintime2timespec(const struct bintime *_bt, struct timespec *_ts)
{

	_ts->tv_sec = _bt->sec;
	_ts->tv_nsec = ((uint64_t)1000000000 *
	    (uint32_t)(_bt->frac >> 32)) >> 32;
}

static __inline void
timespec2bintime(const struct timespec *_ts, struct bintime *_bt)
{

	_bt->sec = _ts->tv_sec;
	/* 18446744073 = int(2^64 / 1000000000) */
	_bt->frac = _ts->tv_nsec * (uint64_t)18446744073LL;
}

static __inline void
bintime2timeval(const struct bintime *_bt, struct timeval *_tv)
{

	_tv->tv_sec = _bt->sec;
	_tv->tv_usec = ((uint64_t)1000000 * (uint32_t)(_bt->frac >> 32)) >> 32;
}

static __inline void
timeval2bintime(const struct timeval *_tv, struct bintime *_bt)
{

	_bt->sec = _tv->tv_sec;
	/* 18446744073709 = int(2^64 / 1000000) */
	_bt->frac = _tv->tv_usec * (uint64_t)18446744073709LL;
}

static __inline struct timespec
sbttots(sbintime_t _sbt)
{
	struct timespec _ts;

	_ts.tv_sec = _sbt >> 32;
	_ts.tv_nsec = ((uint64_t)1000000000 * (uint32_t)_sbt) >> 32;
	return (_ts);
}

static __inline sbintime_t
tstosbt(struct timespec _ts)
{

	return (((sbintime_t)_ts.tv_sec << 32) +
	    (_ts.tv_nsec * (((uint64_t)1 << 63) / 500000000) >> 32));
}

static __inline struct timeval
sbttotv(sbintime_t _sbt)
{
	struct timeval _tv;

	_tv.tv_sec = _sbt >> 32;
	_tv.tv_usec = ((uint64_t)1000000 * (uint32_t)_sbt) >> 32;
	return (_tv);
}

static __inline sbintime_t
tvtosbt(struct timeval _tv)
{

	return (((sbintime_t)_tv.tv_sec << 32) +
	    (_tv.tv_usec * (((uint64_t)1 << 63) / 500000) >> 32));
}
#endif /* __BSD_VISIBLE */
# 243 "/usr/include/sys/time.h" 3 4

#ifdef _KERNEL

/* Operations on timespecs */
#define	timespecclear(tvp)	((tvp)->tv_sec = (tvp)->tv_nsec = 0)
#define	timespecisset(tvp)	((tvp)->tv_sec || (tvp)->tv_nsec)
#define	timespeccmp(tvp, uvp, cmp)					\
	(((tvp)->tv_sec == (uvp)->tv_sec) ?				\
	    ((tvp)->tv_nsec cmp (uvp)->tv_nsec) :			\
	    ((tvp)->tv_sec cmp (uvp)->tv_sec))
#define	timespecadd(vvp, uvp)						\
	do {								\
		(vvp)->tv_sec += (uvp)->tv_sec;				\
		(vvp)->tv_nsec += (uvp)->tv_nsec;			\
		if ((vvp)->tv_nsec >= 1000000000) {			\
			(vvp)->tv_sec++;				\
			(vvp)->tv_nsec -= 1000000000;			\
		}							\
	} while (0)
#define	timespecsub(vvp, uvp)						\
	do {								\
		(vvp)->tv_sec -= (uvp)->tv_sec;				\
		(vvp)->tv_nsec -= (uvp)->tv_nsec;			\
		if ((vvp)->tv_nsec < 0) {				\
			(vvp)->tv_sec--;				\
			(vvp)->tv_nsec += 1000000000;			\
		}							\
	} while (0)

/* Operations on timevals. */

#define	timevalclear(tvp)		((tvp)->tv_sec = (tvp)->tv_usec = 0)
#define	timevalisset(tvp)		((tvp)->tv_sec || (tvp)->tv_usec)
#define	timevalcmp(tvp, uvp, cmp)					\
	(((tvp)->tv_sec == (uvp)->tv_sec) ?				\
	    ((tvp)->tv_usec cmp (uvp)->tv_usec) :			\
	    ((tvp)->tv_sec cmp (uvp)->tv_sec))

/* timevaladd and timevalsub are not inlined */

#endif /* _KERNEL */
# 284 "/usr/include/sys/time.h" 3 4

#ifndef _KERNEL			/* NetBSD/OpenBSD compatible interfaces */

#define	timerclear(tvp)		((tvp)->tv_sec = (tvp)->tv_usec = 0)
#define	timerisset(tvp)		((tvp)->tv_sec || (tvp)->tv_usec)
#define	timercmp(tvp, uvp, cmp)					\
	(((tvp)->tv_sec == (uvp)->tv_sec) ?				\
	    ((tvp)->tv_usec cmp (uvp)->tv_usec) :			\
	    ((tvp)->tv_sec cmp (uvp)->tv_sec))
#define	timeradd(tvp, uvp, vvp)						\
	do {								\
		(vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec;		\
		(vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec;	\
		if ((vvp)->tv_usec >= 1000000) {			\
			(vvp)->tv_sec++;				\
			(vvp)->tv_usec -= 1000000;			\
		}							\
	} while (0)
#define	timersub(tvp, uvp, vvp)						\
	do {								\
		(vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec;		\
		(vvp)->tv_usec = (tvp)->tv_usec - (uvp)->tv_usec;	\
		if ((vvp)->tv_usec < 0) {				\
			(vvp)->tv_sec--;				\
			(vvp)->tv_usec += 1000000;			\
		}							\
	} while (0)
#endif
# 312 "/usr/include/sys/time.h" 3 4

/*
 * Names of the interval timers, and structure
 * defining a timer setting.
 */
#define	ITIMER_REAL	0
#define	ITIMER_VIRTUAL	1
#define	ITIMER_PROF	2

struct itimerval {
	struct	timeval it_interval;	/* timer interval */
	struct	timeval it_value;	/* current value */
};

/*
 * Getkerninfo clock information structure
 */
struct clockinfo {
	int	hz;		/* clock frequency */
	int	tick;		/* micro-seconds per hz tick */
	int	spare;
	int	stathz;		/* statistics clock frequency */
	int	profhz;		/* profiling clock frequency */
};

/* These macros are also in time.h. */
#ifndef CLOCK_REALTIME
#define	CLOCK_REALTIME	0
#define	CLOCK_VIRTUAL	1
#define	CLOCK_PROF	2
#define	CLOCK_MONOTONIC	4
#define	CLOCK_UPTIME	5		/* FreeBSD-specific. */
#define	CLOCK_UPTIME_PRECISE	7	/* FreeBSD-specific. */
#define	CLOCK_UPTIME_FAST	8	/* FreeBSD-specific. */
#define	CLOCK_REALTIME_PRECISE	9	/* FreeBSD-specific. */
#define	CLOCK_REALTIME_FAST	10	/* FreeBSD-specific. */
#define	CLOCK_MONOTONIC_PRECISE	11	/* FreeBSD-specific. */
#define	CLOCK_MONOTONIC_FAST	12	/* FreeBSD-specific. */
#define	CLOCK_SECOND	13		/* FreeBSD-specific. */
#define	CLOCK_THREAD_CPUTIME_ID	14
#define	CLOCK_PROCESS_CPUTIME_ID	15
#endif
# 354 "/usr/include/sys/time.h" 3 4

#ifndef TIMER_ABSTIME
#define	TIMER_RELTIME	0x0	/* relative timer */
#define	TIMER_ABSTIME	0x1	/* absolute timer */
#endif
# 359 "/usr/include/sys/time.h" 3 4

#if __BSD_VISIBLE
#define	CPUCLOCK_WHICH_PID	0
#define	CPUCLOCK_WHICH_TID	1
#endif
# 364 "/usr/include/sys/time.h" 3 4

#ifdef _KERNEL

/*
 * Kernel to clock driver interface.
 */
void	inittodr(time_t base);
void	resettodr(void);

extern volatile time_t	time_second;
extern volatile time_t	time_uptime;
extern struct bintime boottimebin;
extern struct timeval boottime;
extern struct bintime tc_tick_bt;
extern sbintime_t tc_tick_sbt;
extern struct bintime tick_bt;
extern sbintime_t tick_sbt;
extern int tc_precexp;
extern int tc_timepercentage;
extern struct bintime bt_timethreshold;
extern struct bintime bt_tickthreshold;
extern sbintime_t sbt_timethreshold;
extern sbintime_t sbt_tickthreshold;

/*
 * Functions for looking at our clock: [get]{bin,nano,micro}[up]time()
 *
 * Functions without the "get" prefix returns the best timestamp
 * we can produce in the given format.
 *
 * "bin"   == struct bintime  == seconds + 64 bit fraction of seconds.
 * "nano"  == struct timespec == seconds + nanoseconds.
 * "micro" == struct timeval  == seconds + microseconds.
 *
 * Functions containing "up" returns time relative to boot and
 * should be used for calculating time intervals.
 *
 * Functions without "up" returns UTC time.
 *
 * Functions with the "get" prefix returns a less precise result
 * much faster than the functions without "get" prefix and should
 * be used where a precision of 1/hz seconds is acceptable or where
 * performance is priority. (NB: "precision", _not_ "resolution" !)
 */

void	binuptime(struct bintime *bt);
void	nanouptime(struct timespec *tsp);
void	microuptime(struct timeval *tvp);

static __inline sbintime_t
sbinuptime(void)
{
	struct bintime _bt;

	binuptime(&_bt);
	return (bttosbt(_bt));
}

void	bintime(struct bintime *bt);
void	nanotime(struct timespec *tsp);
void	microtime(struct timeval *tvp);

void	getbinuptime(struct bintime *bt);
void	getnanouptime(struct timespec *tsp);
void	getmicrouptime(struct timeval *tvp);

static __inline sbintime_t
getsbinuptime(void)
{
	struct bintime _bt;

	getbinuptime(&_bt);
	return (bttosbt(_bt));
}

void	getbintime(struct bintime *bt);
void	getnanotime(struct timespec *tsp);
void	getmicrotime(struct timeval *tvp);

/* Other functions */
int	itimerdecr(struct itimerval *itp, int usec);
int	itimerfix(struct timeval *tv);
int	ppsratecheck(struct timeval *, int *, int);
int	ratecheck(struct timeval *, const struct timeval *);
void	timevaladd(struct timeval *t1, const struct timeval *t2);
void	timevalsub(struct timeval *t1, const struct timeval *t2);
int	tvtohz(struct timeval *tv);

#define	TC_DEFAULTPERC		5

#define	BT2FREQ(bt)                                                     \
	(((uint64_t)0x8000000000000000 + ((bt)->frac >> 2)) /           \
	    ((bt)->frac >> 1))

#define	SBT2FREQ(sbt)	((SBT_1S + ((sbt) >> 1)) / (sbt))

#define	FREQ2BT(freq, bt)                                               \
{									\
	(bt)->sec = 0;                                                  \
	(bt)->frac = ((uint64_t)0x8000000000000000  / (freq)) << 1;     \
}

#define	TIMESEL(sbt, sbt2)						\
	(((sbt2) >= sbt_timethreshold) ?				\
	    ((*(sbt) = getsbinuptime()), 1) : ((*(sbt) = sbinuptime()), 0))

#else /* !_KERNEL */
# 471 "/usr/include/sys/time.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <time.h>
#endif /* expanded by -frewrite-includes */
# 471 "/usr/include/sys/time.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.3 (Berkeley) 1/21/94
 */

/*
 * $FreeBSD: releng/11.0/include/time.h 245428 2013-01-14 18:01:19Z dim $
 */

#ifndef _TIME_H_
#define	_TIME_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 44 "/usr/include/time.h" 3 4
# 45 "/usr/include/time.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_null.h>
#endif /* expanded by -frewrite-includes */
# 45 "/usr/include/time.h" 3 4
# 46 "/usr/include/time.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 46 "/usr/include/time.h" 3 4
# 47 "/usr/include/time.h" 3 4

#if __POSIX_VISIBLE > 0 && __POSIX_VISIBLE < 200112 || __BSD_VISIBLE
/*
 * Frequency of the clock ticks reported by times().  Deprecated - use
 * sysconf(_SC_CLK_TCK) instead.  (Removed in 1003.1-2001.)
 */
#define	CLK_TCK		128
#endif
# 55 "/usr/include/time.h" 3 4

/* Frequency of the clock ticks reported by clock().  */
#define	CLOCKS_PER_SEC	128

#ifndef _CLOCK_T_DECLARED
typedef	__clock_t	clock_t;
#define	_CLOCK_T_DECLARED
#endif
# 63 "/usr/include/time.h" 3 4

#ifndef _TIME_T_DECLARED
typedef	__time_t	time_t;
#define	_TIME_T_DECLARED
#endif
# 68 "/usr/include/time.h" 3 4

#ifndef _SIZE_T_DECLARED
typedef	__size_t	size_t;
#define	_SIZE_T_DECLARED
#endif
# 73 "/usr/include/time.h" 3 4

#if __POSIX_VISIBLE >= 199309
/*
 * New in POSIX 1003.1b-1993.
 */
#ifndef _CLOCKID_T_DECLARED
typedef	__clockid_t	clockid_t;
#define	_CLOCKID_T_DECLARED
#endif
# 82 "/usr/include/time.h" 3 4

#ifndef _TIMER_T_DECLARED
typedef	__timer_t	timer_t;
#define	_TIMER_T_DECLARED
#endif
# 87 "/usr/include/time.h" 3 4

#if 0 /* expanded by -frewrite-includes */
#include <sys/timespec.h>
#endif /* expanded by -frewrite-includes */
# 88 "/usr/include/time.h" 3 4
# 89 "/usr/include/time.h" 3 4
#endif /* __POSIX_VISIBLE >= 199309 */
# 90 "/usr/include/time.h" 3 4

#if __POSIX_VISIBLE >= 200112
#ifndef _PID_T_DECLARED
typedef	__pid_t		pid_t;
#define	_PID_T_DECLARED
#endif
# 96 "/usr/include/time.h" 3 4
#endif
# 97 "/usr/include/time.h" 3 4

/* These macros are also in sys/time.h. */
#if !defined(CLOCK_REALTIME) && __POSIX_VISIBLE >= 200112
#define CLOCK_REALTIME	0
#ifdef __BSD_VISIBLE
#define CLOCK_VIRTUAL	1
#define CLOCK_PROF	2
#endif
# 105 "/usr/include/time.h" 3 4
#define CLOCK_MONOTONIC	4
#define CLOCK_UPTIME	5		/* FreeBSD-specific. */
#define CLOCK_UPTIME_PRECISE	7	/* FreeBSD-specific. */
#define CLOCK_UPTIME_FAST	8	/* FreeBSD-specific. */
#define CLOCK_REALTIME_PRECISE	9	/* FreeBSD-specific. */
#define CLOCK_REALTIME_FAST	10	/* FreeBSD-specific. */
#define CLOCK_MONOTONIC_PRECISE	11	/* FreeBSD-specific. */
#define CLOCK_MONOTONIC_FAST	12	/* FreeBSD-specific. */
#define CLOCK_SECOND	13		/* FreeBSD-specific. */
#define CLOCK_THREAD_CPUTIME_ID	14
#define	CLOCK_PROCESS_CPUTIME_ID	15
#endif /* !defined(CLOCK_REALTIME) && __POSIX_VISIBLE >= 200112 */
# 117 "/usr/include/time.h" 3 4

#if !defined(TIMER_ABSTIME) && __POSIX_VISIBLE >= 200112
#if __BSD_VISIBLE
#define TIMER_RELTIME	0x0	/* relative timer */
#endif
# 122 "/usr/include/time.h" 3 4
#define TIMER_ABSTIME	0x1	/* absolute timer */
#endif /* !defined(TIMER_ABSTIME) && __POSIX_VISIBLE >= 200112 */
# 124 "/usr/include/time.h" 3 4

struct tm {
	int	tm_sec;		/* seconds after the minute [0-60] */
	int	tm_min;		/* minutes after the hour [0-59] */
	int	tm_hour;	/* hours since midnight [0-23] */
	int	tm_mday;	/* day of the month [1-31] */
	int	tm_mon;		/* months since January [0-11] */
	int	tm_year;	/* years since 1900 */
	int	tm_wday;	/* days since Sunday [0-6] */
	int	tm_yday;	/* days since January 1 [0-365] */
	int	tm_isdst;	/* Daylight Savings Time flag */
	long	tm_gmtoff;	/* offset from UTC in seconds */
	char	*tm_zone;	/* timezone abbreviation */
};

#if __POSIX_VISIBLE
extern char *tzname[];
#endif
# 142 "/usr/include/time.h" 3 4

__BEGIN_DECLS
char *asctime(const struct tm *);
clock_t clock(void);
char *ctime(const time_t *);
double difftime(time_t, time_t);
/* XXX missing: getdate() */
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *);
size_t strftime(char * __restrict, size_t, const char * __restrict,
    const struct tm * __restrict);
time_t time(time_t *);
#if __POSIX_VISIBLE >= 200112
struct sigevent;
int timer_create(clockid_t, struct sigevent *__restrict, timer_t *__restrict);
int timer_delete(timer_t);
int timer_gettime(timer_t, struct itimerspec *);
int timer_getoverrun(timer_t);
int timer_settime(timer_t, int, const struct itimerspec *__restrict,
	struct itimerspec *__restrict);
#endif
# 164 "/usr/include/time.h" 3 4
#if __POSIX_VISIBLE
void tzset(void);
#endif
# 167 "/usr/include/time.h" 3 4

#if __POSIX_VISIBLE >= 199309
int clock_getres(clockid_t, struct timespec *);
int clock_gettime(clockid_t, struct timespec *);
int clock_settime(clockid_t, const struct timespec *);
/* XXX missing: clock_nanosleep() */
int nanosleep(const struct timespec *, struct timespec *);
#endif /* __POSIX_VISIBLE >= 199309 */
# 175 "/usr/include/time.h" 3 4

#if __POSIX_VISIBLE >= 200112
int clock_getcpuclockid(pid_t, clockid_t *);
#endif
# 179 "/usr/include/time.h" 3 4

#if __POSIX_VISIBLE >= 199506
char *asctime_r(const struct tm *, char *);
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t *, struct tm *);
struct tm *localtime_r(const time_t *, struct tm *);
#endif
# 186 "/usr/include/time.h" 3 4

#if __XSI_VISIBLE
char *strptime(const char * __restrict, const char * __restrict,
    struct tm * __restrict);
#endif
# 191 "/usr/include/time.h" 3 4

#if __BSD_VISIBLE
char *timezone(int, int);	/* XXX XSI conflict */
void tzsetwall(void);
time_t timelocal(struct tm * const);
time_t timegm(struct tm * const);
#endif /* __BSD_VISIBLE */
# 198 "/usr/include/time.h" 3 4

#if __POSIX_VISIBLE >= 200809 || defined(_XLOCALE_H_)
#if 0 /* expanded by -frewrite-includes */
#include <xlocale/_time.h>
#endif /* expanded by -frewrite-includes */
# 200 "/usr/include/time.h" 3 4
# 1 "/usr/include/xlocale/_time.h" 1 3 4
/*-
 * Copyright (c) 2011, 2012 The FreeBSD Foundation
 * All rights reserved.
 *
 * This software was developed by David Chisnall under sponsorship from
 * the FreeBSD Foundation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/include/xlocale/_time.h 231673 2012-02-14 12:03:23Z theraven $
 */

#ifndef _LOCALE_T_DEFINED
#define _LOCALE_T_DEFINED
typedef struct	_xlocale *locale_t;
#endif
# 36 "/usr/include/xlocale/_time.h" 3 4

/*
 * This file is included from both locale.h and xlocale.h.  We need to expose
 * the declarations unconditionally if we are included from xlocale.h, but only
 * if we are in POSIX2008 mode if included from locale.h.
 */
#ifndef _XLOCALE_LOCALE1_H
#define _XLOCALE_LOCALE1_H

size_t	 strftime_l(char * __restrict, size_t, const char * __restrict,
	    const struct tm * __restrict, locale_t) __strftimelike(3, 0);

#endif /* _XLOCALE_LOCALE1_H */
# 49 "/usr/include/xlocale/_time.h" 3 4

#ifdef _XLOCALE_H_
#ifndef _XLOCALE_LOCALE2_H
#define _XLOCALE_LOCALE2_H

char	*strptime_l(const char * __restrict, const char * __restrict,
           struct tm * __restrict, locale_t);

#endif /* _XLOCALE_LOCALE2_H */
# 58 "/usr/include/xlocale/_time.h" 3 4
#endif /* _XLOCALE_H_ */
# 59 "/usr/include/xlocale/_time.h" 3 4
# 201 "/usr/include/time.h" 2 3 4
#endif
# 202 "/usr/include/time.h" 3 4
__END_DECLS

#endif /* !_TIME_H_ */
# 205 "/usr/include/time.h" 3 4
# 472 "/usr/include/sys/time.h" 2 3 4

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 473 "/usr/include/sys/time.h" 3 4
# 474 "/usr/include/sys/time.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/select.h>
#endif /* expanded by -frewrite-includes */
# 474 "/usr/include/sys/time.h" 3 4
# 475 "/usr/include/sys/time.h" 3 4

__BEGIN_DECLS
int	setitimer(int, const struct itimerval *, struct itimerval *);
int	utimes(const char *, const struct timeval *);

#if __BSD_VISIBLE
int	adjtime(const struct timeval *, struct timeval *);
int	clock_getcpuclockid2(id_t, int, clockid_t *);
int	futimes(int, const struct timeval *);
int	futimesat(int, const char *, const struct timeval [2]);
int	lutimes(const char *, const struct timeval *);
int	settimeofday(const struct timeval *, const struct timezone *);
#endif
# 488 "/usr/include/sys/time.h" 3 4

#if __XSI_VISIBLE
int	getitimer(int, struct itimerval *);
int	gettimeofday(struct timeval *, struct timezone *);
#endif
# 493 "/usr/include/sys/time.h" 3 4

__END_DECLS

#endif /* !_KERNEL */
# 497 "/usr/include/sys/time.h" 3 4

#endif /* !_SYS_TIME_H_ */
# 499 "/usr/include/sys/time.h" 3 4
# 100 "/usr/include/sys/stat.h" 2 3 4
#endif
# 101 "/usr/include/sys/stat.h" 3 4

#ifdef _KERNEL
struct ostat {
	__uint16_t st_dev;		/* inode's device */
	ino_t	  st_ino;		/* inode's number */
	mode_t	  st_mode;		/* inode protection mode */
	nlink_t	  st_nlink;		/* number of hard links */
	__uint16_t st_uid;		/* user ID of the file's owner */
	__uint16_t st_gid;		/* group ID of the file's group */
	__uint16_t st_rdev;		/* device type */
	__int32_t st_size;		/* file size, in bytes */
	struct	timespec st_atim;	/* time of last access */
	struct	timespec st_mtim;	/* time of last data modification */
	struct	timespec st_ctim;	/* time of last file status change */
	__int32_t st_blksize;		/* optimal blocksize for I/O */
	__int32_t st_blocks;		/* blocks allocated for file */
	fflags_t  st_flags;		/* user defined flags for file */
	__uint32_t st_gen;		/* file generation number */
};
#endif
# 121 "/usr/include/sys/stat.h" 3 4

struct stat {
	__dev_t   st_dev;		/* inode's device */
	ino_t	  st_ino;		/* inode's number */
	mode_t	  st_mode;		/* inode protection mode */
	nlink_t	  st_nlink;		/* number of hard links */
	uid_t	  st_uid;		/* user ID of the file's owner */
	gid_t	  st_gid;		/* group ID of the file's group */
	__dev_t   st_rdev;		/* device type */
	struct	timespec st_atim;	/* time of last access */
	struct	timespec st_mtim;	/* time of last data modification */
	struct	timespec st_ctim;	/* time of last file status change */
	off_t	  st_size;		/* file size, in bytes */
	blkcnt_t st_blocks;		/* blocks allocated for file */
	blksize_t st_blksize;		/* optimal blocksize for I/O */
	fflags_t  st_flags;		/* user defined flags for file */
	__uint32_t st_gen;		/* file generation number */
	__int32_t st_lspare;
	struct timespec st_birthtim;	/* time of file creation */
	/*
	 * Explicitly pad st_birthtim to 16 bytes so that the size of
	 * struct stat is backwards compatible.  We use bitfields instead
	 * of an array of chars so that this doesn't require a C99 compiler
	 * to compile if the size of the padding is 0.  We use 2 bitfields
	 * to cover up to 64 bits on 32-bit machines.  We assume that
	 * CHAR_BIT is 8...
	 */
	unsigned int :(8 / 2) * (16 - (int)sizeof(struct timespec));
	unsigned int :(8 / 2) * (16 - (int)sizeof(struct timespec));
};

#ifdef _KERNEL
struct nstat {
	__dev_t   st_dev;		/* inode's device */
	ino_t	  st_ino;		/* inode's number */
	__uint32_t st_mode;		/* inode protection mode */
	__uint32_t st_nlink;		/* number of hard links */
	uid_t	  st_uid;		/* user ID of the file's owner */
	gid_t	  st_gid;		/* group ID of the file's group */
	__dev_t   st_rdev;		/* device type */
	struct	timespec st_atim;	/* time of last access */
	struct	timespec st_mtim;	/* time of last data modification */
	struct	timespec st_ctim;	/* time of last file status change */
	off_t	  st_size;		/* file size, in bytes */
	blkcnt_t st_blocks;		/* blocks allocated for file */
	blksize_t st_blksize;		/* optimal blocksize for I/O */
	fflags_t  st_flags;		/* user defined flags for file */
	__uint32_t st_gen;		/* file generation number */
	struct timespec st_birthtim;	/* time of file creation */
	/*
	 * See above about the following padding.
	 */
	unsigned int :(8 / 2) * (16 - (int)sizeof(struct timespec));
	unsigned int :(8 / 2) * (16 - (int)sizeof(struct timespec));
};
#endif
# 177 "/usr/include/sys/stat.h" 3 4

#ifndef _KERNEL
#define	st_atime		st_atim.tv_sec
#define	st_mtime		st_mtim.tv_sec
#define	st_ctime		st_ctim.tv_sec
#if __BSD_VISIBLE
#define	st_birthtime		st_birthtim.tv_sec
#endif
# 185 "/usr/include/sys/stat.h" 3 4

/* For compatibility. */
#if __BSD_VISIBLE
#define	st_atimespec		st_atim
#define	st_mtimespec		st_mtim
#define	st_ctimespec		st_ctim
#define	st_birthtimespec	st_birthtim
#endif
# 193 "/usr/include/sys/stat.h" 3 4
#endif /* !_KERNEL */
# 194 "/usr/include/sys/stat.h" 3 4

#define	S_ISUID	0004000			/* set user id on execution */
#define	S_ISGID	0002000			/* set group id on execution */
#if __BSD_VISIBLE
#define	S_ISTXT	0001000			/* sticky bit */
#endif
# 200 "/usr/include/sys/stat.h" 3 4

#define	S_IRWXU	0000700			/* RWX mask for owner */
#define	S_IRUSR	0000400			/* R for owner */
#define	S_IWUSR	0000200			/* W for owner */
#define	S_IXUSR	0000100			/* X for owner */

#if __BSD_VISIBLE
#define	S_IREAD		S_IRUSR
#define	S_IWRITE	S_IWUSR
#define	S_IEXEC		S_IXUSR
#endif
# 211 "/usr/include/sys/stat.h" 3 4

#define	S_IRWXG	0000070			/* RWX mask for group */
#define	S_IRGRP	0000040			/* R for group */
#define	S_IWGRP	0000020			/* W for group */
#define	S_IXGRP	0000010			/* X for group */

#define	S_IRWXO	0000007			/* RWX mask for other */
#define	S_IROTH	0000004			/* R for other */
#define	S_IWOTH	0000002			/* W for other */
#define	S_IXOTH	0000001			/* X for other */

#if __XSI_VISIBLE
#define	S_IFMT	 0170000		/* type of file mask */
#define	S_IFIFO	 0010000		/* named pipe (fifo) */
#define	S_IFCHR	 0020000		/* character special */
#define	S_IFDIR	 0040000		/* directory */
#define	S_IFBLK	 0060000		/* block special */
#define	S_IFREG	 0100000		/* regular */
#define	S_IFLNK	 0120000		/* symbolic link */
#define	S_IFSOCK 0140000		/* socket */
#define	S_ISVTX	 0001000		/* save swapped text even after use */
#endif
# 233 "/usr/include/sys/stat.h" 3 4
#if __BSD_VISIBLE
#define	S_IFWHT  0160000		/* whiteout */
#endif
# 236 "/usr/include/sys/stat.h" 3 4

#define	S_ISDIR(m)	(((m) & 0170000) == 0040000)	/* directory */
#define	S_ISCHR(m)	(((m) & 0170000) == 0020000)	/* char special */
#define	S_ISBLK(m)	(((m) & 0170000) == 0060000)	/* block special */
#define	S_ISREG(m)	(((m) & 0170000) == 0100000)	/* regular file */
#define	S_ISFIFO(m)	(((m) & 0170000) == 0010000)	/* fifo or socket */
#if __POSIX_VISIBLE >= 200112
#define	S_ISLNK(m)	(((m) & 0170000) == 0120000)	/* symbolic link */
#define	S_ISSOCK(m)	(((m) & 0170000) == 0140000)	/* socket */
#endif
# 246 "/usr/include/sys/stat.h" 3 4
#if __BSD_VISIBLE
#define	S_ISWHT(m)	(((m) & 0170000) == 0160000)	/* whiteout */
#endif
# 249 "/usr/include/sys/stat.h" 3 4

#if __BSD_VISIBLE
#define	ACCESSPERMS	(S_IRWXU|S_IRWXG|S_IRWXO)	/* 0777 */
							/* 7777 */
#define	ALLPERMS	(S_ISUID|S_ISGID|S_ISTXT|S_IRWXU|S_IRWXG|S_IRWXO)
							/* 0666 */
#define	DEFFILEMODE	(S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)

#define S_BLKSIZE	512		/* block size used in the stat struct */

/*
 * Definitions of flags stored in file flags word.
 *
 * Super-user and owner changeable flags.
 */
#define	UF_SETTABLE	0x0000ffff	/* mask of owner changeable flags */
#define	UF_NODUMP	0x00000001	/* do not dump file */
#define	UF_IMMUTABLE	0x00000002	/* file may not be changed */
#define	UF_APPEND	0x00000004	/* writes to file may only append */
#define	UF_OPAQUE	0x00000008	/* directory is opaque wrt. union */
#define	UF_NOUNLINK	0x00000010	/* file may not be removed or renamed */
/*
 * These two bits are defined in MacOS X.  They are not currently used in
 * FreeBSD.
 */
#if 0
#define	UF_COMPRESSED	0x00000020	/* file is compressed */
#define	UF_TRACKED	0x00000040	/* renames and deletes are tracked */
#endif
# 278 "/usr/include/sys/stat.h" 3 4

#define	UF_SYSTEM	0x00000080	/* Windows system file bit */
#define	UF_SPARSE	0x00000100	/* sparse file */
#define	UF_OFFLINE	0x00000200	/* file is offline */
#define	UF_REPARSE	0x00000400	/* Windows reparse point file bit */
#define	UF_ARCHIVE	0x00000800	/* file needs to be archived */
#define	UF_READONLY	0x00001000	/* Windows readonly file bit */
/* This is the same as the MacOS X definition of UF_HIDDEN. */
#define	UF_HIDDEN	0x00008000	/* file is hidden */

/*
 * Super-user changeable flags.
 */
#define	SF_SETTABLE	0xffff0000	/* mask of superuser changeable flags */
#define	SF_ARCHIVED	0x00010000	/* file is archived */
#define	SF_IMMUTABLE	0x00020000	/* file may not be changed */
#define	SF_APPEND	0x00040000	/* writes to file may only append */
#define	SF_NOUNLINK	0x00100000	/* file may not be removed or renamed */
#define	SF_SNAPSHOT	0x00200000	/* snapshot inode */

#ifdef _KERNEL
/*
 * Shorthand abbreviations of above.
 */
#define	OPAQUE		(UF_OPAQUE)
#define	APPEND		(UF_APPEND | SF_APPEND)
#define	IMMUTABLE	(UF_IMMUTABLE | SF_IMMUTABLE)
#define	NOUNLINK	(UF_NOUNLINK | SF_NOUNLINK)
#endif
# 307 "/usr/include/sys/stat.h" 3 4

#endif /* __BSD_VISIBLE */
# 309 "/usr/include/sys/stat.h" 3 4

#if __POSIX_VISIBLE >= 200809
#define	UTIME_NOW	-1
#define	UTIME_OMIT	-2
#endif
# 314 "/usr/include/sys/stat.h" 3 4

#ifndef _KERNEL
__BEGIN_DECLS
#if __BSD_VISIBLE
int	chflags(const char *, unsigned long);
int	chflagsat(int, const char *, unsigned long, int);
#endif
# 321 "/usr/include/sys/stat.h" 3 4
int	chmod(const char *, mode_t);
#if __BSD_VISIBLE
int	fchflags(int, unsigned long);
#endif
# 325 "/usr/include/sys/stat.h" 3 4
#if __POSIX_VISIBLE >= 200112
int	fchmod(int, mode_t);
#endif
# 328 "/usr/include/sys/stat.h" 3 4
#if __POSIX_VISIBLE >= 200809
int	fchmodat(int, const char *, mode_t, int);
int	futimens(int fd, const struct timespec times[2]);
int	utimensat(int fd, const char *path, const struct timespec times[2],
		int flag);
#endif
# 334 "/usr/include/sys/stat.h" 3 4
int	fstat(int, struct stat *);
#if __BSD_VISIBLE
int	lchflags(const char *, unsigned long);
int	lchmod(const char *, mode_t);
#endif
# 339 "/usr/include/sys/stat.h" 3 4
#if __POSIX_VISIBLE >= 200112
int	lstat(const char * __restrict, struct stat * __restrict);
#endif
# 342 "/usr/include/sys/stat.h" 3 4
int	mkdir(const char *, mode_t);
int	mkfifo(const char *, mode_t);
#if !defined(_MKNOD_DECLARED) && __XSI_VISIBLE
int	mknod(const char *, mode_t, dev_t);
#define	_MKNOD_DECLARED
#endif
# 348 "/usr/include/sys/stat.h" 3 4
int	stat(const char * __restrict, struct stat * __restrict);
mode_t	umask(mode_t);
#if __POSIX_VISIBLE >= 200809
int	fstatat(int, const char *, struct stat *, int);
int	mkdirat(int, const char *, mode_t);
int	mkfifoat(int, const char *, mode_t);
#endif
# 355 "/usr/include/sys/stat.h" 3 4
#if __XSI_VISIBLE >= 700
int	mknodat(int, const char *, mode_t, dev_t);
#endif
# 358 "/usr/include/sys/stat.h" 3 4
__END_DECLS
#endif /* !_KERNEL */
# 360 "/usr/include/sys/stat.h" 3 4

#endif /* !_SYS_STAT_H_ */
# 362 "/usr/include/sys/stat.h" 3 4
# 46 "include/libbb.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <sys/time.h>
#endif /* expanded by -frewrite-includes */
# 46 "include/libbb.h"
# 47 "include/libbb.h"
#if 0 /* expanded by -frewrite-includes */
#include <sys/types.h>
#endif /* expanded by -frewrite-includes */
# 47 "include/libbb.h"
# 48 "include/libbb.h"
#if !defined(major) || defined(__GLIBC__)
#if 0 /* expanded by -frewrite-includes */
# include <sys/sysmacros.h>
#endif /* expanded by -frewrite-includes */
# 49 "include/libbb.h"
# 50 "include/libbb.h"
#endif
# 51 "include/libbb.h"
#if 0 /* expanded by -frewrite-includes */
#include <sys/wait.h>
#endif /* expanded by -frewrite-includes */
# 51 "include/libbb.h"
# 1 "/usr/include/sys/wait.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)wait.h	8.2 (Berkeley) 7/10/94
 * $FreeBSD: releng/11.0/sys/sys/wait.h 285670 2015-07-18 09:02:50Z kib $
 */

#ifndef _SYS_WAIT_H_
#define _SYS_WAIT_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/sys/wait.h" 3 4
# 37 "/usr/include/sys/wait.h" 3 4

/*
 * This file holds definitions relevant to the wait4 system call and the
 * alternate interfaces that use it (wait, wait3, waitpid).
 */

/*
 * Macros to test the exit status returned by wait and extract the relevant
 * values.
 */
#if __BSD_VISIBLE
#define	WCOREFLAG	0200
#endif
# 50 "/usr/include/sys/wait.h" 3 4
#define	_W_INT(i)	(i)

#define	_WSTATUS(x)	(_W_INT(x) & 0177)
#define	_WSTOPPED	0177		/* _WSTATUS if process is stopped */
#define	WIFSTOPPED(x)	(_WSTATUS(x) == _WSTOPPED)
#define	WSTOPSIG(x)	(_W_INT(x) >> 8)
#define	WIFSIGNALED(x)	(_WSTATUS(x) != _WSTOPPED && _WSTATUS(x) != 0 && (x) != 0x13)
#define	WTERMSIG(x)	(_WSTATUS(x))
#define	WIFEXITED(x)	(_WSTATUS(x) == 0)
#define	WEXITSTATUS(x)	(_W_INT(x) >> 8)
#define	WIFCONTINUED(x)	(x == 0x13)	/* 0x13 == SIGCONT */
#if __BSD_VISIBLE
#define	WCOREDUMP(x)	(_W_INT(x) & WCOREFLAG)

#define	W_EXITCODE(ret, sig)	((ret) << 8 | (sig))
#define	W_STOPCODE(sig)		((sig) << 8 | _WSTOPPED)
#endif
# 67 "/usr/include/sys/wait.h" 3 4

/*
 * Option bits for the third argument of wait4.  WNOHANG causes the
 * wait to not hang if there are no stopped or terminated processes, rather
 * returning an error indication in this case (pid==0).  WUNTRACED
 * indicates that the caller should receive status about untraced children
 * which stop due to signals.  If children are stopped and a wait without
 * this option is done, it is as though they were still running... nothing
 * about them is returned. WNOWAIT only request information about zombie,
 * leaving the proc around, available for later waits.
 */
#define	WNOHANG		1	/* Don't hang in wait. */
#define	WUNTRACED	2	/* Tell about stopped, untraced children. */
#define	WSTOPPED	WUNTRACED   /* SUS compatibility */
#define	WCONTINUED	4	/* Report a job control continued process. */
#define	WNOWAIT		8	/* Poll only. Don't delete the proc entry. */
#define	WEXITED		16	/* Wait for exited processes. */
#define	WTRAPPED	32	/* Wait for a process to hit a trap or
				   a breakpoint. */

#if __BSD_VISIBLE
#define	WLINUXCLONE 0x80000000	/* Wait for kthread spawned from linux_clone. */
#endif
# 90 "/usr/include/sys/wait.h" 3 4

#ifndef _IDTYPE_T_DECLARED
typedef enum
#if __BSD_VISIBLE
	idtype		/* pollutes XPG4.2 namespace */
#endif
# 96 "/usr/include/sys/wait.h" 3 4
		{
	/*
	 * These names were mostly lifted from Solaris source code and
	 * still use Solaris style naming to avoid breaking any
	 * OpenSolaris code which has been ported to FreeBSD.  There
	 * is no clear FreeBSD counterpart for all of the names, but
	 * some have a clear correspondence to FreeBSD entities.
	 *
	 * The numerical values are kept synchronized with the Solaris
	 * values.
	 */
	P_PID,			/* A process identifier. */
	P_PPID,			/* A parent process identifier.	*/
	P_PGID,			/* A process group identifier. */
	P_SID,			/* A session identifier. */
	P_CID,			/* A scheduling class identifier. */
	P_UID,			/* A user identifier. */
	P_GID,			/* A group identifier. */
	P_ALL,			/* All processes. */
	P_LWPID,		/* An LWP identifier. */
	P_TASKID,		/* A task identifier. */
	P_PROJID,		/* A project identifier. */
	P_POOLID,		/* A pool identifier. */
	P_JAILID,		/* A zone identifier. */
	P_CTID,			/* A (process) contract identifier. */
	P_CPUID,		/* CPU identifier. */
	P_PSETID		/* Processor set identifier. */
} idtype_t;			/* The type of id_t we are using. */

#if __BSD_VISIBLE
#define	P_ZONEID	P_JAILID
#endif
# 128 "/usr/include/sys/wait.h" 3 4
#define	_IDTYPE_T_DECLARED
#endif
# 130 "/usr/include/sys/wait.h" 3 4

/*
 * Tokens for special values of the "pid" parameter to wait4.
 * Extended struct __wrusage to collect rusage for both the target
 * process and its children within one wait6() call.
 */
#if __BSD_VISIBLE
#define	WAIT_ANY	(-1)	/* any process */
#define	WAIT_MYPGRP	0	/* any process in my process group */
#endif /* __BSD_VISIBLE */
# 140 "/usr/include/sys/wait.h" 3 4

#if defined(_KERNEL) || defined(_WANT_KW_EXITCODE)

/*
 * Clamp the return code to the low 8 bits from full 32 bit value.
 * Should be used in kernel to construct the wait(2)-compatible process
 * status to usermode.
 */
#define	KW_EXITCODE(ret, sig)	W_EXITCODE((ret) & 0xff, (sig))

#endif	/* _KERNEL || _WANT_KW_EXITCODE */
# 151 "/usr/include/sys/wait.h" 3 4

#ifndef _KERNEL

#if 0 /* expanded by -frewrite-includes */
#include <sys/types.h>
#endif /* expanded by -frewrite-includes */
# 154 "/usr/include/sys/wait.h" 3 4
# 155 "/usr/include/sys/wait.h" 3 4

__BEGIN_DECLS
struct __siginfo;
pid_t	wait(int *);
pid_t	waitpid(pid_t, int *, int);
#if __POSIX_VISIBLE >= 200112
int	waitid(idtype_t, id_t, struct __siginfo *, int);
#endif
# 163 "/usr/include/sys/wait.h" 3 4
#if __BSD_VISIBLE
struct rusage;
struct __wrusage;
pid_t	wait3(int *, int, struct rusage *);
pid_t	wait4(pid_t, int *, int, struct rusage *);
pid_t	wait6(idtype_t, id_t, int *, int, struct __wrusage *,
	    struct __siginfo *);
#endif
# 171 "/usr/include/sys/wait.h" 3 4
__END_DECLS
#endif /* !_KERNEL */
# 173 "/usr/include/sys/wait.h" 3 4

#endif /* !_SYS_WAIT_H_ */
# 175 "/usr/include/sys/wait.h" 3 4
# 52 "include/libbb.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <termios.h>
#endif /* expanded by -frewrite-includes */
# 52 "include/libbb.h"
# 1 "/usr/include/termios.h" 1 3 4
/*-
 * Copyright (c) 1988, 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)termios.h	8.3 (Berkeley) 3/28/94
 * $FreeBSD: releng/11.0/include/termios.h 265878 2014-05-11 13:48:21Z jilles $
 */

#ifndef _TERMIOS_H_
#define	_TERMIOS_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/termios.h" 3 4
# 37 "/usr/include/termios.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_termios.h>
#endif /* expanded by -frewrite-includes */
# 37 "/usr/include/termios.h" 3 4
# 1 "/usr/include/sys/_termios.h" 1 3 4
/*-
 * Copyright (c) 1988, 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)termios.h	8.3 (Berkeley) 3/28/94
 * $FreeBSD: releng/11.0/sys/sys/_termios.h 199898 2009-11-28 23:50:48Z ed $
 */

#ifndef _SYS__TERMIOS_H_
#define	_SYS__TERMIOS_H_

/*
 * Special Control Characters
 *
 * Index into c_cc[] character array.
 *
 *	Name	     Subscript	Enabled by
 */
#define	VEOF		0	/* ICANON */
#define	VEOL		1	/* ICANON */
#ifndef _POSIX_SOURCE
#define	VEOL2		2	/* ICANON together with IEXTEN */
#endif
# 48 "/usr/include/sys/_termios.h" 3 4
#define	VERASE		3	/* ICANON */
#ifndef _POSIX_SOURCE
#define	VWERASE 	4	/* ICANON together with IEXTEN */
#endif
# 52 "/usr/include/sys/_termios.h" 3 4
#define	VKILL		5	/* ICANON */
#ifndef _POSIX_SOURCE
#define	VREPRINT 	6	/* ICANON together with IEXTEN */
#define	VERASE2 	7	/* ICANON */
#endif
# 57 "/usr/include/sys/_termios.h" 3 4
/*			7	   ex-spare 1 */
#define	VINTR		8	/* ISIG */
#define	VQUIT		9	/* ISIG */
#define	VSUSP		10	/* ISIG */
#ifndef _POSIX_SOURCE
#define	VDSUSP		11	/* ISIG together with IEXTEN */
#endif
# 64 "/usr/include/sys/_termios.h" 3 4
#define	VSTART		12	/* IXON, IXOFF */
#define	VSTOP		13	/* IXON, IXOFF */
#ifndef _POSIX_SOURCE
#define	VLNEXT		14	/* IEXTEN */
#define	VDISCARD	15	/* IEXTEN */
#endif
# 70 "/usr/include/sys/_termios.h" 3 4
#define	VMIN		16	/* !ICANON */
#define	VTIME		17	/* !ICANON */
#ifndef _POSIX_SOURCE
#define	VSTATUS		18	/* ICANON together with IEXTEN */
/*			19	   spare 2 */
#endif
# 76 "/usr/include/sys/_termios.h" 3 4
#define	NCCS		20

#define	_POSIX_VDISABLE	0xff

/*
 * Input flags - software input processing
 */
#define	IGNBRK		0x00000001	/* ignore BREAK condition */
#define	BRKINT		0x00000002	/* map BREAK to SIGINTR */
#define	IGNPAR		0x00000004	/* ignore (discard) parity errors */
#define	PARMRK		0x00000008	/* mark parity and framing errors */
#define	INPCK		0x00000010	/* enable checking of parity errors */
#define	ISTRIP		0x00000020	/* strip 8th bit off chars */
#define	INLCR		0x00000040	/* map NL into CR */
#define	IGNCR		0x00000080	/* ignore CR */
#define	ICRNL		0x00000100	/* map CR to NL (ala CRMOD) */
#define	IXON		0x00000200	/* enable output flow control */
#define	IXOFF		0x00000400	/* enable input flow control */
#ifndef _POSIX_SOURCE
#define	IXANY		0x00000800	/* any char will restart after stop */
#define	IMAXBEL		0x00002000	/* ring bell on input queue full */
#endif  /*_POSIX_SOURCE */
# 98 "/usr/include/sys/_termios.h" 3 4

/*
 * Output flags - software output processing
 */
#define	OPOST		0x00000001	/* enable following output processing */
#ifndef _POSIX_SOURCE
#define	ONLCR		0x00000002	/* map NL to CR-NL (ala CRMOD) */
#define	TABDLY		0x00000004	/* tab delay mask */
#define	    TAB0	    0x00000000	    /* no tab delay and expansion */
#define	    TAB3	    0x00000004	    /* expand tabs to spaces */
#define	ONOEOT		0x00000008	/* discard EOT's (^D) on output) */
#define	OCRNL		0x00000010	/* map CR to NL on output */
#define	ONOCR		0x00000020	/* no CR output at column 0 */
#define	ONLRET		0x00000040	/* NL performs CR function */
#endif  /*_POSIX_SOURCE */
# 113 "/usr/include/sys/_termios.h" 3 4

/*
 * Control flags - hardware control of terminal
 */
#ifndef _POSIX_SOURCE
#define	CIGNORE		0x00000001	/* ignore control flags */
#endif
# 120 "/usr/include/sys/_termios.h" 3 4
#define	CSIZE		0x00000300	/* character size mask */
#define	    CS5		    0x00000000	    /* 5 bits (pseudo) */
#define	    CS6		    0x00000100	    /* 6 bits */
#define	    CS7		    0x00000200	    /* 7 bits */
#define	    CS8		    0x00000300	    /* 8 bits */
#define	CSTOPB		0x00000400	/* send 2 stop bits */
#define	CREAD		0x00000800	/* enable receiver */
#define	PARENB		0x00001000	/* parity enable */
#define	PARODD		0x00002000	/* odd parity, else even */
#define	HUPCL		0x00004000	/* hang up on last close */
#define	CLOCAL		0x00008000	/* ignore modem status lines */
#ifndef _POSIX_SOURCE
#define	CCTS_OFLOW	0x00010000	/* CTS flow control of output */
#define	CRTSCTS		(CCTS_OFLOW | CRTS_IFLOW)
#define	CRTS_IFLOW	0x00020000	/* RTS flow control of input */
#define	CDTR_IFLOW	0x00040000	/* DTR flow control of input */
#define	CDSR_OFLOW	0x00080000	/* DSR flow control of output */
#define	CCAR_OFLOW	0x00100000	/* DCD flow control of output */
#endif
# 139 "/usr/include/sys/_termios.h" 3 4


/*
 * "Local" flags - dumping ground for other state
 *
 * Warning: some flags in this structure begin with
 * the letter "I" and look like they belong in the
 * input flag.
 */

#ifndef _POSIX_SOURCE
#define	ECHOKE		0x00000001	/* visual erase for line kill */
#endif  /*_POSIX_SOURCE */
# 152 "/usr/include/sys/_termios.h" 3 4
#define	ECHOE		0x00000002	/* visually erase chars */
#define	ECHOK		0x00000004	/* echo NL after line kill */
#define	ECHO		0x00000008	/* enable echoing */
#define	ECHONL		0x00000010	/* echo NL even if ECHO is off */
#ifndef _POSIX_SOURCE
#define	ECHOPRT		0x00000020	/* visual erase mode for hardcopy */
#define	ECHOCTL  	0x00000040	/* echo control chars as ^(Char) */
#endif  /*_POSIX_SOURCE */
# 160 "/usr/include/sys/_termios.h" 3 4
#define	ISIG		0x00000080	/* enable signals INTR, QUIT, [D]SUSP */
#define	ICANON		0x00000100	/* canonicalize input lines */
#ifndef _POSIX_SOURCE
#define	ALTWERASE	0x00000200	/* use alternate WERASE algorithm */
#endif  /*_POSIX_SOURCE */
# 165 "/usr/include/sys/_termios.h" 3 4
#define	IEXTEN		0x00000400	/* enable DISCARD and LNEXT */
#define	EXTPROC         0x00000800      /* external processing */
#define	TOSTOP		0x00400000	/* stop background jobs from output */
#ifndef _POSIX_SOURCE
#define	FLUSHO		0x00800000	/* output being flushed (state) */
#define	NOKERNINFO	0x02000000	/* no kernel output from VSTATUS */
#define	PENDIN		0x20000000	/* XXX retype pending input (state) */
#endif  /*_POSIX_SOURCE */
# 173 "/usr/include/sys/_termios.h" 3 4
#define	NOFLSH		0x80000000	/* don't flush after interrupt */

/*
 * Standard speeds
 */
#define	B0	0
#define	B50	50
#define	B75	75
#define	B110	110
#define	B134	134
#define	B150	150
#define	B200	200
#define	B300	300
#define	B600	600
#define	B1200	1200
#define	B1800	1800
#define	B2400	2400
#define	B4800	4800
#define	B9600	9600
#define	B19200	19200
#define	B38400	38400
#ifndef _POSIX_SOURCE
#define	B7200	7200
#define	B14400	14400
#define	B28800	28800
#define	B57600	57600
#define	B76800	76800
#define	B115200	115200
#define	B230400	230400
#define	B460800	460800
#define	B921600	921600
#define	EXTA	19200
#define	EXTB	38400
#endif  /* !_POSIX_SOURCE */
# 207 "/usr/include/sys/_termios.h" 3 4

typedef unsigned int	tcflag_t;
typedef unsigned char	cc_t;
typedef unsigned int	speed_t;

struct termios {
	tcflag_t	c_iflag;	/* input flags */
	tcflag_t	c_oflag;	/* output flags */
	tcflag_t	c_cflag;	/* control flags */
	tcflag_t	c_lflag;	/* local flags */
	cc_t		c_cc[NCCS];	/* control chars */
	speed_t		c_ispeed;	/* input speed */
	speed_t		c_ospeed;	/* output speed */
};

#endif /* !_SYS__TERMIOS_H_ */
# 223 "/usr/include/sys/_termios.h" 3 4
# 38 "/usr/include/termios.h" 2 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 38 "/usr/include/termios.h" 3 4
# 39 "/usr/include/termios.h" 3 4

#ifndef _PID_T_DECLARED
typedef	__pid_t		pid_t;
#define	_PID_T_DECLARED
#endif
# 44 "/usr/include/termios.h" 3 4

#ifndef _POSIX_SOURCE
#define	OXTABS		TAB3
#define	MDMBUF		CCAR_OFLOW
#endif 
# 49 "/usr/include/termios.h" 3 4

#ifndef _POSIX_SOURCE
#define	CCEQ(val, c)	((c) == (val) && (val) != _POSIX_VDISABLE)
#endif
# 53 "/usr/include/termios.h" 3 4

/*
 * Commands passed to tcsetattr() for setting the termios structure.
 */
#define	TCSANOW		0		/* make change immediate */
#define	TCSADRAIN	1		/* drain output, then change */
#define	TCSAFLUSH	2		/* drain output, flush input */
#ifndef _POSIX_SOURCE
#define	TCSASOFT	0x10		/* flag - don't alter h.w. state */
#endif
# 63 "/usr/include/termios.h" 3 4

#define	TCIFLUSH	1
#define	TCOFLUSH	2
#define	TCIOFLUSH	3
#define	TCOOFF		1
#define	TCOON		2
#define	TCIOFF		3
#define	TCION		4

__BEGIN_DECLS
speed_t	cfgetispeed(const struct termios *);
speed_t	cfgetospeed(const struct termios *);
int	cfsetispeed(struct termios *, speed_t);
int	cfsetospeed(struct termios *, speed_t);
int	tcgetattr(int, struct termios *);
int	tcsetattr(int, int, const struct termios *);
int	tcdrain(int);
int	tcflow(int, int);
int	tcflush(int, int);
int	tcsendbreak(int, int);

#if __POSIX_VISIBLE >= 200112
pid_t	tcgetsid(int);
#endif
# 87 "/usr/include/termios.h" 3 4
#if __BSD_VISIBLE
int	tcsetsid(int, pid_t);

void	cfmakeraw(struct termios *);
void	cfmakesane(struct termios *);
int	cfsetspeed(struct termios *, speed_t);
#endif
# 94 "/usr/include/termios.h" 3 4
__END_DECLS

#endif /* !_TERMIOS_H_ */
# 97 "/usr/include/termios.h" 3 4

#ifndef _POSIX_SOURCE
#if 0 /* expanded by -frewrite-includes */
#include <sys/ttycom.h>
#endif /* expanded by -frewrite-includes */
# 99 "/usr/include/termios.h" 3 4
# 100 "/usr/include/termios.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/ttydefaults.h>
#endif /* expanded by -frewrite-includes */
# 100 "/usr/include/termios.h" 3 4
# 1 "/usr/include/sys/ttydefaults.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ttydefaults.h	8.4 (Berkeley) 1/21/94
 * $FreeBSD: releng/11.0/sys/sys/ttydefaults.h 249311 2013-04-09 16:16:34Z ed $
 */

/*
 * System wide defaults for terminal state.
 */
#ifndef _SYS_TTYDEFAULTS_H_
#define	_SYS_TTYDEFAULTS_H_

/*
 * Defaults on "first" open.
 */
#define	TTYDEF_IFLAG	(BRKINT	| ICRNL	| IMAXBEL | IXON | IXANY)
#define	TTYDEF_OFLAG	(OPOST | ONLCR)
#define	TTYDEF_LFLAG_NOECHO (ICANON | ISIG | IEXTEN)
#define	TTYDEF_LFLAG_ECHO (TTYDEF_LFLAG_NOECHO \
	| ECHO | ECHOE | ECHOKE | ECHOCTL)
#define	TTYDEF_LFLAG TTYDEF_LFLAG_ECHO
#define	TTYDEF_CFLAG	(CREAD | CS8 | HUPCL)
#define	TTYDEF_SPEED	(B9600)

/*
 * Control Character Defaults
 */
/*
 * XXX: A lot of code uses lowercase characters, but control-character
 * conversion is actually only valid when applied to uppercase
 * characters. We just treat lowercase characters as if they were
 * inserted as uppercase.
 */
#define	CTRL(x) ((x) >= 'a' && (x) <= 'z' ? \
	((x) - 'a' + 1) : (((x) - 'A' + 1) & 0x7f))
#define	CEOF		CTRL('D')
#define	CEOL		0xff		/* XXX avoid _POSIX_VDISABLE */
#define	CERASE		CTRL('?')
#define	CERASE2		CTRL('H')
#define	CINTR		CTRL('C')
#define	CSTATUS		CTRL('T')
#define	CKILL		CTRL('U')
#define	CMIN		1
#define	CQUIT		CTRL('\\')
#define	CSUSP		CTRL('Z')
#define	CTIME		0
#define	CDSUSP		CTRL('Y')
#define	CSTART		CTRL('Q')
#define	CSTOP		CTRL('S')
#define	CLNEXT		CTRL('V')
#define	CDISCARD	CTRL('O')
#define	CWERASE		CTRL('W')
#define	CREPRINT	CTRL('R')
#define	CEOT		CEOF
/* compat */
#define	CBRK		CEOL
#define	CRPRNT		CREPRINT
#define	CFLUSH		CDISCARD

/* PROTECTED INCLUSION ENDS HERE */
#endif /* !_SYS_TTYDEFAULTS_H_ */
# 93 "/usr/include/sys/ttydefaults.h" 3 4

/*
 * #define TTYDEFCHARS to include an array of default control characters.
 */
#ifdef TTYDEFCHARS

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 99 "/usr/include/sys/ttydefaults.h" 3 4
# 100 "/usr/include/sys/ttydefaults.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_termios.h>
#endif /* expanded by -frewrite-includes */
# 100 "/usr/include/sys/ttydefaults.h" 3 4
# 101 "/usr/include/sys/ttydefaults.h" 3 4

static const cc_t ttydefchars[] = {
	CEOF, CEOL, CEOL, CERASE, CWERASE, CKILL, CREPRINT, CERASE2, CINTR,
	CQUIT, CSUSP, CDSUSP, CSTART, CSTOP, CLNEXT, CDISCARD, CMIN, CTIME,
	CSTATUS, _POSIX_VDISABLE
};
_Static_assert(sizeof(ttydefchars) / sizeof(cc_t) == NCCS,
    "Size of ttydefchars does not match NCCS");

#undef TTYDEFCHARS
#endif /* TTYDEFCHARS */
# 112 "/usr/include/sys/ttydefaults.h" 3 4
# 101 "/usr/include/termios.h" 2 3 4
#endif
# 102 "/usr/include/termios.h" 3 4
# 53 "include/libbb.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <time.h>
#endif /* expanded by -frewrite-includes */
# 53 "include/libbb.h"
# 54 "include/libbb.h"
#if 0 /* expanded by -frewrite-includes */
#include <sys/param.h>
#endif /* expanded by -frewrite-includes */
# 54 "include/libbb.h"
# 1 "/usr/include/sys/param.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)param.h	8.3 (Berkeley) 4/4/95
 * $FreeBSD: releng/11.0/sys/sys/param.h 304610 2016-08-22 16:04:25Z bdrewery $
 */

#ifndef _SYS_PARAM_H_
#define _SYS_PARAM_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/_null.h>
#endif /* expanded by -frewrite-includes */
# 41 "/usr/include/sys/param.h" 3 4
# 42 "/usr/include/sys/param.h" 3 4

#define	BSD	199506		/* System version (year & month). */
#define BSD4_3	1
#define BSD4_4	1

/* 
 * __FreeBSD_version numbers are documented in the Porter's Handbook.
 * If you bump the version for any reason, you should update the documentation
 * there.
 * Currently this lives here in the doc/ repository:
 *
 *	head/en_US.ISO8859-1/books/porters-handbook/versions/chapter.xml
 *
 * scheme is:  <major><two digit minor>Rxx
 *		'R' is in the range 0 to 4 if this is a release branch or
 *		x.0-CURRENT before RELENG_*_0 is created, otherwise 'R' is
 *		in the range 5 to 9.
 */
#undef __FreeBSD_version
#define __FreeBSD_version 1100122	/* Master, propagated to newvers */

/*
 * __FreeBSD_kernel__ indicates that this system uses the kernel of FreeBSD,
 * which by definition is always true on FreeBSD. This macro is also defined
 * on other systems that use the kernel of FreeBSD, such as GNU/kFreeBSD.
 *
 * It is tempting to use this macro in userland code when we want to enable
 * kernel-specific routines, and in fact it's fine to do this in code that
 * is part of FreeBSD itself.  However, be aware that as presence of this
 * macro is still not widespread (e.g. older FreeBSD versions, 3rd party
 * compilers, etc), it is STRONGLY DISCOURAGED to check for this macro in
 * external applications without also checking for __FreeBSD__ as an
 * alternative.
 */
#undef __FreeBSD_kernel__
#define __FreeBSD_kernel__

#ifdef _KERNEL
#define	P_OSREL_SIGWAIT			700000
#define	P_OSREL_SIGSEGV			700004
#define	P_OSREL_MAP_ANON		800104
#define	P_OSREL_MAP_FSTRICT		1100036
#define	P_OSREL_SHUTDOWN_ENOTCONN	1100077

#define	P_OSREL_MAJOR(x)		((x) / 100000)
#endif
# 88 "/usr/include/sys/param.h" 3 4

#ifndef LOCORE
#if 0 /* expanded by -frewrite-includes */
#include <sys/types.h>
#endif /* expanded by -frewrite-includes */
# 90 "/usr/include/sys/param.h" 3 4
# 91 "/usr/include/sys/param.h" 3 4
#endif
# 92 "/usr/include/sys/param.h" 3 4

/*
 * Machine-independent constants (some used in following include files).
 * Redefined constants are from POSIX 1003.1 limits file.
 *
 * MAXCOMLEN should be >= sizeof(ac_comm) (see <acct.h>)
 */
#if 0 /* expanded by -frewrite-includes */
#include <sys/syslimits.h>
#endif /* expanded by -frewrite-includes */
# 99 "/usr/include/sys/param.h" 3 4
# 100 "/usr/include/sys/param.h" 3 4

#define	MAXCOMLEN	19		/* max command name remembered */
#define	MAXINTERP	PATH_MAX	/* max interpreter file name length */
#define	MAXLOGNAME	33		/* max login name length (incl. NUL) */
#define	MAXUPRC		CHILD_MAX	/* max simultaneous processes */
#define	NCARGS		ARG_MAX		/* max bytes for an exec function */
#define	NGROUPS		(NGROUPS_MAX+1)	/* max number groups */
#define	NOFILE		OPEN_MAX	/* max open files per process */
#define	NOGROUP		65535		/* marker for empty group set member */
#define MAXHOSTNAMELEN	256		/* max hostname size */
#define SPECNAMELEN	63		/* max length of devicename */

/* More types and definitions used throughout the kernel. */
#ifdef _KERNEL
#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 114 "/usr/include/sys/param.h" 3 4
# 115 "/usr/include/sys/param.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/errno.h>
#endif /* expanded by -frewrite-includes */
# 115 "/usr/include/sys/param.h" 3 4
# 116 "/usr/include/sys/param.h" 3 4
#ifndef LOCORE
#if 0 /* expanded by -frewrite-includes */
#include <sys/time.h>
#endif /* expanded by -frewrite-includes */
# 117 "/usr/include/sys/param.h" 3 4
# 118 "/usr/include/sys/param.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/priority.h>
#endif /* expanded by -frewrite-includes */
# 118 "/usr/include/sys/param.h" 3 4
# 119 "/usr/include/sys/param.h" 3 4
#endif
# 120 "/usr/include/sys/param.h" 3 4

#ifndef FALSE
#define	FALSE	0
#endif
# 124 "/usr/include/sys/param.h" 3 4
#ifndef TRUE
#define	TRUE	1
#endif
# 127 "/usr/include/sys/param.h" 3 4
#endif
# 128 "/usr/include/sys/param.h" 3 4

#ifndef _KERNEL
/* Signals. */
#if 0 /* expanded by -frewrite-includes */
#include <sys/signal.h>
#endif /* expanded by -frewrite-includes */
# 131 "/usr/include/sys/param.h" 3 4
# 132 "/usr/include/sys/param.h" 3 4
#endif
# 133 "/usr/include/sys/param.h" 3 4

/* Machine type dependent parameters. */
#if 0 /* expanded by -frewrite-includes */
#include <machine/param.h>
#endif /* expanded by -frewrite-includes */
# 135 "/usr/include/sys/param.h" 3 4
# 1 "/usr/include/machine/param.h" 1 3 4
/*-
 * Copyright (c) 2002 David E. O'Brien.  All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department and Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)param.h	8.1 (Berkeley) 6/10/93
 * $FreeBSD: releng/11.0/sys/amd64/include/param.h 297877 2016-04-12 21:23:44Z jhb $
 */


#ifndef _AMD64_INCLUDE_PARAM_H_
#define	_AMD64_INCLUDE_PARAM_H_

#if 0 /* expanded by -frewrite-includes */
#include <machine/_align.h>
#endif /* expanded by -frewrite-includes */
# 46 "/usr/include/machine/param.h" 3 4
# 1 "/usr/include/machine/_align.h" 1 3 4
/*-
 * This file is in the public domain.
 */
/* $FreeBSD: releng/11.0/sys/amd64/include/_align.h 215856 2010-11-26 10:59:20Z tijl $ */

#if 0 /* expanded by -frewrite-includes */
#include <x86/_align.h>
#endif /* expanded by -frewrite-includes */
# 6 "/usr/include/machine/_align.h" 3 4
# 7 "/usr/include/machine/_align.h" 3 4
# 47 "/usr/include/machine/param.h" 2 3 4

/*
 * Machine dependent constants for AMD64.
 */


#define __HAVE_ACPI
#define __PCI_REROUTE_INTERRUPT

#ifndef MACHINE
#define	MACHINE		"amd64"
#endif
# 59 "/usr/include/machine/param.h" 3 4
#ifndef MACHINE_ARCH
#define	MACHINE_ARCH	"amd64"
#endif
# 62 "/usr/include/machine/param.h" 3 4
#ifndef MACHINE_ARCH32
#define	MACHINE_ARCH32	"i386"
#endif
# 65 "/usr/include/machine/param.h" 3 4

#if defined(SMP) || defined(KLD_MODULE)
#ifndef MAXCPU
#define MAXCPU		256
#endif
# 70 "/usr/include/machine/param.h" 3 4
#else
# 71 "/usr/include/machine/param.h" 3 4
#define MAXCPU		1
#endif
# 73 "/usr/include/machine/param.h" 3 4

#ifndef MAXMEMDOM
#define	MAXMEMDOM	8
#endif
# 77 "/usr/include/machine/param.h" 3 4

#define	ALIGNBYTES		_ALIGNBYTES
#define	ALIGN(p)		_ALIGN(p)
/*
 * ALIGNED_POINTER is a boolean macro that checks whether an address
 * is valid to fetch data elements of type t from on this architecture.
 * This does not reflect the optimal alignment, just the possibility
 * (within reasonable limits). 
 */
#define	ALIGNED_POINTER(p, t)	1

/*
 * CACHE_LINE_SIZE is the compile-time maximum cache line size for an
 * architecture.  It should be used with appropriate caution.
 */
#define	CACHE_LINE_SHIFT	7
#define	CACHE_LINE_SIZE		(1 << CACHE_LINE_SHIFT)

/* Size of the level 1 page table units */
#define NPTEPG		(PAGE_SIZE/(sizeof (pt_entry_t)))
#define	NPTEPGSHIFT	9		/* LOG2(NPTEPG) */
#define PAGE_SHIFT	12		/* LOG2(PAGE_SIZE) */
#define PAGE_SIZE	(1<<PAGE_SHIFT)	/* bytes/page */
#define PAGE_MASK	(PAGE_SIZE-1)
/* Size of the level 2 page directory units */
#define	NPDEPG		(PAGE_SIZE/(sizeof (pd_entry_t)))
#define	NPDEPGSHIFT	9		/* LOG2(NPDEPG) */
#define	PDRSHIFT	21              /* LOG2(NBPDR) */
#define	NBPDR		(1<<PDRSHIFT)   /* bytes/page dir */
#define	PDRMASK		(NBPDR-1)
/* Size of the level 3 page directory pointer table units */
#define	NPDPEPG		(PAGE_SIZE/(sizeof (pdp_entry_t)))
#define	NPDPEPGSHIFT	9		/* LOG2(NPDPEPG) */
#define	PDPSHIFT	30		/* LOG2(NBPDP) */
#define	NBPDP		(1<<PDPSHIFT)	/* bytes/page dir ptr table */
#define	PDPMASK		(NBPDP-1)
/* Size of the level 4 page-map level-4 table units */
#define	NPML4EPG	(PAGE_SIZE/(sizeof (pml4_entry_t)))
#define	NPML4EPGSHIFT	9		/* LOG2(NPML4EPG) */
#define	PML4SHIFT	39		/* LOG2(NBPML4) */
#define	NBPML4		(1UL<<PML4SHIFT)/* bytes/page map lev4 table */
#define	PML4MASK	(NBPML4-1)

#define	MAXPAGESIZES	3	/* maximum number of supported page sizes */

#define IOPAGES	2		/* pages of i/o permission bitmap */
/*
 * I/O permission bitmap has a bit for each I/O port plus an additional
 * byte at the end with all bits set. See section "I/O Permission Bit Map"
 * in the Intel SDM for more details.
 */
#define	IOPERM_BITMAP_SIZE	(IOPAGES * PAGE_SIZE + 1)

#ifndef	KSTACK_PAGES
#define	KSTACK_PAGES	4	/* pages of kstack (with pcb) */
#endif
# 133 "/usr/include/machine/param.h" 3 4
#define	KSTACK_GUARD_PAGES 1	/* pages of kstack guard; 0 disables */

/*
 * Mach derived conversion macros
 */
#define	round_page(x)	((((unsigned long)(x)) + PAGE_MASK) & ~(PAGE_MASK))
#define	trunc_page(x)	((unsigned long)(x) & ~(PAGE_MASK))
#define trunc_2mpage(x)	((unsigned long)(x) & ~PDRMASK)
#define round_2mpage(x)	((((unsigned long)(x)) + PDRMASK) & ~PDRMASK)
#define trunc_1gpage(x)	((unsigned long)(x) & ~PDPMASK)

#define	atop(x)		((unsigned long)(x) >> PAGE_SHIFT)
#define	ptoa(x)		((unsigned long)(x) << PAGE_SHIFT)

#define	amd64_btop(x)	((unsigned long)(x) >> PAGE_SHIFT)
#define	amd64_ptob(x)	((unsigned long)(x) << PAGE_SHIFT)

#define	pgtok(x)	((unsigned long)(x) * (PAGE_SIZE / 1024)) 

#define	INKERNEL(va) (((va) >= DMAP_MIN_ADDRESS && (va) < DMAP_MAX_ADDRESS) \
    || ((va) >= VM_MIN_KERNEL_ADDRESS && (va) < VM_MAX_KERNEL_ADDRESS))

#endif /* !_AMD64_INCLUDE_PARAM_H_ */
# 156 "/usr/include/machine/param.h" 3 4
# 136 "/usr/include/sys/param.h" 2 3 4
#ifndef _KERNEL
#if 0 /* expanded by -frewrite-includes */
#include <sys/limits.h>
#endif /* expanded by -frewrite-includes */
# 137 "/usr/include/sys/param.h" 3 4
# 138 "/usr/include/sys/param.h" 3 4
#endif
# 139 "/usr/include/sys/param.h" 3 4

#ifndef DEV_BSHIFT
#define	DEV_BSHIFT	9		/* log2(DEV_BSIZE) */
#endif
# 143 "/usr/include/sys/param.h" 3 4
#define	DEV_BSIZE	(1<<DEV_BSHIFT)

#ifndef BLKDEV_IOSIZE
#define BLKDEV_IOSIZE  PAGE_SIZE	/* default block device I/O size */
#endif
# 148 "/usr/include/sys/param.h" 3 4
#ifndef DFLTPHYS
#define DFLTPHYS	(64 * 1024)	/* default max raw I/O transfer size */
#endif
# 151 "/usr/include/sys/param.h" 3 4
#ifndef MAXPHYS
#define MAXPHYS		(128 * 1024)	/* max raw I/O transfer size */
#endif
# 154 "/usr/include/sys/param.h" 3 4
#ifndef MAXDUMPPGS
#define MAXDUMPPGS	(DFLTPHYS/PAGE_SIZE)
#endif
# 157 "/usr/include/sys/param.h" 3 4

/*
 * Constants related to network buffer management.
 * MCLBYTES must be no larger than PAGE_SIZE.
 */
#ifndef	MSIZE
#define	MSIZE		256		/* size of an mbuf */
#endif
# 165 "/usr/include/sys/param.h" 3 4

#ifndef	MCLSHIFT
#define MCLSHIFT	11		/* convert bytes to mbuf clusters */
#endif	/* MCLSHIFT */
# 169 "/usr/include/sys/param.h" 3 4

#define MCLBYTES	(1 << MCLSHIFT)	/* size of an mbuf cluster */

#if PAGE_SIZE < 2048
#define	MJUMPAGESIZE	MCLBYTES
#elif PAGE_SIZE <= 8192
# 175 "/usr/include/sys/param.h" 3 4
#define	MJUMPAGESIZE	PAGE_SIZE
#else
# 177 "/usr/include/sys/param.h" 3 4
#define	MJUMPAGESIZE	(8 * 1024)
#endif
# 179 "/usr/include/sys/param.h" 3 4

#define	MJUM9BYTES	(9 * 1024)	/* jumbo cluster 9k */
#define	MJUM16BYTES	(16 * 1024)	/* jumbo cluster 16k */

/*
 * Some macros for units conversion
 */

/* clicks to bytes */
#ifndef ctob
#define ctob(x)	((x)<<PAGE_SHIFT)
#endif
# 191 "/usr/include/sys/param.h" 3 4

/* bytes to clicks */
#ifndef btoc
#define btoc(x)	(((vm_offset_t)(x)+PAGE_MASK)>>PAGE_SHIFT)
#endif
# 196 "/usr/include/sys/param.h" 3 4

/*
 * btodb() is messy and perhaps slow because `bytes' may be an off_t.  We
 * want to shift an unsigned type to avoid sign extension and we don't
 * want to widen `bytes' unnecessarily.  Assume that the result fits in
 * a daddr_t.
 */
#ifndef btodb
#define btodb(bytes)	 		/* calculates (bytes / DEV_BSIZE) */ \
	(sizeof (bytes) > sizeof(long) \
	 ? (daddr_t)((unsigned long long)(bytes) >> DEV_BSHIFT) \
	 : (daddr_t)((unsigned long)(bytes) >> DEV_BSHIFT))
#endif
# 209 "/usr/include/sys/param.h" 3 4

#ifndef dbtob
#define dbtob(db)			/* calculates (db * DEV_BSIZE) */ \
	((off_t)(db) << DEV_BSHIFT)
#endif
# 214 "/usr/include/sys/param.h" 3 4

#define	PRIMASK	0x0ff
#define	PCATCH	0x100		/* OR'd with pri for tsleep to check signals */
#define	PDROP	0x200	/* OR'd with pri to stop re-entry of interlock mutex */

#define	NZERO	0		/* default "nice" */

#define	NBBY	8		/* number of bits in a byte */
#define	NBPW	sizeof(int)	/* number of bytes per word (integer) */

#define	CMASK	022		/* default file mask: S_IWGRP|S_IWOTH */

#define	NODEV	(dev_t)(-1)	/* non-existent device */

/*
 * File system parameters and macros.
 *
 * MAXBSIZE -	Filesystems are made out of blocks of at most MAXBSIZE bytes
 *		per block.  MAXBSIZE may be made larger without effecting
 *		any existing filesystems as long as it does not exceed MAXPHYS,
 *		and may be made smaller at the risk of not being able to use
 *		filesystems which require a block size exceeding MAXBSIZE.
 *
 * MAXBCACHEBUF - Maximum size of a buffer in the buffer cache.  This must
 *		be >= MAXBSIZE and can be set differently for different
 *		architectures by defining it in <machine/param.h>.
 *		Making this larger allows NFS to do larger reads/writes.
 *
 * BKVASIZE -	Nominal buffer space per buffer, in bytes.  BKVASIZE is the
 *		minimum KVM memory reservation the kernel is willing to make.
 *		Filesystems can of course request smaller chunks.  Actual 
 *		backing memory uses a chunk size of a page (PAGE_SIZE).
 *		The default value here can be overridden on a per-architecture
 *		basis by defining it in <machine/param.h>.  This should
 *		probably be done to increase its value, when MAXBCACHEBUF is
 *		defined as a larger value in <machine/param.h>.
 *
 *		If you make BKVASIZE too small you risk seriously fragmenting
 *		the buffer KVM map which may slow things down a bit.  If you
 *		make it too big the kernel will not be able to optimally use 
 *		the KVM memory reserved for the buffer cache and will wind 
 *		up with too-few buffers.
 *
 *		The default is 16384, roughly 2x the block size used by a
 *		normal UFS filesystem.
 */
#define MAXBSIZE	65536	/* must be power of 2 */
#ifndef	MAXBCACHEBUF
#define	MAXBCACHEBUF	MAXBSIZE /* must be a power of 2 >= MAXBSIZE */
#endif
# 264 "/usr/include/sys/param.h" 3 4
#ifndef	BKVASIZE
#define BKVASIZE	16384	/* must be power of 2 */
#endif
# 267 "/usr/include/sys/param.h" 3 4
#define BKVAMASK	(BKVASIZE-1)

/*
 * MAXPATHLEN defines the longest permissible path length after expanding
 * symbolic links. It is used to allocate a temporary buffer from the buffer
 * pool in which to do the name expansion, hence should be a power of two,
 * and must be less than or equal to MAXBSIZE.  MAXSYMLINKS defines the
 * maximum number of symbolic links that may be expanded in a path name.
 * It should be set high enough to allow all legitimate uses, but halt
 * infinite loops reasonably quickly.
 */
#define	MAXPATHLEN	PATH_MAX
#define MAXSYMLINKS	32

/* Bit map related macros. */
#define	setbit(a,i)	(((unsigned char *)(a))[(i)/NBBY] |= 1<<((i)%NBBY))
#define	clrbit(a,i)	(((unsigned char *)(a))[(i)/NBBY] &= ~(1<<((i)%NBBY)))
#define	isset(a,i)							\
	(((const unsigned char *)(a))[(i)/NBBY] & (1<<((i)%NBBY)))
#define	isclr(a,i)							\
	((((const unsigned char *)(a))[(i)/NBBY] & (1<<((i)%NBBY))) == 0)

/* Macros for counting and rounding. */
#ifndef howmany
#define	howmany(x, y)	(((x)+((y)-1))/(y))
#endif
# 293 "/usr/include/sys/param.h" 3 4
#define	nitems(x)	(sizeof((x)) / sizeof((x)[0]))
#define	rounddown(x, y)	(((x)/(y))*(y))
#define	rounddown2(x, y) ((x)&(~((y)-1)))          /* if y is power of two */
#define	roundup(x, y)	((((x)+((y)-1))/(y))*(y))  /* to any y */
#define	roundup2(x, y)	(((x)+((y)-1))&(~((y)-1))) /* if y is powers of two */
#define powerof2(x)	((((x)-1)&(x))==0)

/* Macros for min/max. */
#define	MIN(a,b) (((a)<(b))?(a):(b))
#define	MAX(a,b) (((a)>(b))?(a):(b))

#ifdef _KERNEL
/*
 * Basic byte order function prototypes for non-inline functions.
 */
#ifndef LOCORE
#ifndef _BYTEORDER_PROTOTYPED
#define	_BYTEORDER_PROTOTYPED
__BEGIN_DECLS
__uint32_t	 htonl(__uint32_t);
__uint16_t	 htons(__uint16_t);
__uint32_t	 ntohl(__uint32_t);
__uint16_t	 ntohs(__uint16_t);
__END_DECLS
#endif
# 318 "/usr/include/sys/param.h" 3 4
#endif
# 319 "/usr/include/sys/param.h" 3 4

#ifndef lint
#ifndef _BYTEORDER_FUNC_DEFINED
#define	_BYTEORDER_FUNC_DEFINED
#define	htonl(x)	__htonl(x)
#define	htons(x)	__htons(x)
#define	ntohl(x)	__ntohl(x)
#define	ntohs(x)	__ntohs(x)
#endif /* !_BYTEORDER_FUNC_DEFINED */
# 328 "/usr/include/sys/param.h" 3 4
#endif /* lint */
# 329 "/usr/include/sys/param.h" 3 4
#endif /* _KERNEL */
# 330 "/usr/include/sys/param.h" 3 4

/*
 * Scale factor for scaled integers used to count %cpu time and load avgs.
 *
 * The number of CPU `tick's that map to a unique `%age' can be expressed
 * by the formula (1 / (2 ^ (FSHIFT - 11))).  The maximum load average that
 * can be calculated (assuming 32 bits) can be closely approximated using
 * the formula (2 ^ (2 * (16 - FSHIFT))) for (FSHIFT < 15).
 *
 * For the scheduler to maintain a 1:1 mapping of CPU `tick' to `%age',
 * FSHIFT must be at least 11; this gives us a maximum load avg of ~1024.
 */
#define	FSHIFT	11		/* bits to right of fixed binary point */
#define FSCALE	(1<<FSHIFT)

#define dbtoc(db)			/* calculates devblks to pages */ \
	((db + (ctodb(1) - 1)) >> (PAGE_SHIFT - DEV_BSHIFT))
 
#define ctodb(db)			/* calculates pages to devblks */ \
	((db) << (PAGE_SHIFT - DEV_BSHIFT))

/*
 * Old spelling of __containerof().
 */
#define	member2struct(s, m, x)						\
	((struct s *)(void *)((char *)(x) - offsetof(struct s, m)))

/*
 * Access a variable length array that has been declared as a fixed
 * length array.
 */
#define __PAST_END(array, offset) (((__typeof__(*(array)) *)(array))[offset])

#endif	/* _SYS_PARAM_H_ */
# 364 "/usr/include/sys/param.h" 3 4
# 55 "include/libbb.h" 2
#ifndef HAVE_XTABS
# define XTABS OXTABS
#endif
# 58 "include/libbb.h"
#if 0 /* expanded by -frewrite-includes */
#include <pwd.h>
#endif /* expanded by -frewrite-includes */
# 58 "include/libbb.h"
# 1 "/usr/include/pwd.h" 1 3 4
/*-
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)pwd.h	8.2 (Berkeley) 1/21/94
 * $FreeBSD: releng/11.0/include/pwd.h 241731 2012-10-19 12:44:22Z brooks $
 */

#ifndef _PWD_H_
#define	_PWD_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 41 "/usr/include/pwd.h" 3 4
# 42 "/usr/include/pwd.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 42 "/usr/include/pwd.h" 3 4
# 43 "/usr/include/pwd.h" 3 4

#ifndef _GID_T_DECLARED
typedef	__gid_t		gid_t;
#define	_GID_T_DECLARED
#endif
# 48 "/usr/include/pwd.h" 3 4

#ifndef _TIME_T_DECLARED
typedef	__time_t	time_t;
#define	_TIME_T_DECLARED
#endif
# 53 "/usr/include/pwd.h" 3 4

#ifndef _UID_T_DECLARED
typedef	__uid_t		uid_t;
#define	_UID_T_DECLARED
#endif
# 58 "/usr/include/pwd.h" 3 4

#ifndef _SIZE_T_DECLARED
typedef __size_t	size_t;
#define _SIZE_T_DECLARED
#endif
# 63 "/usr/include/pwd.h" 3 4

#define _PATH_PWD		"/etc"
#define	_PATH_PASSWD		"/etc/passwd"
#define	_PASSWD			"passwd"
#define	_PATH_MASTERPASSWD	"/etc/master.passwd"
#define	_MASTERPASSWD		"master.passwd"

#define	_PATH_MP_DB		"/etc/pwd.db"
#define	_MP_DB			"pwd.db"
#define	_PATH_SMP_DB		"/etc/spwd.db"
#define	_SMP_DB			"spwd.db"

#define	_PATH_PWD_MKDB		"/usr/sbin/pwd_mkdb"

/* Historically, the keys in _PATH_MP_DB/_PATH_SMP_DB had the format
 * `1 octet tag | key', where the tag is one of the _PW_KEY* values
 * listed below.  These values happen to be ASCII digits.  Starting
 * with FreeBSD 5.1, the tag is now still a single octet, but the
 * upper 4 bits are interpreted as a version.  Pre-FreeBSD 5.1 format
 * entries are version `3' -- this conveniently results in the same
 * key values as before.  The new, architecture-independent entries
 * are version `4'.
 * As it happens, some applications read the database directly.
 * (Bad app, no cookie!)  Thus, we leave the _PW_KEY* symbols at their
 * old pre-FreeBSD 5.1 values so these apps still work.  Consequently
 * we have to muck around a bit more to get the correct, versioned
 * tag, and that is what the _PW_VERSIONED macro is about.
 */

#define _PW_VERSION_MASK	'\xF0'
#define _PW_VERSIONED(x, v)	((unsigned char)(((x) & 0xCF) | ((v)<<4)))

#define	_PW_KEYBYNAME		'\x31'	/* stored by name */
#define	_PW_KEYBYNUM		'\x32'	/* stored by entry in the "file" */
#define	_PW_KEYBYUID		'\x33'	/* stored by uid */
#define _PW_KEYYPENABLED	'\x34'	/* YP is enabled */
#define	_PW_KEYYPBYNUM		'\x35'	/* special +@netgroup entries */

/* The database also contains a key to indicate the format version of
 * the entries therein.  There may be other, older versioned entries
 * as well.
 */
#define _PWD_VERSION_KEY	"\xFF" "VERSION"
#define _PWD_CURRENT_VERSION	'\x04'

#define	_PASSWORD_EFMT1		'_'	/* extended encryption format */

#define	_PASSWORD_LEN		128	/* max length, not counting NULL */

struct passwd {
	char	*pw_name;		/* user name */
	char	*pw_passwd;		/* encrypted password */
	uid_t	pw_uid;			/* user uid */
	gid_t	pw_gid;			/* user gid */
	time_t	pw_change;		/* password change time */
	char	*pw_class;		/* user access class */
	char	*pw_gecos;		/* Honeywell login info */
	char	*pw_dir;		/* home directory */
	char	*pw_shell;		/* default shell */
	time_t	pw_expire;		/* account expiration */
	int	pw_fields;		/* internal: fields filled in */
};

/* Mapping from fields to bits for pw_fields. */
#define _PWF(x)		(1 << x)
#define _PWF_NAME	_PWF(0)
#define _PWF_PASSWD	_PWF(1)
#define _PWF_UID	_PWF(2)
#define _PWF_GID	_PWF(3)
#define _PWF_CHANGE	_PWF(4)
#define _PWF_CLASS	_PWF(5)
#define _PWF_GECOS	_PWF(6)
#define _PWF_DIR	_PWF(7)
#define _PWF_SHELL	_PWF(8)
#define _PWF_EXPIRE	_PWF(9)

/* XXX These flags are bogus.  With nsswitch, there are many
 * possible sources and they cannot be represented in a small integer.
 */                           
#define _PWF_SOURCE	0x3000
#define _PWF_FILES	0x1000
#define _PWF_NIS	0x2000
#define _PWF_HESIOD	0x3000

__BEGIN_DECLS
struct passwd	*getpwnam(const char *);
struct passwd	*getpwuid(uid_t);

#if __XSI_VISIBLE >= 500
void		 endpwent(void);
struct passwd	*getpwent(void);
void		 setpwent(void);
#endif
# 156 "/usr/include/pwd.h" 3 4

#if __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE >= 500
int		 getpwnam_r(const char *, struct passwd *, char *, size_t,
		    struct passwd **);
int		 getpwuid_r(uid_t, struct passwd *, char *, size_t,
		    struct passwd **);
#endif
# 163 "/usr/include/pwd.h" 3 4

#if __BSD_VISIBLE
int		 getpwent_r(struct passwd *, char *, size_t, struct passwd **);
int		 setpassent(int);
const char	*user_from_uid(uid_t, int);
int		 uid_from_user(const char *, uid_t *);
int		 pwcache_userdb(int (*)(int), void (*)(void),
		    struct passwd * (*)(const char *),
		    struct passwd * (*)(uid_t));
#endif
# 173 "/usr/include/pwd.h" 3 4
__END_DECLS

#endif /* !_PWD_H_ */
# 176 "/usr/include/pwd.h" 3 4
# 59 "include/libbb.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <grp.h>
#endif /* expanded by -frewrite-includes */
# 59 "include/libbb.h"
# 1 "/usr/include/grp.h" 1 3 4
/*-
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)grp.h	8.2 (Berkeley) 1/21/94
 * $FreeBSD: releng/11.0/include/grp.h 265878 2014-05-11 13:48:21Z jilles $
 */

#ifndef _GRP_H_
#define	_GRP_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 41 "/usr/include/grp.h" 3 4
# 42 "/usr/include/grp.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 42 "/usr/include/grp.h" 3 4
# 43 "/usr/include/grp.h" 3 4

#define	_PATH_GROUP		"/etc/group"

#ifndef _GID_T_DECLARED
typedef	__gid_t		gid_t;
#define	_GID_T_DECLARED
#endif
# 50 "/usr/include/grp.h" 3 4

#ifndef _SIZE_T_DECLARED
typedef __size_t	size_t;
#define _SIZE_T_DECLARED
#endif
# 55 "/usr/include/grp.h" 3 4

struct group {
	char	*gr_name;		/* group name */
	char	*gr_passwd;		/* group password */
	gid_t	gr_gid;			/* group id */
	char	**gr_mem;		/* group members */
};

__BEGIN_DECLS
#if __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE
void		 endgrent(void);
struct group	*getgrent(void);
#endif
# 68 "/usr/include/grp.h" 3 4
struct group	*getgrgid(gid_t);
struct group	*getgrnam(const char *);
#if __BSD_VISIBLE
const char	*group_from_gid(gid_t, int);
int		 gid_from_group(const char *, gid_t *);
int		 pwcache_groupdb(int (*)(int), void (*)(void),
		    struct group * (*)(const char *),
		    struct group * (*)(gid_t));
#endif
# 77 "/usr/include/grp.h" 3 4
#if __XSI_VISIBLE
/* XXX IEEE Std 1003.1, 2003 specifies `void setgrent(void)' */
int		 setgrent(void);
#endif
# 81 "/usr/include/grp.h" 3 4
#if __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE
int		 getgrgid_r(gid_t, struct group *, char *, size_t,
		    struct group **);
int		 getgrnam_r(const char *, struct group *, char *, size_t,
		    struct group **);
#endif
# 87 "/usr/include/grp.h" 3 4
#if __BSD_VISIBLE
int		 getgrent_r(struct group *, char *, size_t, struct group **);
int		 setgroupent(int);
#endif
# 91 "/usr/include/grp.h" 3 4
__END_DECLS

#endif /* !_GRP_H_ */
# 94 "/usr/include/grp.h" 3 4
# 60 "include/libbb.h" 2
#if ENABLE_FEATURE_SHADOWPASSWDS
# if !ENABLE_USE_BB_SHADOW
/* If using busybox's shadow implementation, do not include the shadow.h
 * header as the toolchain may not provide it at all.
 */
#if 0 /* expanded by -frewrite-includes */
#  include <shadow.h>
#endif /* expanded by -frewrite-includes */
# 65 "include/libbb.h"
# 66 "include/libbb.h"
# endif
# 67 "include/libbb.h"
#endif
# 68 "include/libbb.h"
#if defined(ANDROID) || defined(__ANDROID__)
# define endpwent() ((void)0)
# define endgrent() ((void)0)
#endif
# 72 "include/libbb.h"
#ifdef HAVE_MNTENT_H
#if 0 /* expanded by -frewrite-includes */
# include <mntent.h>
#endif /* expanded by -frewrite-includes */
# 73 "include/libbb.h"
# 74 "include/libbb.h"
#endif
# 75 "include/libbb.h"
#ifdef HAVE_SYS_STATFS_H
#if 0 /* expanded by -frewrite-includes */
# include <sys/statfs.h>
#endif /* expanded by -frewrite-includes */
# 76 "include/libbb.h"
# 77 "include/libbb.h"
#endif
# 78 "include/libbb.h"
/* Don't do this here:
 * #include <sys/sysinfo.h>
 * Some linux/ includes pull in conflicting definition
 * of struct sysinfo (only in some toolchanins), which breaks build.
 * Include sys/sysinfo.h only in those files which need it.
 */
#if ENABLE_SELINUX
#if 0 /* expanded by -frewrite-includes */
# include <selinux/selinux.h>
#endif /* expanded by -frewrite-includes */
# 85 "include/libbb.h"
# 86 "include/libbb.h"
#if 0 /* expanded by -frewrite-includes */
# include <selinux/context.h>
#endif /* expanded by -frewrite-includes */
# 86 "include/libbb.h"
# 87 "include/libbb.h"
#endif
# 88 "include/libbb.h"
#if ENABLE_FEATURE_UTMP
# if defined __UCLIBC__ && ( \
    (UCLIBC_VERSION >= KERNEL_VERSION(0, 9, 32) \
     && UCLIBC_VERSION < KERNEL_VERSION(0, 9, 34) \
     && defined __UCLIBC_HAS_UTMPX__ \
    ) || ( \
	 UCLIBC_VERSION >= KERNEL_VERSION(0, 9, 34) \
	) \
  )
#if 0 /* expanded by -frewrite-includes */
#  include <utmpx.h>
#endif /* expanded by -frewrite-includes */
# 97 "include/libbb.h"
# 98 "include/libbb.h"
# elif defined __UCLIBC__
# 99 "include/libbb.h"
#if 0 /* expanded by -frewrite-includes */
#  include <utmp.h>
#endif /* expanded by -frewrite-includes */
# 99 "include/libbb.h"
# 100 "include/libbb.h"
#  define utmpx utmp
#  define setutxent setutent
#  define endutxent endutent
#  define getutxent getutent
#  define getutxid getutid
#  define getutxline getutline
#  define pututxline pututline
#  define utmpxname utmpname
#  define updwtmpx updwtmp
#  define _PATH_UTMPX _PATH_UTMP
# else
# 111 "include/libbb.h"
#if 0 /* expanded by -frewrite-includes */
#  include <utmp.h>
#endif /* expanded by -frewrite-includes */
# 111 "include/libbb.h"
# 112 "include/libbb.h"
#if 0 /* expanded by -frewrite-includes */
#  include <utmpx.h>
#endif /* expanded by -frewrite-includes */
# 112 "include/libbb.h"
# 113 "include/libbb.h"
#  if defined _PATH_UTMP && !defined _PATH_UTMPX
#   define _PATH_UTMPX _PATH_UTMP
#  endif
# 116 "include/libbb.h"
# endif
# 117 "include/libbb.h"
#endif
# 118 "include/libbb.h"
#if ENABLE_LOCALE_SUPPORT
#if 0 /* expanded by -frewrite-includes */
# include <locale.h>
#endif /* expanded by -frewrite-includes */
# 119 "include/libbb.h"
# 1 "/usr/include/locale.h" 1 3 4
/*
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)locale.h	8.1 (Berkeley) 6/2/93
 * $FreeBSD: releng/11.0/include/locale.h 232498 2012-03-04 15:31:13Z theraven $
 */

#ifndef _LOCALE_H_
#define _LOCALE_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/_null.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/locale.h" 3 4
# 37 "/usr/include/locale.h" 3 4

struct lconv {
	char	*decimal_point;
	char	*thousands_sep;
	char	*grouping;
	char	*int_curr_symbol;
	char	*currency_symbol;
	char	*mon_decimal_point;
	char	*mon_thousands_sep;
	char	*mon_grouping;
	char	*positive_sign;
	char	*negative_sign;
	char	int_frac_digits;
	char	frac_digits;
	char	p_cs_precedes;
	char	p_sep_by_space;
	char	n_cs_precedes;
	char	n_sep_by_space;
	char	p_sign_posn;
	char	n_sign_posn;
	char	int_p_cs_precedes;
	char	int_n_cs_precedes;
	char	int_p_sep_by_space;
	char	int_n_sep_by_space;
	char	int_p_sign_posn;
	char	int_n_sign_posn;
};

#define	LC_ALL		0
#define	LC_COLLATE	1
#define	LC_CTYPE	2
#define	LC_MONETARY	3
#define	LC_NUMERIC	4
#define	LC_TIME		5
#define	LC_MESSAGES	6

#define	_LC_LAST	7		/* marks end */

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 75 "/usr/include/locale.h" 3 4
# 76 "/usr/include/locale.h" 3 4

__BEGIN_DECLS
struct lconv	*localeconv(void);
char		*setlocale(int, const char *);

#if __POSIX_VISIBLE >= 200809
#if 0 /* expanded by -frewrite-includes */
#include <xlocale/_locale.h>
#endif /* expanded by -frewrite-includes */
# 82 "/usr/include/locale.h" 3 4
# 1 "/usr/include/xlocale/_locale.h" 1 3 4
/*-
 * Copyright (c) 2011, 2012 The FreeBSD Foundation
 * All rights reserved.
 *
 * This software was developed by David Chisnall under sponsorship from
 * the FreeBSD Foundation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: releng/11.0/include/xlocale/_locale.h 231673 2012-02-14 12:03:23Z theraven $
 */

#ifndef _XLOCALE_LOCALE_H
#define _XLOCALE_LOCALE_H

#define LC_COLLATE_MASK  (1<<0)
#define LC_CTYPE_MASK    (1<<1)
#define LC_MESSAGES_MASK (1<<2)
#define LC_MONETARY_MASK (1<<3)
#define LC_NUMERIC_MASK  (1<<4)
#define LC_TIME_MASK     (1<<5)
#define LC_ALL_MASK      (LC_COLLATE_MASK | LC_CTYPE_MASK | LC_MESSAGES_MASK | \
			  LC_MONETARY_MASK | LC_NUMERIC_MASK | LC_TIME_MASK)
#define LC_GLOBAL_LOCALE ((locale_t)-1)

#ifndef _LOCALE_T_DEFINED
#define _LOCALE_T_DEFINED
typedef struct	_xlocale *locale_t;
#endif
# 49 "/usr/include/xlocale/_locale.h" 3 4

locale_t	 duplocale(locale_t base);
int		 freelocale(locale_t loc);
locale_t	 newlocale(int mask, const char *locale, locale_t base);
const char	*querylocale(int mask, locale_t loc);
locale_t	 uselocale(locale_t loc);

#endif /* _XLOCALE_LOCALE_H */
# 57 "/usr/include/xlocale/_locale.h" 3 4
# 83 "/usr/include/locale.h" 2 3 4
#endif
# 84 "/usr/include/locale.h" 3 4
__END_DECLS


#endif /* _LOCALE_H_ */
# 88 "/usr/include/locale.h" 3 4
# 120 "include/libbb.h" 2
#else
# 121 "include/libbb.h"
# define setlocale(x,y) ((void)0)
#endif
# 123 "include/libbb.h"
#ifdef DMALLOC
#if 0 /* expanded by -frewrite-includes */
# include <dmalloc.h>
#endif /* expanded by -frewrite-includes */
# 124 "include/libbb.h"
# 125 "include/libbb.h"
#endif
# 126 "include/libbb.h"
/* Just in case libc doesn't define some of these... */
#ifndef _PATH_PASSWD
#define _PATH_PASSWD  "/etc/passwd"
#endif
# 130 "include/libbb.h"
#ifndef _PATH_GROUP
#define _PATH_GROUP   "/etc/group"
#endif
# 133 "include/libbb.h"
#ifndef _PATH_SHADOW
#define _PATH_SHADOW  "/etc/shadow"
#endif
# 136 "include/libbb.h"
#ifndef _PATH_GSHADOW
#define _PATH_GSHADOW "/etc/gshadow"
#endif
# 139 "include/libbb.h"
#if defined __FreeBSD__ || defined __OpenBSD__
#if 0 /* expanded by -frewrite-includes */
# include <netinet/in.h>
#endif /* expanded by -frewrite-includes */
# 140 "include/libbb.h"
# 1 "/usr/include/netinet/in.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)in.h	8.3 (Berkeley) 1/3/94
 * $FreeBSD: releng/11.0/sys/netinet/in.h 281649 2015-04-17 11:57:06Z glebius $
 */

#ifndef _NETINET_IN_H_
#define	_NETINET_IN_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/netinet/in.h" 3 4
# 37 "/usr/include/netinet/in.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 37 "/usr/include/netinet/in.h" 3 4
# 38 "/usr/include/netinet/in.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <machine/endian.h>
#endif /* expanded by -frewrite-includes */
# 38 "/usr/include/netinet/in.h" 3 4
# 1 "/usr/include/machine/endian.h" 1 3 4
/*-
 * This file is in the public domain.
 */
/* $FreeBSD: releng/11.0/sys/amd64/include/endian.h 232266 2012-02-28 19:39:54Z tijl $ */

#if 0 /* expanded by -frewrite-includes */
#include <x86/endian.h>
#endif /* expanded by -frewrite-includes */
# 6 "/usr/include/machine/endian.h" 3 4
# 7 "/usr/include/machine/endian.h" 3 4
# 39 "/usr/include/netinet/in.h" 2 3 4

/* Protocols common to RFC 1700, POSIX, and X/Open. */
#define	IPPROTO_IP		0		/* dummy for IP */
#define	IPPROTO_ICMP		1		/* control message protocol */
#define	IPPROTO_TCP		6		/* tcp */
#define	IPPROTO_UDP		17		/* user datagram protocol */

#define	INADDR_ANY		((in_addr_t)0x00000000)
#define	INADDR_BROADCAST	((in_addr_t)0xffffffff)	/* must be masked */

#ifndef _UINT8_T_DECLARED
typedef	__uint8_t		uint8_t;
#define	_UINT8_T_DECLARED
#endif
# 53 "/usr/include/netinet/in.h" 3 4

#ifndef _UINT16_T_DECLARED
typedef	__uint16_t		uint16_t;
#define	_UINT16_T_DECLARED
#endif
# 58 "/usr/include/netinet/in.h" 3 4

#ifndef _UINT32_T_DECLARED
typedef	__uint32_t		uint32_t;
#define	_UINT32_T_DECLARED
#endif
# 63 "/usr/include/netinet/in.h" 3 4

#ifndef _IN_ADDR_T_DECLARED
typedef	uint32_t		in_addr_t;
#define	_IN_ADDR_T_DECLARED
#endif
# 68 "/usr/include/netinet/in.h" 3 4

#ifndef _IN_PORT_T_DECLARED
typedef	uint16_t		in_port_t;
#define	_IN_PORT_T_DECLARED
#endif
# 73 "/usr/include/netinet/in.h" 3 4

#ifndef _SA_FAMILY_T_DECLARED
typedef	__sa_family_t		sa_family_t;
#define	_SA_FAMILY_T_DECLARED
#endif
# 78 "/usr/include/netinet/in.h" 3 4

/* Internet address (a structure for historical reasons). */
#ifndef	_STRUCT_IN_ADDR_DECLARED
struct in_addr {
	in_addr_t s_addr;
};
#define	_STRUCT_IN_ADDR_DECLARED
#endif
# 86 "/usr/include/netinet/in.h" 3 4

#ifndef	_SOCKLEN_T_DECLARED
typedef	__socklen_t	socklen_t;
#define	_SOCKLEN_T_DECLARED
#endif
# 91 "/usr/include/netinet/in.h" 3 4

#if 0 /* expanded by -frewrite-includes */
#include <sys/_sockaddr_storage.h>
#endif /* expanded by -frewrite-includes */
# 92 "/usr/include/netinet/in.h" 3 4
# 93 "/usr/include/netinet/in.h" 3 4

/* Socket address, internet style. */
struct sockaddr_in {
	uint8_t	sin_len;
	sa_family_t	sin_family;
	in_port_t	sin_port;
	struct	in_addr sin_addr;
	char	sin_zero[8];
};

#if !defined(_KERNEL) && __POSIX_VISIBLE >= 200112

#ifndef _BYTEORDER_PROTOTYPED
#define	_BYTEORDER_PROTOTYPED
__BEGIN_DECLS
uint32_t	htonl(uint32_t);
uint16_t	htons(uint16_t);
uint32_t	ntohl(uint32_t);
uint16_t	ntohs(uint16_t);
__END_DECLS
#endif
# 114 "/usr/include/netinet/in.h" 3 4

#ifndef _BYTEORDER_FUNC_DEFINED
#define	_BYTEORDER_FUNC_DEFINED
#define	htonl(x)	__htonl(x)
#define	htons(x)	__htons(x)
#define	ntohl(x)	__ntohl(x)
#define	ntohs(x)	__ntohs(x)
#endif
# 122 "/usr/include/netinet/in.h" 3 4

#endif /* !_KERNEL && __POSIX_VISIBLE >= 200112 */
# 124 "/usr/include/netinet/in.h" 3 4

#if __POSIX_VISIBLE >= 200112
#define	IPPROTO_IPV6		41		/* IP6 header */
#define	IPPROTO_RAW		255		/* raw IP packet */
#define	INET_ADDRSTRLEN		16
#endif
# 130 "/usr/include/netinet/in.h" 3 4

#if __BSD_VISIBLE
/*
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981, and numerous additions.
 */

/*
 * Protocols (RFC 1700)
 */
#define	IPPROTO_HOPOPTS		0		/* IP6 hop-by-hop options */
#define	IPPROTO_IGMP		2		/* group mgmt protocol */
#define	IPPROTO_GGP		3		/* gateway^2 (deprecated) */
#define	IPPROTO_IPV4		4		/* IPv4 encapsulation */
#define	IPPROTO_IPIP		IPPROTO_IPV4	/* for compatibility */
#define	IPPROTO_ST		7		/* Stream protocol II */
#define	IPPROTO_EGP		8		/* exterior gateway protocol */
#define	IPPROTO_PIGP		9		/* private interior gateway */
#define	IPPROTO_RCCMON		10		/* BBN RCC Monitoring */
#define	IPPROTO_NVPII		11		/* network voice protocol*/
#define	IPPROTO_PUP		12		/* pup */
#define	IPPROTO_ARGUS		13		/* Argus */
#define	IPPROTO_EMCON		14		/* EMCON */
#define	IPPROTO_XNET		15		/* Cross Net Debugger */
#define	IPPROTO_CHAOS		16		/* Chaos*/
#define	IPPROTO_MUX		18		/* Multiplexing */
#define	IPPROTO_MEAS		19		/* DCN Measurement Subsystems */
#define	IPPROTO_HMP		20		/* Host Monitoring */
#define	IPPROTO_PRM		21		/* Packet Radio Measurement */
#define	IPPROTO_IDP		22		/* xns idp */
#define	IPPROTO_TRUNK1		23		/* Trunk-1 */
#define	IPPROTO_TRUNK2		24		/* Trunk-2 */
#define	IPPROTO_LEAF1		25		/* Leaf-1 */
#define	IPPROTO_LEAF2		26		/* Leaf-2 */
#define	IPPROTO_RDP		27		/* Reliable Data */
#define	IPPROTO_IRTP		28		/* Reliable Transaction */
#define	IPPROTO_TP		29		/* tp-4 w/ class negotiation */
#define	IPPROTO_BLT		30		/* Bulk Data Transfer */
#define	IPPROTO_NSP		31		/* Network Services */
#define	IPPROTO_INP		32		/* Merit Internodal */
#define	IPPROTO_SEP		33		/* Sequential Exchange */
#define	IPPROTO_3PC		34		/* Third Party Connect */
#define	IPPROTO_IDPR		35		/* InterDomain Policy Routing */
#define	IPPROTO_XTP		36		/* XTP */
#define	IPPROTO_DDP		37		/* Datagram Delivery */
#define	IPPROTO_CMTP		38		/* Control Message Transport */
#define	IPPROTO_TPXX		39		/* TP++ Transport */
#define	IPPROTO_IL		40		/* IL transport protocol */
#define	IPPROTO_SDRP		42		/* Source Demand Routing */
#define	IPPROTO_ROUTING		43		/* IP6 routing header */
#define	IPPROTO_FRAGMENT	44		/* IP6 fragmentation header */
#define	IPPROTO_IDRP		45		/* InterDomain Routing*/
#define	IPPROTO_RSVP		46		/* resource reservation */
#define	IPPROTO_GRE		47		/* General Routing Encap. */
#define	IPPROTO_MHRP		48		/* Mobile Host Routing */
#define	IPPROTO_BHA		49		/* BHA */
#define	IPPROTO_ESP		50		/* IP6 Encap Sec. Payload */
#define	IPPROTO_AH		51		/* IP6 Auth Header */
#define	IPPROTO_INLSP		52		/* Integ. Net Layer Security */
#define	IPPROTO_SWIPE		53		/* IP with encryption */
#define	IPPROTO_NHRP		54		/* Next Hop Resolution */
#define	IPPROTO_MOBILE		55		/* IP Mobility */
#define	IPPROTO_TLSP		56		/* Transport Layer Security */
#define	IPPROTO_SKIP		57		/* SKIP */
#define	IPPROTO_ICMPV6		58		/* ICMP6 */
#define	IPPROTO_NONE		59		/* IP6 no next header */
#define	IPPROTO_DSTOPTS		60		/* IP6 destination option */
#define	IPPROTO_AHIP		61		/* any host internal protocol */
#define	IPPROTO_CFTP		62		/* CFTP */
#define	IPPROTO_HELLO		63		/* "hello" routing protocol */
#define	IPPROTO_SATEXPAK	64		/* SATNET/Backroom EXPAK */
#define	IPPROTO_KRYPTOLAN	65		/* Kryptolan */
#define	IPPROTO_RVD		66		/* Remote Virtual Disk */
#define	IPPROTO_IPPC		67		/* Pluribus Packet Core */
#define	IPPROTO_ADFS		68		/* Any distributed FS */
#define	IPPROTO_SATMON		69		/* Satnet Monitoring */
#define	IPPROTO_VISA		70		/* VISA Protocol */
#define	IPPROTO_IPCV		71		/* Packet Core Utility */
#define	IPPROTO_CPNX		72		/* Comp. Prot. Net. Executive */
#define	IPPROTO_CPHB		73		/* Comp. Prot. HeartBeat */
#define	IPPROTO_WSN		74		/* Wang Span Network */
#define	IPPROTO_PVP		75		/* Packet Video Protocol */
#define	IPPROTO_BRSATMON	76		/* BackRoom SATNET Monitoring */
#define	IPPROTO_ND		77		/* Sun net disk proto (temp.) */
#define	IPPROTO_WBMON		78		/* WIDEBAND Monitoring */
#define	IPPROTO_WBEXPAK		79		/* WIDEBAND EXPAK */
#define	IPPROTO_EON		80		/* ISO cnlp */
#define	IPPROTO_VMTP		81		/* VMTP */
#define	IPPROTO_SVMTP		82		/* Secure VMTP */
#define	IPPROTO_VINES		83		/* Banyon VINES */
#define	IPPROTO_TTP		84		/* TTP */
#define	IPPROTO_IGP		85		/* NSFNET-IGP */
#define	IPPROTO_DGP		86		/* dissimilar gateway prot. */
#define	IPPROTO_TCF		87		/* TCF */
#define	IPPROTO_IGRP		88		/* Cisco/GXS IGRP */
#define	IPPROTO_OSPFIGP		89		/* OSPFIGP */
#define	IPPROTO_SRPC		90		/* Strite RPC protocol */
#define	IPPROTO_LARP		91		/* Locus Address Resoloution */
#define	IPPROTO_MTP		92		/* Multicast Transport */
#define	IPPROTO_AX25		93		/* AX.25 Frames */
#define	IPPROTO_IPEIP		94		/* IP encapsulated in IP */
#define	IPPROTO_MICP		95		/* Mobile Int.ing control */
#define	IPPROTO_SCCSP		96		/* Semaphore Comm. security */
#define	IPPROTO_ETHERIP		97		/* Ethernet IP encapsulation */
#define	IPPROTO_ENCAP		98		/* encapsulation header */
#define	IPPROTO_APES		99		/* any private encr. scheme */
#define	IPPROTO_GMTP		100		/* GMTP*/
#define	IPPROTO_IPCOMP		108		/* payload compression (IPComp) */
#define	IPPROTO_SCTP		132		/* SCTP */
#define	IPPROTO_MH		135		/* IPv6 Mobility Header */
#define	IPPROTO_UDPLITE		136		/* UDP-Lite */
#define	IPPROTO_HIP		139		/* IP6 Host Identity Protocol */
#define	IPPROTO_SHIM6		140		/* IP6 Shim6 Protocol */
/* 101-254: Partly Unassigned */
#define	IPPROTO_PIM		103		/* Protocol Independent Mcast */
#define	IPPROTO_CARP		112		/* CARP */
#define	IPPROTO_PGM		113		/* PGM */
#define	IPPROTO_MPLS		137		/* MPLS-in-IP */
#define	IPPROTO_PFSYNC		240		/* PFSYNC */
#define	IPPROTO_RESERVED_253	253		/* Reserved */
#define	IPPROTO_RESERVED_254	254		/* Reserved */
/* 255: Reserved */
/* BSD Private, local use, namespace incursion, no longer used */
#define	IPPROTO_OLD_DIVERT	254		/* OLD divert pseudo-proto */
#define	IPPROTO_MAX		256

/* last return value of *_input(), meaning "all job for this pkt is done".  */
#define	IPPROTO_DONE		257

/* Only used internally, so can be outside the range of valid IP protocols. */
#define	IPPROTO_DIVERT		258		/* divert pseudo-protocol */
#define	IPPROTO_SEND		259		/* SeND pseudo-protocol */

/*
 * Defined to avoid confusion.  The master value is defined by
 * PROTO_SPACER in sys/protosw.h.
 */
#define	IPPROTO_SPACER		32767		/* spacer for loadable protos */

/*
 * Local port number conventions:
 *
 * When a user does a bind(2) or connect(2) with a port number of zero,
 * a non-conflicting local port address is chosen.
 * The default range is IPPORT_HIFIRSTAUTO through
 * IPPORT_HILASTAUTO, although that is settable by sysctl.
 *
 * A user may set the IPPROTO_IP option IP_PORTRANGE to change this
 * default assignment range.
 *
 * The value IP_PORTRANGE_DEFAULT causes the default behavior.
 *
 * The value IP_PORTRANGE_HIGH changes the range of candidate port numbers
 * into the "high" range.  These are reserved for client outbound connections
 * which do not want to be filtered by any firewalls.
 *
 * The value IP_PORTRANGE_LOW changes the range to the "low" are
 * that is (by convention) restricted to privileged processes.  This
 * convention is based on "vouchsafe" principles only.  It is only secure
 * if you trust the remote host to restrict these ports.
 *
 * The default range of ports and the high range can be changed by
 * sysctl(3).  (net.inet.ip.port{hi,low}{first,last}_auto)
 *
 * Changing those values has bad security implications if you are
 * using a stateless firewall that is allowing packets outside of that
 * range in order to allow transparent outgoing connections.
 *
 * Such a firewall configuration will generally depend on the use of these
 * default values.  If you change them, you may find your Security
 * Administrator looking for you with a heavy object.
 *
 * For a slightly more orthodox text view on this:
 *
 *            ftp://ftp.isi.edu/in-notes/iana/assignments/port-numbers
 *
 *    port numbers are divided into three ranges:
 *
 *                0 -  1023 Well Known Ports
 *             1024 - 49151 Registered Ports
 *            49152 - 65535 Dynamic and/or Private Ports
 *
 */

/*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).         (IP_PORTRANGE_LOW)
 */
#define	IPPORT_RESERVED		1024

/*
 * Default local port range, used by IP_PORTRANGE_DEFAULT
 */
#define IPPORT_EPHEMERALFIRST	10000
#define IPPORT_EPHEMERALLAST	65535 
 
/*
 * Dynamic port range, used by IP_PORTRANGE_HIGH.
 */
#define	IPPORT_HIFIRSTAUTO	49152
#define	IPPORT_HILASTAUTO	65535

/*
 * Scanning for a free reserved port return a value below IPPORT_RESERVED,
 * but higher than IPPORT_RESERVEDSTART.  Traditionally the start value was
 * 512, but that conflicts with some well-known-services that firewalls may
 * have a fit if we use.
 */
#define	IPPORT_RESERVEDSTART	600

#define	IPPORT_MAX		65535

/*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 */
#define	IN_CLASSA(i)		(((in_addr_t)(i) & 0x80000000) == 0)
#define	IN_CLASSA_NET		0xff000000
#define	IN_CLASSA_NSHIFT	24
#define	IN_CLASSA_HOST		0x00ffffff
#define	IN_CLASSA_MAX		128

#define	IN_CLASSB(i)		(((in_addr_t)(i) & 0xc0000000) == 0x80000000)
#define	IN_CLASSB_NET		0xffff0000
#define	IN_CLASSB_NSHIFT	16
#define	IN_CLASSB_HOST		0x0000ffff
#define	IN_CLASSB_MAX		65536

#define	IN_CLASSC(i)		(((in_addr_t)(i) & 0xe0000000) == 0xc0000000)
#define	IN_CLASSC_NET		0xffffff00
#define	IN_CLASSC_NSHIFT	8
#define	IN_CLASSC_HOST		0x000000ff

#define	IN_CLASSD(i)		(((in_addr_t)(i) & 0xf0000000) == 0xe0000000)
#define	IN_CLASSD_NET		0xf0000000	/* These ones aren't really */
#define	IN_CLASSD_NSHIFT	28		/* net and host fields, but */
#define	IN_CLASSD_HOST		0x0fffffff	/* routing needn't know.    */
#define	IN_MULTICAST(i)		IN_CLASSD(i)

#define	IN_EXPERIMENTAL(i)	(((in_addr_t)(i) & 0xf0000000) == 0xf0000000)
#define	IN_BADCLASS(i)		(((in_addr_t)(i) & 0xf0000000) == 0xf0000000)

#define IN_LINKLOCAL(i)		(((in_addr_t)(i) & 0xffff0000) == 0xa9fe0000)
#define IN_LOOPBACK(i)		(((in_addr_t)(i) & 0xff000000) == 0x7f000000)
#define IN_ZERONET(i)		(((in_addr_t)(i) & 0xff000000) == 0)

#define	IN_PRIVATE(i)	((((in_addr_t)(i) & 0xff000000) == 0x0a000000) || \
			 (((in_addr_t)(i) & 0xfff00000) == 0xac100000) || \
			 (((in_addr_t)(i) & 0xffff0000) == 0xc0a80000))

#define	IN_LOCAL_GROUP(i)	(((in_addr_t)(i) & 0xffffff00) == 0xe0000000)
 
#define	IN_ANY_LOCAL(i)		(IN_LINKLOCAL(i) || IN_LOCAL_GROUP(i))

#define	INADDR_LOOPBACK		((in_addr_t)0x7f000001)
#ifndef _KERNEL
#define	INADDR_NONE		((in_addr_t)0xffffffff)	/* -1 return */
#endif
# 389 "/usr/include/netinet/in.h" 3 4

#define	INADDR_UNSPEC_GROUP	((in_addr_t)0xe0000000)	/* 224.0.0.0 */
#define	INADDR_ALLHOSTS_GROUP	((in_addr_t)0xe0000001)	/* 224.0.0.1 */
#define	INADDR_ALLRTRS_GROUP	((in_addr_t)0xe0000002)	/* 224.0.0.2 */
#define	INADDR_ALLRPTS_GROUP	((in_addr_t)0xe0000016)	/* 224.0.0.22, IGMPv3 */
#define	INADDR_CARP_GROUP	((in_addr_t)0xe0000012)	/* 224.0.0.18 */
#define	INADDR_PFSYNC_GROUP	((in_addr_t)0xe00000f0)	/* 224.0.0.240 */
#define	INADDR_ALLMDNS_GROUP	((in_addr_t)0xe00000fb)	/* 224.0.0.251 */
#define	INADDR_MAX_LOCAL_GROUP	((in_addr_t)0xe00000ff)	/* 224.0.0.255 */

#define	IN_LOOPBACKNET		127			/* official! */

#define	IN_RFC3021_MASK		((in_addr_t)0xfffffffe)

/*
 * Options for use with [gs]etsockopt at the IP level.
 * First word of comment is data type; bool is stored in int.
 */
#define	IP_OPTIONS		1    /* buf/ip_opts; set/get IP options */
#define	IP_HDRINCL		2    /* int; header is included with data */
#define	IP_TOS			3    /* int; IP type of service and preced. */
#define	IP_TTL			4    /* int; IP time to live */
#define	IP_RECVOPTS		5    /* bool; receive all IP opts w/dgram */
#define	IP_RECVRETOPTS		6    /* bool; receive IP opts for response */
#define	IP_RECVDSTADDR		7    /* bool; receive IP dst addr w/dgram */
#define	IP_SENDSRCADDR		IP_RECVDSTADDR /* cmsg_type to set src addr */
#define	IP_RETOPTS		8    /* ip_opts; set/get IP options */
#define	IP_MULTICAST_IF		9    /* struct in_addr *or* struct ip_mreqn;
				      * set/get IP multicast i/f  */
#define	IP_MULTICAST_TTL	10   /* u_char; set/get IP multicast ttl */
#define	IP_MULTICAST_LOOP	11   /* u_char; set/get IP multicast loopback */
#define	IP_ADD_MEMBERSHIP	12   /* ip_mreq; add an IP group membership */
#define	IP_DROP_MEMBERSHIP	13   /* ip_mreq; drop an IP group membership */
#define	IP_MULTICAST_VIF	14   /* set/get IP mcast virt. iface */
#define	IP_RSVP_ON		15   /* enable RSVP in kernel */
#define	IP_RSVP_OFF		16   /* disable RSVP in kernel */
#define	IP_RSVP_VIF_ON		17   /* set RSVP per-vif socket */
#define	IP_RSVP_VIF_OFF		18   /* unset RSVP per-vif socket */
#define	IP_PORTRANGE		19   /* int; range to choose for unspec port */
#define	IP_RECVIF		20   /* bool; receive reception if w/dgram */
/* for IPSEC */
#define	IP_IPSEC_POLICY		21   /* int; set/get security policy */
				     /* unused; was IP_FAITH */
#define	IP_ONESBCAST		23   /* bool: send all-ones broadcast */
#define	IP_BINDANY		24   /* bool: allow bind to any address */
#define	IP_BINDMULTI		25   /* bool: allow multiple listeners on a tuple */
#define	IP_RSS_LISTEN_BUCKET	26   /* int; set RSS listen bucket */

/*
 * Options for controlling the firewall and dummynet.
 * Historical options (from 40 to 64) will eventually be
 * replaced by only two options, IP_FW3 and IP_DUMMYNET3.
 */
#define	IP_FW_TABLE_ADD		40   /* add entry */
#define	IP_FW_TABLE_DEL		41   /* delete entry */
#define	IP_FW_TABLE_FLUSH	42   /* flush table */
#define	IP_FW_TABLE_GETSIZE	43   /* get table size */
#define	IP_FW_TABLE_LIST	44   /* list table contents */

#define	IP_FW3			48   /* generic ipfw v.3 sockopts */
#define	IP_DUMMYNET3		49   /* generic dummynet v.3 sockopts */

#define	IP_FW_ADD		50   /* add a firewall rule to chain */
#define	IP_FW_DEL		51   /* delete a firewall rule from chain */
#define	IP_FW_FLUSH		52   /* flush firewall rule chain */
#define	IP_FW_ZERO		53   /* clear single/all firewall counter(s) */
#define	IP_FW_GET		54   /* get entire firewall rule chain */
#define	IP_FW_RESETLOG		55   /* reset logging counters */

#define IP_FW_NAT_CFG           56   /* add/config a nat rule */
#define IP_FW_NAT_DEL           57   /* delete a nat rule */
#define IP_FW_NAT_GET_CONFIG    58   /* get configuration of a nat rule */
#define IP_FW_NAT_GET_LOG       59   /* get log of a nat rule */

#define	IP_DUMMYNET_CONFIGURE	60   /* add/configure a dummynet pipe */
#define	IP_DUMMYNET_DEL		61   /* delete a dummynet pipe from chain */
#define	IP_DUMMYNET_FLUSH	62   /* flush dummynet */
#define	IP_DUMMYNET_GET		64   /* get entire dummynet pipes */

#define	IP_RECVTTL		65   /* bool; receive IP TTL w/dgram */
#define	IP_MINTTL		66   /* minimum TTL for packet or drop */
#define	IP_DONTFRAG		67   /* don't fragment packet */
#define	IP_RECVTOS		68   /* bool; receive IP TOS w/dgram */

/* IPv4 Source Filter Multicast API [RFC3678] */
#define	IP_ADD_SOURCE_MEMBERSHIP	70   /* join a source-specific group */
#define	IP_DROP_SOURCE_MEMBERSHIP	71   /* drop a single source */
#define	IP_BLOCK_SOURCE			72   /* block a source */
#define	IP_UNBLOCK_SOURCE		73   /* unblock a source */

/* The following option is private; do not use it from user applications. */
#define	IP_MSFILTER			74   /* set/get filter list */

/* Protocol Independent Multicast API [RFC3678] */
#define	MCAST_JOIN_GROUP		80   /* join an any-source group */
#define	MCAST_LEAVE_GROUP		81   /* leave all sources for group */
#define	MCAST_JOIN_SOURCE_GROUP		82   /* join a source-specific group */
#define	MCAST_LEAVE_SOURCE_GROUP	83   /* leave a single source */
#define	MCAST_BLOCK_SOURCE		84   /* block a source */
#define	MCAST_UNBLOCK_SOURCE		85   /* unblock a source */

/* Flow and RSS definitions */
#define	IP_FLOWID		90   /* get flow id for the given socket/inp */
#define	IP_FLOWTYPE		91   /* get flow type (M_HASHTYPE) */
#define	IP_RSSBUCKETID		92   /* get RSS flowid -> bucket mapping */
#define	IP_RECVFLOWID		93   /* bool; receive IP flowid/flowtype w/ datagram */
#define	IP_RECVRSSBUCKETID	94   /* bool; receive IP RSS bucket id w/ datagram */

/*
 * Defaults and limits for options
 */
#define	IP_DEFAULT_MULTICAST_TTL  1	/* normally limit m'casts to 1 hop  */
#define	IP_DEFAULT_MULTICAST_LOOP 1	/* normally hear sends if a member  */

/*
 * The imo_membership vector for each socket is now dynamically allocated at
 * run-time, bounded by USHRT_MAX, and is reallocated when needed, sized
 * according to a power-of-two increment.
 */
#define	IP_MIN_MEMBERSHIPS	31
#define	IP_MAX_MEMBERSHIPS	4095
#define	IP_MAX_SOURCE_FILTER	1024	/* XXX to be unused */

/*
 * Default resource limits for IPv4 multicast source filtering.
 * These may be modified by sysctl.
 */
#define	IP_MAX_GROUP_SRC_FILTER		512	/* sources per group */
#define	IP_MAX_SOCK_SRC_FILTER		128	/* sources per socket/group */
#define	IP_MAX_SOCK_MUTE_FILTER		128	/* XXX no longer used */

/*
 * Argument structure for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP.
 */
struct ip_mreq {
	struct	in_addr imr_multiaddr;	/* IP multicast address of group */
	struct	in_addr imr_interface;	/* local IP address of interface */
};

/*
 * Modified argument structure for IP_MULTICAST_IF, obtained from Linux.
 * This is used to specify an interface index for multicast sends, as
 * the IPv4 legacy APIs do not support this (unless IP_SENDIF is available).
 */
struct ip_mreqn {
	struct	in_addr imr_multiaddr;	/* IP multicast address of group */
	struct	in_addr imr_address;	/* local IP address of interface */
	int		imr_ifindex;	/* Interface index; cast to uint32_t */
};

/*
 * Argument structure for IPv4 Multicast Source Filter APIs. [RFC3678]
 */
struct ip_mreq_source {
	struct	in_addr imr_multiaddr;	/* IP multicast address of group */
	struct	in_addr imr_sourceaddr;	/* IP address of source */
	struct	in_addr imr_interface;	/* local IP address of interface */
};

/*
 * Argument structures for Protocol-Independent Multicast Source
 * Filter APIs. [RFC3678]
 */
struct group_req {
	uint32_t		gr_interface;	/* interface index */
	struct sockaddr_storage	gr_group;	/* group address */
};

struct group_source_req {
	uint32_t		gsr_interface;	/* interface index */
	struct sockaddr_storage	gsr_group;	/* group address */
	struct sockaddr_storage	gsr_source;	/* source address */
};

#ifndef __MSFILTERREQ_DEFINED
#define __MSFILTERREQ_DEFINED
/*
 * The following structure is private; do not use it from user applications.
 * It is used to communicate IP_MSFILTER/IPV6_MSFILTER information between
 * the RFC 3678 libc functions and the kernel.
 */
struct __msfilterreq {
	uint32_t		 msfr_ifindex;	/* interface index */
	uint32_t		 msfr_fmode;	/* filter mode for group */
	uint32_t		 msfr_nsrcs;	/* # of sources in msfr_srcs */
	struct sockaddr_storage	 msfr_group;	/* group address */
	struct sockaddr_storage	*msfr_srcs;	/* pointer to the first member
						 * of a contiguous array of
						 * sources to filter in full.
						 */
};
#endif
# 581 "/usr/include/netinet/in.h" 3 4

struct sockaddr;

/*
 * Advanced (Full-state) APIs [RFC3678]
 * The RFC specifies uint_t for the 6th argument to [sg]etsourcefilter().
 * We use uint32_t here to be consistent.
 */
int	setipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t,
	    uint32_t, struct in_addr *);
int	getipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t *,
	    uint32_t *, struct in_addr *);
int	setsourcefilter(int, uint32_t, struct sockaddr *, socklen_t,
	    uint32_t, uint32_t, struct sockaddr_storage *);
int	getsourcefilter(int, uint32_t, struct sockaddr *, socklen_t,
	    uint32_t *, uint32_t *, struct sockaddr_storage *);

/*
 * Filter modes; also used to represent per-socket filter mode internally.
 */
#define	MCAST_UNDEFINED	0	/* fmode: not yet defined */
#define	MCAST_INCLUDE	1	/* fmode: include these source(s) */
#define	MCAST_EXCLUDE	2	/* fmode: exclude these source(s) */

/*
 * Argument for IP_PORTRANGE:
 * - which range to search when port is unspecified at bind() or connect()
 */
#define	IP_PORTRANGE_DEFAULT	0	/* default range */
#define	IP_PORTRANGE_HIGH	1	/* "high" - request firewall bypass */
#define	IP_PORTRANGE_LOW	2	/* "low" - vouchsafe security */

/*
 * Identifiers for IP sysctl nodes
 */
#define	IPCTL_FORWARDING	1	/* act as router */
#define	IPCTL_SENDREDIRECTS	2	/* may send redirects when forwarding */
#define	IPCTL_DEFTTL		3	/* default TTL */
#ifdef notyet
#define	IPCTL_DEFMTU		4	/* default MTU */
#endif
# 622 "/usr/include/netinet/in.h" 3 4
/*	IPCTL_RTEXPIRE		5	deprecated */
/*	IPCTL_RTMINEXPIRE	6	deprecated */
/*	IPCTL_RTMAXCACHE	7	deprecated */
#define	IPCTL_SOURCEROUTE	8	/* may perform source routes */
#define	IPCTL_DIRECTEDBROADCAST	9	/* may re-broadcast received packets */
#define	IPCTL_INTRQMAXLEN	10	/* max length of netisr queue */
#define	IPCTL_INTRQDROPS	11	/* number of netisr q drops */
#define	IPCTL_STATS		12	/* ipstat structure */
#define	IPCTL_ACCEPTSOURCEROUTE	13	/* may accept source routed packets */
#define	IPCTL_FASTFORWARDING	14	/* use fast IP forwarding code */
					/* 15, unused, was: IPCTL_KEEPFAITH  */
#define	IPCTL_GIF_TTL		16	/* default TTL for gif encap packet */

#endif /* __BSD_VISIBLE */
# 636 "/usr/include/netinet/in.h" 3 4

#ifdef _KERNEL

struct ifnet; struct mbuf;	/* forward declarations for Standard C */

int	 in_broadcast(struct in_addr, struct ifnet *);
int	 in_canforward(struct in_addr);
int	 in_localaddr(struct in_addr);
int	 in_localip(struct in_addr);
int	 in_ifhasaddr(struct ifnet *, struct in_addr);
int	 inet_aton(const char *, struct in_addr *); /* in libkern */
char	*inet_ntoa(struct in_addr); /* in libkern */
char	*inet_ntoa_r(struct in_addr ina, char *buf); /* in libkern */
char	*inet_ntop(int, const void *, char *, socklen_t); /* in libkern */
int	 inet_pton(int af, const char *, void *); /* in libkern */
void	 in_ifdetach(struct ifnet *);

#define	in_hosteq(s, t)	((s).s_addr == (t).s_addr)
#define	in_nullhost(x)	((x).s_addr == INADDR_ANY)
#define	in_allhosts(x)	((x).s_addr == htonl(INADDR_ALLHOSTS_GROUP))

#define	satosin(sa)	((struct sockaddr_in *)(sa))
#define	sintosa(sin)	((struct sockaddr *)(sin))
#define	ifatoia(ifa)	((struct in_ifaddr *)(ifa))
#endif /* _KERNEL */
# 661 "/usr/include/netinet/in.h" 3 4

/* INET6 stuff */
#if __POSIX_VISIBLE >= 200112
#define	__KAME_NETINET_IN_H_INCLUDED_
#if 0 /* expanded by -frewrite-includes */
#include <netinet6/in6.h>
#endif /* expanded by -frewrite-includes */
# 665 "/usr/include/netinet/in.h" 3 4
# 1 "/usr/include/netinet6/in6.h" 1 3 4
/*-
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$KAME: in6.h,v 1.89 2001/05/27 13:28:35 itojun Exp $
 */

/*-
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)in.h	8.3 (Berkeley) 1/3/94
 * $FreeBSD: releng/11.0/sys/netinet6/in6.h 301217 2016-06-02 17:51:29Z gnn $
 */

#ifndef __KAME_NETINET_IN_H_INCLUDED_
#error "do not include netinet6/in6.h directly, include netinet/in.h.  see RFC2553"
#endif
# 67 "/usr/include/netinet6/in6.h" 3 4

#ifndef _NETINET6_IN6_H_
#define _NETINET6_IN6_H_

/*
 * Identification of the network protocol stack
 * for *BSD-current/release: http://www.kame.net/dev/cvsweb.cgi/kame/COVERAGE
 * has the table of implementation/integration differences.
 */
#define __KAME__
#define __KAME_VERSION		"FreeBSD"

/*
 * IPv6 port allocation rules should mirror the IPv4 rules and are controlled
 * by the net.inet.ip.portrange sysctl tree. The following defines exist
 * for compatibility with userland applications that need them.
 */
#if __BSD_VISIBLE
#define	IPV6PORT_RESERVED	1024
#define	IPV6PORT_ANONMIN	49152
#define	IPV6PORT_ANONMAX	65535
#define	IPV6PORT_RESERVEDMIN	600
#define	IPV6PORT_RESERVEDMAX	(IPV6PORT_RESERVED-1)
#endif
# 91 "/usr/include/netinet6/in6.h" 3 4

/*
 * IPv6 address
 */
struct in6_addr {
	union {
		uint8_t		__u6_addr8[16];
		uint16_t	__u6_addr16[8];
		uint32_t	__u6_addr32[4];
	} __u6_addr;			/* 128-bit IP6 address */
};

#define s6_addr   __u6_addr.__u6_addr8
#ifdef _KERNEL	/* XXX nonstandard */
#define s6_addr8  __u6_addr.__u6_addr8
#define s6_addr16 __u6_addr.__u6_addr16
#define s6_addr32 __u6_addr.__u6_addr32
#endif
# 109 "/usr/include/netinet6/in6.h" 3 4

#define INET6_ADDRSTRLEN	46

/*
 * XXX missing POSIX.1-2001 macro IPPROTO_IPV6.
 */

/*
 * Socket address for IPv6
 */
#if __BSD_VISIBLE
#define SIN6_LEN
#endif
# 122 "/usr/include/netinet6/in6.h" 3 4

struct sockaddr_in6 {
	uint8_t		sin6_len;	/* length of this struct */
	sa_family_t	sin6_family;	/* AF_INET6 */
	in_port_t	sin6_port;	/* Transport layer port # */
	uint32_t	sin6_flowinfo;	/* IP6 flow information */
	struct in6_addr	sin6_addr;	/* IP6 address */
	uint32_t	sin6_scope_id;	/* scope zone index */
};

/*
 * Local definition for masks
 */
#ifdef _KERNEL	/* XXX nonstandard */
#define IN6MASK0	{{{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }}}
#define IN6MASK32	{{{ 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, \
			    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }}}
#define IN6MASK64	{{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, \
			    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }}}
#define IN6MASK96	{{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, \
			    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00 }}}
#define IN6MASK128	{{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, \
			    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }}}
#endif
# 146 "/usr/include/netinet6/in6.h" 3 4

#ifdef _KERNEL
extern const struct sockaddr_in6 sa6_any;

extern const struct in6_addr in6mask0;
extern const struct in6_addr in6mask32;
extern const struct in6_addr in6mask64;
extern const struct in6_addr in6mask96;
extern const struct in6_addr in6mask128;
#endif /* _KERNEL */
# 156 "/usr/include/netinet6/in6.h" 3 4

/*
 * Macros started with IPV6_ADDR is KAME local
 */
#ifdef _KERNEL	/* XXX nonstandard */
#if _BYTE_ORDER == _BIG_ENDIAN
#define IPV6_ADDR_INT32_ONE	1
#define IPV6_ADDR_INT32_TWO	2
#define IPV6_ADDR_INT32_MNL	0xff010000
#define IPV6_ADDR_INT32_MLL	0xff020000
#define IPV6_ADDR_INT32_SMP	0x0000ffff
#define IPV6_ADDR_INT16_ULL	0xfe80
#define IPV6_ADDR_INT16_USL	0xfec0
#define IPV6_ADDR_INT16_MLL	0xff02
#elif _BYTE_ORDER == _LITTLE_ENDIAN
# 171 "/usr/include/netinet6/in6.h" 3 4
#define IPV6_ADDR_INT32_ONE	0x01000000
#define IPV6_ADDR_INT32_TWO	0x02000000
#define IPV6_ADDR_INT32_MNL	0x000001ff
#define IPV6_ADDR_INT32_MLL	0x000002ff
#define IPV6_ADDR_INT32_SMP	0xffff0000
#define IPV6_ADDR_INT16_ULL	0x80fe
#define IPV6_ADDR_INT16_USL	0xc0fe
#define IPV6_ADDR_INT16_MLL	0x02ff
#endif
# 180 "/usr/include/netinet6/in6.h" 3 4
#endif
# 181 "/usr/include/netinet6/in6.h" 3 4

/*
 * Definition of some useful macros to handle IP6 addresses
 */
#if __BSD_VISIBLE
#define IN6ADDR_ANY_INIT \
	{{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }}}
#define IN6ADDR_LOOPBACK_INIT \
	{{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}}
#define IN6ADDR_NODELOCAL_ALLNODES_INIT \
	{{{ 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}}
#define IN6ADDR_INTFACELOCAL_ALLNODES_INIT \
	{{{ 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}}
#define IN6ADDR_LINKLOCAL_ALLNODES_INIT \
	{{{ 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}}
#define IN6ADDR_LINKLOCAL_ALLROUTERS_INIT \
	{{{ 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02 }}}
#define IN6ADDR_LINKLOCAL_ALLV2ROUTERS_INIT \
	{{{ 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16 }}}
#endif
# 208 "/usr/include/netinet6/in6.h" 3 4

extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;
#if __BSD_VISIBLE
extern const struct in6_addr in6addr_nodelocal_allnodes;
extern const struct in6_addr in6addr_linklocal_allnodes;
extern const struct in6_addr in6addr_linklocal_allrouters;
extern const struct in6_addr in6addr_linklocal_allv2routers;
#endif
# 217 "/usr/include/netinet6/in6.h" 3 4

/*
 * Equality
 * NOTE: Some of kernel programming environment (for example, openbsd/sparc)
 * does not supply memcmp().  For userland memcmp() is preferred as it is
 * in ANSI standard.
 */
#ifdef _KERNEL
#define IN6_ARE_ADDR_EQUAL(a, b)			\
    (bcmp(&(a)->s6_addr[0], &(b)->s6_addr[0], sizeof(struct in6_addr)) == 0)
#else
# 228 "/usr/include/netinet6/in6.h" 3 4
#if __BSD_VISIBLE
#define IN6_ARE_ADDR_EQUAL(a, b)			\
    (memcmp(&(a)->s6_addr[0], &(b)->s6_addr[0], sizeof(struct in6_addr)) == 0)
#endif
# 232 "/usr/include/netinet6/in6.h" 3 4
#endif
# 233 "/usr/include/netinet6/in6.h" 3 4

/*
 * Unspecified
 */
#define IN6_IS_ADDR_UNSPECIFIED(a)	\
	((a)->__u6_addr.__u6_addr32[0] == 0 &&	\
	 (a)->__u6_addr.__u6_addr32[1] == 0 &&	\
	 (a)->__u6_addr.__u6_addr32[2] == 0 &&	\
	 (a)->__u6_addr.__u6_addr32[3] == 0)

/*
 * Loopback
 */
#define IN6_IS_ADDR_LOOPBACK(a)		\
	((a)->__u6_addr.__u6_addr32[0] == 0 &&	\
	 (a)->__u6_addr.__u6_addr32[1] == 0 &&	\
	 (a)->__u6_addr.__u6_addr32[2] == 0 &&	\
	 (a)->__u6_addr.__u6_addr32[3] == ntohl(1))

/*
 * IPv4 compatible
 */
#define IN6_IS_ADDR_V4COMPAT(a)		\
	((a)->__u6_addr.__u6_addr32[0] == 0 &&	\
	 (a)->__u6_addr.__u6_addr32[1] == 0 &&	\
	 (a)->__u6_addr.__u6_addr32[2] == 0 &&	\
	 (a)->__u6_addr.__u6_addr32[3] != 0 &&	\
	 (a)->__u6_addr.__u6_addr32[3] != ntohl(1))

/*
 * Mapped
 */
#define IN6_IS_ADDR_V4MAPPED(a)		      \
	((a)->__u6_addr.__u6_addr32[0] == 0 &&	\
	 (a)->__u6_addr.__u6_addr32[1] == 0 &&	\
	 (a)->__u6_addr.__u6_addr32[2] == ntohl(0x0000ffff))

/*
 * KAME Scope Values
 */

#ifdef _KERNEL	/* XXX nonstandard */
#define IPV6_ADDR_SCOPE_NODELOCAL	0x01
#define IPV6_ADDR_SCOPE_INTFACELOCAL	0x01
#define IPV6_ADDR_SCOPE_LINKLOCAL	0x02
#define IPV6_ADDR_SCOPE_SITELOCAL	0x05
#define IPV6_ADDR_SCOPE_ORGLOCAL	0x08	/* just used in this file */
#define IPV6_ADDR_SCOPE_GLOBAL		0x0e
#else
# 282 "/usr/include/netinet6/in6.h" 3 4
#define __IPV6_ADDR_SCOPE_NODELOCAL	0x01
#define __IPV6_ADDR_SCOPE_INTFACELOCAL	0x01
#define __IPV6_ADDR_SCOPE_LINKLOCAL	0x02
#define __IPV6_ADDR_SCOPE_SITELOCAL	0x05
#define __IPV6_ADDR_SCOPE_ORGLOCAL	0x08	/* just used in this file */
#define __IPV6_ADDR_SCOPE_GLOBAL	0x0e
#endif
# 289 "/usr/include/netinet6/in6.h" 3 4

/*
 * Unicast Scope
 * Note that we must check topmost 10 bits only, not 16 bits (see RFC2373).
 */
#define IN6_IS_ADDR_LINKLOCAL(a)	\
	(((a)->s6_addr[0] == 0xfe) && (((a)->s6_addr[1] & 0xc0) == 0x80))
#define IN6_IS_ADDR_SITELOCAL(a)	\
	(((a)->s6_addr[0] == 0xfe) && (((a)->s6_addr[1] & 0xc0) == 0xc0))

/*
 * Multicast
 */
#define IN6_IS_ADDR_MULTICAST(a)	((a)->s6_addr[0] == 0xff)

#ifdef _KERNEL	/* XXX nonstandard */
#define IPV6_ADDR_MC_SCOPE(a)		((a)->s6_addr[1] & 0x0f)
#else
# 307 "/usr/include/netinet6/in6.h" 3 4
#define __IPV6_ADDR_MC_SCOPE(a)		((a)->s6_addr[1] & 0x0f)
#endif
# 309 "/usr/include/netinet6/in6.h" 3 4

/*
 * Multicast Scope
 */
#ifdef _KERNEL	/* refers nonstandard items */
#define IN6_IS_ADDR_MC_NODELOCAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) &&	\
	 (IPV6_ADDR_MC_SCOPE(a) == IPV6_ADDR_SCOPE_NODELOCAL))
#define IN6_IS_ADDR_MC_INTFACELOCAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) &&	\
	 (IPV6_ADDR_MC_SCOPE(a) == IPV6_ADDR_SCOPE_INTFACELOCAL))
#define IN6_IS_ADDR_MC_LINKLOCAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) &&	\
	 (IPV6_ADDR_MC_SCOPE(a) == IPV6_ADDR_SCOPE_LINKLOCAL))
#define IN6_IS_ADDR_MC_SITELOCAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) &&	\
	 (IPV6_ADDR_MC_SCOPE(a) == IPV6_ADDR_SCOPE_SITELOCAL))
#define IN6_IS_ADDR_MC_ORGLOCAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) &&	\
	 (IPV6_ADDR_MC_SCOPE(a) == IPV6_ADDR_SCOPE_ORGLOCAL))
#define IN6_IS_ADDR_MC_GLOBAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) &&	\
	 (IPV6_ADDR_MC_SCOPE(a) == IPV6_ADDR_SCOPE_GLOBAL))
#else
# 333 "/usr/include/netinet6/in6.h" 3 4
#define IN6_IS_ADDR_MC_NODELOCAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) &&	\
	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_NODELOCAL))
#define IN6_IS_ADDR_MC_LINKLOCAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) &&	\
	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_LINKLOCAL))
#define IN6_IS_ADDR_MC_SITELOCAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) &&	\
	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_SITELOCAL))
#define IN6_IS_ADDR_MC_ORGLOCAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) &&	\
	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_ORGLOCAL))
#define IN6_IS_ADDR_MC_GLOBAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) &&	\
	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_GLOBAL))
#endif
# 349 "/usr/include/netinet6/in6.h" 3 4

#ifdef _KERNEL	/* nonstandard */
/*
 * KAME Scope
 */
#define IN6_IS_SCOPE_LINKLOCAL(a)	\
	((IN6_IS_ADDR_LINKLOCAL(a)) ||	\
	 (IN6_IS_ADDR_MC_LINKLOCAL(a)))
#define	IN6_IS_SCOPE_EMBED(a)			\
	((IN6_IS_ADDR_LINKLOCAL(a)) ||		\
	 (IN6_IS_ADDR_MC_LINKLOCAL(a)) ||	\
	 (IN6_IS_ADDR_MC_INTFACELOCAL(a)))

#define IFA6_IS_DEPRECATED(a) \
	((a)->ia6_lifetime.ia6t_pltime != ND6_INFINITE_LIFETIME && \
	 (u_int32_t)((time_uptime - (a)->ia6_updatetime)) > \
	 (a)->ia6_lifetime.ia6t_pltime)
#define IFA6_IS_INVALID(a) \
	((a)->ia6_lifetime.ia6t_vltime != ND6_INFINITE_LIFETIME && \
	 (u_int32_t)((time_uptime - (a)->ia6_updatetime)) > \
	 (a)->ia6_lifetime.ia6t_vltime)
#endif /* _KERNEL */
# 371 "/usr/include/netinet6/in6.h" 3 4

/*
 * IP6 route structure
 */
#if __BSD_VISIBLE
struct route_in6 {
	struct	rtentry *ro_rt;
	struct	llentry *ro_lle;
	/*
	 * ro_prepend and ro_plen are only used for bpf to pass in a
	 * preformed header.  They are not cacheable.
	 */
	char		*ro_prepend;
	uint16_t	ro_plen;
	uint16_t	ro_flags;
	uint16_t	ro_mtu;	/* saved ro_rt mtu */
	uint16_t	spare;
	struct	sockaddr_in6 ro_dst;
};
#endif
# 391 "/usr/include/netinet6/in6.h" 3 4

#ifdef _KERNEL
#define MTAG_ABI_IPV6		1444287380	/* IPv6 ABI */
#define IPV6_TAG_DIRECT		0		/* direct-dispatch IPv6 */
#endif /* _KERNEL */
# 396 "/usr/include/netinet6/in6.h" 3 4

/*
 * Options for use with [gs]etsockopt at the IPV6 level.
 * First word of comment is data type; bool is stored in int.
 */
/* no hdrincl */
#if 0 /* the followings are relic in IPv4 and hence are disabled */
#define IPV6_OPTIONS		1  /* buf/ip6_opts; set/get IP6 options */
#define IPV6_RECVOPTS		5  /* bool; receive all IP6 opts w/dgram */
#define IPV6_RECVRETOPTS	6  /* bool; receive IP6 opts for response */
#define IPV6_RECVDSTADDR	7  /* bool; receive IP6 dst addr w/dgram */
#define IPV6_RETOPTS		8  /* ip6_opts; set/get IP6 options */
#endif
# 409 "/usr/include/netinet6/in6.h" 3 4
#define IPV6_SOCKOPT_RESERVED1	3  /* reserved for future use */
#define IPV6_UNICAST_HOPS	4  /* int; IP6 hops */
#define IPV6_MULTICAST_IF	9  /* u_int; set/get IP6 multicast i/f  */
#define IPV6_MULTICAST_HOPS	10 /* int; set/get IP6 multicast hops */
#define IPV6_MULTICAST_LOOP	11 /* u_int; set/get IP6 multicast loopback */
#define IPV6_JOIN_GROUP		12 /* ipv6_mreq; join a group membership */
#define IPV6_LEAVE_GROUP	13 /* ipv6_mreq; leave a group membership */
#define IPV6_PORTRANGE		14 /* int; range to choose for unspec port */
#define ICMP6_FILTER		18 /* icmp6_filter; icmp6 filter */
/* RFC2292 options */
#ifdef _KERNEL
#define IPV6_2292PKTINFO	19 /* bool; send/recv if, src/dst addr */
#define IPV6_2292HOPLIMIT	20 /* bool; hop limit */
#define IPV6_2292NEXTHOP	21 /* bool; next hop addr */
#define IPV6_2292HOPOPTS	22 /* bool; hop-by-hop option */
#define IPV6_2292DSTOPTS	23 /* bool; destinaion option */
#define IPV6_2292RTHDR		24 /* bool; routing header */
#define IPV6_2292PKTOPTIONS	25 /* buf/cmsghdr; set/get IPv6 options */
#endif
# 428 "/usr/include/netinet6/in6.h" 3 4

#define IPV6_CHECKSUM		26 /* int; checksum offset for raw socket */
#define IPV6_V6ONLY		27 /* bool; make AF_INET6 sockets v6 only */
#ifndef _KERNEL
#define IPV6_BINDV6ONLY		IPV6_V6ONLY
#endif
# 434 "/usr/include/netinet6/in6.h" 3 4

#if 1 /* IPSEC */
#define IPV6_IPSEC_POLICY	28 /* struct; get/set security policy */
#endif /* IPSEC */
# 438 "/usr/include/netinet6/in6.h" 3 4

				   /* 29; unused; was IPV6_FAITH */
#if 1 /* IPV6FIREWALL */
#define IPV6_FW_ADD		30 /* add a firewall rule to chain */
#define IPV6_FW_DEL		31 /* delete a firewall rule from chain */
#define IPV6_FW_FLUSH		32 /* flush firewall rule chain */
#define IPV6_FW_ZERO		33 /* clear single/all firewall counter(s) */
#define IPV6_FW_GET		34 /* get entire firewall rule chain */
#endif
# 447 "/usr/include/netinet6/in6.h" 3 4

/* new socket options introduced in RFC3542 */
#define IPV6_RTHDRDSTOPTS	35 /* ip6_dest; send dst option before rthdr */

#define IPV6_RECVPKTINFO	36 /* bool; recv if, dst addr */
#define IPV6_RECVHOPLIMIT	37 /* bool; recv hop limit */
#define IPV6_RECVRTHDR		38 /* bool; recv routing header */
#define IPV6_RECVHOPOPTS	39 /* bool; recv hop-by-hop option */
#define IPV6_RECVDSTOPTS	40 /* bool; recv dst option after rthdr */
#ifdef _KERNEL
#define IPV6_RECVRTHDRDSTOPTS	41 /* bool; recv dst option before rthdr */
#endif
# 459 "/usr/include/netinet6/in6.h" 3 4

#define IPV6_USE_MIN_MTU	42 /* bool; send packets at the minimum MTU */
#define IPV6_RECVPATHMTU	43 /* bool; notify an according MTU */

#define IPV6_PATHMTU		44 /* mtuinfo; get the current path MTU (sopt),
				      4 bytes int; MTU notification (cmsg) */
#if 0 /*obsoleted during 2292bis -> 3542*/
#define IPV6_REACHCONF		45 /* no data; ND reachability confirm
				      (cmsg only/not in of RFC3542) */
#endif
# 469 "/usr/include/netinet6/in6.h" 3 4

/* more new socket options introduced in RFC3542 */
#define IPV6_PKTINFO		46 /* in6_pktinfo; send if, src addr */
#define IPV6_HOPLIMIT		47 /* int; send hop limit */
#define IPV6_NEXTHOP		48 /* sockaddr; next hop addr */
#define IPV6_HOPOPTS		49 /* ip6_hbh; send hop-by-hop option */
#define IPV6_DSTOPTS		50 /* ip6_dest; send dst option befor rthdr */
#define IPV6_RTHDR		51 /* ip6_rthdr; send routing header */
#if 0
#define IPV6_PKTOPTIONS		52 /* buf/cmsghdr; set/get IPv6 options */
				   /* obsoleted by RFC3542 */
#endif
# 481 "/usr/include/netinet6/in6.h" 3 4

#define IPV6_RECVTCLASS		57 /* bool; recv traffic class values */

#define IPV6_AUTOFLOWLABEL	59 /* bool; attach flowlabel automagically */

#define IPV6_TCLASS		61 /* int; send traffic class value */
#define IPV6_DONTFRAG		62 /* bool; disable IPv6 fragmentation */

#define IPV6_PREFER_TEMPADDR	63 /* int; prefer temporary addresses as
				    * the source address.
				    */

#define	IPV6_BINDANY		64 /* bool: allow bind to any address */

#define	IPV6_BINDMULTI		65 /* bool; allow multibind to same addr/port */
#define	IPV6_RSS_LISTEN_BUCKET	66 /* int; set RSS listen bucket */
#define	IPV6_FLOWID		67 /* int; flowid of given socket */
#define	IPV6_FLOWTYPE		68 /* int; flowtype of given socket */
#define	IPV6_RSSBUCKETID	69 /* int; RSS bucket ID of given socket */
#define	IPV6_RECVFLOWID		70 /* bool; receive IP6 flowid/flowtype w/ datagram */
#define	IPV6_RECVRSSBUCKETID	71 /* bool; receive IP6 RSS bucket id w/ datagram */

/*
 * The following option is private; do not use it from user applications.
 * It is deliberately defined to the same value as IP_MSFILTER.
 */
#define	IPV6_MSFILTER		74 /* struct __msfilterreq;
				    * set/get multicast source filter list.
				    */

/* to define items, should talk with KAME guys first, for *BSD compatibility */

#define IPV6_RTHDR_LOOSE     0 /* this hop need not be a neighbor. XXX old spec */
#define IPV6_RTHDR_STRICT    1 /* this hop must be a neighbor. XXX old spec */
#define IPV6_RTHDR_TYPE_0    0 /* IPv6 routing header type 0 */

/*
 * Defaults and limits for options
 */
#define IPV6_DEFAULT_MULTICAST_HOPS 1	/* normally limit m'casts to 1 hop */
#define IPV6_DEFAULT_MULTICAST_LOOP 1	/* normally hear sends if a member */

/*
 * The im6o_membership vector for each socket is now dynamically allocated at
 * run-time, bounded by USHRT_MAX, and is reallocated when needed, sized
 * according to a power-of-two increment.
 */
#define	IPV6_MIN_MEMBERSHIPS	31
#define	IPV6_MAX_MEMBERSHIPS	4095

/*
 * Default resource limits for IPv6 multicast source filtering.
 * These may be modified by sysctl.
 */
#define	IPV6_MAX_GROUP_SRC_FILTER	512	/* sources per group */
#define	IPV6_MAX_SOCK_SRC_FILTER	128	/* sources per socket/group */

/*
 * Argument structure for IPV6_JOIN_GROUP and IPV6_LEAVE_GROUP.
 */
struct ipv6_mreq {
	struct in6_addr	ipv6mr_multiaddr;
	unsigned int	ipv6mr_interface;
};

/*
 * IPV6_PKTINFO: Packet information(RFC2292 sec 5)
 */
struct in6_pktinfo {
	struct in6_addr	ipi6_addr;	/* src/dst IPv6 address */
	unsigned int	ipi6_ifindex;	/* send/recv interface index */
};

/*
 * Control structure for IPV6_RECVPATHMTU socket option.
 */
struct ip6_mtuinfo {
	struct sockaddr_in6 ip6m_addr;	/* or sockaddr_storage? */
	uint32_t ip6m_mtu;
};

/*
 * Argument for IPV6_PORTRANGE:
 * - which range to search when port is unspecified at bind() or connect()
 */
#define	IPV6_PORTRANGE_DEFAULT	0	/* default range */
#define	IPV6_PORTRANGE_HIGH	1	/* "high" - request firewall bypass */
#define	IPV6_PORTRANGE_LOW	2	/* "low" - vouchsafe security */

#if __BSD_VISIBLE
/*
 * Definitions for inet6 sysctl operations.
 *
 * Third level is protocol number.
 * Fourth level is desired variable within that protocol.
 */
#define IPV6PROTO_MAXID	(IPPROTO_PIM + 1)	/* don't list to IPV6PROTO_MAX */

/*
 * Names for IP sysctl objects
 */
#define IPV6CTL_FORWARDING	1	/* act as router */
#define IPV6CTL_SENDREDIRECTS	2	/* may send redirects when forwarding*/
#define IPV6CTL_DEFHLIM		3	/* default Hop-Limit */
#ifdef notyet
#define IPV6CTL_DEFMTU		4	/* default MTU */
#endif
# 588 "/usr/include/netinet6/in6.h" 3 4
#define IPV6CTL_FORWSRCRT	5	/* forward source-routed dgrams */
#define IPV6CTL_STATS		6	/* stats */
#define IPV6CTL_MRTSTATS	7	/* multicast forwarding stats */
#define IPV6CTL_MRTPROTO	8	/* multicast routing protocol */
#define IPV6CTL_MAXFRAGPACKETS	9	/* max packets reassembly queue */
#define IPV6CTL_SOURCECHECK	10	/* verify source route and intf */
#define IPV6CTL_SOURCECHECK_LOGINT 11	/* minimume logging interval */
#define IPV6CTL_ACCEPT_RTADV	12
					/* 13; unused; was: IPV6CTL_KEEPFAITH */
#define IPV6CTL_LOG_INTERVAL	14
#define IPV6CTL_HDRNESTLIMIT	15
#define IPV6CTL_DAD_COUNT	16
#define IPV6CTL_AUTO_FLOWLABEL	17
#define IPV6CTL_DEFMCASTHLIM	18
#define IPV6CTL_GIF_HLIM	19	/* default HLIM for gif encap packet */
#define IPV6CTL_KAME_VERSION	20
#define IPV6CTL_USE_DEPRECATED	21	/* use deprecated addr (RFC2462 5.5.4) */
#define IPV6CTL_RR_PRUNE	22	/* walk timer for router renumbering */
#if 0	/* obsolete */
#define IPV6CTL_MAPPED_ADDR	23
#endif
# 609 "/usr/include/netinet6/in6.h" 3 4
#define IPV6CTL_V6ONLY		24
/*	IPV6CTL_RTEXPIRE	25	deprecated */
/*	IPV6CTL_RTMINEXPIRE	26	deprecated */
/*	IPV6CTL_RTMAXCACHE	27	deprecated */

#define IPV6CTL_USETEMPADDR	32	/* use temporary addresses (RFC3041) */
#define IPV6CTL_TEMPPLTIME	33	/* preferred lifetime for tmpaddrs */
#define IPV6CTL_TEMPVLTIME	34	/* valid lifetime for tmpaddrs */
#define IPV6CTL_AUTO_LINKLOCAL	35	/* automatic link-local addr assign */
#define IPV6CTL_RIP6STATS	36	/* raw_ip6 stats */
#define IPV6CTL_PREFER_TEMPADDR	37	/* prefer temporary addr as src */
#define IPV6CTL_ADDRCTLPOLICY	38	/* get/set address selection policy */
#define IPV6CTL_USE_DEFAULTZONE	39	/* use default scope zone */

#define IPV6CTL_MAXFRAGS	41	/* max fragments */
#if 0
#define IPV6CTL_IFQ		42	/* ip6intrq node */
#define IPV6CTL_ISATAPRTR	43	/* isatap router */
#endif
# 628 "/usr/include/netinet6/in6.h" 3 4
#define IPV6CTL_MCAST_PMTU	44	/* enable pMTU discovery for multicast? */

/* New entries should be added here from current IPV6CTL_MAXID value. */
/* to define items, should talk with KAME guys first, for *BSD compatibility */
#define IPV6CTL_STEALTH		45

#define	ICMPV6CTL_ND6_ONLINKNSRFC4861	47
#define	IPV6CTL_NO_RADR		48	/* No defroute from RA */
#define	IPV6CTL_NORBIT_RAIF	49	/* Disable R-bit in NA on RA
					 * receiving IF. */
#define	IPV6CTL_RFC6204W3	50	/* Accept defroute even when forwarding
					   enabled */
#define	IPV6CTL_MAXID		51
#endif /* __BSD_VISIBLE */
# 642 "/usr/include/netinet6/in6.h" 3 4

/*
 * Since both netinet/ and netinet6/ call into netipsec/ and netpfil/,
 * the protocol specific mbuf flags are shared between them.
 */
#define	M_FASTFWD_OURS		M_PROTO1	/* changed dst to local */
#define	M_IP6_NEXTHOP		M_PROTO2	/* explicit ip nexthop */
#define	M_IP_NEXTHOP		M_PROTO2	/* explicit ip nexthop */
#define	M_SKIP_FIREWALL		M_PROTO3	/* skip firewall processing */
#define	M_AUTHIPHDR		M_PROTO4
#define	M_DECRYPTED		M_PROTO5
#define	M_LOOP			M_PROTO6
#define	M_AUTHIPDGM		M_PROTO7
#define	M_RTALERT_MLD		M_PROTO8

#ifdef _KERNEL
struct cmsghdr;
struct ip6_hdr;

int	in6_cksum_pseudo(struct ip6_hdr *, uint32_t, uint8_t, uint16_t);
int	in6_cksum(struct mbuf *, u_int8_t, u_int32_t, u_int32_t);
int	in6_cksum_partial(struct mbuf *, u_int8_t, u_int32_t, u_int32_t,
			  u_int32_t);
int	in6_localaddr(struct in6_addr *);
int	in6_localip(struct in6_addr *);
int	in6_ifhasaddr(struct ifnet *, struct in6_addr *);
int	in6_addrscope(const struct in6_addr *);
char	*ip6_sprintf(char *, const struct in6_addr *);
struct	in6_ifaddr *in6_ifawithifp(struct ifnet *, struct in6_addr *);
extern void in6_if_up(struct ifnet *);
struct sockaddr;
extern	u_char	ip6_protox[];

void	in6_sin6_2_sin(struct sockaddr_in *sin,
			    struct sockaddr_in6 *sin6);
void	in6_sin_2_v4mapsin6(struct sockaddr_in *sin,
				 struct sockaddr_in6 *sin6);
void	in6_sin6_2_sin_in_sock(struct sockaddr *nam);
void	in6_sin_2_v4mapsin6_in_sock(struct sockaddr **nam);
extern void addrsel_policy_init(void);

#define	satosin6(sa)	((struct sockaddr_in6 *)(sa))
#define	sin6tosa(sin6)	((struct sockaddr *)(sin6))
#define	ifatoia6(ifa)	((struct in6_ifaddr *)(ifa))

#endif /* _KERNEL */
# 688 "/usr/include/netinet6/in6.h" 3 4

#ifndef _SIZE_T_DECLARED
typedef	__size_t	size_t;
#define	_SIZE_T_DECLARED
#endif
# 693 "/usr/include/netinet6/in6.h" 3 4

#ifndef _SOCKLEN_T_DECLARED
typedef	__socklen_t	socklen_t;
#define	_SOCKLEN_T_DECLARED
#endif
# 698 "/usr/include/netinet6/in6.h" 3 4

#if __BSD_VISIBLE

__BEGIN_DECLS
struct cmsghdr;

extern int inet6_option_space(int);
extern int inet6_option_init(void *, struct cmsghdr **, int);
extern int inet6_option_append(struct cmsghdr *, const uint8_t *,
	int, int);
extern uint8_t *inet6_option_alloc(struct cmsghdr *, int, int, int);
extern int inet6_option_next(const struct cmsghdr *, uint8_t **);
extern int inet6_option_find(const struct cmsghdr *, uint8_t **, int);

extern size_t inet6_rthdr_space(int, int);
extern struct cmsghdr *inet6_rthdr_init(void *, int);
extern int inet6_rthdr_add(struct cmsghdr *, const struct in6_addr *,
	unsigned int);
extern int inet6_rthdr_lasthop(struct cmsghdr *, unsigned int);
#if 0 /* not implemented yet */
extern int inet6_rthdr_reverse(const struct cmsghdr *, struct cmsghdr *);
#endif
# 720 "/usr/include/netinet6/in6.h" 3 4
extern int inet6_rthdr_segments(const struct cmsghdr *);
extern struct in6_addr *inet6_rthdr_getaddr(struct cmsghdr *, int);
extern int inet6_rthdr_getflags(const struct cmsghdr *, int);

extern int inet6_opt_init(void *, socklen_t);
extern int inet6_opt_append(void *, socklen_t, int, uint8_t, socklen_t,
	uint8_t, void **);
extern int inet6_opt_finish(void *, socklen_t, int);
extern int inet6_opt_set_val(void *, int, void *, socklen_t);

extern int inet6_opt_next(void *, socklen_t, int, uint8_t *, socklen_t *,
	void **);
extern int inet6_opt_find(void *, socklen_t, int, uint8_t, socklen_t *,
	void **);
extern int inet6_opt_get_val(void *, int, void *, socklen_t);
extern socklen_t inet6_rth_space(int, int);
extern void *inet6_rth_init(void *, socklen_t, int, int);
extern int inet6_rth_add(void *, const struct in6_addr *);
extern int inet6_rth_reverse(const void *, void *);
extern int inet6_rth_segments(const void *);
extern struct in6_addr *inet6_rth_getaddr(const void *, int);
__END_DECLS

#endif /* __BSD_VISIBLE */
# 744 "/usr/include/netinet6/in6.h" 3 4

#endif /* !_NETINET6_IN6_H_ */
# 746 "/usr/include/netinet6/in6.h" 3 4
# 666 "/usr/include/netinet/in.h" 2 3 4
#undef __KAME_NETINET_IN_H_INCLUDED_
#endif
# 668 "/usr/include/netinet/in.h" 3 4

#endif /* !_NETINET_IN_H_*/
# 670 "/usr/include/netinet/in.h" 3 4
# 141 "include/libbb.h" 2
#if 0 /* expanded by -frewrite-includes */
# include <arpa/inet.h>
#endif /* expanded by -frewrite-includes */
# 141 "include/libbb.h"
# 1 "/usr/include/arpa/inet.h" 1 3 4
/*
 * ++Copyright++ 1983, 1993
 * -
 * Copyright (c) 1983, 1993
 *    The Regents of the University of California.  All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * -
 * Portions Copyright (c) 1993 by Digital Equipment Corporation.
 * 
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies, and that
 * the name of Digital Equipment Corporation not be used in advertising or
 * publicity pertaining to distribution of the document or software without
 * specific, written prior permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT
 * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 * -
 * --Copyright--
 */

/*%
 *	@(#)inet.h	8.1 (Berkeley) 6/2/93
 *	$Id: inet.h,v 1.3 2005/04/27 04:56:16 sra Exp $
 * $FreeBSD: releng/11.0/include/arpa/inet.h 269867 2014-08-12 12:36:06Z ume $
 */

#ifndef _ARPA_INET_H_
#define	_ARPA_INET_H_

/* External definitions for functions in inet(3). */

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 63 "/usr/include/arpa/inet.h" 3 4
# 64 "/usr/include/arpa/inet.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 64 "/usr/include/arpa/inet.h" 3 4
# 65 "/usr/include/arpa/inet.h" 3 4

/* Required for byteorder(3) functions. */
#if 0 /* expanded by -frewrite-includes */
#include <machine/endian.h>
#endif /* expanded by -frewrite-includes */
# 67 "/usr/include/arpa/inet.h" 3 4
# 1 "/usr/include/machine/endian.h" 1 3 4
/*-
 * This file is in the public domain.
 */
/* $FreeBSD: releng/11.0/sys/amd64/include/endian.h 232266 2012-02-28 19:39:54Z tijl $ */

#if 0 /* expanded by -frewrite-includes */
#include <x86/endian.h>
#endif /* expanded by -frewrite-includes */
# 6 "/usr/include/machine/endian.h" 3 4
# 7 "/usr/include/machine/endian.h" 3 4
# 68 "/usr/include/arpa/inet.h" 2 3 4

#define	INET_ADDRSTRLEN		16
#define	INET6_ADDRSTRLEN	46

#ifndef _UINT16_T_DECLARED
typedef	__uint16_t	uint16_t;
#define	_UINT16_T_DECLARED
#endif
# 76 "/usr/include/arpa/inet.h" 3 4

#ifndef _UINT32_T_DECLARED
typedef	__uint32_t	uint32_t;
#define	_UINT32_T_DECLARED
#endif
# 81 "/usr/include/arpa/inet.h" 3 4

#ifndef _IN_ADDR_T_DECLARED
typedef	uint32_t	in_addr_t;
#define	_IN_ADDR_T_DECLARED
#endif
# 86 "/usr/include/arpa/inet.h" 3 4

#ifndef _IN_PORT_T_DECLARED
typedef	uint16_t	in_port_t;
#define	_IN_PORT_T_DECLARED
#endif
# 91 "/usr/include/arpa/inet.h" 3 4

#if __BSD_VISIBLE
#ifndef _SIZE_T_DECLARED
typedef	__size_t	size_t;
#define	_SIZE_T_DECLARED
#endif
# 97 "/usr/include/arpa/inet.h" 3 4
#endif
# 98 "/usr/include/arpa/inet.h" 3 4

/*
 * XXX socklen_t is used by a POSIX.1-2001 interface, but not required by
 * POSIX.1-2001.
 */
#ifndef _SOCKLEN_T_DECLARED
typedef	__socklen_t	socklen_t;
#define	_SOCKLEN_T_DECLARED
#endif
# 107 "/usr/include/arpa/inet.h" 3 4

#ifndef _STRUCT_IN_ADDR_DECLARED
struct in_addr {
	in_addr_t s_addr;
};
#define	_STRUCT_IN_ADDR_DECLARED
#endif
# 114 "/usr/include/arpa/inet.h" 3 4

/* XXX all new diversions!! argh!! */
#if __BSD_VISIBLE
#define	inet_addr		__inet_addr
#define	inet_aton		__inet_aton
#define	inet_lnaof		__inet_lnaof
#define	inet_makeaddr		__inet_makeaddr
#define	inet_neta		__inet_neta
#define	inet_netof		__inet_netof
#define	inet_network		__inet_network
#define	inet_net_ntop		__inet_net_ntop
#define	inet_net_pton		__inet_net_pton
#define	inet_cidr_ntop		__inet_cidr_ntop
#define	inet_cidr_pton		__inet_cidr_pton
#define	inet_ntoa		__inet_ntoa
#define	inet_ntoa_r		__inet_ntoa_r
#define	inet_pton		__inet_pton
#define	inet_ntop		__inet_ntop
#define	inet_nsap_addr		__inet_nsap_addr
#define	inet_nsap_ntoa		__inet_nsap_ntoa
#endif /* __BSD_VISIBLE */
# 135 "/usr/include/arpa/inet.h" 3 4

__BEGIN_DECLS
#ifndef _BYTEORDER_PROTOTYPED
#define	_BYTEORDER_PROTOTYPED
uint32_t	 htonl(uint32_t);
uint16_t	 htons(uint16_t);
uint32_t	 ntohl(uint32_t);
uint16_t	 ntohs(uint16_t);
#endif
# 144 "/usr/include/arpa/inet.h" 3 4

in_addr_t	 inet_addr(const char *);
/*const*/ char	*inet_ntoa(struct in_addr);
const char	*inet_ntop(int, const void * __restrict, char * __restrict,
		    socklen_t);
int		 inet_pton(int, const char * __restrict, void * __restrict);

#if __BSD_VISIBLE
int		 inet_aton(const char *, struct in_addr *);
in_addr_t	 inet_lnaof(struct in_addr);
struct in_addr	 inet_makeaddr(in_addr_t, in_addr_t);
char *		 inet_neta(in_addr_t, char *, size_t);
in_addr_t	 inet_netof(struct in_addr);
in_addr_t	 inet_network(const char *);
char		*inet_net_ntop(int, const void *, int, char *, size_t);
int		 inet_net_pton(int, const char *, void *, size_t);
char		*inet_ntoa_r(struct in_addr, char *buf, socklen_t size);
char		*inet_cidr_ntop(int, const void *, int, char *, size_t);
int		 inet_cidr_pton(int, const char *, void *, int *);
unsigned	 inet_nsap_addr(const char *, unsigned char *, int);
char		*inet_nsap_ntoa(int, const unsigned char *, char *);
#endif /* __BSD_VISIBLE */
# 166 "/usr/include/arpa/inet.h" 3 4
__END_DECLS

#ifndef _BYTEORDER_FUNC_DEFINED
#define	_BYTEORDER_FUNC_DEFINED
#define	htonl(x)	__htonl(x)
#define	htons(x)	__htons(x)
#define	ntohl(x)	__ntohl(x)
#define	ntohs(x)	__ntohs(x)
#endif
# 175 "/usr/include/arpa/inet.h" 3 4

#endif /* !_ARPA_INET_H_ */
# 177 "/usr/include/arpa/inet.h" 3 4

/*! \file */
# 142 "include/libbb.h" 2
#elif defined __APPLE__
# 143 "include/libbb.h"
#if 0 /* expanded by -frewrite-includes */
# include <netinet/in.h>
#endif /* expanded by -frewrite-includes */
# 143 "include/libbb.h"
# 144 "include/libbb.h"
#else
# 145 "include/libbb.h"
#if 0 /* expanded by -frewrite-includes */
# include <arpa/inet.h>
#endif /* expanded by -frewrite-includes */
# 145 "include/libbb.h"
# 146 "include/libbb.h"
//This breaks on bionic:
//# if !defined(__socklen_t_defined) && !defined(_SOCKLEN_T_DECLARED)
///* We #define socklen_t *after* includes, otherwise we get
// * typedef redefinition errors from system headers
// * (in case "is it defined already" detection above failed)
// */
//#  define socklen_t bb_socklen_t
//   typedef unsigned socklen_t;
//# endif
//if this is still needed, add a fix along the lines of
//  ifdef SPECIFIC_BROKEN_LIBC_CHECK / typedef socklen_t / endif
//in platform.h instead!
#endif
# 159 "include/libbb.h"
#ifndef HAVE_CLEARENV
# define clearenv() do { if (environ) environ[0] = NULL; } while (0)
#endif
# 162 "include/libbb.h"
#ifndef HAVE_FDATASYNC
# define fdatasync fsync
#endif
# 165 "include/libbb.h"


/* Some libc's forget to declare these, do it ourself */

extern char **environ;
#if defined(__GLIBC__) && __GLIBC__ < 2
int vdprintf(int d, const char *format, va_list ap);
#endif
# 173 "include/libbb.h"
/* klogctl is in libc's klog.h, but we cheat and not #include that */
int klogctl(int type, char *b, int len);
#ifndef PATH_MAX
# define PATH_MAX 256
#endif
# 178 "include/libbb.h"
#ifndef BUFSIZ
# define BUFSIZ 4096
#endif
# 181 "include/libbb.h"


/* Busybox does not use threads, we can speed up stdio. */
#ifdef HAVE_UNLOCKED_STDIO
# undef  getc
# define getc(stream)   getc_unlocked(stream)
# undef  getchar
# define getchar()      getchar_unlocked()
# undef  putc
# define putc(c,stream) putc_unlocked(c,stream)
# undef  putchar
# define putchar(c)     putchar_unlocked(c)
# undef  fgetc
# define fgetc(stream)  getc_unlocked(stream)
# undef  fputc
# define fputc(c,stream) putc_unlocked(c,stream)
#endif
# 198 "include/libbb.h"
/* Above functions are required by POSIX.1-2008, below ones are extensions */
#ifdef HAVE_UNLOCKED_LINE_OPS
# undef  fgets
# define fgets(s,n,stream) fgets_unlocked(s,n,stream)
# undef  fputs
# define fputs(s,stream) fputs_unlocked(s,stream)
/* musl <= 1.1.15 does not support fflush_unlocked(NULL) */
//# undef  fflush
//# define fflush(stream) fflush_unlocked(stream)
# undef  feof
# define feof(stream)   feof_unlocked(stream)
# undef  ferror
# define ferror(stream) ferror_unlocked(stream)
# undef  fileno
# define fileno(stream) fileno_unlocked(stream)
#endif
# 214 "include/libbb.h"


/* Make all declarations hidden (-fvisibility flag only affects definitions) */
/* (don't include system headers after this until corresponding pop!) */
PUSH_AND_SET_FUNCTION_VISIBILITY_TO_HIDDEN


#if ENABLE_USE_BB_PWD_GRP
#if 0 /* expanded by -frewrite-includes */
# include "pwd_.h"
#endif /* expanded by -frewrite-includes */
# 222 "include/libbb.h"
# 1 "include/pwd_.h" 1
/* vi: set sw=4 ts=4: */
/* Copyright (C) 1991,92,95,96,97,98,99,2001 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 * POSIX Standard: 9.2.2 User Database Access	<pwd.h>
 */

#ifndef BB_PWD_H
#define BB_PWD_H 1

PUSH_AND_SET_FUNCTION_VISIBILITY_TO_HIDDEN

/* This file is #included after #include <pwd.h>
 * We will use libc-defined structures, but will #define function names
 * so that function calls are directed to bb_internal_XXX replacements
 */
#undef endpwent
#define setpwent    bb_internal_setpwent
#define endpwent    bb_internal_endpwent
#define getpwent    bb_internal_getpwent
#define getpwuid    bb_internal_getpwuid
#define getpwnam    bb_internal_getpwnam
#define getpwnam_r  bb_internal_getpwnam_r

/* All function names below should be remapped by #defines above
 * in order to not collide with libc names. */

/* Rewind the password-file stream.  */
void FAST_FUNC setpwent(void);

/* Close the password-file stream.  */
void FAST_FUNC endpwent(void);

/* Read an entry from the password-file stream, opening it if necessary.  */
struct passwd* FAST_FUNC getpwent(void);

/* Search for an entry with a matching user ID.  */
struct passwd* FAST_FUNC getpwuid(uid_t __uid);

/* Search for an entry with a matching username.  */
struct passwd* FAST_FUNC getpwnam(const char *__name);

/* Reentrant versions of some of the functions above. */
int FAST_FUNC getpwnam_r(const char *__restrict __name,
		struct passwd *__restrict __resultbuf,
		char *__restrict __buffer, size_t __buflen,
		struct passwd **__restrict __result);

POP_SAVED_FUNCTION_VISIBILITY

#endif
# 68 "include/pwd_.h"
# 223 "include/libbb.h" 2
#if 0 /* expanded by -frewrite-includes */
# include "grp_.h"
#endif /* expanded by -frewrite-includes */
# 223 "include/libbb.h"
# 1 "include/grp_.h" 1
/* vi: set sw=4 ts=4: */
/* Copyright (C) 1991,92,95,96,97,98,99,2000,01 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.
 */
/*
 * POSIX Standard: 9.2.1 Group Database Access	<grp.h>
 */
#ifndef BB_GRP_H
#define BB_GRP_H 1

PUSH_AND_SET_FUNCTION_VISIBILITY_TO_HIDDEN

/* This file is #included after #include <grp.h>
 * We will use libc-defined structures, but will #define function names
 * so that function calls are directed to bb_internal_XXX replacements
 */
#undef endgrent
#define endgrent     bb_internal_endgrent
#define getgrgid     bb_internal_getgrgid
#define getgrnam     bb_internal_getgrnam
#define getgrouplist bb_internal_getgrouplist
#define initgroups   bb_internal_initgroups

/* All function names below should be remapped by #defines above
 * in order to not collide with libc names. */

/* Close the group-file stream.  */
void FAST_FUNC endgrent(void);

/* Search for an entry with a matching group ID.  */
struct group* FAST_FUNC getgrgid(gid_t __gid);

/* Search for an entry with a matching group name.  */
struct group* FAST_FUNC getgrnam(const char *__name);

/* Reentrant versions of some of the functions above. */

/* Store at most *NGROUPS members of the group set for USER into
   *GROUPS.  Also include GROUP.  The actual number of groups found is
   returned in *NGROUPS.  Return -1 if the if *NGROUPS is too small.  */
int FAST_FUNC getgrouplist(const char *__user, gid_t __group,
		gid_t *__groups, int *__ngroups);

/* Initialize the group set for the current user
   by reading the group database and using all groups
   of which USER is a member.  Also include GROUP.  */
int FAST_FUNC initgroups(const char *__user, gid_t __group);

POP_SAVED_FUNCTION_VISIBILITY

#endif
# 67 "include/grp_.h"
# 224 "include/libbb.h" 2
#endif
# 225 "include/libbb.h"
#if ENABLE_FEATURE_SHADOWPASSWDS
# if ENABLE_USE_BB_SHADOW
#if 0 /* expanded by -frewrite-includes */
#  include "shadow_.h"
#endif /* expanded by -frewrite-includes */
# 227 "include/libbb.h"
# 228 "include/libbb.h"
# endif
# 229 "include/libbb.h"
#endif
# 230 "include/libbb.h"

/* Tested to work correctly with all int types (IIRC :]) */
#define MAXINT(T) (T)( \
	((T)-1) > 0 \
	? (T)-1 \
	: (T)~((T)1 << (sizeof(T)*8-1)) \
	)

#define MININT(T) (T)( \
	((T)-1) > 0 \
	? (T)0 \
	: ((T)1 << (sizeof(T)*8-1)) \
	)

/* Large file support */
/* Note that CONFIG_LFS=y forces bbox to be built with all common ops
 * (stat, lseek etc) mapped to "largefile" variants by libc.
 * Practically it means that open() automatically has O_LARGEFILE added
 * and all filesize/file_offset parameters and struct members are "large"
 * (in today's world - signed 64bit). For full support of large files,
 * we need a few helper #defines (below) and careful use of off_t
 * instead of int/ssize_t. No lseek64(), O_LARGEFILE etc necessary */
#if ENABLE_LFS
/* CONFIG_LFS is on */
# if ULONG_MAX > 0xffffffff
/* "long" is long enough on this system */
typedef unsigned long uoff_t;
#  define XATOOFF(a) xatoul_range((a), 0, LONG_MAX)
/* usage: sz = BB_STRTOOFF(s, NULL, 10); if (errno || sz < 0) die(); */
#  define BB_STRTOOFF bb_strtoul
#  define STRTOOFF strtoul
/* usage: printf("size: %"OFF_FMT"d (%"OFF_FMT"x)\n", sz, sz); */
#  define OFF_FMT "l"
# else
# 264 "include/libbb.h"
/* "long" is too short, need "long long" */
typedef unsigned long long uoff_t;
#  define XATOOFF(a) xatoull_range((a), 0, LLONG_MAX)
#  define BB_STRTOOFF bb_strtoull
#  define STRTOOFF strtoull
#  define OFF_FMT "ll"
# endif
# 271 "include/libbb.h"
#else
# 272 "include/libbb.h"
/* CONFIG_LFS is off */
# if UINT_MAX == 0xffffffff
/* While sizeof(off_t) == sizeof(int), off_t is typedef'ed to long anyway.
 * gcc will throw warnings on printf("%d", off_t). Crap... */
typedef unsigned long uoff_t;
#  define XATOOFF(a) xatoi_positive(a)
#  define BB_STRTOOFF bb_strtou
#  define STRTOOFF strtol
#  define OFF_FMT "l"
# else
# 282 "include/libbb.h"
typedef unsigned long uoff_t;
#  define XATOOFF(a) xatoul_range((a), 0, LONG_MAX)
#  define BB_STRTOOFF bb_strtoul
#  define STRTOOFF strtol
#  define OFF_FMT "l"
# endif
# 288 "include/libbb.h"
#endif
# 289 "include/libbb.h"
/* scary. better ideas? (but do *test* them first!) */
#define OFF_T_MAX  ((off_t)~((off_t)1 << (sizeof(off_t)*8-1)))
/* Users report bionic to use 32-bit off_t even if LARGEFILE support is requested.
 * We misdetected that. Don't let it build:
 */
struct BUG_off_t_size_is_misdetected {
	char BUG_off_t_size_is_misdetected[sizeof(off_t) == sizeof(uoff_t) ? 1 : -1];
};

/* Some useful definitions */
#undef FALSE
#define FALSE   ((int) 0)
#undef TRUE
#define TRUE    ((int) 1)
#undef SKIP
#define SKIP	((int) 2)

/* Macros for min/max.  */
#ifndef MIN
#define MIN(a,b) (((a)<(b))?(a):(b))
#endif
# 310 "include/libbb.h"

#ifndef MAX
#define MAX(a,b) (((a)>(b))?(a):(b))
#endif
# 314 "include/libbb.h"

/* buffer allocation schemes */
#if ENABLE_FEATURE_BUFFERS_GO_ON_STACK
#define RESERVE_CONFIG_BUFFER(buffer,len)  char buffer[len]
#define RESERVE_CONFIG_UBUFFER(buffer,len) unsigned char buffer[len]
#define RELEASE_CONFIG_BUFFER(buffer)      ((void)0)
#else
# 321 "include/libbb.h"
#if ENABLE_FEATURE_BUFFERS_GO_IN_BSS
#define RESERVE_CONFIG_BUFFER(buffer,len)  static          char buffer[len]
#define RESERVE_CONFIG_UBUFFER(buffer,len) static unsigned char buffer[len]
#define RELEASE_CONFIG_BUFFER(buffer)      ((void)0)
#else
# 326 "include/libbb.h"
#define RESERVE_CONFIG_BUFFER(buffer,len)  char *buffer = xmalloc(len)
#define RESERVE_CONFIG_UBUFFER(buffer,len) unsigned char *buffer = xmalloc(len)
#define RELEASE_CONFIG_BUFFER(buffer)      free(buffer)
#endif
# 330 "include/libbb.h"
#endif
# 331 "include/libbb.h"

#if defined(__GLIBC__)
/* glibc uses __errno_location() to get a ptr to errno */
/* We can just memorize it once - no multithreading in busybox :) */
extern int *const bb_errno;
#undef errno
#define errno (*bb_errno)
#endif
# 339 "include/libbb.h"

#if !(ULONG_MAX > 0xffffffff)
/* Only 32-bit CPUs need this, 64-bit ones use inlined version */
uint64_t bb_bswap_64(uint64_t x) FAST_FUNC;
#endif
# 344 "include/libbb.h"

unsigned long long monotonic_ns(void) FAST_FUNC;
unsigned long long monotonic_us(void) FAST_FUNC;
unsigned long long monotonic_ms(void) FAST_FUNC;
unsigned monotonic_sec(void) FAST_FUNC;

extern void chomp(char *s) FAST_FUNC;
extern void trim(char *s) FAST_FUNC;
extern char *skip_whitespace(const char *) FAST_FUNC;
extern char *skip_non_whitespace(const char *) FAST_FUNC;
extern char *skip_dev_pfx(const char *tty_name) FAST_FUNC;

extern char *strrstr(const char *haystack, const char *needle) FAST_FUNC;

//TODO: supply a pointer to char[11] buffer (avoid statics)?
extern const char *bb_mode_string(mode_t mode) FAST_FUNC;
extern int is_directory(const char *name, int followLinks) FAST_FUNC;
enum {	/* cp.c, mv.c, install.c depend on these values. CAREFUL when changing them! */
	FILEUTILS_PRESERVE_STATUS = 1 << 0, /* -p */
	FILEUTILS_DEREFERENCE     = 1 << 1, /* !-d */
	FILEUTILS_RECUR           = 1 << 2, /* -R */
	FILEUTILS_FORCE           = 1 << 3, /* -f */
	FILEUTILS_INTERACTIVE     = 1 << 4, /* -i */
	FILEUTILS_MAKE_HARDLINK   = 1 << 5, /* -l */
	FILEUTILS_MAKE_SOFTLINK   = 1 << 6, /* -s */
	FILEUTILS_DEREF_SOFTLINK  = 1 << 7, /* -L */
	FILEUTILS_DEREFERENCE_L0  = 1 << 8, /* -H */
	/* -a = -pdR (mapped in cp.c) */
	/* -r = -dR  (mapped in cp.c) */
	/* -P = -d   (mapped in cp.c) */
	FILEUTILS_VERBOSE         = (1 << 12) * ENABLE_FEATURE_VERBOSE,	/* -v */
	FILEUTILS_UPDATE          = 1 << 13, /* -u */
#if ENABLE_SELINUX
	FILEUTILS_PRESERVE_SECURITY_CONTEXT = 1 << 14, /* -c */
#endif
# 379 "include/libbb.h"
	FILEUTILS_RMDEST          = 1 << (15 - !ENABLE_SELINUX), /* --remove-destination */
	/*
	 * Hole. cp may have some bits set here,
	 * they should not affect remove_file()/copy_file()
	 */
#if ENABLE_SELINUX
	FILEUTILS_SET_SECURITY_CONTEXT = 1 << 30,
#endif
# 387 "include/libbb.h"
	FILEUTILS_IGNORE_CHMOD_ERR = 1 << 31,
};
#define FILEUTILS_CP_OPTSTR "pdRfilsLHarPvu" IF_SELINUX("c")
extern int remove_file(const char *path, int flags) FAST_FUNC;
/* NB: without FILEUTILS_RECUR in flags, it will basically "cat"
 * the source, not copy (unless "source" is a directory).
 * This makes "cp /dev/null file" and "install /dev/null file" (!!!)
 * work coreutils-compatibly. */
extern int copy_file(const char *source, const char *dest, int flags) FAST_FUNC;

enum {
	ACTION_RECURSE        = (1 << 0),
	ACTION_FOLLOWLINKS    = (1 << 1),
	ACTION_FOLLOWLINKS_L0 = (1 << 2),
	ACTION_DEPTHFIRST     = (1 << 3),
	/*ACTION_REVERSE      = (1 << 4), - unused */
	ACTION_QUIET          = (1 << 5),
	ACTION_DANGLING_OK    = (1 << 6),
};
typedef uint8_t recurse_flags_t;
extern int recursive_action(const char *fileName, unsigned flags,
	int FAST_FUNC (*fileAction)(const char *fileName, struct stat* statbuf, void* userData, int depth),
	int FAST_FUNC (*dirAction)(const char *fileName, struct stat* statbuf, void* userData, int depth),
	void* userData, unsigned depth) FAST_FUNC;
extern int device_open(const char *device, int mode) FAST_FUNC;
enum { GETPTY_BUFSIZE = 16 }; /* more than enough for "/dev/ttyXXX" */
extern int xgetpty(char *line) FAST_FUNC;
extern int get_console_fd_or_die(void) FAST_FUNC;
extern void console_make_active(int fd, const int vt_num) FAST_FUNC;
extern char *find_block_device(const char *path) FAST_FUNC;
/* bb_copyfd_XX print read/write errors and return -1 if they occur */
extern off_t bb_copyfd_eof(int fd1, int fd2) FAST_FUNC;
extern off_t bb_copyfd_size(int fd1, int fd2, off_t size) FAST_FUNC;
extern void bb_copyfd_exact_size(int fd1, int fd2, off_t size) FAST_FUNC;
/* "short" copy can be detected by return value < size */
/* this helper yells "short read!" if param is not -1 */
extern void complain_copyfd_and_die(off_t sz) NORETURN FAST_FUNC;

extern char bb_process_escape_sequence(const char **ptr) FAST_FUNC;
char* strcpy_and_process_escape_sequences(char *dst, const char *src) FAST_FUNC;
/* xxxx_strip version can modify its parameter:
 * "/"        -> "/"
 * "abc"      -> "abc"
 * "abc/def"  -> "def"
 * "abc/def/" -> "def" !!
 */
char *bb_get_last_path_component_strip(char *path) FAST_FUNC;
/* "abc/def/" -> "" and it never modifies 'path' */
char *bb_get_last_path_component_nostrip(const char *path) FAST_FUNC;
/* Simpler version: does not special case "/" string */
const char *bb_basename(const char *name) FAST_FUNC;
/* NB: can violate const-ness (similarly to strchr) */
char *last_char_is(const char *s, int c) FAST_FUNC;
const char* endofname(const char *name) FAST_FUNC;
char *is_prefixed_with(const char *string, const char *key) FAST_FUNC;
char *is_suffixed_with(const char *string, const char *key) FAST_FUNC;

int ndelay_on(int fd) FAST_FUNC;
int ndelay_off(int fd) FAST_FUNC;
void close_on_exec_on(int fd) FAST_FUNC;
void xdup2(int, int) FAST_FUNC;
void xmove_fd(int, int) FAST_FUNC;


DIR *xopendir(const char *path) FAST_FUNC;
DIR *warn_opendir(const char *path) FAST_FUNC;

char *xmalloc_realpath(const char *path) FAST_FUNC RETURNS_MALLOC;
char *xmalloc_readlink(const char *path) FAST_FUNC RETURNS_MALLOC;
char *xmalloc_readlink_or_warn(const char *path) FAST_FUNC RETURNS_MALLOC;
/* !RETURNS_MALLOC: it's a realloc-like function */
char *xrealloc_getcwd_or_warn(char *cwd) FAST_FUNC;

char *xmalloc_follow_symlinks(const char *path) FAST_FUNC RETURNS_MALLOC;


enum {
	/* bb_signals(BB_FATAL_SIGS, handler) catches all signals which
	 * otherwise would kill us, except for those resulting from bugs:
	 * SIGSEGV, SIGILL, SIGFPE.
	 * Other fatal signals not included (TODO?):
	 * SIGBUS   Bus error (bad memory access)
	 * SIGPOLL  Pollable event. Synonym of SIGIO
	 * SIGPROF  Profiling timer expired
	 * SIGSYS   Bad argument to routine
	 * SIGTRAP  Trace/breakpoint trap
	 *
	 * The only known arch with some of these sigs not fitting
	 * into 32 bits is parisc (SIGXCPU=33, SIGXFSZ=34, SIGSTKFLT=36).
	 * Dance around with long long to guard against that...
	 */
	BB_FATAL_SIGS = (int)(0
		+ (1LL << SIGHUP)
		+ (1LL << SIGINT)
		+ (1LL << SIGTERM)
		+ (1LL << SIGPIPE)   // Write to pipe with no readers
		+ (1LL << SIGQUIT)   // Quit from keyboard
		+ (1LL << SIGABRT)   // Abort signal from abort(3)
		+ (1LL << SIGALRM)   // Timer signal from alarm(2)
		+ (1LL << SIGVTALRM) // Virtual alarm clock
		+ (1LL << SIGXCPU)   // CPU time limit exceeded
		+ (1LL << SIGXFSZ)   // File size limit exceeded
		+ (1LL << SIGUSR1)   // Yes kids, these are also fatal!
		+ (1LL << SIGUSR2)
		+ 0),
};
void bb_signals(int sigs, void (*f)(int)) FAST_FUNC;
/* Unlike signal() and bb_signals, sets handler with sigaction()
 * and in a way that while signal handler is run, no other signals
 * will be blocked; syscalls will not be restarted: */
void bb_signals_recursive_norestart(int sigs, void (*f)(int)) FAST_FUNC;
/* syscalls like read() will be interrupted with EINTR: */
void signal_no_SA_RESTART_empty_mask(int sig, void (*handler)(int)) FAST_FUNC;
/* syscalls like read() won't be interrupted (though select/poll will be): */
void signal_SA_RESTART_empty_mask(int sig, void (*handler)(int)) FAST_FUNC;
void wait_for_any_sig(void) FAST_FUNC;
void kill_myself_with_sig(int sig) NORETURN FAST_FUNC;
void sig_block(int sig) FAST_FUNC;
void sig_unblock(int sig) FAST_FUNC;
/* Will do sigaction(signum, act, NULL): */
int sigaction_set(int sig, const struct sigaction *act) FAST_FUNC;
/* SIG_BLOCK/SIG_UNBLOCK all signals: */
int sigprocmask_allsigs(int how) FAST_FUNC;
/* Standard handler which just records signo */
extern smallint bb_got_signal;
void record_signo(int signo); /* not FAST_FUNC! */


void xsetgid(gid_t gid) FAST_FUNC;
void xsetuid(uid_t uid) FAST_FUNC;
void xsetegid(gid_t egid) FAST_FUNC;
void xseteuid(uid_t euid) FAST_FUNC;
void xchdir(const char *path) FAST_FUNC;
void xfchdir(int fd) FAST_FUNC;
void xchroot(const char *path) FAST_FUNC;
void xsetenv(const char *key, const char *value) FAST_FUNC;
void bb_unsetenv(const char *key) FAST_FUNC;
void bb_unsetenv_and_free(char *key) FAST_FUNC;
void xunlink(const char *pathname) FAST_FUNC;
void xstat(const char *pathname, struct stat *buf) FAST_FUNC;
void xfstat(int fd, struct stat *buf, const char *errmsg) FAST_FUNC;
int open3_or_warn(const char *pathname, int flags, int mode) FAST_FUNC;
int open_or_warn(const char *pathname, int flags) FAST_FUNC;
int xopen3(const char *pathname, int flags, int mode) FAST_FUNC;
int xopen(const char *pathname, int flags) FAST_FUNC;
int xopen_nonblocking(const char *pathname) FAST_FUNC;
int xopen_as_uid_gid(const char *pathname, int flags, uid_t u, gid_t g) FAST_FUNC;
int open_or_warn_stdin(const char *pathname) FAST_FUNC;
int xopen_stdin(const char *pathname) FAST_FUNC;
void xrename(const char *oldpath, const char *newpath) FAST_FUNC;
int rename_or_warn(const char *oldpath, const char *newpath) FAST_FUNC;
off_t xlseek(int fd, off_t offset, int whence) FAST_FUNC;
int xmkstemp(char *template) FAST_FUNC;
off_t fdlength(int fd) FAST_FUNC;

uoff_t FAST_FUNC get_volume_size_in_bytes(int fd,
		const char *override,
		unsigned override_units,
		int extend);

void xpipe(int filedes[2]) FAST_FUNC;
/* In this form code with pipes is much more readable */
struct fd_pair { int rd; int wr; };
#define piped_pair(pair)  pipe(&((pair).rd))
#define xpiped_pair(pair) xpipe(&((pair).rd))

/* Useful for having small structure members/global variables */
typedef int8_t socktype_t;
typedef int8_t family_t;
struct BUG_too_small {
	char BUG_socktype_t_too_small[(0
			| SOCK_STREAM
			| SOCK_DGRAM
			| SOCK_RDM
			| SOCK_SEQPACKET
			| SOCK_RAW
			) <= 127 ? 1 : -1];
	char BUG_family_t_too_small[(0
			| AF_UNSPEC
			| AF_INET
			| AF_INET6
			| AF_UNIX
#ifdef AF_PACKET
			| AF_PACKET
#endif
# 572 "include/libbb.h"
#ifdef AF_NETLINK
			| AF_NETLINK
#endif
# 575 "include/libbb.h"
			/* | AF_DECnet */
			/* | AF_IPX */
			) <= 127 ? 1 : -1];
};


void parse_datestr(const char *date_str, struct tm *ptm) FAST_FUNC;
time_t validate_tm_time(const char *date_str, struct tm *ptm) FAST_FUNC;
char *strftime_HHMMSS(char *buf, unsigned len, time_t *tp) FAST_FUNC;
char *strftime_YYYYMMDDHHMMSS(char *buf, unsigned len, time_t *tp) FAST_FUNC;

int xsocket(int domain, int type, int protocol) FAST_FUNC;
void xbind(int sockfd, struct sockaddr *my_addr, socklen_t addrlen) FAST_FUNC;
void xlisten(int s, int backlog) FAST_FUNC;
void xconnect(int s, const struct sockaddr *s_addr, socklen_t addrlen) FAST_FUNC;
ssize_t xsendto(int s, const void *buf, size_t len, const struct sockaddr *to,
				socklen_t tolen) FAST_FUNC;

int setsockopt_int(int fd, int level, int optname, int optval) FAST_FUNC;
int setsockopt_1(int fd, int level, int optname) FAST_FUNC;
int setsockopt_SOL_SOCKET_int(int fd, int optname, int optval) FAST_FUNC;
int setsockopt_SOL_SOCKET_1(int fd, int optname) FAST_FUNC;
/* SO_REUSEADDR allows a server to rebind to an address that is already
 * "in use" by old connections to e.g. previous server instance which is
 * killed or crashed. Without it bind will fail until all such connections
 * time out. Linux does not allow multiple live binds on same ip:port
 * regardless of SO_REUSEADDR (unlike some other flavors of Unix).
 * Turn it on before you call bind(). */
void setsockopt_reuseaddr(int fd) FAST_FUNC; /* On Linux this never fails. */
int setsockopt_keepalive(int fd) FAST_FUNC;
int setsockopt_broadcast(int fd) FAST_FUNC;
int setsockopt_bindtodevice(int fd, const char *iface) FAST_FUNC;
/* NB: returns port in host byte order */
unsigned bb_lookup_port(const char *port, const char *protocol, unsigned default_port) FAST_FUNC;
typedef struct len_and_sockaddr {
	socklen_t len;
	union {
		struct sockaddr sa;
		struct sockaddr_in sin;
#if ENABLE_FEATURE_IPV6
		struct sockaddr_in6 sin6;
#endif
# 617 "include/libbb.h"
	} u;
} len_and_sockaddr;
enum {
	LSA_LEN_SIZE = offsetof(len_and_sockaddr, u),
	LSA_SIZEOF_SA = sizeof(
		union {
			struct sockaddr sa;
			struct sockaddr_in sin;
#if ENABLE_FEATURE_IPV6
			struct sockaddr_in6 sin6;
#endif
# 628 "include/libbb.h"
		}
	)
};
/* Create stream socket, and allocate suitable lsa.
 * (lsa of correct size and lsa->sa.sa_family (AF_INET/AF_INET6))
 * af == AF_UNSPEC will result in trying to create IPv6 socket,
 * and if kernel doesn't support it, fall back to IPv4.
 * This is useful if you plan to bind to resulting local lsa.
 */
int xsocket_type(len_and_sockaddr **lsap, int af, int sock_type) FAST_FUNC;
int xsocket_stream(len_and_sockaddr **lsap) FAST_FUNC;
/* Create server socket bound to bindaddr:port. bindaddr can be NULL,
 * numeric IP ("N.N.N.N") or numeric IPv6 address,
 * and can have ":PORT" suffix (for IPv6 use "[X:X:...:X]:PORT").
 * Only if there is no suffix, port argument is used */
/* NB: these set SO_REUSEADDR before bind */
int create_and_bind_stream_or_die(const char *bindaddr, int port) FAST_FUNC;
int create_and_bind_dgram_or_die(const char *bindaddr, int port) FAST_FUNC;
/* Create client TCP socket connected to peer:port. Peer cannot be NULL.
 * Peer can be numeric IP ("N.N.N.N"), numeric IPv6 address or hostname,
 * and can have ":PORT" suffix (for IPv6 use "[X:X:...:X]:PORT").
 * If there is no suffix, port argument is used */
int create_and_connect_stream_or_die(const char *peer, int port) FAST_FUNC;
/* Connect to peer identified by lsa */
int xconnect_stream(const len_and_sockaddr *lsa) FAST_FUNC;
/* Get local address of bound or accepted socket */
len_and_sockaddr *get_sock_lsa(int fd) FAST_FUNC RETURNS_MALLOC;
/* Get remote address of connected or accepted socket */
len_and_sockaddr *get_peer_lsa(int fd) FAST_FUNC RETURNS_MALLOC;
/* Return malloc'ed len_and_sockaddr with socket address of host:port
 * Currently will return IPv4 or IPv6 sockaddrs only
 * (depending on host), but in theory nothing prevents e.g.
 * UNIX socket address being returned, IPX sockaddr etc...
 * On error does bb_error_msg and returns NULL */
len_and_sockaddr* host2sockaddr(const char *host, int port) FAST_FUNC RETURNS_MALLOC;
/* Version which dies on error */
len_and_sockaddr* xhost2sockaddr(const char *host, int port) FAST_FUNC RETURNS_MALLOC;
len_and_sockaddr* xdotted2sockaddr(const char *host, int port) FAST_FUNC RETURNS_MALLOC;
/* Same, useful if you want to force family (e.g. IPv6) */
#if !ENABLE_FEATURE_IPV6
#define host_and_af2sockaddr(host, port, af) host2sockaddr((host), (port))
#define xhost_and_af2sockaddr(host, port, af) xhost2sockaddr((host), (port))
#else
# 671 "include/libbb.h"
len_and_sockaddr* host_and_af2sockaddr(const char *host, int port, sa_family_t af) FAST_FUNC RETURNS_MALLOC;
len_and_sockaddr* xhost_and_af2sockaddr(const char *host, int port, sa_family_t af) FAST_FUNC RETURNS_MALLOC;
#endif
# 674 "include/libbb.h"
/* Assign sin[6]_port member if the socket is an AF_INET[6] one,
 * otherwise no-op. Useful for ftp.
 * NB: does NOT do htons() internally, just direct assignment. */
void set_nport(struct sockaddr *sa, unsigned port) FAST_FUNC;
/* Retrieve sin[6]_port or return -1 for non-INET[6] lsa's */
int get_nport(const struct sockaddr *sa) FAST_FUNC;
/* Reverse DNS. Returns NULL on failure. */
char* xmalloc_sockaddr2host(const struct sockaddr *sa) FAST_FUNC RETURNS_MALLOC;
/* This one doesn't append :PORTNUM */
char* xmalloc_sockaddr2host_noport(const struct sockaddr *sa) FAST_FUNC RETURNS_MALLOC;
/* This one also doesn't fall back to dotted IP (returns NULL) */
char* xmalloc_sockaddr2hostonly_noport(const struct sockaddr *sa) FAST_FUNC RETURNS_MALLOC;
/* inet_[ap]ton on steroids */
char* xmalloc_sockaddr2dotted(const struct sockaddr *sa) FAST_FUNC RETURNS_MALLOC;
char* xmalloc_sockaddr2dotted_noport(const struct sockaddr *sa) FAST_FUNC RETURNS_MALLOC;
// "old" (ipv4 only) API
// users: traceroute.c hostname.c - use _list_ of all IPs
struct hostent *xgethostbyname(const char *name) FAST_FUNC;
// Also mount.c and inetd.c are using gethostbyname(),
// + inet_common.c has additional IPv4-only stuff


void socket_want_pktinfo(int fd) FAST_FUNC;
ssize_t send_to_from(int fd, void *buf, size_t len, int flags,
		const struct sockaddr *to,
		const struct sockaddr *from,
		socklen_t tolen) FAST_FUNC;
ssize_t recv_from_to(int fd, void *buf, size_t len, int flags,
		struct sockaddr *from,
		struct sockaddr *to,
		socklen_t sa_size) FAST_FUNC;

uint16_t inet_cksum(uint16_t *addr, int len) FAST_FUNC;

char *xstrdup(const char *s) FAST_FUNC RETURNS_MALLOC;
char *xstrndup(const char *s, int n) FAST_FUNC RETURNS_MALLOC;
void *xmemdup(const void *s, int n) FAST_FUNC RETURNS_MALLOC;
void overlapping_strcpy(char *dst, const char *src) FAST_FUNC;
char *safe_strncpy(char *dst, const char *src, size_t size) FAST_FUNC;
char *strncpy_IFNAMSIZ(char *dst, const char *src) FAST_FUNC;
unsigned count_strstr(const char *str, const char *sub) FAST_FUNC;
char *xmalloc_substitute_string(const char *src, int count, const char *sub, const char *repl) FAST_FUNC;
/* Guaranteed to NOT be a macro (smallest code). Saves nearly 2k on uclibc.
 * But potentially slow, don't use in one-billion-times loops */
int bb_putchar(int ch) FAST_FUNC;
/* Note: does not use stdio, writes to fd 2 directly */
int bb_putchar_stderr(char ch) FAST_FUNC;
char *xasprintf(const char *format, ...) __attribute__ ((format(printf, 1, 2))) FAST_FUNC RETURNS_MALLOC;
char *auto_string(char *str) FAST_FUNC;
// gcc-4.1.1 still isn't good enough at optimizing it
// (+200 bytes compared to macro)
//static ALWAYS_INLINE
//int LONE_DASH(const char *s) { return s[0] == '-' && !s[1]; }
//static ALWAYS_INLINE
//int NOT_LONE_DASH(const char *s) { return s[0] != '-' || s[1]; }
#define LONE_DASH(s)     ((s)[0] == '-' && !(s)[1])
#define NOT_LONE_DASH(s) ((s)[0] != '-' || (s)[1])
#define LONE_CHAR(s,c)     ((s)[0] == (c) && !(s)[1])
#define NOT_LONE_CHAR(s,c) ((s)[0] != (c) || (s)[1])
#define DOT_OR_DOTDOT(s) ((s)[0] == '.' && (!(s)[1] || ((s)[1] == '.' && !(s)[2])))

typedef struct uni_stat_t {
	unsigned byte_count;
	unsigned unicode_count;
	unsigned unicode_width;
} uni_stat_t;
/* Returns a string with unprintable chars replaced by '?' or
 * SUBST_WCHAR. This function is unicode-aware. */
const char* FAST_FUNC printable_string(uni_stat_t *stats, const char *str);
/* Prints unprintable char ch as ^C or M-c to file
 * (M-c is used only if ch is ORed with PRINTABLE_META),
 * else it is printed as-is (except for ch = 0x9b) */
enum { PRINTABLE_META = 0x100 };
void fputc_printable(int ch, FILE *file) FAST_FUNC;
/* Return a string that is the printable representation of character ch.
 * Buffer must hold at least four characters. */
enum {
	VISIBLE_ENDLINE   = 1 << 0,
	VISIBLE_SHOW_TABS = 1 << 1,
};
void visible(unsigned ch, char *buf, int flags) FAST_FUNC;

/* dmalloc will redefine these to it's own implementation. It is safe
 * to have the prototypes here unconditionally.  */
void *malloc_or_warn(size_t size) FAST_FUNC RETURNS_MALLOC;
void *xmalloc(size_t size) FAST_FUNC RETURNS_MALLOC;
void *xzalloc(size_t size) FAST_FUNC RETURNS_MALLOC;
void *xrealloc(void *old, size_t size) FAST_FUNC;
/* After v = xrealloc_vector(v, SHIFT, idx) it's ok to use
 * at least v[idx] and v[idx+1], for all idx values.
 * SHIFT specifies how many new elements are added (1:2, 2:4, ..., 8:256...)
 * when all elements are used up. New elements are zeroed out.
 * xrealloc_vector(v, SHIFT, idx) *MUST* be called with consecutive IDXs -
 * skipping an index is a bad bug - it may miss a realloc!
 */
#define xrealloc_vector(vector, shift, idx) \
	xrealloc_vector_helper((vector), (sizeof((vector)[0]) << 8) + (shift), (idx))
void* xrealloc_vector_helper(void *vector, unsigned sizeof_and_shift, int idx) FAST_FUNC;


extern ssize_t safe_read(int fd, void *buf, size_t count) FAST_FUNC;
extern ssize_t nonblock_immune_read(int fd, void *buf, size_t count) FAST_FUNC;
// NB: will return short read on error, not -1,
// if some data was read before error occurred
extern ssize_t full_read(int fd, void *buf, size_t count) FAST_FUNC;
extern void xread(int fd, void *buf, size_t count) FAST_FUNC;
extern unsigned char xread_char(int fd) FAST_FUNC;
extern ssize_t read_close(int fd, void *buf, size_t maxsz) FAST_FUNC;
extern ssize_t open_read_close(const char *filename, void *buf, size_t maxsz) FAST_FUNC;
// Reads one line a-la fgets (but doesn't save terminating '\n').
// Reads byte-by-byte. Useful when it is important to not read ahead.
// Bytes are appended to pfx (which must be malloced, or NULL).
extern char *xmalloc_reads(int fd, size_t *maxsz_p) FAST_FUNC;
/* Reads block up to *maxsz_p (default: INT_MAX - 4095) */
extern void *xmalloc_read(int fd, size_t *maxsz_p) FAST_FUNC RETURNS_MALLOC;
/* Returns NULL if file can't be opened (default max size: INT_MAX - 4095) */
extern void *xmalloc_open_read_close(const char *filename, size_t *maxsz_p) FAST_FUNC RETURNS_MALLOC;
/* Never returns NULL */
extern void *xmalloc_xopen_read_close(const char *filename, size_t *maxsz_p) FAST_FUNC RETURNS_MALLOC;

#if defined(ARG_MAX) && (ARG_MAX >= 60*1024 || !defined(_SC_ARG_MAX))
/* Use _constant_ maximum if: defined && (big enough || no variable one exists) */
# define bb_arg_max() ((unsigned)ARG_MAX)
#elif defined(_SC_ARG_MAX)
# 798 "include/libbb.h"
/* Else use variable one (a bit more expensive) */
unsigned bb_arg_max(void) FAST_FUNC;
#else
# 801 "include/libbb.h"
/* If all else fails */
# define bb_arg_max() ((unsigned)(32 * 1024))
#endif
# 804 "include/libbb.h"
unsigned bb_clk_tck(void) FAST_FUNC;

#define SEAMLESS_COMPRESSION (0 \
 || ENABLE_FEATURE_SEAMLESS_XZ \
 || ENABLE_FEATURE_SEAMLESS_LZMA \
 || ENABLE_FEATURE_SEAMLESS_BZ2 \
 || ENABLE_FEATURE_SEAMLESS_GZ \
 || ENABLE_FEATURE_SEAMLESS_Z)

#if SEAMLESS_COMPRESSION
/* Autodetects gzip/bzip2 formats. fd may be in the middle of the file! */
extern int setup_unzip_on_fd(int fd, int fail_if_not_compressed) FAST_FUNC;
/* Autodetects .gz etc */
extern int open_zipped(const char *fname, int fail_if_not_compressed) FAST_FUNC;
extern void *xmalloc_open_zipped_read_close(const char *fname, size_t *maxsz_p) FAST_FUNC RETURNS_MALLOC;
#else
# 820 "include/libbb.h"
# define setup_unzip_on_fd(...) (0)
# define open_zipped(fname, fail_if_not_compressed)  open((fname), O_RDONLY);
# define xmalloc_open_zipped_read_close(fname, maxsz_p) xmalloc_open_read_close((fname), (maxsz_p))
#endif
# 824 "include/libbb.h"

extern ssize_t safe_write(int fd, const void *buf, size_t count) FAST_FUNC;
// NB: will return short write on error, not -1,
// if some data was written before error occurred
extern ssize_t full_write(int fd, const void *buf, size_t count) FAST_FUNC;
extern void xwrite(int fd, const void *buf, size_t count) FAST_FUNC;
extern void xwrite_str(int fd, const char *str) FAST_FUNC;
extern ssize_t full_write1_str(const char *str) FAST_FUNC;
extern ssize_t full_write2_str(const char *str) FAST_FUNC;
extern void xopen_xwrite_close(const char* file, const char *str) FAST_FUNC;

/* Close fd, but check for failures (some types of write errors) */
extern void xclose(int fd) FAST_FUNC;

/* Reads and prints to stdout till eof, then closes FILE. Exits on error: */
extern void xprint_and_close_file(FILE *file) FAST_FUNC;

/* Reads a line from a text file, up to a newline or NUL byte, inclusive.
 * Returns malloc'ed char*. If end is NULL '\n' isn't considered
 * end of line. If end isn't NULL, length of the chunk is stored in it.
 * Returns NULL if EOF/error.
 */
extern char *bb_get_chunk_from_file(FILE *file, int *end) FAST_FUNC;
/* Reads up to (and including) TERMINATING_STRING: */
extern char *xmalloc_fgets_str(FILE *file, const char *terminating_string) FAST_FUNC RETURNS_MALLOC;
/* Same, with limited max size, and returns the length (excluding NUL): */
extern char *xmalloc_fgets_str_len(FILE *file, const char *terminating_string, size_t *maxsz_p) FAST_FUNC RETURNS_MALLOC;
/* Chops off TERMINATING_STRING from the end: */
extern char *xmalloc_fgetline_str(FILE *file, const char *terminating_string) FAST_FUNC RETURNS_MALLOC;
/* Reads up to (and including) "\n" or NUL byte: */
extern char *xmalloc_fgets(FILE *file) FAST_FUNC RETURNS_MALLOC;
/* Chops off '\n' from the end, unlike fgets: */
extern char *xmalloc_fgetline(FILE *file) FAST_FUNC RETURNS_MALLOC;
/* Same, but doesn't try to conserve space (may have some slack after the end) */
/* extern char *xmalloc_fgetline_fast(FILE *file) FAST_FUNC RETURNS_MALLOC; */

void die_if_ferror(FILE *file, const char *msg) FAST_FUNC;
void die_if_ferror_stdout(void) FAST_FUNC;
int fflush_all(void) FAST_FUNC;
void fflush_stdout_and_exit(int retval) NORETURN FAST_FUNC;
int fclose_if_not_stdin(FILE *file) FAST_FUNC;
FILE* xfopen(const char *filename, const char *mode) FAST_FUNC;
/* Prints warning to stderr and returns NULL on failure: */
FILE* fopen_or_warn(const char *filename, const char *mode) FAST_FUNC;
/* "Opens" stdin if filename is special, else just opens file: */
FILE* xfopen_stdin(const char *filename) FAST_FUNC;
FILE* fopen_or_warn_stdin(const char *filename) FAST_FUNC;
FILE* fopen_for_read(const char *path) FAST_FUNC;
FILE* xfopen_for_read(const char *path) FAST_FUNC;
FILE* fopen_for_write(const char *path) FAST_FUNC;
FILE* xfopen_for_write(const char *path) FAST_FUNC;
FILE* xfdopen_for_read(int fd) FAST_FUNC;
FILE* xfdopen_for_write(int fd) FAST_FUNC;

int bb_pstrcmp(const void *a, const void *b) /* not FAST_FUNC! */;
void qsort_string_vector(char **sv, unsigned count) FAST_FUNC;

/* Wrapper which restarts poll on EINTR or ENOMEM.
 * On other errors complains [perror("poll")] and returns.
 * Warning! May take (much) longer than timeout_ms to return!
 * If this is a problem, use bare poll and open-code EINTR/ENOMEM handling */
int safe_poll(struct pollfd *ufds, nfds_t nfds, int timeout_ms) FAST_FUNC;

char *safe_gethostname(void) FAST_FUNC;

/* Convert each alpha char in str to lower-case */
char* str_tolower(char *str) FAST_FUNC;

char *utoa(unsigned n) FAST_FUNC;
char *itoa(int n) FAST_FUNC;
/* Returns a pointer past the formatted number, does NOT null-terminate */
char *utoa_to_buf(unsigned n, char *buf, unsigned buflen) FAST_FUNC;
char *itoa_to_buf(int n, char *buf, unsigned buflen) FAST_FUNC;
/* Intelligent formatters of bignums */
char *smart_ulltoa4(unsigned long long ul, char buf[4], const char *scale) FAST_FUNC;
char *smart_ulltoa5(unsigned long long ul, char buf[5], const char *scale) FAST_FUNC;
/* If block_size == 0, display size without fractional part,
 * else display (size * block_size) with one decimal digit.
 * If display_unit == 0, show value no bigger than 1024 with suffix (K,M,G...),
 * else divide by display_unit and do not use suffix. */
#define HUMAN_READABLE_MAX_WIDTH      7  /* "1024.0G" */
#define HUMAN_READABLE_MAX_WIDTH_STR "7"
//TODO: provide pointer to buf (avoid statics)?
const char *make_human_readable_str(unsigned long long size,
		unsigned long block_size, unsigned long display_unit) FAST_FUNC;
/* Put a string of hex bytes ("1b2e66fe"...), return advanced pointer */
char *bin2hex(char *dst, const char *src, int count) FAST_FUNC;
/* Reverse */
char* hex2bin(char *dst, const char *src, int count) FAST_FUNC;

/* Generate a UUID */
void generate_uuid(uint8_t *buf) FAST_FUNC;

/* Last element is marked by mult == 0 */
struct suffix_mult {
	char suffix[4];
	unsigned mult;
};
extern const struct suffix_mult bkm_suffixes[];
#define km_suffixes (bkm_suffixes + 1)
extern const struct suffix_mult cwbkMG_suffixes[];
#define kMG_suffixes (cwbkMG_suffixes + 3)
extern const struct suffix_mult kmg_i_suffixes[];

#if 0 /* expanded by -frewrite-includes */
#include "xatonum.h"
#endif /* expanded by -frewrite-includes */
# 928 "include/libbb.h"
# 1 "include/xatonum.h" 1
/* vi: set sw=4 ts=4: */
/*
 * ascii-to-numbers implementations for busybox
 *
 * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
 *
 * Licensed under GPLv2, see file LICENSE in this source tree.
 */

PUSH_AND_SET_FUNCTION_VISIBILITY_TO_HIDDEN

/* Provides extern declarations of functions */
#define DECLARE_STR_CONV(type, T, UT) \
\
unsigned type xstrto##UT##_range_sfx(const char *str, int b, unsigned type l, unsigned type u, const struct suffix_mult *sfx) FAST_FUNC; \
unsigned type xstrto##UT##_range(const char *str, int b, unsigned type l, unsigned type u) FAST_FUNC; \
unsigned type xstrto##UT##_sfx(const char *str, int b, const struct suffix_mult *sfx) FAST_FUNC; \
unsigned type xstrto##UT(const char *str, int b) FAST_FUNC; \
unsigned type xato##UT##_range_sfx(const char *str, unsigned type l, unsigned type u, const struct suffix_mult *sfx) FAST_FUNC; \
unsigned type xato##UT##_range(const char *str, unsigned type l, unsigned type u) FAST_FUNC; \
unsigned type xato##UT##_sfx(const char *str, const struct suffix_mult *sfx) FAST_FUNC; \
unsigned type xato##UT(const char *str) FAST_FUNC; \
type xstrto##T##_range_sfx(const char *str, int b, type l, type u, const struct suffix_mult *sfx) FAST_FUNC; \
type xstrto##T##_range(const char *str, int b, type l, type u) FAST_FUNC; \
type xstrto##T(const char *str, int b) FAST_FUNC; \
type xato##T##_range_sfx(const char *str, type l, type u, const struct suffix_mult *sfx) FAST_FUNC; \
type xato##T##_range(const char *str, type l, type u) FAST_FUNC; \
type xato##T##_sfx(const char *str, const struct suffix_mult *sfx) FAST_FUNC; \
type xato##T(const char *str) FAST_FUNC; \

/* Unsigned long long functions always exist */
DECLARE_STR_CONV(long long, ll, ull)


/* Provides inline definitions of functions */
/* (useful for mapping them to the type of the same width) */
#define DEFINE_EQUIV_STR_CONV(narrow, N, W, UN, UW) \
\
static ALWAYS_INLINE \
unsigned narrow xstrto##UN##_range_sfx(const char *str, int b, unsigned narrow l, unsigned narrow u, const struct suffix_mult *sfx) \
{ return xstrto##UW##_range_sfx(str, b, l, u, sfx); } \
static ALWAYS_INLINE \
unsigned narrow xstrto##UN##_range(const char *str, int b, unsigned narrow l, unsigned narrow u) \
{ return xstrto##UW##_range(str, b, l, u); } \
static ALWAYS_INLINE \
unsigned narrow xstrto##UN##_sfx(const char *str, int b, const struct suffix_mult *sfx) \
{ return xstrto##UW##_sfx(str, b, sfx); } \
static ALWAYS_INLINE \
unsigned narrow xstrto##UN(const char *str, int b) \
{ return xstrto##UW(str, b); } \
static ALWAYS_INLINE \
unsigned narrow xato##UN##_range_sfx(const char *str, unsigned narrow l, unsigned narrow u, const struct suffix_mult *sfx) \
{ return xato##UW##_range_sfx(str, l, u, sfx); } \
static ALWAYS_INLINE \
unsigned narrow xato##UN##_range(const char *str, unsigned narrow l, unsigned narrow u) \
{ return xato##UW##_range(str, l, u); } \
static ALWAYS_INLINE \
unsigned narrow xato##UN##_sfx(const char *str, const struct suffix_mult *sfx) \
{ return xato##UW##_sfx(str, sfx); } \
static ALWAYS_INLINE \
unsigned narrow xato##UN(const char *str) \
{ return xato##UW(str); } \
static ALWAYS_INLINE \
narrow xstrto##N##_range_sfx(const char *str, int b, narrow l, narrow u, const struct suffix_mult *sfx) \
{ return xstrto##W##_range_sfx(str, b, l, u, sfx); } \
static ALWAYS_INLINE \
narrow xstrto##N##_range(const char *str, int b, narrow l, narrow u) \
{ return xstrto##W##_range(str, b, l, u); } \
static ALWAYS_INLINE \
narrow xstrto##N(const char *str, int b) \
{ return xstrto##W(str, b); } \
static ALWAYS_INLINE \
narrow xato##N##_range_sfx(const char *str, narrow l, narrow u, const struct suffix_mult *sfx) \
{ return xato##W##_range_sfx(str, l, u, sfx); } \
static ALWAYS_INLINE \
narrow xato##N##_range(const char *str, narrow l, narrow u) \
{ return xato##W##_range(str, l, u); } \
static ALWAYS_INLINE \
narrow xato##N##_sfx(const char *str, const struct suffix_mult *sfx) \
{ return xato##W##_sfx(str, sfx); } \
static ALWAYS_INLINE \
narrow xato##N(const char *str) \
{ return xato##W(str); } \

/* If long == long long, then just map them one-to-one */
#if ULONG_MAX == ULLONG_MAX
DEFINE_EQUIV_STR_CONV(long, l, ll, ul, ull)
#else
# 89 "include/xatonum.h"
/* Else provide extern defs */
DECLARE_STR_CONV(long, l, ul)
#endif
# 92 "include/xatonum.h"

/* Same for int -> [long] long */
#if UINT_MAX == ULLONG_MAX
DEFINE_EQUIV_STR_CONV(int, i, ll, u, ull)
#elif UINT_MAX == ULONG_MAX
# 97 "include/xatonum.h"
DEFINE_EQUIV_STR_CONV(int, i, l, u, ul)
#else
# 99 "include/xatonum.h"
DECLARE_STR_CONV(int, i, u)
#endif
# 101 "include/xatonum.h"

/* Specialized */

uint32_t BUG_xatou32_unimplemented(void);
static ALWAYS_INLINE uint32_t xatou32(const char *numstr)
{
	if (UINT_MAX == 0xffffffff)
		return xatou(numstr);
	if (ULONG_MAX == 0xffffffff)
		return xatoul(numstr);
	return BUG_xatou32_unimplemented();
}

/* Non-aborting kind of convertors: bb_strto[u][l]l */

/* On exit: errno = 0 only if there was non-empty, '\0' terminated value
 * errno = EINVAL if value was not '\0' terminated, but otherwise ok
 *    Return value is still valid, caller should just check whether end[0]
 *    is a valid terminating char for particular case. OTOH, if caller
 *    requires '\0' terminated input, [s]he can just check errno == 0.
 * errno = ERANGE if value had alphanumeric terminating char ("1234abcg").
 * errno = ERANGE if value is out of range, missing, etc.
 * errno = ERANGE if value had minus sign for strtouXX (even "-0" is not ok )
 *    return value is all-ones in this case.
 */

unsigned long long bb_strtoull(const char *arg, char **endp, int base) FAST_FUNC;
long long bb_strtoll(const char *arg, char **endp, int base) FAST_FUNC;

#if ULONG_MAX == ULLONG_MAX
static ALWAYS_INLINE
unsigned long bb_strtoul(const char *arg, char **endp, int base)
{ return bb_strtoull(arg, endp, base); }
static ALWAYS_INLINE
long bb_strtol(const char *arg, char **endp, int base)
{ return bb_strtoll(arg, endp, base); }
#else
# 138 "include/xatonum.h"
unsigned long bb_strtoul(const char *arg, char **endp, int base) FAST_FUNC;
long bb_strtol(const char *arg, char **endp, int base) FAST_FUNC;
#endif
# 141 "include/xatonum.h"

#if UINT_MAX == ULLONG_MAX
static ALWAYS_INLINE
unsigned bb_strtou(const char *arg, char **endp, int base)
{ return bb_strtoull(arg, endp, base); }
static ALWAYS_INLINE
int bb_strtoi(const char *arg, char **endp, int base)
{ return bb_strtoll(arg, endp, base); }
#elif UINT_MAX == ULONG_MAX
# 150 "include/xatonum.h"
static ALWAYS_INLINE
unsigned bb_strtou(const char *arg, char **endp, int base)
{ return bb_strtoul(arg, endp, base); }
static ALWAYS_INLINE
int bb_strtoi(const char *arg, char **endp, int base)
{ return bb_strtol(arg, endp, base); }
#else
# 157 "include/xatonum.h"
unsigned bb_strtou(const char *arg, char **endp, int base) FAST_FUNC;
int bb_strtoi(const char *arg, char **endp, int base) FAST_FUNC;
#endif
# 160 "include/xatonum.h"

uint32_t BUG_bb_strtou32_unimplemented(void);
static ALWAYS_INLINE
uint32_t bb_strtou32(const char *arg, char **endp, int base)
{
	if (sizeof(uint32_t) == sizeof(unsigned))
		return bb_strtou(arg, endp, base);
	if (sizeof(uint32_t) == sizeof(unsigned long))
		return bb_strtoul(arg, endp, base);
	return BUG_bb_strtou32_unimplemented();
}
static ALWAYS_INLINE
int32_t bb_strtoi32(const char *arg, char **endp, int base)
{
	if (sizeof(int32_t) == sizeof(int))
		return bb_strtoi(arg, endp, base);
	if (sizeof(int32_t) == sizeof(long))
		return bb_strtol(arg, endp, base);
	return BUG_bb_strtou32_unimplemented();
}

/* Floating point */

double bb_strtod(const char *arg, char **endp) FAST_FUNC;

POP_SAVED_FUNCTION_VISIBILITY
# 929 "include/libbb.h" 2
/* Specialized: */

/* Using xatoi() instead of naive atoi() is not always convenient -
 * in many places people want *non-negative* values, but store them
 * in signed int. Therefore we need this one:
 * dies if input is not in [0, INT_MAX] range. Also will reject '-0' etc.
 * It should really be named xatoi_nonnegative (since it allows 0),
 * but that would be too long.
 */
int xatoi_positive(const char *numstr) FAST_FUNC;

/* Useful for reading port numbers */
uint16_t xatou16(const char *numstr) FAST_FUNC;


/* These parse entries in /etc/passwd and /etc/group.  This is desirable
 * for BusyBox since we want to avoid using the glibc NSS stuff, which
 * increases target size and is often not needed on embedded systems.  */
long xuname2uid(const char *name) FAST_FUNC;
long xgroup2gid(const char *name) FAST_FUNC;
/* wrapper: allows string to contain numeric uid or gid */
unsigned long get_ug_id(const char *s, long FAST_FUNC (*xname2id)(const char *)) FAST_FUNC;
struct bb_uidgid_t {
	uid_t uid;
	gid_t gid;
};
/* always sets uid and gid; returns 0 on failure */
int get_uidgid(struct bb_uidgid_t*, const char*) FAST_FUNC;
/* always sets uid and gid; exits on failure */
void xget_uidgid(struct bb_uidgid_t*, const char*) FAST_FUNC;
/* chown-like handling of "user[:[group]" */
void parse_chown_usergroup_or_die(struct bb_uidgid_t *u, char *user_group) FAST_FUNC;
struct passwd* xgetpwnam(const char *name) FAST_FUNC;
struct group* xgetgrnam(const char *name) FAST_FUNC;
struct passwd* xgetpwuid(uid_t uid) FAST_FUNC;
struct group* xgetgrgid(gid_t gid) FAST_FUNC;
char* xuid2uname(uid_t uid) FAST_FUNC;
char* xgid2group(gid_t gid) FAST_FUNC;
char* uid2uname(uid_t uid) FAST_FUNC;
char* gid2group(gid_t gid) FAST_FUNC;
char* uid2uname_utoa(uid_t uid) FAST_FUNC;
char* gid2group_utoa(gid_t gid) FAST_FUNC;
/* versions which cache results (useful for ps, ls etc) */
const char* get_cached_username(uid_t uid) FAST_FUNC;
const char* get_cached_groupname(gid_t gid) FAST_FUNC;
void clear_username_cache(void) FAST_FUNC;
/* internally usernames are saved in fixed-sized char[] buffers */
enum { USERNAME_MAX_SIZE = 32 - sizeof(uid_t) };
#if ENABLE_FEATURE_CHECK_NAMES
void die_if_bad_username(const char* name) FAST_FUNC;
#else
# 980 "include/libbb.h"
#define die_if_bad_username(name) ((void)(name))
#endif
# 982 "include/libbb.h"

#if ENABLE_FEATURE_UTMP
void FAST_FUNC write_new_utmp(pid_t pid, int new_type, const char *tty_name, const char *username, const char *hostname);
void FAST_FUNC update_utmp(pid_t pid, int new_type, const char *tty_name, const char *username, const char *hostname);
void FAST_FUNC update_utmp_DEAD_PROCESS(pid_t pid);
#else
# 988 "include/libbb.h"
# define write_new_utmp(pid, new_type, tty_name, username, hostname) ((void)0)
# define update_utmp(pid, new_type, tty_name, username, hostname) ((void)0)
# define update_utmp_DEAD_PROCESS(pid) ((void)0)
#endif
# 992 "include/libbb.h"


int file_is_executable(const char *name) FAST_FUNC;
char *find_executable(const char *filename, char **PATHp) FAST_FUNC;
int executable_exists(const char *filename) FAST_FUNC;

/* BB_EXECxx always execs (it's not doing NOFORK/NOEXEC stuff),
 * but it may exec busybox and call applet instead of searching PATH.
 */
#if ENABLE_FEATURE_PREFER_APPLETS
int BB_EXECVP(const char *file, char *const argv[]) FAST_FUNC;
#define BB_EXECLP(prog,cmd,...) \
	do { \
		if (find_applet_by_name(prog) >= 0) \
			execlp(bb_busybox_exec_path, cmd, __VA_ARGS__); \
		execlp(prog, cmd, __VA_ARGS__); \
	} while (0)
#else
# 1010 "include/libbb.h"
#define BB_EXECVP(prog,cmd)     execvp(prog,cmd)
#define BB_EXECLP(prog,cmd,...) execlp(prog,cmd,__VA_ARGS__)
#endif
# 1013 "include/libbb.h"
void BB_EXECVP_or_die(char **argv) NORETURN FAST_FUNC;
void exec_prog_or_SHELL(char **argv) NORETURN FAST_FUNC;

/* xvfork() can't be a _function_, return after vfork in child mangles stack
 * in the parent. It must be a macro. */
#define xvfork() \
({ \
	pid_t bb__xvfork_pid = vfork(); \
	if (bb__xvfork_pid < 0) \
		bb_perror_msg_and_die("vfork"); \
	bb__xvfork_pid; \
})
#if BB_MMU
pid_t xfork(void) FAST_FUNC;
#endif
# 1028 "include/libbb.h"
void xvfork_parent_waits_and_exits(void) FAST_FUNC;

/* NOMMU friendy fork+exec: */
pid_t spawn(char **argv) FAST_FUNC;
pid_t xspawn(char **argv) FAST_FUNC;

pid_t safe_waitpid(pid_t pid, int *wstat, int options) FAST_FUNC;
pid_t wait_any_nohang(int *wstat) FAST_FUNC;
/* wait4pid: unlike waitpid, waits ONLY for one process.
 * Returns sig + 0x180 if child is killed by signal.
 * It's safe to pass negative 'pids' from failed [v]fork -
 * wait4pid will return -1 (and will not clobber [v]fork's errno).
 * IOW: rc = wait4pid(spawn(argv));
 *      if (rc < 0) bb_perror_msg("%s", argv[0]);
 *      if (rc > 0) bb_error_msg("exit code: %d", rc & 0xff);
 */
int wait4pid(pid_t pid) FAST_FUNC;
int wait_for_exitstatus(pid_t pid) FAST_FUNC;
/* Same as wait4pid(spawn(argv)), but with NOFORK/NOEXEC if configured: */
int spawn_and_wait(char **argv) FAST_FUNC;
/* Does NOT check that applet is NOFORK, just blindly runs it */
int run_nofork_applet(int applet_no, char **argv) FAST_FUNC;

/* Helpers for daemonization.
 *
 * bb_daemonize(flags) = daemonize, does not compile on NOMMU
 *
 * bb_daemonize_or_rexec(flags, argv) = daemonizes on MMU (and ignores argv),
 *      rexec's itself on NOMMU with argv passed as command line.
 * Thus bb_daemonize_or_rexec may cause your <applet>_main() to be re-executed
 * from the start. (It will detect it and not reexec again second time).
 * You have to audit carefully that you don't do something twice as a result
 * (opening files/sockets, parsing config files etc...)!
 *
 * Both of the above will redirect fd 0,1,2 to /dev/null and drop ctty
 * (will do setsid()).
 *
 * fork_or_rexec(argv) = bare-bones fork on MMU,
 *      "vfork + re-exec ourself" on NOMMU. No fd redirection, no setsid().
 *      On MMU ignores argv.
 *
 * Helper for network daemons in foreground mode:
 *
 * bb_sanitize_stdio() = make sure that fd 0,1,2 are opened by opening them
 * to /dev/null if they are not.
 */
enum {
	DAEMON_CHDIR_ROOT = 1,
	DAEMON_DEVNULL_STDIO = 2,
	DAEMON_CLOSE_EXTRA_FDS = 4,
	DAEMON_ONLY_SANITIZE = 8, /* internal use */
	DAEMON_DOUBLE_FORK = 16, /* double fork to avoid controlling tty */
};
#if BB_MMU
  enum { re_execed = 0 };
# define fork_or_rexec(argv)                xfork()
# define bb_daemonize_or_rexec(flags, argv) bb_daemonize_or_rexec(flags)
# define bb_daemonize(flags)                bb_daemonize_or_rexec(flags, bogus)
#else
# 1087 "include/libbb.h"
  extern bool re_execed;
  /* Note: re_exec() and fork_or_rexec() do argv[0][0] |= 0x80 on NOMMU!
   * _Parent_ needs to undo it if it doesn't want to have argv[0] mangled.
   */
  void re_exec(char **argv) NORETURN FAST_FUNC;
  pid_t fork_or_rexec(char **argv) FAST_FUNC;
  int  BUG_fork_is_unavailable_on_nommu(void) FAST_FUNC;
  int  BUG_daemon_is_unavailable_on_nommu(void) FAST_FUNC;
  void BUG_bb_daemonize_is_unavailable_on_nommu(void) FAST_FUNC;
# define fork()          BUG_fork_is_unavailable_on_nommu()
# define xfork()         BUG_fork_is_unavailable_on_nommu()
# define daemon(a,b)     BUG_daemon_is_unavailable_on_nommu()
# define bb_daemonize(a) BUG_bb_daemonize_is_unavailable_on_nommu()
#endif
# 1101 "include/libbb.h"
void bb_daemonize_or_rexec(int flags, char **argv) FAST_FUNC;
void bb_sanitize_stdio(void) FAST_FUNC;
/* Clear dangerous stuff, set PATH. Return 1 if was run by different user. */
int sanitize_env_if_suid(void) FAST_FUNC;


char* single_argv(char **argv) FAST_FUNC;
extern const char *const bb_argv_dash[]; /* "-", NULL */
extern const char *opt_complementary;
#if ENABLE_LONG_OPTS || ENABLE_FEATURE_GETOPT_LONG
#define No_argument "\0"
#define Required_argument "\001"
#define Optional_argument "\002"
extern const char *applet_long_options;
#endif
# 1116 "include/libbb.h"
extern uint32_t option_mask32;
extern uint32_t getopt32(char **argv, const char *applet_opts, ...) FAST_FUNC;


/* Having next pointer as a first member allows easy creation
 * of "llist-compatible" structs, and using llist_FOO functions
 * on them.
 */
typedef struct llist_t {
	struct llist_t *link;
	char *data;
} llist_t;
void llist_add_to(llist_t **old_head, void *data) FAST_FUNC;
void llist_add_to_end(llist_t **list_head, void *data) FAST_FUNC;
void *llist_pop(llist_t **elm) FAST_FUNC;
void llist_unlink(llist_t **head, llist_t *elm) FAST_FUNC;
void llist_free(llist_t *elm, void (*freeit)(void *data)) FAST_FUNC;
llist_t *llist_rev(llist_t *list) FAST_FUNC;
llist_t *llist_find_str(llist_t *first, const char *str) FAST_FUNC;
/* BTW, surprisingly, changing API to
 *   llist_t *llist_add_to(llist_t *old_head, void *data)
 * etc does not result in smaller code... */

/* start_stop_daemon and udhcpc are special - they want
 * to create pidfiles regardless of FEATURE_PIDFILE */
#if ENABLE_FEATURE_PIDFILE || defined(WANT_PIDFILE)
/* True only if we created pidfile which is *file*, not /dev/null etc */
extern smallint wrote_pidfile;
void write_pidfile(const char *path) FAST_FUNC;
#define remove_pidfile(path) do { if (wrote_pidfile) unlink(path); } while (0)
#else
# 1147 "include/libbb.h"
enum { wrote_pidfile = 0 };
#define write_pidfile(path)  ((void)0)
#define remove_pidfile(path) ((void)0)
#endif
# 1151 "include/libbb.h"

enum {
	LOGMODE_NONE = 0,
	LOGMODE_STDIO = (1 << 0),
	LOGMODE_SYSLOG = (1 << 1) * ENABLE_FEATURE_SYSLOG,
	LOGMODE_BOTH = LOGMODE_SYSLOG + LOGMODE_STDIO,
};
extern const char *msg_eol;
extern smallint syslog_level;
extern smallint logmode;
extern uint8_t xfunc_error_retval;
extern void (*die_func)(void);
extern void xfunc_die(void) NORETURN FAST_FUNC;
extern void bb_show_usage(void) NORETURN FAST_FUNC;
extern void bb_error_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
extern void bb_error_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2))) FAST_FUNC;
extern void bb_perror_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
extern void bb_simple_perror_msg(const char *s) FAST_FUNC;
extern void bb_perror_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2))) FAST_FUNC;
extern void bb_simple_perror_msg_and_die(const char *s) NORETURN FAST_FUNC;
extern void bb_herror_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
extern void bb_herror_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2))) FAST_FUNC;
extern void bb_perror_nomsg_and_die(void) NORETURN FAST_FUNC;
extern void bb_perror_nomsg(void) FAST_FUNC;
extern void bb_verror_msg(const char *s, va_list p, const char *strerr) FAST_FUNC;
extern void bb_logenv_override(void) FAST_FUNC;

/* We need to export XXX_main from libbusybox
 * only if we build "individual" binaries
 */
#if ENABLE_FEATURE_INDIVIDUAL
#define MAIN_EXTERNALLY_VISIBLE EXTERNALLY_VISIBLE
#else
# 1184 "include/libbb.h"
#define MAIN_EXTERNALLY_VISIBLE
#endif
# 1186 "include/libbb.h"


/* Applets which are useful from another applets */
int bb_cat(char** argv);
/* If shell needs them, they exist even if not enabled as applets */
int echo_main(int argc, char** argv) IF_ECHO(MAIN_EXTERNALLY_VISIBLE);
int printf_main(int argc, char **argv) IF_PRINTF(MAIN_EXTERNALLY_VISIBLE);
int test_main(int argc, char **argv)
#if ENABLE_TEST || ENABLE_TEST1 || ENABLE_TEST2
		MAIN_EXTERNALLY_VISIBLE
#endif
# 1197 "include/libbb.h"
;
int kill_main(int argc, char **argv)
#if ENABLE_KILL || ENABLE_KILLALL || ENABLE_KILLALL5
		MAIN_EXTERNALLY_VISIBLE
#endif
# 1202 "include/libbb.h"
;
/* Similar, but used by chgrp, not shell */
int chown_main(int argc, char **argv) IF_CHOWN(MAIN_EXTERNALLY_VISIBLE);
/* Used by ftpd */
int ls_main(int argc, char **argv) IF_LS(MAIN_EXTERNALLY_VISIBLE);
/* Don't need IF_xxx() guard for these */
int gunzip_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
int bunzip2_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;

#if ENABLE_ROUTE
void bb_displayroutes(int noresolve, int netstatfmt) FAST_FUNC;
#endif
# 1214 "include/libbb.h"


/* Networking */
/* This structure defines protocol families and their handlers. */
struct aftype {
	const char *name;
	const char *title;
	int af;
	int alen;
	char*       FAST_FUNC (*print)(unsigned char *);
	const char* FAST_FUNC (*sprint)(struct sockaddr *, int numeric);
	int         FAST_FUNC (*input)(/*int type,*/ const char *bufp, struct sockaddr *);
	void        FAST_FUNC (*herror)(char *text);
	int         FAST_FUNC (*rprint)(int options);
	int         FAST_FUNC (*rinput)(int typ, int ext, char **argv);
	/* may modify src */
	int         FAST_FUNC (*getmask)(char *src, struct sockaddr *mask, char *name);
};
/* This structure defines hardware protocols and their handlers. */
struct hwtype {
	const char *name;
	const char *title;
	int type;
	int alen;
	char* FAST_FUNC (*print)(unsigned char *);
	int   FAST_FUNC (*input)(const char *, struct sockaddr *);
	int   FAST_FUNC (*activate)(int fd);
	int suppress_null_addr;
};
extern smallint interface_opt_a;
int display_interfaces(char *ifname) FAST_FUNC;
int in_ether(const char *bufp, struct sockaddr *sap) FAST_FUNC;
#if ENABLE_FEATURE_HWIB
int in_ib(const char *bufp, struct sockaddr *sap) FAST_FUNC;
#else
# 1249 "include/libbb.h"
#define in_ib(a, b) 1 /* fail */
#endif
# 1251 "include/libbb.h"
const struct aftype *get_aftype(const char *name) FAST_FUNC;
const struct hwtype *get_hwtype(const char *name) FAST_FUNC;
const struct hwtype *get_hwntype(int type) FAST_FUNC;


#ifndef BUILD_INDIVIDUAL
extern int find_applet_by_name(const char *name) FAST_FUNC;
extern void run_applet_no_and_exit(int a, char **argv) NORETURN FAST_FUNC;
#endif
# 1260 "include/libbb.h"

#ifdef HAVE_MNTENT_H
extern int match_fstype(const struct mntent *mt, const char *fstypes) FAST_FUNC;
extern struct mntent *find_mount_point(const char *name, int subdir_too) FAST_FUNC;
#endif
# 1265 "include/libbb.h"
extern void erase_mtab(const char * name) FAST_FUNC;
extern unsigned int tty_baud_to_value(speed_t speed) FAST_FUNC;
extern speed_t tty_value_to_baud(unsigned int value) FAST_FUNC;
#if ENABLE_DESKTOP
extern void bb_warn_ignoring_args(char *arg) FAST_FUNC;
#else
# 1271 "include/libbb.h"
# define bb_warn_ignoring_args(arg) ((void)0)
#endif
# 1273 "include/libbb.h"

extern int get_linux_version_code(void) FAST_FUNC;

extern char *query_loop(const char *device) FAST_FUNC;
extern int del_loop(const char *device) FAST_FUNC;
/* If *devname is not NULL, use that name, otherwise try to find free one,
 * malloc and return it in *devname.
 * return value: 1: read-only loopdev was setup, 0: rw, < 0: error */
extern int set_loop(char **devname, const char *file, unsigned long long offset, int ro) FAST_FUNC;

/* Like bb_ask below, but asks on stdin with no timeout.  */
char *bb_ask_stdin(const char * prompt) FAST_FUNC;
//TODO: pass buf pointer or return allocated buf (avoid statics)?
char *bb_ask(const int fd, int timeout, const char * prompt) FAST_FUNC;
int bb_ask_confirmation(void) FAST_FUNC;

/* Returns -1 if input is invalid. current_mode is a base for e.g. "u+rw" */
int bb_parse_mode(const char* s, unsigned cur_mode) FAST_FUNC;

/*
 * Config file parser
 */
enum {
	PARSE_COLLAPSE  = 0x00010000, // treat consecutive delimiters as one
	PARSE_TRIM      = 0x00020000, // trim leading and trailing delimiters
// TODO: COLLAPSE and TRIM seem to always go in pair
	PARSE_GREEDY    = 0x00040000, // last token takes entire remainder of the line
	PARSE_MIN_DIE   = 0x00100000, // die if < min tokens found
	// keep a copy of current line
	PARSE_KEEP_COPY = 0x00200000 * ENABLE_FEATURE_CROND_D,
	PARSE_EOL_COMMENTS = 0x00400000, // comments are recognized even if they aren't the first char
	// NORMAL is:
	// * remove leading and trailing delimiters and collapse
	//   multiple delimiters into one
	// * warn and continue if less than mintokens delimiters found
	// * grab everything into last token
	// * comments are recognized even if they aren't the first char
	PARSE_NORMAL    = PARSE_COLLAPSE | PARSE_TRIM | PARSE_GREEDY | PARSE_EOL_COMMENTS,
};
typedef struct parser_t {
	FILE *fp;
	char *data;
	char *line, *nline;
	size_t line_alloc, nline_alloc;
	int lineno;
} parser_t;
parser_t* config_open(const char *filename) FAST_FUNC;
parser_t* config_open2(const char *filename, FILE* FAST_FUNC (*fopen_func)(const char *path)) FAST_FUNC;
/* delims[0] is a comment char (use '\0' to disable), the rest are token delimiters */
int config_read(parser_t *parser, char **tokens, unsigned flags, const char *delims) FAST_FUNC;
#define config_read(parser, tokens, max, min, str, flags) \
	config_read(parser, tokens, ((flags) | (((min) & 0xFF) << 8) | ((max) & 0xFF)), str)
void config_close(parser_t *parser) FAST_FUNC;

/* Concatenate path and filename to new allocated buffer.
 * Add "/" only as needed (no duplicate "//" are produced).
 * If path is NULL, it is assumed to be "/".
 * filename should not be NULL. */
char *concat_path_file(const char *path, const char *filename) FAST_FUNC;
/* Returns NULL on . and .. */
char *concat_subpath_file(const char *path, const char *filename) FAST_FUNC;


int bb_make_directory(char *path, long mode, int flags) FAST_FUNC;

int get_signum(const char *name) FAST_FUNC;
const char *get_signame(int number) FAST_FUNC;
void print_signames(void) FAST_FUNC;

char *bb_simplify_path(const char *path) FAST_FUNC;
/* Returns ptr to NUL */
char *bb_simplify_abs_path_inplace(char *path) FAST_FUNC;

#ifndef LOGIN_FAIL_DELAY
#define LOGIN_FAIL_DELAY 3
#endif
# 1349 "include/libbb.h"
extern void bb_do_delay(int seconds) FAST_FUNC;
extern void change_identity(const struct passwd *pw) FAST_FUNC;
extern void run_shell(const char *shell, int loginshell, const char **args) NORETURN FAST_FUNC;

/* Returns $SHELL, getpwuid(getuid())->pw_shell, or DEFAULT_SHELL.
 * Note that getpwuid result might need xstrdup'ing
 * if there is a possibility of intervening getpwxxx() calls.
 */
const char *get_shell_name(void) FAST_FUNC;

#if ENABLE_SELINUX
extern void renew_current_security_context(void) FAST_FUNC;
extern void set_current_security_context(security_context_t sid) FAST_FUNC;
extern context_t set_security_context_component(security_context_t cur_context,
						char *user, char *role, char *type, char *range) FAST_FUNC;
extern void setfscreatecon_or_die(security_context_t scontext) FAST_FUNC;
extern void selinux_preserve_fcontext(int fdesc) FAST_FUNC;
#else
# 1367 "include/libbb.h"
#define selinux_preserve_fcontext(fdesc) ((void)0)
#endif
# 1369 "include/libbb.h"
extern void selinux_or_die(void) FAST_FUNC;


/* setup_environment:
 * if chdir pw->pw_dir: ok: else if to_tmp == 1: goto /tmp else: goto / or die
 * if clear_env = 1: cd(pw->pw_dir), clear environment, then set
 *   TERM=(old value)
 *   USER=pw->pw_name, LOGNAME=pw->pw_name
 *   PATH=bb_default_[root_]path
 *   HOME=pw->pw_dir
 *   SHELL=shell
 * else if change_env = 1:
 *   if not root (if pw->pw_uid != 0):
 *     USER=pw->pw_name, LOGNAME=pw->pw_name
 *   HOME=pw->pw_dir
 *   SHELL=shell
 * else does nothing
 */
#define SETUP_ENV_CHANGEENV (1 << 0)
#define SETUP_ENV_CLEARENV  (1 << 1)
#define SETUP_ENV_TO_TMP    (1 << 2)
#define SETUP_ENV_NO_CHDIR  (1 << 4)
void setup_environment(const char *shell, int flags, const struct passwd *pw) FAST_FUNC;
void nuke_str(char *str) FAST_FUNC;
int check_password(const struct passwd *pw, const char *plaintext) FAST_FUNC;
int ask_and_check_password_extended(const struct passwd *pw, int timeout, const char *prompt) FAST_FUNC;
int ask_and_check_password(const struct passwd *pw) FAST_FUNC;
/* Returns a malloced string */
#if !ENABLE_USE_BB_CRYPT
#define pw_encrypt(clear, salt, cleanup) pw_encrypt(clear, salt)
#endif
# 1400 "include/libbb.h"
extern char *pw_encrypt(const char *clear, const char *salt, int cleanup) FAST_FUNC;
extern int obscure(const char *old, const char *newval, const struct passwd *pwdp) FAST_FUNC;
/*
 * rnd is additional random input. New one is returned.
 * Useful if you call crypt_make_salt many times in a row:
 * rnd = crypt_make_salt(buf1, 4, 0);
 * rnd = crypt_make_salt(buf2, 4, rnd);
 * rnd = crypt_make_salt(buf3, 4, rnd);
 * (otherwise we risk having same salt generated)
 */
extern int crypt_make_salt(char *p, int cnt /*, int rnd*/) FAST_FUNC;
/* "$N$" + sha_salt_16_bytes + NUL */
#define MAX_PW_SALT_LEN (3 + 16 + 1)
extern char* crypt_make_pw_salt(char p[MAX_PW_SALT_LEN], const char *algo) FAST_FUNC;


/* Returns number of lines changed, or -1 on error */
#if !(ENABLE_FEATURE_ADDUSER_TO_GROUP || ENABLE_FEATURE_DEL_USER_FROM_GROUP)
#define update_passwd(filename, username, data, member) \
	update_passwd(filename, username, data)
#endif
# 1421 "include/libbb.h"
extern int update_passwd(const char *filename,
		const char *username,
		const char *data,
		const char *member) FAST_FUNC;

int index_in_str_array(const char *const string_array[], const char *key) FAST_FUNC;
int index_in_strings(const char *strings, const char *key) FAST_FUNC;
int index_in_substr_array(const char *const string_array[], const char *key) FAST_FUNC;
int index_in_substrings(const char *strings, const char *key) FAST_FUNC;
const char *nth_string(const char *strings, int n) FAST_FUNC;

extern void print_login_issue(const char *issue_file, const char *tty) FAST_FUNC;
extern void print_login_prompt(void) FAST_FUNC;

char *xmalloc_ttyname(int fd) FAST_FUNC RETURNS_MALLOC;
/* NB: typically you want to pass fd 0, not 1. Think 'applet | grep something' */
int get_terminal_width_height(int fd, unsigned *width, unsigned *height) FAST_FUNC;
int get_terminal_width(int fd) FAST_FUNC;

int tcsetattr_stdin_TCSANOW(const struct termios *tp) FAST_FUNC;

/* NB: "unsigned request" is crucial! "int request" will break some arches! */
int ioctl_or_perror(int fd, unsigned request, void *argp, const char *fmt,...) __attribute__ ((format (printf, 4, 5))) FAST_FUNC;
int ioctl_or_perror_and_die(int fd, unsigned request, void *argp, const char *fmt,...) __attribute__ ((format (printf, 4, 5))) FAST_FUNC;
#if ENABLE_IOCTL_HEX2STR_ERROR
int bb_ioctl_or_warn(int fd, unsigned request, void *argp, const char *ioctl_name) FAST_FUNC;
int bb_xioctl(int fd, unsigned request, void *argp, const char *ioctl_name) FAST_FUNC;
#define ioctl_or_warn(fd,request,argp) bb_ioctl_or_warn(fd,request,argp,#request)
#define xioctl(fd,request,argp)        bb_xioctl(fd,request,argp,#request)
#else
# 1451 "include/libbb.h"
int bb_ioctl_or_warn(int fd, unsigned request, void *argp) FAST_FUNC;
int bb_xioctl(int fd, unsigned request, void *argp) FAST_FUNC;
#define ioctl_or_warn(fd,request,argp) bb_ioctl_or_warn(fd,request,argp)
#define xioctl(fd,request,argp)        bb_xioctl(fd,request,argp)
#endif
# 1456 "include/libbb.h"

char *is_in_ino_dev_hashtable(const struct stat *statbuf) FAST_FUNC;
void add_to_ino_dev_hashtable(const struct stat *statbuf, const char *name) FAST_FUNC;
void reset_ino_dev_hashtable(void) FAST_FUNC;
#ifdef __GLIBC__
/* At least glibc has horrendously large inline for this, so wrap it */
unsigned long long bb_makedev(unsigned major, unsigned minor) FAST_FUNC;
#undef makedev
#define makedev(a,b) bb_makedev(a,b)
#endif
# 1466 "include/libbb.h"


/* "Keycodes" that report an escape sequence.
 * We use something which fits into signed char,
 * yet doesn't represent any valid Unicode character.
 * Also, -1 is reserved for error indication and we don't use it. */
enum {
	KEYCODE_UP        =  -2,
	KEYCODE_DOWN      =  -3,
	KEYCODE_RIGHT     =  -4,
	KEYCODE_LEFT      =  -5,
	KEYCODE_HOME      =  -6,
	KEYCODE_END       =  -7,
	KEYCODE_INSERT    =  -8,
	KEYCODE_DELETE    =  -9,
	KEYCODE_PAGEUP    = -10,
	KEYCODE_PAGEDOWN  = -11,
	KEYCODE_BACKSPACE = -12, /* Used only if Alt/Ctrl/Shifted */
	KEYCODE_D         = -13, /* Used only if Alted */
#if 0
	KEYCODE_FUN1      = ,
	KEYCODE_FUN2      = ,
	KEYCODE_FUN3      = ,
	KEYCODE_FUN4      = ,
	KEYCODE_FUN5      = ,
	KEYCODE_FUN6      = ,
	KEYCODE_FUN7      = ,
	KEYCODE_FUN8      = ,
	KEYCODE_FUN9      = ,
	KEYCODE_FUN10     = ,
	KEYCODE_FUN11     = ,
	KEYCODE_FUN12     = ,
#endif
# 1499 "include/libbb.h"
	/* ^^^^^ Be sure that last defined value is small enough.
	 * Current read_key() code allows going up to -32 (0xfff..fffe0).
	 * This gives three upper bits in LSB to play with:
	 * KEYCODE_foo values are 0xfff..fffXX, lowest XX bits are: scavvvvv,
	 * s=0 if SHIFT, c=0 if CTRL, a=0 if ALT,
	 * vvvvv bits are the same for same key regardless of "shift bits".
	 */
	//KEYCODE_SHIFT_...   = KEYCODE_...   & ~0x80,
	KEYCODE_CTRL_RIGHT    = KEYCODE_RIGHT & ~0x40,
	KEYCODE_CTRL_LEFT     = KEYCODE_LEFT  & ~0x40,
	KEYCODE_ALT_RIGHT     = KEYCODE_RIGHT & ~0x20,
	KEYCODE_ALT_LEFT      = KEYCODE_LEFT  & ~0x20,
	KEYCODE_ALT_BACKSPACE = KEYCODE_BACKSPACE & ~0x20,
	KEYCODE_ALT_D         = KEYCODE_D     & ~0x20,

	KEYCODE_CURSOR_POS = -0x100, /* 0xfff..fff00 */
	/* How long is the longest ESC sequence we know?
	 * We want it big enough to be able to contain
	 * cursor position sequence "ESC [ 9999 ; 9999 R"
	 */
	KEYCODE_BUFFER_SIZE = 16
};
/* Note: fd may be in blocking or non-blocking mode, both make sense.
 * For one, less uses non-blocking mode.
 * Only the first read syscall inside read_key may block indefinitely
 * (unless fd is in non-blocking mode),
 * subsequent reads will time out after a few milliseconds.
 * Return of -1 means EOF or error (errno == 0 on EOF).
 * buffer[0] is used as a counter of buffered chars and must be 0
 * on first call.
 * timeout:
 * -2: do not poll for input;
 * -1: poll(-1) (i.e. block);
 * >=0: poll for TIMEOUT milliseconds, return -1/EAGAIN on timeout
 */
int64_t read_key(int fd, char *buffer, int timeout) FAST_FUNC;
void read_key_ungets(char *buffer, const char *str, unsigned len) FAST_FUNC;


#if ENABLE_FEATURE_EDITING
/* It's NOT just ENABLEd or disabled. It's a number: */
# if defined CONFIG_FEATURE_EDITING_HISTORY && CONFIG_FEATURE_EDITING_HISTORY > 0
#  define MAX_HISTORY (CONFIG_FEATURE_EDITING_HISTORY + 0)
unsigned size_from_HISTFILESIZE(const char *hp) FAST_FUNC;
# else
# 1544 "include/libbb.h"
#  define MAX_HISTORY 0
# endif
# 1546 "include/libbb.h"
typedef struct line_input_t {
	int flags;
	const char *path_lookup;
# if MAX_HISTORY
	int cnt_history;
	int cur_history;
	int max_history; /* must never be <= 0 */
#  if ENABLE_FEATURE_EDITING_SAVEHISTORY
	/* meaning of this field depends on FEATURE_EDITING_SAVE_ON_EXIT:
	 * if !FEATURE_EDITING_SAVE_ON_EXIT: "how many lines are
	 * in on-disk history"
	 * if FEATURE_EDITING_SAVE_ON_EXIT: "how many in-memory lines are
	 * also in on-disk history (and thus need to be skipped on save)"
	 */
	unsigned cnt_history_in_file;
	const char *hist_file;
#  endif
# 1563 "include/libbb.h"
	char *history[MAX_HISTORY + 1];
# endif
# 1565 "include/libbb.h"
} line_input_t;
enum {
	DO_HISTORY       = 1 * (MAX_HISTORY > 0),
	TAB_COMPLETION   = 2 * ENABLE_FEATURE_TAB_COMPLETION,
	USERNAME_COMPLETION = 4 * ENABLE_FEATURE_USERNAME_COMPLETION,
	VI_MODE          = 8 * ENABLE_FEATURE_EDITING_VI,
	WITH_PATH_LOOKUP = 0x10,
	FOR_SHELL        = DO_HISTORY | TAB_COMPLETION | USERNAME_COMPLETION,
};
line_input_t *new_line_input_t(int flags) FAST_FUNC;
/* So far static: void free_line_input_t(line_input_t *n) FAST_FUNC; */
/*
 * maxsize must be >= 2.
 * Returns:
 * -1 on read errors or EOF, or on bare Ctrl-D,
 * 0  on ctrl-C (the line entered is still returned in 'command'),
 * >0 length of input string, including terminating '\n'
 */
int read_line_input(line_input_t *st, const char *prompt, char *command, int maxsize, int timeout) FAST_FUNC;
void show_history(const line_input_t *st) FAST_FUNC;
# if ENABLE_FEATURE_EDITING_SAVE_ON_EXIT
void save_history(line_input_t *st);
# endif
# 1588 "include/libbb.h"
#else
# 1589 "include/libbb.h"
#define MAX_HISTORY 0
int read_line_input(const char* prompt, char* command, int maxsize) FAST_FUNC;
#define read_line_input(state, prompt, command, maxsize, timeout) \
	read_line_input(prompt, command, maxsize)
#endif
# 1594 "include/libbb.h"


#ifndef COMM_LEN
# ifdef TASK_COMM_LEN
enum { COMM_LEN = TASK_COMM_LEN };
# else
# 1600 "include/libbb.h"
/* synchronize with sizeof(task_struct.comm) in /usr/include/linux/sched.h */
enum { COMM_LEN = 16 };
# endif
# 1603 "include/libbb.h"
#endif
# 1604 "include/libbb.h"

struct smaprec {
	unsigned long mapped_rw;
	unsigned long mapped_ro;
	unsigned long shared_clean;
	unsigned long shared_dirty;
	unsigned long private_clean;
	unsigned long private_dirty;
	unsigned long stack;
	unsigned long smap_pss, smap_swap;
	unsigned long smap_size;
	unsigned long smap_start;
	char smap_mode[5];
	char *smap_name;
};

#if !ENABLE_PMAP
#define procps_read_smaps(pid, total, cb, data) \
	procps_read_smaps(pid, total)
#endif
# 1624 "include/libbb.h"
int FAST_FUNC procps_read_smaps(pid_t pid, struct smaprec *total,
		void (*cb)(struct smaprec *, void *), void *data);

typedef struct procps_status_t {
	DIR *dir;
	IF_FEATURE_SHOW_THREADS(DIR *task_dir;)
	uint8_t shift_pages_to_bytes;
	uint8_t shift_pages_to_kb;
/* Fields are set to 0/NULL if failed to determine (or not requested) */
	uint16_t argv_len;
	char *argv0;
	char *exe;
	IF_SELINUX(char *context;)
	IF_FEATURE_SHOW_THREADS(unsigned main_thread_pid;)
	/* Everything below must contain no ptrs to malloc'ed data:
	 * it is memset(0) for each process in procps_scan() */
	unsigned long vsz, rss; /* we round it to kbytes */
	unsigned long stime, utime;
	unsigned long start_time;
	unsigned pid;
	unsigned ppid;
	unsigned pgid;
	unsigned sid;
	unsigned uid;
	unsigned gid;
#if ENABLE_FEATURE_PS_ADDITIONAL_COLUMNS
	unsigned ruid;
	unsigned rgid;
	int niceness;
#endif
# 1654 "include/libbb.h"
	unsigned tty_major,tty_minor;
#if ENABLE_FEATURE_TOPMEM
	struct smaprec smaps;
#endif
# 1658 "include/libbb.h"
	char state[4];
	/* basename of executable in exec(2), read from /proc/N/stat
	 * (if executable is symlink or script, it is NOT replaced
	 * by link target or interpreter name) */
	char comm[COMM_LEN];
	/* user/group? - use passwd/group parsing functions */
#if ENABLE_FEATURE_TOP_SMP_PROCESS
	int last_seen_on_cpu;
#endif
# 1667 "include/libbb.h"
} procps_status_t;
/* flag bits for procps_scan(xx, flags) calls */
enum {
	PSSCAN_PID      = 1 << 0,
	PSSCAN_PPID     = 1 << 1,
	PSSCAN_PGID     = 1 << 2,
	PSSCAN_SID      = 1 << 3,
	PSSCAN_UIDGID   = 1 << 4,
	PSSCAN_COMM     = 1 << 5,
	/* PSSCAN_CMD      = 1 << 6, - use read_cmdline instead */
	PSSCAN_ARGV0    = 1 << 7,
	PSSCAN_EXE      = 1 << 8,
	PSSCAN_STATE    = 1 << 9,
	PSSCAN_VSZ      = 1 << 10,
	PSSCAN_RSS      = 1 << 11,
	PSSCAN_STIME    = 1 << 12,
	PSSCAN_UTIME    = 1 << 13,
	PSSCAN_TTY      = 1 << 14,
	PSSCAN_SMAPS	= (1 << 15) * ENABLE_FEATURE_TOPMEM,
	/* NB: used by find_pid_by_name(). Any applet using it
	 * needs to be mentioned here. */
	PSSCAN_ARGVN    = (1 << 16) * (ENABLE_KILLALL
				|| ENABLE_PGREP || ENABLE_PKILL
				|| ENABLE_PIDOF
				|| ENABLE_SESTATUS
				),
	PSSCAN_CONTEXT  = (1 << 17) * ENABLE_SELINUX,
	PSSCAN_START_TIME = 1 << 18,
	PSSCAN_CPU      = (1 << 19) * ENABLE_FEATURE_TOP_SMP_PROCESS,
	PSSCAN_NICE     = (1 << 20) * ENABLE_FEATURE_PS_ADDITIONAL_COLUMNS,
	PSSCAN_RUIDGID  = (1 << 21) * ENABLE_FEATURE_PS_ADDITIONAL_COLUMNS,
	PSSCAN_TASKS	= (1 << 22) * ENABLE_FEATURE_SHOW_THREADS,
};
//procps_status_t* alloc_procps_scan(void) FAST_FUNC;
void free_procps_scan(procps_status_t* sp) FAST_FUNC;
procps_status_t* procps_scan(procps_status_t* sp, int flags) FAST_FUNC;
/* Format cmdline (up to col chars) into char buf[size] */
/* Puts [comm] if cmdline is empty (-> process is a kernel thread) */
void read_cmdline(char *buf, int size, unsigned pid, const char *comm) FAST_FUNC;
pid_t *find_pid_by_name(const char* procName) FAST_FUNC;
pid_t *pidlist_reverse(pid_t *pidList) FAST_FUNC;
int starts_with_cpu(const char *str) FAST_FUNC;
unsigned get_cpu_count(void) FAST_FUNC;


/* Use strict=1 if you process input from untrusted source:
 * it will return NULL on invalid %xx (bad hex chars)
 * and str + 1 if decoded char is / or NUL.
 * In non-strict mode, it always succeeds (returns str),
 * and also it additionally decoded '+' to space.
 */
char *percent_decode_in_place(char *str, int strict) FAST_FUNC;


extern const char bb_uuenc_tbl_base64[] ALIGN1;
extern const char bb_uuenc_tbl_std[] ALIGN1;
void bb_uuencode(char *store, const void *s, int length, const char *tbl) FAST_FUNC;
enum {
	BASE64_FLAG_UU_STOP = 0x100,
	/* Sign-extends to a value which never matches fgetc result: */
	BASE64_FLAG_NO_STOP_CHAR = 0x80,
};
const char *decode_base64(char **pp_dst, const char *src) FAST_FUNC;
void read_base64(FILE *src_stream, FILE *dst_stream, int flags) FAST_FUNC;

typedef struct md5_ctx_t {
	uint8_t wbuffer[64]; /* always correctly aligned for uint64_t */
	void (*process_block)(struct md5_ctx_t*) FAST_FUNC;
	uint64_t total64;    /* must be directly before hash[] */
	uint32_t hash[8];    /* 4 elements for md5, 5 for sha1, 8 for sha256 */
} md5_ctx_t;
typedef struct md5_ctx_t sha1_ctx_t;
typedef struct md5_ctx_t sha256_ctx_t;
typedef struct sha512_ctx_t {
	uint64_t total64[2];  /* must be directly before hash[] */
	uint64_t hash[8];
	uint8_t wbuffer[128]; /* always correctly aligned for uint64_t */
} sha512_ctx_t;
typedef struct sha3_ctx_t {
	uint64_t state[25];
	unsigned bytes_queued;
	unsigned input_block_bytes;
} sha3_ctx_t;
void md5_begin(md5_ctx_t *ctx) FAST_FUNC;
void md5_hash(md5_ctx_t *ctx, const void *buffer, size_t len) FAST_FUNC;
void md5_end(md5_ctx_t *ctx, void *resbuf) FAST_FUNC;
void sha1_begin(sha1_ctx_t *ctx) FAST_FUNC;
#define sha1_hash md5_hash
void sha1_end(sha1_ctx_t *ctx, void *resbuf) FAST_FUNC;
void sha256_begin(sha256_ctx_t *ctx) FAST_FUNC;
#define sha256_hash md5_hash
#define sha256_end  sha1_end
void sha512_begin(sha512_ctx_t *ctx) FAST_FUNC;
void sha512_hash(sha512_ctx_t *ctx, const void *buffer, size_t len) FAST_FUNC;
void sha512_end(sha512_ctx_t *ctx, void *resbuf) FAST_FUNC;
void sha3_begin(sha3_ctx_t *ctx) FAST_FUNC;
void sha3_hash(sha3_ctx_t *ctx, const void *buffer, size_t len) FAST_FUNC;
void sha3_end(sha3_ctx_t *ctx, void *resbuf) FAST_FUNC;

extern uint32_t *global_crc32_table;
uint32_t *crc32_filltable(uint32_t *tbl256, int endian) FAST_FUNC;
uint32_t crc32_block_endian1(uint32_t val, const void *buf, unsigned len, uint32_t *crc_table) FAST_FUNC;
uint32_t crc32_block_endian0(uint32_t val, const void *buf, unsigned len, uint32_t *crc_table) FAST_FUNC;

typedef struct masks_labels_t {
	const char *labels;
	const int masks[];
} masks_labels_t;
int print_flags_separated(const int *masks, const char *labels,
		int flags, const char *separator) FAST_FUNC;
int print_flags(const masks_labels_t *ml, int flags) FAST_FUNC;

typedef struct bb_progress_t {
	unsigned last_size;
	unsigned last_update_sec;
	unsigned last_change_sec;
	unsigned start_sec;
	const char *curfile;
} bb_progress_t;

#define is_bb_progress_inited(p) ((p)->curfile != NULL)
#define bb_progress_free(p) do { \
	if (ENABLE_UNICODE_SUPPORT) free((char*)((p)->curfile)); \
	(p)->curfile = NULL; \
} while (0)
void bb_progress_init(bb_progress_t *p, const char *curfile) FAST_FUNC;
void bb_progress_update(bb_progress_t *p,
			uoff_t beg_range,
			uoff_t transferred,
			uoff_t totalsize) FAST_FUNC;

unsigned ubi_devnum_from_devname(const char *str) FAST_FUNC;
int ubi_get_volid_by_name(unsigned ubi_devnum, const char *vol_name) FAST_FUNC;


extern const char *applet_name;

/* Some older linkers don't perform string merging, we used to have common strings
 * as global arrays to do it by hand. But:
 * (1) newer linkers do it themselves,
 * (2) however, they DONT merge string constants with global arrays,
 * even if the value is the same (!). Thus global arrays actually
 * increased size a bit: for example, "/etc/passwd" string from libc
 * wasn't merged with bb_path_passwd_file[] array!
 * Therefore now we use #defines.
 */
/* "BusyBox vN.N.N (timestamp or extra_version)" */
extern const char bb_banner[] ALIGN1;
extern const char bb_msg_memory_exhausted[] ALIGN1;
extern const char bb_msg_invalid_date[] ALIGN1;
#define bb_msg_read_error "read error"
#define bb_msg_write_error "write error"
extern const char bb_msg_unknown[] ALIGN1;
extern const char bb_msg_can_not_create_raw_socket[] ALIGN1;
extern const char bb_msg_perm_denied_are_you_root[] ALIGN1;
extern const char bb_msg_you_must_be_root[] ALIGN1;
extern const char bb_msg_requires_arg[] ALIGN1;
extern const char bb_msg_invalid_arg_to[] ALIGN1;
extern const char bb_msg_standard_input[] ALIGN1;
extern const char bb_msg_standard_output[] ALIGN1;

/* NB: (bb_hexdigits_upcase[i] | 0x20) -> lowercase hex digit */
extern const char bb_hexdigits_upcase[] ALIGN1;

extern const char bb_path_wtmp_file[] ALIGN1;

/* Busybox mount uses either /proc/mounts or /etc/mtab to
 * get the list of currently mounted filesystems */
#define bb_path_mtab_file IF_FEATURE_MTAB_SUPPORT("/etc/mtab")IF_NOT_FEATURE_MTAB_SUPPORT("/proc/mounts")

#define bb_path_passwd_file  _PATH_PASSWD
#define bb_path_group_file   _PATH_GROUP
#define bb_path_shadow_file  _PATH_SHADOW
#define bb_path_gshadow_file _PATH_GSHADOW

#define bb_path_motd_file "/etc/motd"

#define bb_dev_null "/dev/null"
extern const char bb_busybox_exec_path[] ALIGN1;
/* util-linux manpage says /sbin:/bin:/usr/sbin:/usr/bin,
 * but I want to save a few bytes here */
extern const char bb_PATH_root_path[] ALIGN1; /* "PATH=/sbin:/usr/sbin:/bin:/usr/bin" */
#define bb_default_root_path (bb_PATH_root_path + sizeof("PATH"))
#define bb_default_path      (bb_PATH_root_path + sizeof("PATH=/sbin:/usr/sbin"))

extern const int const_int_0;
//extern const int const_int_1;

/* This struct is deliberately not defined. */
/* See docs/keep_data_small.txt */
struct globals;
/* '*const' ptr makes gcc optimize code much better.
 * Magic prevents ptr_to_globals from going into rodata.
 * If you want to assign a value, use SET_PTR_TO_GLOBALS(x) */
extern struct globals *const ptr_to_globals;
/* At least gcc 3.4.6 on mipsel system needs optimization barrier */
#define barrier() __asm__ __volatile__("":::"memory")
#define SET_PTR_TO_GLOBALS(x) do { \
	(*(struct globals**)&ptr_to_globals) = (void*)(x); \
	barrier(); \
} while (0)
#define FREE_PTR_TO_GLOBALS() do { \
	if (ENABLE_FEATURE_CLEAN_UP) { \
		free(ptr_to_globals); \
	} \
} while (0)

/* You can change LIBBB_DEFAULT_LOGIN_SHELL, but don't use it,
 * use bb_default_login_shell and following defines.
 * If you change LIBBB_DEFAULT_LOGIN_SHELL,
 * don't forget to change increment constant. */
#define LIBBB_DEFAULT_LOGIN_SHELL  "-/bin/sh"
extern const char bb_default_login_shell[] ALIGN1;
/* "/bin/sh" */
#define DEFAULT_SHELL              (bb_default_login_shell+1)
/* "sh" */
#define DEFAULT_SHELL_SHORT_NAME   (bb_default_login_shell+6)

/* The following devices are the same on all systems.  */
#define CURRENT_TTY "/dev/tty"
#define DEV_CONSOLE "/dev/console"

#if defined(__FreeBSD_kernel__)
# define CURRENT_VC CURRENT_TTY
# define VC_1 "/dev/ttyv0"
# define VC_2 "/dev/ttyv1"
# define VC_3 "/dev/ttyv2"
# define VC_4 "/dev/ttyv3"
# define VC_5 "/dev/ttyv4"
# define VC_FORMAT "/dev/ttyv%d"
#elif defined(__GNU__)
# 1898 "include/libbb.h"
# define CURRENT_VC CURRENT_TTY
# define VC_1 "/dev/tty1"
# define VC_2 "/dev/tty2"
# define VC_3 "/dev/tty3"
# define VC_4 "/dev/tty4"
# define VC_5 "/dev/tty5"
# define VC_FORMAT "/dev/tty%d"
#elif ENABLE_FEATURE_DEVFS
# 1906 "include/libbb.h"
/*Linux, obsolete devfs names */
# define CURRENT_VC "/dev/vc/0"
# define VC_1 "/dev/vc/1"
# define VC_2 "/dev/vc/2"
# define VC_3 "/dev/vc/3"
# define VC_4 "/dev/vc/4"
# define VC_5 "/dev/vc/5"
# define VC_FORMAT "/dev/vc/%d"
# define LOOP_FORMAT "/dev/loop/%u"
# define LOOP_NAMESIZE (sizeof("/dev/loop/") + sizeof(int)*3 + 1)
# define LOOP_NAME "/dev/loop/"
# define FB_0 "/dev/fb/0"
#else
# 1919 "include/libbb.h"
/*Linux, normal names */
# define CURRENT_VC "/dev/tty0"
# define VC_1 "/dev/tty1"
# define VC_2 "/dev/tty2"
# define VC_3 "/dev/tty3"
# define VC_4 "/dev/tty4"
# define VC_5 "/dev/tty5"
# define VC_FORMAT "/dev/tty%d"
# define LOOP_FORMAT "/dev/loop%u"
# define LOOP_NAMESIZE (sizeof("/dev/loop") + sizeof(int)*3 + 1)
# define LOOP_NAME "/dev/loop"
# define FB_0 "/dev/fb0"
#endif
# 1932 "include/libbb.h"


#define ARRAY_SIZE(x) ((unsigned)(sizeof(x) / sizeof((x)[0])))
#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))


/* We redefine ctype macros. Unicode-correct handling of char types
 * can't be done with such byte-oriented operations anyway,
 * we don't lose anything.
 */
#undef isalnum
#undef isalpha
#undef isascii
#undef isblank
#undef iscntrl
#undef isdigit
#undef isgraph
#undef islower
#undef isprint
#undef ispunct
#undef isspace
#undef isupper
#undef isxdigit
#undef toupper
#undef tolower

/* We save ~500 bytes on isdigit alone.
 * BTW, x86 likes (unsigned char) cast more than (unsigned). */

/* These work the same for ASCII and Unicode,
 * assuming no one asks "is this a *Unicode* letter?" using isalpha(letter) */
#define isascii(a) ((unsigned char)(a) <= 0x7f)
#define isdigit(a) ((unsigned char)((a) - '0') <= 9)
#define isupper(a) ((unsigned char)((a) - 'A') <= ('Z' - 'A'))
#define islower(a) ((unsigned char)((a) - 'a') <= ('z' - 'a'))
#define isalpha(a) ((unsigned char)(((a)|0x20) - 'a') <= ('z' - 'a'))
#define isblank(a) ({ unsigned char bb__isblank = (a); bb__isblank == ' ' || bb__isblank == '\t'; })
#define iscntrl(a) ({ unsigned char bb__iscntrl = (a); bb__iscntrl < ' ' || bb__iscntrl == 0x7f; })
/* In POSIX/C locale isspace is only these chars: "\t\n\v\f\r" and space.
 * "\t\n\v\f\r" happen to have ASCII codes 9,10,11,12,13.
 */
#define isspace(a) ({ unsigned char bb__isspace = (a) - 9; bb__isspace == (' ' - 9) || bb__isspace <= (13 - 9); })
// Unsafe wrt NUL: #define ispunct(a) (strchr("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", (a)) != NULL)
#define ispunct(a) (strchrnul("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", (a))[0])
// Bigger code: #define isalnum(a) ({ unsigned char bb__isalnum = (a) - '0'; bb__isalnum <= 9 || ((bb__isalnum - ('A' - '0')) & 0xdf) <= 25; })
#define isalnum(a) bb_ascii_isalnum(a)
static ALWAYS_INLINE int bb_ascii_isalnum(unsigned char a)
{
	unsigned char b = a - '0';
	if (b <= 9)
		return (b <= 9);
	b = (a|0x20) - 'a';
	return b <= 'z' - 'a';
}
#define isxdigit(a) bb_ascii_isxdigit(a)
static ALWAYS_INLINE int bb_ascii_isxdigit(unsigned char a)
{
	unsigned char b = a - '0';
	if (b <= 9)
		return (b <= 9);
	b = (a|0x20) - 'a';
	return b <= 'f' - 'a';
}
#define toupper(a) bb_ascii_toupper(a)
static ALWAYS_INLINE unsigned char bb_ascii_toupper(unsigned char a)
{
	unsigned char b = a - 'a';
	if (b <= ('z' - 'a'))
		a -= 'a' - 'A';
	return a;
}
#define tolower(a) bb_ascii_tolower(a)
static ALWAYS_INLINE unsigned char bb_ascii_tolower(unsigned char a)
{
	unsigned char b = a - 'A';
	if (b <= ('Z' - 'A'))
		a += 'a' - 'A';
	return a;
}

/* In ASCII and Unicode, these are likely to be very different.
 * Let's prevent ambiguous usage from the start */
#define isgraph(a) isgraph_is_ambiguous_dont_use(a)
#define isprint(a) isprint_is_ambiguous_dont_use(a)
/* NB: must not treat EOF as isgraph or isprint */
#define isgraph_asciionly(a) ((unsigned)((a) - 0x21) <= 0x7e - 0x21)
#define isprint_asciionly(a) ((unsigned)((a) - 0x20) <= 0x7e - 0x20)


/* Simple unit-testing framework */

typedef void (*bbunit_testfunc)(void);

struct bbunit_listelem {
	const char* name;
	bbunit_testfunc testfunc;
};

void bbunit_registertest(struct bbunit_listelem* test);
void bbunit_settestfailed(void);

#define BBUNIT_DEFINE_TEST(NAME) \
	static void bbunit_##NAME##_test(void); \
	static struct bbunit_listelem bbunit_##NAME##_elem = { \
		.name = #NAME, \
		.testfunc = bbunit_##NAME##_test, \
	}; \
	static void INIT_FUNC bbunit_##NAME##_register(void) \
	{ \
		bbunit_registertest(&bbunit_##NAME##_elem); \
	} \
	static void bbunit_##NAME##_test(void)

/*
 * Both 'goto bbunit_end' and 'break' are here only to get rid
 * of compiler warnings.
 */
#define BBUNIT_ENDTEST \
	do { \
		goto bbunit_end; \
	bbunit_end: \
		break; \
	} while (0)

#define BBUNIT_PRINTASSERTFAIL \
	do { \
		bb_error_msg( \
			"[ERROR] Assertion failed in file %s, line %d", \
			__FILE__, __LINE__); \
	} while (0)

#define BBUNIT_ASSERTION_FAILED \
	do { \
		bbunit_settestfailed(); \
		goto bbunit_end; \
	} while (0)

/*
 * Assertions.
 * For now we only offer assertions which cause tests to fail
 * immediately. In the future 'expects' might be added too -
 * similar to those offered by the gtest framework.
 */
#define BBUNIT_ASSERT_EQ(EXPECTED, ACTUAL) \
	do { \
		if ((EXPECTED) != (ACTUAL)) { \
			BBUNIT_PRINTASSERTFAIL; \
			bb_error_msg("[ERROR] '%s' isn't equal to '%s'", \
						#EXPECTED, #ACTUAL); \
			BBUNIT_ASSERTION_FAILED; \
		} \
	} while (0)

#define BBUNIT_ASSERT_NOTEQ(EXPECTED, ACTUAL) \
	do { \
		if ((EXPECTED) == (ACTUAL)) { \
			BBUNIT_PRINTASSERTFAIL; \
			bb_error_msg("[ERROR] '%s' is equal to '%s'", \
						#EXPECTED, #ACTUAL); \
			BBUNIT_ASSERTION_FAILED; \
		} \
	} while (0)

#define BBUNIT_ASSERT_NOTNULL(PTR) \
	do { \
		if ((PTR) == NULL) { \
			BBUNIT_PRINTASSERTFAIL; \
			bb_error_msg("[ERROR] '%s' is NULL!", #PTR); \
			BBUNIT_ASSERTION_FAILED; \
		} \
	} while (0)

#define BBUNIT_ASSERT_NULL(PTR) \
	do { \
		if ((PTR) != NULL) { \
			BBUNIT_PRINTASSERTFAIL; \
			bb_error_msg("[ERROR] '%s' is not NULL!", #PTR); \
			BBUNIT_ASSERTION_FAILED; \
		} \
	} while (0)

#define BBUNIT_ASSERT_FALSE(STATEMENT) \
	do { \
		if ((STATEMENT)) { \
			BBUNIT_PRINTASSERTFAIL; \
			bb_error_msg("[ERROR] Statement '%s' evaluated to true!", \
								#STATEMENT); \
			BBUNIT_ASSERTION_FAILED; \
		} \
	} while (0)

#define BBUNIT_ASSERT_TRUE(STATEMENT) \
	do { \
		if (!(STATEMENT)) { \
			BBUNIT_PRINTASSERTFAIL; \
			bb_error_msg("[ERROR] Statement '%s' evaluated to false!", \
					#STATEMENT); \
			BBUNIT_ASSERTION_FAILED; \
		} \
	} while (0)

#define BBUNIT_ASSERT_STREQ(STR1, STR2) \
	do { \
		if (strcmp(STR1, STR2) != 0) { \
			BBUNIT_PRINTASSERTFAIL; \
			bb_error_msg("[ERROR] Strings '%s' and '%s' " \
					"are not the same", STR1, STR2); \
			BBUNIT_ASSERTION_FAILED; \
		} \
	} while (0)

#define BBUNIT_ASSERT_STRNOTEQ(STR1, STR2) \
	do { \
		if (strcmp(STR1, STR2) == 0) { \
			BBUNIT_PRINTASSERTFAIL; \
			bb_error_msg("[ERROR] Strings '%s' and '%s' " \
					"are the same, but were " \
					"expected to differ", STR1, STR2); \
			BBUNIT_ASSERTION_FAILED; \
		} \
	} while (0)


POP_SAVED_FUNCTION_VISIBILITY

#endif
# 2158 "include/libbb.h"
# 9 "include/busybox.h" 2
/* BB_DIR_foo and BB_SUID_bar constants: */
#if 0 /* expanded by -frewrite-includes */
#include "applet_metadata.h"
#endif /* expanded by -frewrite-includes */
# 10 "include/busybox.h"
# 1 "include/applet_metadata.h" 1
/* vi: set sw=4 ts=4: */
/*
 * Licensed under GPLv2 or later, see file LICENSE in this source tree.
 */
#ifndef APPLET_METADATA_H
#define APPLET_METADATA_H 1

/* Note: can be included by both host and target builds! */

/* order matters: used as index into "install_dir[]" in appletlib.c */
typedef enum bb_install_loc_t {
	BB_DIR_ROOT = 0,
	BB_DIR_BIN,
	BB_DIR_SBIN,
#if ENABLE_INSTALL_NO_USR
	BB_DIR_USR_BIN  = BB_DIR_BIN,
	BB_DIR_USR_SBIN = BB_DIR_SBIN,
#else
# 19 "include/applet_metadata.h"
	BB_DIR_USR_BIN,
	BB_DIR_USR_SBIN,
#endif
# 22 "include/applet_metadata.h"
} bb_install_loc_t;

typedef enum bb_suid_t {
	BB_SUID_DROP = 0,
	BB_SUID_MAYBE,
	BB_SUID_REQUIRE
} bb_suid_t;

#endif
# 31 "include/applet_metadata.h"
# 11 "include/busybox.h" 2

PUSH_AND_SET_FUNCTION_VISIBILITY_TO_HIDDEN

/* Defined in appletlib.c (by including generated applet_tables.h) */
/* Keep in sync with applets/applet_tables.c! */
extern const char applet_names[] ALIGN1;
extern int (*const applet_main[])(int argc, char **argv);
extern const uint8_t applet_flags[] ALIGN1;
extern const uint8_t applet_suid[] ALIGN1;
extern const uint8_t applet_install_loc[] ALIGN1;

#if ENABLE_FEATURE_PREFER_APPLETS \
 || ENABLE_FEATURE_SH_STANDALONE \
 || ENABLE_FEATURE_SH_NOFORK
# define APPLET_IS_NOFORK(i) (applet_flags[(i)/4] & (1 << (2 * ((i)%4))))
# define APPLET_IS_NOEXEC(i) (applet_flags[(i)/4] & (1 << ((2 * ((i)%4))+1)))
#else
# 28 "include/busybox.h"
# define APPLET_IS_NOFORK(i) 0
# define APPLET_IS_NOEXEC(i) 0
#endif
# 31 "include/busybox.h"

#if ENABLE_FEATURE_SUID
# define APPLET_SUID(i) ((applet_suid[(i)/4] >> (2 * ((i)%4)) & 3))
#endif
# 35 "include/busybox.h"

#if ENABLE_FEATURE_INSTALLER
#define APPLET_INSTALL_LOC(i) ({ \
	unsigned v = (i); \
	if (v & 1) v = applet_install_loc[v/2] >> 4; \
	else v = applet_install_loc[v/2] & 0xf; \
	v; })
#endif
# 43 "include/busybox.h"


/* Length of these names has effect on size of libbusybox
 * and "individual" binaries. Keep them short.
 */
#if ENABLE_BUILD_LIBBUSYBOX
#if ENABLE_FEATURE_SHARED_BUSYBOX
int lbb_main(char **argv) EXTERNALLY_VISIBLE;
#else
# 52 "include/busybox.h"
int lbb_main(char **argv);
#endif
# 54 "include/busybox.h"
#endif
# 55 "include/busybox.h"

POP_SAVED_FUNCTION_VISIBILITY

#endif
# 59 "include/busybox.h"
# 181 "shell/ash.c" 2

#if defined(__ANDROID_API__) && __ANDROID_API__ <= 24
/* Bionic at least up to version 24 has no glob() */
# undef  ENABLE_ASH_INTERNAL_GLOB
# define ENABLE_ASH_INTERNAL_GLOB 1
#endif
# 187 "shell/ash.c"

#if !ENABLE_ASH_INTERNAL_GLOB && defined(__UCLIBC__)
# error uClibc glob() is buggy, use ASH_INTERNAL_GLOB.
# error The bug is: for "$PWD"/<pattern> ash will escape e.g. dashes in "$PWD"
# error with backslash, even ones which do not need to be: "/a-b" -> "/a\-b"
# error glob() should unbackslash them and match. uClibc does not unbackslash,
# error fails to match dirname, subsequently not expanding <pattern> in it.
// Testcase:
// if (glob("/etc/polkit\\-1", 0, NULL, &pglob)) - this returns 0 on uclibc, no bug
// if (glob("/etc/polkit\\-1/*", 0, NULL, &pglob)) printf("uclibc bug!\n");
#endif
# 198 "shell/ash.c"

#if !ENABLE_ASH_INTERNAL_GLOB
#if 0 /* expanded by -frewrite-includes */
# include <glob.h>
#endif /* expanded by -frewrite-includes */
# 200 "shell/ash.c"
# 1 "/usr/include/glob.h" 1 3 4
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Guido van Rossum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)glob.h	8.1 (Berkeley) 6/2/93
 * $FreeBSD: releng/11.0/include/glob.h 228754 2011-12-20 22:56:13Z eadler $
 */

#ifndef _GLOB_H_
#define	_GLOB_H_

#if 0 /* expanded by -frewrite-includes */
#include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 39 "/usr/include/glob.h" 3 4
# 40 "/usr/include/glob.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sys/_types.h>
#endif /* expanded by -frewrite-includes */
# 40 "/usr/include/glob.h" 3 4
# 41 "/usr/include/glob.h" 3 4

#ifndef	_SIZE_T_DECLARED
typedef	__size_t	size_t;
#define	_SIZE_T_DECLARED
#endif
# 46 "/usr/include/glob.h" 3 4

struct stat;
typedef struct {
	size_t gl_pathc;	/* Count of total paths so far. */
	size_t gl_matchc;	/* Count of paths matching pattern. */
	size_t gl_offs;		/* Reserved at beginning of gl_pathv. */
	int gl_flags;		/* Copy of flags parameter to glob. */
	char **gl_pathv;	/* List of paths matching pattern. */
				/* Copy of errfunc parameter to glob. */
	int (*gl_errfunc)(const char *, int);

	/*
	 * Alternate filesystem access methods for glob; replacement
	 * versions of closedir(3), readdir(3), opendir(3), stat(2)
	 * and lstat(2).
	 */
	void (*gl_closedir)(void *);
	struct dirent *(*gl_readdir)(void *);
	void *(*gl_opendir)(const char *);
	int (*gl_lstat)(const char *, struct stat *);
	int (*gl_stat)(const char *, struct stat *);
} glob_t;

#if __POSIX_VISIBLE >= 199209
/* Believed to have been introduced in 1003.2-1992 */
#define	GLOB_APPEND	0x0001	/* Append to output from previous call. */
#define	GLOB_DOOFFS	0x0002	/* Use gl_offs. */
#define	GLOB_ERR	0x0004	/* Return on error. */
#define	GLOB_MARK	0x0008	/* Append / to matching directories. */
#define	GLOB_NOCHECK	0x0010	/* Return pattern itself if nothing matches. */
#define	GLOB_NOSORT	0x0020	/* Don't sort. */
#define	GLOB_NOESCAPE	0x2000	/* Disable backslash escaping. */

/* Error values returned by glob(3) */
#define	GLOB_NOSPACE	(-1)	/* Malloc call failed. */
#define	GLOB_ABORTED	(-2)	/* Unignored error. */
#define	GLOB_NOMATCH	(-3)	/* No match and GLOB_NOCHECK was not set. */
#define	GLOB_NOSYS	(-4)	/* Obsolete: source comptability only. */
#endif /* __POSIX_VISIBLE >= 199209 */
# 85 "/usr/include/glob.h" 3 4

#if __BSD_VISIBLE
#define	GLOB_ALTDIRFUNC	0x0040	/* Use alternately specified directory funcs. */
#define	GLOB_BRACE	0x0080	/* Expand braces ala csh. */
#define	GLOB_MAGCHAR	0x0100	/* Pattern had globbing characters. */
#define	GLOB_NOMAGIC	0x0200	/* GLOB_NOCHECK without magic chars (csh). */
#define	GLOB_QUOTE	0x0400	/* Quote special chars with \. */
#define	GLOB_TILDE	0x0800	/* Expand tilde names from the passwd file. */
#define	GLOB_LIMIT	0x1000	/* limit number of returned paths */

/* source compatibility, these are the old names */
#define GLOB_MAXPATH	GLOB_LIMIT
#define	GLOB_ABEND	GLOB_ABORTED
#endif /* __BSD_VISIBLE */
# 99 "/usr/include/glob.h" 3 4

__BEGIN_DECLS
int	glob(const char * __restrict, int,
	int (*)(const char *, int), glob_t * __restrict);
void	globfree(glob_t *);
__END_DECLS

#endif /* !_GLOB_H_ */
# 107 "/usr/include/glob.h" 3 4
# 201 "shell/ash.c" 2
#endif
# 202 "shell/ash.c"

#if 0 /* expanded by -frewrite-includes */
#include "unicode.h"
#endif /* expanded by -frewrite-includes */
# 203 "shell/ash.c"
# 1 "include/unicode.h" 1
/* vi: set sw=4 ts=4: */
/*
 * Licensed under GPLv2, see file LICENSE in this source tree.
 */
#ifndef UNICODE_H
#define UNICODE_H 1

#if ENABLE_UNICODE_USING_LOCALE
#if 0 /* expanded by -frewrite-includes */
# include <wchar.h>
#endif /* expanded by -frewrite-includes */
# 9 "include/unicode.h"
# 10 "include/unicode.h"
#if 0 /* expanded by -frewrite-includes */
# include <wctype.h>
#endif /* expanded by -frewrite-includes */
# 10 "include/unicode.h"
# 11 "include/unicode.h"
#endif
# 12 "include/unicode.h"

PUSH_AND_SET_FUNCTION_VISIBILITY_TO_HIDDEN

enum {
	UNICODE_UNKNOWN = 0,
	UNICODE_OFF = 1,
	UNICODE_ON = 2,
};

#define unicode_bidi_isrtl(wc) 0
#define unicode_bidi_is_neutral_wchar(wc) (wc <= 126 && !isalpha(wc))

#if !ENABLE_UNICODE_SUPPORT

# define unicode_strlen(string)   strlen(string)
# define unicode_strwidth(string) strlen(string)
# define unicode_status UNICODE_OFF
# define init_unicode() ((void)0)
# define reinit_unicode(LANG) ((void)0)

#else
# 33 "include/unicode.h"

# if CONFIG_LAST_SUPPORTED_WCHAR < 126 || CONFIG_LAST_SUPPORTED_WCHAR >= 0x30000
#  undef CONFIG_LAST_SUPPORTED_WCHAR
#  define CONFIG_LAST_SUPPORTED_WCHAR 0x2ffff
# endif
# 38 "include/unicode.h"

# if CONFIG_LAST_SUPPORTED_WCHAR < 0x300
#  undef ENABLE_UNICODE_COMBINING_WCHARS
#  define ENABLE_UNICODE_COMBINING_WCHARS 0
# endif
# 43 "include/unicode.h"

# if CONFIG_LAST_SUPPORTED_WCHAR < 0x1100
#  undef ENABLE_UNICODE_WIDE_WCHARS
#  define ENABLE_UNICODE_WIDE_WCHARS 0
# endif
# 48 "include/unicode.h"

# if CONFIG_LAST_SUPPORTED_WCHAR < 0x590
#  undef  ENABLE_UNICODE_BIDI_SUPPORT
#  define ENABLE_UNICODE_BIDI_SUPPORT 0
# endif
# 53 "include/unicode.h"

/* Number of unicode chars. Falls back to strlen() on invalid unicode */
size_t FAST_FUNC unicode_strlen(const char *string);
/* Width on terminal */
size_t FAST_FUNC unicode_strwidth(const char *string);
enum {
	UNI_FLAG_PAD = (1 << 0),
};
//UNUSED: unsigned FAST_FUNC unicode_padding_to_width(unsigned width, const char *src);
//UNUSED: char* FAST_FUNC unicode_conv_to_printable2(uni_stat_t *stats, const char *src, unsigned width, int flags);
char* FAST_FUNC unicode_conv_to_printable(uni_stat_t *stats, const char *src);
//UNUSED: char* FAST_FUNC unicode_conv_to_printable_maxwidth(uni_stat_t *stats, const char *src, unsigned maxwidth);
char* FAST_FUNC unicode_conv_to_printable_fixedwidth(/*uni_stat_t *stats,*/ const char *src, unsigned width);

# if ENABLE_UNICODE_USING_LOCALE

extern uint8_t unicode_status;
void init_unicode(void) FAST_FUNC;
void reinit_unicode(const char *LANG) FAST_FUNC;

# else
# 74 "include/unicode.h"

/* Homegrown Unicode support. It knows only C and Unicode locales. */

#  if !ENABLE_FEATURE_CHECK_UNICODE_IN_ENV
#   define unicode_status UNICODE_ON
#   define init_unicode() ((void)0)
#   define reinit_unicode(LANG) ((void)0)
#  else
# 82 "include/unicode.h"
extern uint8_t unicode_status;
void init_unicode(void) FAST_FUNC;
void reinit_unicode(const char *LANG) FAST_FUNC;
#  endif
# 86 "include/unicode.h"

#  undef MB_CUR_MAX
#  define MB_CUR_MAX 6

/* Prevent name collisions */
#  define wint_t    bb_wint_t
#  define mbstate_t bb_mbstate_t
#  define mbstowcs  bb_mbstowcs
#  define wcstombs  bb_wcstombs
#  define wcrtomb   bb_wcrtomb
#  define iswspace  bb_iswspace
#  define iswalnum  bb_iswalnum
#  define iswpunct  bb_iswpunct
#  define wcwidth   bb_wcwidth

typedef int32_t wint_t;
typedef struct {
	char bogus;
} mbstate_t;

size_t mbstowcs(wchar_t *dest, const char *src, size_t n) FAST_FUNC;
size_t wcstombs(char *dest, const wchar_t *src, size_t n) FAST_FUNC;
size_t wcrtomb(char *s, wchar_t wc, mbstate_t *ps) FAST_FUNC;
int iswspace(wint_t wc) FAST_FUNC;
int iswalnum(wint_t wc) FAST_FUNC;
int iswpunct(wint_t wc) FAST_FUNC;
int wcwidth(unsigned ucs) FAST_FUNC;
#  if ENABLE_UNICODE_BIDI_SUPPORT
#   undef unicode_bidi_isrtl
int unicode_bidi_isrtl(wint_t wc) FAST_FUNC;
#   if ENABLE_UNICODE_NEUTRAL_TABLE
#    undef unicode_bidi_is_neutral_wchar
int unicode_bidi_is_neutral_wchar(wint_t wc) FAST_FUNC;
#   endif
# 120 "include/unicode.h"
#  endif
# 121 "include/unicode.h"


# endif /* !UNICODE_USING_LOCALE */
# 124 "include/unicode.h"

#endif /* UNICODE_SUPPORT */
# 126 "include/unicode.h"

POP_SAVED_FUNCTION_VISIBILITY

#endif
# 130 "include/unicode.h"
# 204 "shell/ash.c" 2
#if 0 /* expanded by -frewrite-includes */
#include "shell_common.h"
#endif /* expanded by -frewrite-includes */
# 204 "shell/ash.c"
# 1 "shell/shell_common.h" 1
/* vi: set sw=4 ts=4: */
/*
 * Adapted from ash applet code
 *
 * This code is derived from software contributed to Berkeley by
 * Kenneth Almquist.
 *
 * Copyright (c) 1989, 1991, 1993, 1994
 *      The Regents of the University of California.  All rights reserved.
 *
 * Copyright (c) 1997-2005 Herbert Xu <herbert@gondor.apana.org.au>
 * was re-ported from NetBSD and debianized.
 *
 * Copyright (c) 2010 Denys Vlasenko
 * Split from ash.c
 *
 * Licensed under GPLv2 or later, see file LICENSE in this source tree.
 */
#ifndef SHELL_COMMON_H
#define SHELL_COMMON_H 1

PUSH_AND_SET_FUNCTION_VISIBILITY_TO_HIDDEN

extern const char defifsvar[] ALIGN1; /* "IFS= \t\n" */
#define defifs (defifsvar + 4)

extern const char defoptindvar[] ALIGN1; /* "OPTIND=1" */

int FAST_FUNC is_well_formed_var_name(const char *s, char terminator);

/* Builtins */

enum {
	BUILTIN_READ_SILENT = 1 << 0,
	BUILTIN_READ_RAW    = 1 << 1,
};
const char* FAST_FUNC
shell_builtin_read(void FAST_FUNC (*setvar)(const char *name, const char *val),
	char       **argv,
	const char *ifs,
	int        read_flags,
	const char *opt_n,
	const char *opt_p,
	const char *opt_t,
	const char *opt_u
);

int FAST_FUNC
shell_builtin_ulimit(char **argv);

POP_SAVED_FUNCTION_VISIBILITY

#endif
# 54 "shell/shell_common.h"
# 205 "shell/ash.c" 2
#if ENABLE_FEATURE_SH_MATH
#if 0 /* expanded by -frewrite-includes */
# include "math.h"
#endif /* expanded by -frewrite-includes */
# 206 "shell/ash.c"
# 207 "shell/ash.c"
#endif
# 208 "shell/ash.c"
#if ENABLE_ASH_RANDOM_SUPPORT
#if 0 /* expanded by -frewrite-includes */
# include "random.h"
#endif /* expanded by -frewrite-includes */
# 209 "shell/ash.c"
# 210 "shell/ash.c"
#else
# 211 "shell/ash.c"
# define CLEAR_RANDOM_T(rnd) ((void)0)
#endif
# 213 "shell/ash.c"

#if 0 /* expanded by -frewrite-includes */
#include "NUM_APPLETS.h"
#endif /* expanded by -frewrite-includes */
# 214 "shell/ash.c"
# 1 "include/NUM_APPLETS.h" 1
#define NUM_APPLETS 171
# 215 "shell/ash.c" 2
#if NUM_APPLETS == 1
/* STANDALONE does not make sense, and won't compile */
# undef CONFIG_FEATURE_SH_STANDALONE
# undef ENABLE_FEATURE_SH_STANDALONE
# undef IF_FEATURE_SH_STANDALONE
# undef IF_NOT_FEATURE_SH_STANDALONE
# define ENABLE_FEATURE_SH_STANDALONE 0
# define IF_FEATURE_SH_STANDALONE(...)
# define IF_NOT_FEATURE_SH_STANDALONE(...) __VA_ARGS__
#endif
# 225 "shell/ash.c"

#ifndef PIPE_BUF
# define PIPE_BUF 4096           /* amount of buffering in a pipe */
#endif
# 229 "shell/ash.c"

#if !BB_MMU
# error "Do not even bother, ash will not run on NOMMU machine"
#endif
# 233 "shell/ash.c"


/* ============ Hash table sizes. Configurable. */

#define VTABSIZE 39
#define ATABSIZE 39
#define CMDTABLESIZE 31         /* should be prime */


/* ============ Shell options */

static const char *const optletters_optnames[] = {
	"e"   "errexit",
	"f"   "noglob",
	"I"   "ignoreeof",
	"i"   "interactive",
	"m"   "monitor",
	"n"   "noexec",
	"s"   "stdin",
	"x"   "xtrace",
	"v"   "verbose",
	"C"   "noclobber",
	"a"   "allexport",
	"b"   "notify",
	"u"   "nounset",
	"\0"  "vi"
#if ENABLE_ASH_BASH_COMPAT
	,"\0"  "pipefail"
#endif
# 262 "shell/ash.c"
#if DEBUG
	,"\0"  "nolog"
	,"\0"  "debug"
#endif
# 266 "shell/ash.c"
};

#define optletters(n)  optletters_optnames[n][0]
#define optnames(n)   (optletters_optnames[n] + 1)

enum { NOPTS = ARRAY_SIZE(optletters_optnames) };


/* ============ Misc data */

#define msg_illnum "Illegal number: %s"

/*
 * We enclose jmp_buf in a structure so that we can declare pointers to
 * jump locations.  The global variable handler contains the location to
 * jump to when an exception occurs, and the global variable exception_type
 * contains a code identifying the exception.  To implement nested
 * exception handlers, the user should save the value of handler on entry
 * to an inner scope, set handler to point to a jmploc structure for the
 * inner scope, and restore handler on exit from the scope.
 */
struct jmploc {
	jmp_buf loc;
};

struct globals_misc {
	uint8_t exitstatus;     /* exit status of last command */
	uint8_t back_exitstatus;/* exit status of backquoted command */
	smallint job_warning;   /* user was warned about stopped jobs (can be 2, 1 or 0). */
	int rootpid;            /* pid of main shell */
	/* shell level: 0 for the main shell, 1 for its children, and so on */
	int shlvl;
#define rootshell (!shlvl)
	char *minusc;  /* argument to -c option */

	char *curdir; // = nullstr;     /* current working directory */
	char *physdir; // = nullstr;    /* physical working directory */

	char *arg0; /* value of $0 */

	struct jmploc *exception_handler;

	volatile int suppress_int; /* counter */
	volatile /*sig_atomic_t*/ smallint pending_int; /* 1 = got SIGINT */
	volatile /*sig_atomic_t*/ smallint got_sigchld; /* 1 = got SIGCHLD */
	volatile /*sig_atomic_t*/ smallint pending_sig;	/* last pending signal */
	smallint exception_type; /* kind of exception (0..5) */
	/* exceptions */
#define EXINT 0         /* SIGINT received */
#define EXERROR 1       /* a generic error */
#define EXEXIT 4        /* exit the shell */

	smallint isloginsh;
	char nullstr[1];        /* zero length string */

	char optlist[NOPTS];
#define eflag optlist[0]
#define fflag optlist[1]
#define Iflag optlist[2]
#define iflag optlist[3]
#define mflag optlist[4]
#define nflag optlist[5]
#define sflag optlist[6]
#define xflag optlist[7]
#define vflag optlist[8]
#define Cflag optlist[9]
#define aflag optlist[10]
#define bflag optlist[11]
#define uflag optlist[12]
#define viflag optlist[13]
#if ENABLE_ASH_BASH_COMPAT
# define pipefail optlist[14]
#else
# 339 "shell/ash.c"
# define pipefail 0
#endif
# 341 "shell/ash.c"
#if DEBUG
# define nolog optlist[14 + ENABLE_ASH_BASH_COMPAT]
# define debug optlist[15 + ENABLE_ASH_BASH_COMPAT]
#endif
# 345 "shell/ash.c"

	/* trap handler commands */
	/*
	 * Sigmode records the current value of the signal handlers for the various
	 * modes.  A value of zero means that the current handler is not known.
	 * S_HARD_IGN indicates that the signal was ignored on entry to the shell.
	 */
	char sigmode[NSIG - 1];
#define S_DFL      1            /* default signal handling (SIG_DFL) */
#define S_CATCH    2            /* signal is caught */
#define S_IGN      3            /* signal is ignored (SIG_IGN) */
#define S_HARD_IGN 4            /* signal is ignored permanently */

	/* indicates specified signal received */
	uint8_t gotsig[NSIG - 1]; /* offset by 1: "signal" 0 is meaningless */
	uint8_t may_have_traps; /* 0: definitely no traps are set, 1: some traps may be set */
	char *trap[NSIG];
	char **trap_ptr;        /* used only by "trap hack" */

	/* Rarely referenced stuff */
#if ENABLE_ASH_RANDOM_SUPPORT
	random_t random_gen;
#endif
# 368 "shell/ash.c"
	pid_t backgndpid;        /* pid of last background process */
};
extern struct globals_misc *const ash_ptr_to_globals_misc;
#define G_misc (*ash_ptr_to_globals_misc)
#define exitstatus        (G_misc.exitstatus )
#define back_exitstatus   (G_misc.back_exitstatus )
#define job_warning       (G_misc.job_warning)
#define rootpid     (G_misc.rootpid    )
#define shlvl       (G_misc.shlvl      )
#define minusc      (G_misc.minusc     )
#define curdir      (G_misc.curdir     )
#define physdir     (G_misc.physdir    )
#define arg0        (G_misc.arg0       )
#define exception_handler (G_misc.exception_handler)
#define exception_type    (G_misc.exception_type   )
#define suppress_int      (G_misc.suppress_int     )
#define pending_int       (G_misc.pending_int      )
#define got_sigchld       (G_misc.got_sigchld      )
#define pending_sig       (G_misc.pending_sig      )
#define isloginsh   (G_misc.isloginsh  )
#define nullstr     (G_misc.nullstr    )
#define optlist     (G_misc.optlist    )
#define sigmode     (G_misc.sigmode    )
#define gotsig      (G_misc.gotsig     )
#define may_have_traps    (G_misc.may_have_traps   )
#define trap        (G_misc.trap       )
#define trap_ptr    (G_misc.trap_ptr   )
#define random_gen  (G_misc.random_gen )
#define backgndpid  (G_misc.backgndpid )
#define INIT_G_misc() do { \
	(*(struct globals_misc**)&ash_ptr_to_globals_misc) = xzalloc(sizeof(G_misc)); \
	barrier(); \
	curdir = nullstr; \
	physdir = nullstr; \
	trap_ptr = trap; \
} while (0)


/* ============ DEBUG */
#if DEBUG
static void trace_printf(const char *fmt, ...);
static void trace_vprintf(const char *fmt, va_list va);
# define TRACE(param)    trace_printf param
# define TRACEV(param)   trace_vprintf param
# define close(fd) do { \
	int dfd = (fd); \
	if (close(dfd) < 0) \
		bb_error_msg("bug on %d: closing %d(0x%x)", \
			__LINE__, dfd, dfd); \
} while (0)
#else
# 419 "shell/ash.c"
# define TRACE(param)
# define TRACEV(param)
#endif
# 422 "shell/ash.c"


/* ============ Utility functions */
#define is_name(c)      ((c) == '_' || isalpha((unsigned char)(c)))
#define is_in_name(c)   ((c) == '_' || isalnum((unsigned char)(c)))

static int
isdigit_str9(const char *str)
{
	int maxlen = 9 + 1; /* max 9 digits: 999999999 */
	while (--maxlen && isdigit(*str))
		str++;
	return (*str == '\0');
}

static const char *
var_end(const char *var)
{
	while (*var)
		if (*var++ == '=')
			break;
	return var;
}


/* ============ Interrupts / exceptions */

static void exitshell(void) NORETURN;

/*
 * These macros allow the user to suspend the handling of interrupt signals
 * over a period of time.  This is similar to SIGHOLD or to sigblock, but
 * much more efficient and portable.  (But hacking the kernel is so much
 * more fun than worrying about efficiency and portability. :-))
 */
#if DEBUG_INTONOFF
# define INT_OFF do { \
	TRACE(("%s:%d INT_OFF(%d)\n", __func__, __LINE__, suppress_int)); \
	suppress_int++; \
	barrier(); \
} while (0)
#else
# 464 "shell/ash.c"
# define INT_OFF do { \
	suppress_int++; \
	barrier(); \
} while (0)
#endif
# 469 "shell/ash.c"

/*
 * Called to raise an exception.  Since C doesn't include exceptions, we
 * just do a longjmp to the exception handler.  The type of exception is
 * stored in the global variable "exception_type".
 */
static void raise_exception(int) NORETURN;
static void
raise_exception(int e)
{
#if DEBUG
	if (exception_handler == NULL)
		abort();
#endif
# 483 "shell/ash.c"
	INT_OFF;
	exception_type = e;
	longjmp(exception_handler->loc, 1);
}
#if DEBUG
#define raise_exception(e) do { \
	TRACE(("raising exception %d on line %d\n", (e), __LINE__)); \
	raise_exception(e); \
} while (0)
#endif
# 493 "shell/ash.c"

/*
 * Called when a SIGINT is received.  (If the user specifies
 * that SIGINT is to be trapped or ignored using the trap builtin, then
 * this routine is not called.)  Suppressint is nonzero when interrupts
 * are held using the INT_OFF macro.  (The test for iflag is just
 * defensive programming.)
 */
static void raise_interrupt(void) NORETURN;
static void
raise_interrupt(void)
{
	pending_int = 0;
	/* Signal is not automatically unmasked after it is raised,
	 * do it ourself - unmask all signals */
	sigprocmask_allsigs(SIG_UNBLOCK);
	/* pending_sig = 0; - now done in signal_handler() */

	if (!(rootshell && iflag)) {
		/* Kill ourself with SIGINT */
		signal(SIGINT, SIG_DFL);
		raise(SIGINT);
	}
	/* bash: ^C even on empty command line sets $? */
	exitstatus = SIGINT + 128;
	raise_exception(EXINT);
	/* NOTREACHED */
}
#if DEBUG
#define raise_interrupt() do { \
	TRACE(("raising interrupt on line %d\n", __LINE__)); \
	raise_interrupt(); \
} while (0)
#endif
# 527 "shell/ash.c"

static IF_ASH_OPTIMIZE_FOR_SIZE(inline) void
int_on(void)
{
	barrier();
	if (--suppress_int == 0 && pending_int) {
		raise_interrupt();
	}
}
#if DEBUG_INTONOFF
# define INT_ON do { \
	TRACE(("%s:%d INT_ON(%d)\n", __func__, __LINE__, suppress_int-1)); \
	int_on(); \
} while (0)
#else
# 542 "shell/ash.c"
# define INT_ON int_on()
#endif
# 544 "shell/ash.c"
static IF_ASH_OPTIMIZE_FOR_SIZE(inline) void
force_int_on(void)
{
	barrier();
	suppress_int = 0;
	if (pending_int)
		raise_interrupt();
}
#define FORCE_INT_ON force_int_on()

#define SAVE_INT(v) ((v) = suppress_int)

#define RESTORE_INT(v) do { \
	barrier(); \
	suppress_int = (v); \
	if (suppress_int == 0 && pending_int) \
		raise_interrupt(); \
} while (0)


/* ============ Stdout/stderr output */

static void
outstr(const char *p, FILE *file)
{
	INT_OFF;
	fputs(p, file);
	INT_ON;
}

static void
flush_stdout_stderr(void)
{
	INT_OFF;
	fflush_all();
	INT_ON;
}

/* Was called outcslow(c,FILE*), but c was always '\n' */
static void
newline_and_flush(FILE *dest)
{
	INT_OFF;
	putc('\n', dest);
	fflush(dest);
	INT_ON;
}

static int out1fmt(const char *, ...) __attribute__((__format__(__printf__,1,2)));
static int
out1fmt(const char *fmt, ...)
{
	va_list ap;
	int r;

	INT_OFF;
	va_start(ap, fmt);
	r = vprintf(fmt, ap);
	va_end(ap);
	INT_ON;
	return r;
}

static int fmtstr(char *, size_t, const char *, ...) __attribute__((__format__(__printf__,3,4)));
static int
fmtstr(char *outbuf, size_t length, const char *fmt, ...)
{
	va_list ap;
	int ret;

	va_start(ap, fmt);
	INT_OFF;
	ret = vsnprintf(outbuf, length, fmt, ap);
	va_end(ap);
	INT_ON;
	return ret;
}

static void
out1str(const char *p)
{
	outstr(p, stdout);
}

static void
out2str(const char *p)
{
	outstr(p, stderr);
	flush_stdout_stderr();
}


/* ============ Parser structures */

/* control characters in argument strings */
#define CTL_FIRST CTLESC
#define CTLESC       ((unsigned char)'\201')    /* escape next character */
#define CTLVAR       ((unsigned char)'\202')    /* variable defn */
#define CTLENDVAR    ((unsigned char)'\203')
#define CTLBACKQ     ((unsigned char)'\204')
#define CTLARI       ((unsigned char)'\206')    /* arithmetic expression */
#define CTLENDARI    ((unsigned char)'\207')
#define CTLQUOTEMARK ((unsigned char)'\210')
#define CTL_LAST CTLQUOTEMARK

/* variable substitution byte (follows CTLVAR) */
#define VSTYPE  0x0f            /* type of variable substitution */
#define VSNUL   0x10            /* colon--treat the empty string as unset */

/* values of VSTYPE field */
#define VSNORMAL        0x1     /* normal variable:  $var or ${var} */
#define VSMINUS         0x2     /* ${var-text} */
#define VSPLUS          0x3     /* ${var+text} */
#define VSQUESTION      0x4     /* ${var?message} */
#define VSASSIGN        0x5     /* ${var=text} */
#define VSTRIMRIGHT     0x6     /* ${var%pattern} */
#define VSTRIMRIGHTMAX  0x7     /* ${var%%pattern} */
#define VSTRIMLEFT      0x8     /* ${var#pattern} */
#define VSTRIMLEFTMAX   0x9     /* ${var##pattern} */
#define VSLENGTH        0xa     /* ${#var} */
#if ENABLE_ASH_BASH_COMPAT
#define VSSUBSTR        0xc     /* ${var:position:length} */
#define VSREPLACE       0xd     /* ${var/pattern/replacement} */
#define VSREPLACEALL    0xe     /* ${var//pattern/replacement} */
#endif
# 669 "shell/ash.c"

static const char dolatstr[] ALIGN1 = {
	CTLQUOTEMARK, CTLVAR, VSNORMAL, '@', '=', CTLQUOTEMARK, '\0'
};
#define DOLATSTRLEN 6

#define NCMD      0
#define NPIPE     1
#define NREDIR    2
#define NBACKGND  3
#define NSUBSHELL 4
#define NAND      5
#define NOR       6
#define NSEMI     7
#define NIF       8
#define NWHILE    9
#define NUNTIL   10
#define NFOR     11
#define NCASE    12
#define NCLIST   13
#define NDEFUN   14
#define NARG     15
#define NTO      16
#if ENABLE_ASH_BASH_COMPAT
#define NTO2     17
#endif
# 695 "shell/ash.c"
#define NCLOBBER 18
#define NFROM    19
#define NFROMTO  20
#define NAPPEND  21
#define NTOFD    22
#define NFROMFD  23
#define NHERE    24
#define NXHERE   25
#define NNOT     26
#define N_NUMBER 27

union node;

struct ncmd {
	smallint type; /* Nxxxx */
	union node *assign;
	union node *args;
	union node *redirect;
};

struct npipe {
	smallint type;
	smallint pipe_backgnd;
	struct nodelist *cmdlist;
};

struct nredir {
	smallint type;
	union node *n;
	union node *redirect;
};

struct nbinary {
	smallint type;
	union node *ch1;
	union node *ch2;
};

struct nif {
	smallint type;
	union node *test;
	union node *ifpart;
	union node *elsepart;
};

struct nfor {
	smallint type;
	union node *args;
	union node *body;
	char *var;
};

struct ncase {
	smallint type;
	union node *expr;
	union node *cases;
};

struct nclist {
	smallint type;
	union node *next;
	union node *pattern;
	union node *body;
};

struct narg {
	smallint type;
	union node *next;
	char *text;
	struct nodelist *backquote;
};

/* nfile and ndup layout must match!
 * NTOFD (>&fdnum) uses ndup structure, but we may discover mid-flight
 * that it is actually NTO2 (>&file), and change its type.
 */
struct nfile {
	smallint type;
	union node *next;
	int fd;
	int _unused_dupfd;
	union node *fname;
	char *expfname;
};

struct ndup {
	smallint type;
	union node *next;
	int fd;
	int dupfd;
	union node *vname;
	char *_unused_expfname;
};

struct nhere {
	smallint type;
	union node *next;
	int fd;
	union node *doc;
};

struct nnot {
	smallint type;
	union node *com;
};

union node {
	smallint type;
	struct ncmd ncmd;
	struct npipe npipe;
	struct nredir nredir;
	struct nbinary nbinary;
	struct nif nif;
	struct nfor nfor;
	struct ncase ncase;
	struct nclist nclist;
	struct narg narg;
	struct nfile nfile;
	struct ndup ndup;
	struct nhere nhere;
	struct nnot nnot;
};

/*
 * NODE_EOF is returned by parsecmd when it encounters an end of file.
 * It must be distinct from NULL.
 */
#define NODE_EOF ((union node *) -1L)

struct nodelist {
	struct nodelist *next;
	union node *n;
};

struct funcnode {
	int count;
	union node n;
};

/*
 * Free a parse tree.
 */
static void
freefunc(struct funcnode *f)
{
	if (f && --f->count < 0)
		free(f);
}


/* ============ Debugging output */

#if DEBUG

static FILE *tracefile;

static void
trace_printf(const char *fmt, ...)
{
	va_list va;

	if (debug != 1)
		return;
	if (DEBUG_TIME)
		fprintf(tracefile, "%u ", (int) time(NULL));
	if (DEBUG_PID)
		fprintf(tracefile, "[%u] ", (int) getpid());
	if (DEBUG_SIG)
		fprintf(tracefile, "pending s:%d i:%d(supp:%d) ", pending_sig, pending_int, suppress_int);
	va_start(va, fmt);
	vfprintf(tracefile, fmt, va);
	va_end(va);
}

static void
trace_vprintf(const char *fmt, va_list va)
{
	if (debug != 1)
		return;
	vfprintf(tracefile, fmt, va);
	fprintf(tracefile, "\n");
}

static void
trace_puts(const char *s)
{
	if (debug != 1)
		return;
	fputs(s, tracefile);
}

static void
trace_puts_quoted(char *s)
{
	char *p;
	char c;

	if (debug != 1)
		return;
	putc('"', tracefile);
	for (p = s; *p; p++) {
		switch ((unsigned char)*p) {
		case '\n': c = 'n'; goto backslash;
		case '\t': c = 't'; goto backslash;
		case '\r': c = 'r'; goto backslash;
		case '\"': c = '\"'; goto backslash;
		case '\\': c = '\\'; goto backslash;
		case CTLESC: c = 'e'; goto backslash;
		case CTLVAR: c = 'v'; goto backslash;
		case CTLBACKQ: c = 'q'; goto backslash;
 backslash:
			putc('\\', tracefile);
			putc(c, tracefile);
			break;
		default:
			if (*p >= ' ' && *p <= '~')
				putc(*p, tracefile);
			else {
				putc('\\', tracefile);
				putc((*p >> 6) & 03, tracefile);
				putc((*p >> 3) & 07, tracefile);
				putc(*p & 07, tracefile);
			}
			break;
		}
	}
	putc('"', tracefile);
}

static void
trace_puts_args(char **ap)
{
	if (debug != 1)
		return;
	if (!*ap)
		return;
	while (1) {
		trace_puts_quoted(*ap);
		if (!*++ap) {
			putc('\n', tracefile);
			break;
		}
		putc(' ', tracefile);
	}
}

static void
opentrace(void)
{
	char s[100];
#ifdef O_APPEND
	int flags;
#endif
# 948 "shell/ash.c"

	if (debug != 1) {
		if (tracefile)
			fflush(tracefile);
		/* leave open because libedit might be using it */
		return;
	}
	strcpy(s, "./trace");
	if (tracefile) {
		if (!freopen(s, "a", tracefile)) {
			fprintf(stderr, "Can't re-open %s\n", s);
			debug = 0;
			return;
		}
	} else {
		tracefile = fopen(s, "a");
		if (tracefile == NULL) {
			fprintf(stderr, "Can't open %s\n", s);
			debug = 0;
			return;
		}
	}
#ifdef O_APPEND
	flags = fcntl(fileno(tracefile), F_GETFL);
	if (flags >= 0)
		fcntl(fileno(tracefile), F_SETFL, flags | O_APPEND);
#endif
# 975 "shell/ash.c"
	setlinebuf(tracefile);
	fputs("\nTracing started.\n", tracefile);
}

static void
indent(int amount, char *pfx, FILE *fp)
{
	int i;

	for (i = 0; i < amount; i++) {
		if (pfx && i == amount - 1)
			fputs(pfx, fp);
		putc('\t', fp);
	}
}

/* little circular references here... */
static void shtree(union node *n, int ind, char *pfx, FILE *fp);

static void
sharg(union node *arg, FILE *fp)
{
	char *p;
	struct nodelist *bqlist;
	unsigned char subtype;

	if (arg->type != NARG) {
		out1fmt("<node type %d>\n", arg->type);
		abort();
	}
	bqlist = arg->narg.backquote;
	for (p = arg->narg.text; *p; p++) {
		switch ((unsigned char)*p) {
		case CTLESC:
			p++;
			putc(*p, fp);
			break;
		case CTLVAR:
			putc('$', fp);
			putc('{', fp);
			subtype = *++p;
			if (subtype == VSLENGTH)
				putc('#', fp);

			while (*p != '=') {
				putc(*p, fp);
				p++;
			}

			if (subtype & VSNUL)
				putc(':', fp);

			switch (subtype & VSTYPE) {
			case VSNORMAL:
				putc('}', fp);
				break;
			case VSMINUS:
				putc('-', fp);
				break;
			case VSPLUS:
				putc('+', fp);
				break;
			case VSQUESTION:
				putc('?', fp);
				break;
			case VSASSIGN:
				putc('=', fp);
				break;
			case VSTRIMLEFT:
				putc('#', fp);
				break;
			case VSTRIMLEFTMAX:
				putc('#', fp);
				putc('#', fp);
				break;
			case VSTRIMRIGHT:
				putc('%', fp);
				break;
			case VSTRIMRIGHTMAX:
				putc('%', fp);
				putc('%', fp);
				break;
			case VSLENGTH:
				break;
			default:
				out1fmt("<subtype %d>", subtype);
			}
			break;
		case CTLENDVAR:
			putc('}', fp);
			break;
		case CTLBACKQ:
			putc('$', fp);
			putc('(', fp);
			shtree(bqlist->n, -1, NULL, fp);
			putc(')', fp);
			break;
		default:
			putc(*p, fp);
			break;
		}
	}
}

static void
shcmd(union node *cmd, FILE *fp)
{
	union node *np;
	int first;
	const char *s;
	int dftfd;

	first = 1;
	for (np = cmd->ncmd.args; np; np = np->narg.next) {
		if (!first)
			putc(' ', fp);
		sharg(np, fp);
		first = 0;
	}
	for (np = cmd->ncmd.redirect; np; np = np->nfile.next) {
		if (!first)
			putc(' ', fp);
		dftfd = 0;
		switch (np->nfile.type) {
		case NTO:      s = ">>"+1; dftfd = 1; break;
		case NCLOBBER: s = ">|"; dftfd = 1; break;
		case NAPPEND:  s = ">>"; dftfd = 1; break;
#if ENABLE_ASH_BASH_COMPAT
		case NTO2:
#endif
# 1105 "shell/ash.c"
		case NTOFD:    s = ">&"; dftfd = 1; break;
		case NFROM:    s = "<"; break;
		case NFROMFD:  s = "<&"; break;
		case NFROMTO:  s = "<>"; break;
		default:       s = "*error*"; break;
		}
		if (np->nfile.fd != dftfd)
			fprintf(fp, "%d", np->nfile.fd);
		fputs(s, fp);
		if (np->nfile.type == NTOFD || np->nfile.type == NFROMFD) {
			fprintf(fp, "%d", np->ndup.dupfd);
		} else {
			sharg(np->nfile.fname, fp);
		}
		first = 0;
	}
}

static void
shtree(union node *n, int ind, char *pfx, FILE *fp)
{
	struct nodelist *lp;
	const char *s;

	if (n == NULL)
		return;

	indent(ind, pfx, fp);

	if (n == NODE_EOF) {
		fputs("<EOF>", fp);
		return;
	}

	switch (n->type) {
	case NSEMI:
		s = "; ";
		goto binop;
	case NAND:
		s = " && ";
		goto binop;
	case NOR:
		s = " || ";
 binop:
		shtree(n->nbinary.ch1, ind, NULL, fp);
		/* if (ind < 0) */
			fputs(s, fp);
		shtree(n->nbinary.ch2, ind, NULL, fp);
		break;
	case NCMD:
		shcmd(n, fp);
		if (ind >= 0)
			putc('\n', fp);
		break;
	case NPIPE:
		for (lp = n->npipe.cmdlist; lp; lp = lp->next) {
			shtree(lp->n, 0, NULL, fp);
			if (lp->next)
				fputs(" | ", fp);
		}
		if (n->npipe.pipe_backgnd)
			fputs(" &", fp);
		if (ind >= 0)
			putc('\n', fp);
		break;
	default:
		fprintf(fp, "<node type %d>", n->type);
		if (ind >= 0)
			putc('\n', fp);
		break;
	}
}

static void
showtree(union node *n)
{
	trace_puts("showtree called\n");
	shtree(n, 1, NULL, stderr);
}

#endif /* DEBUG */
# 1186 "shell/ash.c"


/* ============ Parser data */

/*
 * ash_vmsg() needs parsefile->fd, hence parsefile definition is moved up.
 */
struct strlist {
	struct strlist *next;
	char *text;
};

struct alias;

struct strpush {
	struct strpush *prev;   /* preceding string on stack */
	char *prev_string;
	int prev_left_in_line;
#if ENABLE_ASH_ALIAS
	struct alias *ap;       /* if push was associated with an alias */
#endif
# 1207 "shell/ash.c"
	char *string;           /* remember the string since it may change */

	/* Remember last two characters for pungetc. */
	int lastc[2];

	/* Number of outstanding calls to pungetc. */
	int unget;
};

struct parsefile {
	struct parsefile *prev; /* preceding file on stack */
	int linno;              /* current line */
	int pf_fd;              /* file descriptor (or -1 if string) */
	int left_in_line;       /* number of chars left in this line */
	int left_in_buffer;     /* number of chars left in this buffer past the line */
	char *next_to_pgetc;    /* next char in buffer */
	char *buf;              /* input buffer */
	struct strpush *strpush; /* for pushing strings at this level */
	struct strpush basestrpush; /* so pushing one is fast */

	/* Remember last two characters for pungetc. */
	int lastc[2];

	/* Number of outstanding calls to pungetc. */
	int unget;
};

static struct parsefile basepf;        /* top level input file */
static struct parsefile *g_parsefile = &basepf;  /* current input file */
static int startlinno;                 /* line # where last token started */
static char *commandname;              /* currently executing command */
static struct strlist *cmdenviron;     /* environment for builtin command */


/* ============ Message printing */

static void
ash_vmsg(const char *msg, va_list ap)
{
	fprintf(stderr, "%s: ", arg0);
	if (commandname) {
		if (strcmp(arg0, commandname))
			fprintf(stderr, "%s: ", commandname);
		if (!iflag || g_parsefile->pf_fd > 0)
			fprintf(stderr, "line %d: ", startlinno);
	}
	vfprintf(stderr, msg, ap);
	newline_and_flush(stderr);
}

/*
 * Exverror is called to raise the error exception.  If the second argument
 * is not NULL then error prints an error message using printf style
 * formatting.  It then raises the error exception.
 */
static void ash_vmsg_and_raise(int, const char *, va_list) NORETURN;
static void
ash_vmsg_and_raise(int cond, const char *msg, va_list ap)
{
#if DEBUG
	if (msg) {
		TRACE(("ash_vmsg_and_raise(%d):", cond));
		TRACEV((msg, ap));
	} else
		TRACE(("ash_vmsg_and_raise(%d):NULL\n", cond));
	if (msg)
#endif
# 1274 "shell/ash.c"
		ash_vmsg(msg, ap);

	flush_stdout_stderr();
	raise_exception(cond);
	/* NOTREACHED */
}

static void ash_msg_and_raise_error(const char *, ...) NORETURN;
static void
ash_msg_and_raise_error(const char *msg, ...)
{
	va_list ap;

	exitstatus = 2;

	va_start(ap, msg);
	ash_vmsg_and_raise(EXERROR, msg, ap);
	/* NOTREACHED */
	va_end(ap);
}

static void raise_error_syntax(const char *) NORETURN;
static void
raise_error_syntax(const char *msg)
{
	ash_msg_and_raise_error("syntax error: %s", msg);
	/* NOTREACHED */
}

static void ash_msg_and_raise(int, const char *, ...) NORETURN;
static void
ash_msg_and_raise(int cond, const char *msg, ...)
{
	va_list ap;

	va_start(ap, msg);
	ash_vmsg_and_raise(cond, msg, ap);
	/* NOTREACHED */
	va_end(ap);
}

/*
 * error/warning routines for external builtins
 */
static void
ash_msg(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	ash_vmsg(fmt, ap);
	va_end(ap);
}

/*
 * Return a string describing an error.  The returned string may be a
 * pointer to a static buffer that will be overwritten on the next call.
 * Action describes the operation that got the error.
 */
static const char *
errmsg(int e, const char *em)
{
	if (e == ENOENT || e == ENOTDIR) {
		return em;
	}
	return strerror(e);
}


/* ============ Memory allocation */

#if 0
/* I consider these wrappers nearly useless:
 * ok, they return you to nearest exception handler, but
 * how much memory do you leak in the process, making
 * memory starvation worse?
 */
static void *
ckrealloc(void * p, size_t nbytes)
{
	p = realloc(p, nbytes);
	if (!p)
		ash_msg_and_raise_error(bb_msg_memory_exhausted);
	return p;
}

static void *
ckmalloc(size_t nbytes)
{
	return ckrealloc(NULL, nbytes);
}

static void *
ckzalloc(size_t nbytes)
{
	return memset(ckmalloc(nbytes), 0, nbytes);
}

static char *
ckstrdup(const char *s)
{
	char *p = strdup(s);
	if (!p)
		ash_msg_and_raise_error(bb_msg_memory_exhausted);
	return p;
}
#else
# 1381 "shell/ash.c"
/* Using bbox equivalents. They exit if out of memory */
# define ckrealloc xrealloc
# define ckmalloc  xmalloc
# define ckzalloc  xzalloc
# define ckstrdup  xstrdup
#endif
# 1387 "shell/ash.c"

/*
 * It appears that grabstackstr() will barf with such alignments
 * because stalloc() will return a string allocated in a new stackblock.
 */
#define SHELL_ALIGN(nbytes) (((nbytes) + SHELL_SIZE) & ~SHELL_SIZE)
enum {
	/* Most machines require the value returned from malloc to be aligned
	 * in some way.  The following macro will get this right
	 * on many machines.  */
	SHELL_SIZE = sizeof(union { int i; char *cp; double d; }) - 1,
	/* Minimum size of a block */
	MINSIZE = SHELL_ALIGN(504),
};

struct stack_block {
	struct stack_block *prev;
	char space[MINSIZE];
};

struct stackmark {
	struct stack_block *stackp;
	char *stacknxt;
	size_t stacknleft;
};


struct globals_memstack {
	struct stack_block *g_stackp; // = &stackbase;
	char *g_stacknxt; // = stackbase.space;
	char *sstrend; // = stackbase.space + MINSIZE;
	size_t g_stacknleft; // = MINSIZE;
	struct stack_block stackbase;
};
extern struct globals_memstack *const ash_ptr_to_globals_memstack;
#define G_memstack (*ash_ptr_to_globals_memstack)
#define g_stackp     (G_memstack.g_stackp    )
#define g_stacknxt   (G_memstack.g_stacknxt  )
#define sstrend      (G_memstack.sstrend     )
#define g_stacknleft (G_memstack.g_stacknleft)
#define stackbase    (G_memstack.stackbase   )
#define INIT_G_memstack() do { \
	(*(struct globals_memstack**)&ash_ptr_to_globals_memstack) = xzalloc(sizeof(G_memstack)); \
	barrier(); \
	g_stackp = &stackbase; \
	g_stacknxt = stackbase.space; \
	g_stacknleft = MINSIZE; \
	sstrend = stackbase.space + MINSIZE; \
} while (0)


#define stackblock()     ((void *)g_stacknxt)
#define stackblocksize() g_stacknleft

/*
 * Parse trees for commands are allocated in lifo order, so we use a stack
 * to make this more efficient, and also to avoid all sorts of exception
 * handling code to handle interrupts in the middle of a parse.
 *
 * The size 504 was chosen because the Ultrix malloc handles that size
 * well.
 */
static void *
stalloc(size_t nbytes)
{
	char *p;
	size_t aligned;

	aligned = SHELL_ALIGN(nbytes);
	if (aligned > g_stacknleft) {
		size_t len;
		size_t blocksize;
		struct stack_block *sp;

		blocksize = aligned;
		if (blocksize < MINSIZE)
			blocksize = MINSIZE;
		len = sizeof(struct stack_block) - MINSIZE + blocksize;
		if (len < blocksize)
			ash_msg_and_raise_error(bb_msg_memory_exhausted);
		INT_OFF;
		sp = ckmalloc(len);
		sp->prev = g_stackp;
		g_stacknxt = sp->space;
		g_stacknleft = blocksize;
		sstrend = g_stacknxt + blocksize;
		g_stackp = sp;
		INT_ON;
	}
	p = g_stacknxt;
	g_stacknxt += aligned;
	g_stacknleft -= aligned;
	return p;
}

static void *
stzalloc(size_t nbytes)
{
	return memset(stalloc(nbytes), 0, nbytes);
}

static void
stunalloc(void *p)
{
#if DEBUG
	if (!p || (g_stacknxt < (char *)p) || ((char *)p < g_stackp->space)) {
		write(STDERR_FILENO, "stunalloc\n", 10);
		abort();
	}
#endif
# 1497 "shell/ash.c"
	g_stacknleft += g_stacknxt - (char *)p;
	g_stacknxt = p;
}

/*
 * Like strdup but works with the ash stack.
 */
static char *
sstrdup(const char *p)
{
	size_t len = strlen(p) + 1;
	return memcpy(stalloc(len), p, len);
}

static inline void
grabstackblock(size_t len)
{
	stalloc(len);
}

static void
pushstackmark(struct stackmark *mark, size_t len)
{
	mark->stackp = g_stackp;
	mark->stacknxt = g_stacknxt;
	mark->stacknleft = g_stacknleft;
	grabstackblock(len);
}

static void
setstackmark(struct stackmark *mark)
{
	pushstackmark(mark, g_stacknxt == g_stackp->space && g_stackp != &stackbase);
}

static void
popstackmark(struct stackmark *mark)
{
	struct stack_block *sp;

	if (!mark->stackp)
		return;

	INT_OFF;
	while (g_stackp != mark->stackp) {
		sp = g_stackp;
		g_stackp = sp->prev;
		free(sp);
	}
	g_stacknxt = mark->stacknxt;
	g_stacknleft = mark->stacknleft;
	sstrend = mark->stacknxt + mark->stacknleft;
	INT_ON;
}

/*
 * When the parser reads in a string, it wants to stick the string on the
 * stack and only adjust the stack pointer when it knows how big the
 * string is.  Stackblock (defined in stack.h) returns a pointer to a block
 * of space on top of the stack and stackblocklen returns the length of
 * this block.  Growstackblock will grow this space by at least one byte,
 * possibly moving it (like realloc).  Grabstackblock actually allocates the
 * part of the block that has been used.
 */
static void
growstackblock(void)
{
	size_t newlen;

	newlen = g_stacknleft * 2;
	if (newlen < g_stacknleft)
		ash_msg_and_raise_error(bb_msg_memory_exhausted);
	if (newlen < 128)
		newlen += 128;

	if (g_stacknxt == g_stackp->space && g_stackp != &stackbase) {
		struct stack_block *sp;
		struct stack_block *prevstackp;
		size_t grosslen;

		INT_OFF;
		sp = g_stackp;
		prevstackp = sp->prev;
		grosslen = newlen + sizeof(struct stack_block) - MINSIZE;
		sp = ckrealloc(sp, grosslen);
		sp->prev = prevstackp;
		g_stackp = sp;
		g_stacknxt = sp->space;
		g_stacknleft = newlen;
		sstrend = sp->space + newlen;
		INT_ON;
	} else {
		char *oldspace = g_stacknxt;
		size_t oldlen = g_stacknleft;
		char *p = stalloc(newlen);

		/* free the space we just allocated */
		g_stacknxt = memcpy(p, oldspace, oldlen);
		g_stacknleft += newlen;
	}
}

/*
 * The following routines are somewhat easier to use than the above.
 * The user declares a variable of type STACKSTR, which may be declared
 * to be a register.  The macro STARTSTACKSTR initializes things.  Then
 * the user uses the macro STPUTC to add characters to the string.  In
 * effect, STPUTC(c, p) is the same as *p++ = c except that the stack is
 * grown as necessary.  When the user is done, she can just leave the
 * string there and refer to it using stackblock().  Or she can allocate
 * the space for it using grabstackstr().  If it is necessary to allow
 * someone else to use the stack temporarily and then continue to grow
 * the string, the user should use grabstack to allocate the space, and
 * then call ungrabstr(p) to return to the previous mode of operation.
 *
 * USTPUTC is like STPUTC except that it doesn't check for overflow.
 * CHECKSTACKSPACE can be called before USTPUTC to ensure that there
 * is space for at least one character.
 */
static void *
growstackstr(void)
{
	size_t len = stackblocksize();
	growstackblock();
	return (char *)stackblock() + len;
}

/*
 * Called from CHECKSTRSPACE.
 */
static char *
makestrspace(size_t newlen, char *p)
{
	size_t len = p - g_stacknxt;
	size_t size;

	for (;;) {
		size_t nleft;

		size = stackblocksize();
		nleft = size - len;
		if (nleft >= newlen)
			break;
		growstackblock();
	}
	return (char *)stackblock() + len;
}

static char *
stack_nputstr(const char *s, size_t n, char *p)
{
	p = makestrspace(n, p);
	p = (char *)memcpy(p, s, n) + n;
	return p;
}

static char *
stack_putstr(const char *s, char *p)
{
	return stack_nputstr(s, strlen(s), p);
}

static char *
_STPUTC(int c, char *p)
{
	if (p == sstrend)
		p = growstackstr();
	*p++ = c;
	return p;
}

#define STARTSTACKSTR(p)        ((p) = stackblock())
#define STPUTC(c, p)            ((p) = _STPUTC((c), (p)))
#define CHECKSTRSPACE(n, p) do { \
	char *q = (p); \
	size_t l = (n); \
	size_t m = sstrend - q; \
	if (l > m) \
		(p) = makestrspace(l, q); \
} while (0)
#define USTPUTC(c, p)           (*(p)++ = (c))
#define STACKSTRNUL(p) do { \
	if ((p) == sstrend) \
		(p) = growstackstr(); \
	*(p) = '\0'; \
} while (0)
#define STUNPUTC(p)             (--(p))
#define STTOPC(p)               ((p)[-1])
#define STADJUST(amount, p)     ((p) += (amount))

#define grabstackstr(p)         stalloc((char *)(p) - (char *)stackblock())
#define ungrabstackstr(s, p)    stunalloc(s)
#define stackstrend()           ((void *)sstrend)


/* ============ String helpers */

/*
 * prefix -- see if pfx is a prefix of string.
 */
static char *
prefix(const char *string, const char *pfx)
{
	while (*pfx) {
		if (*pfx++ != *string++)
			return NULL;
	}
	return (char *) string;
}

/*
 * Check for a valid number.  This should be elsewhere.
 */
static int
is_number(const char *p)
{
	do {
		if (!isdigit(*p))
			return 0;
	} while (*++p != '\0');
	return 1;
}

/*
 * Convert a string of digits to an integer, printing an error message on
 * failure.
 */
static int
number(const char *s)
{
	if (!is_number(s))
		ash_msg_and_raise_error(msg_illnum, s);
	return atoi(s);
}

/*
 * Produce a possibly single quoted string suitable as input to the shell.
 * The return string is allocated on the stack.
 */
static char *
single_quote(const char *s)
{
	char *p;

	STARTSTACKSTR(p);

	do {
		char *q;
		size_t len;

		len = strchrnul(s, '\'') - s;

		q = p = makestrspace(len + 3, p);

		*q++ = '\'';
		q = (char *)memcpy(q, s, len) + len;
		*q++ = '\'';
		s += len;

		STADJUST(q - p, p);

		if (*s != '\'')
			break;
		len = 0;
		do len++; while (*++s == '\'');

		q = p = makestrspace(len + 3, p);

		*q++ = '"';
		q = (char *)memcpy(q, s - len, len) + len;
		*q++ = '"';

		STADJUST(q - p, p);
	} while (*s);

	USTPUTC('\0', p);

	return stackblock();
}


/* ============ nextopt */

static char **argptr;                  /* argument list for builtin commands */
static char *optionarg;                /* set by nextopt (like getopt) */
static char *optptr;                   /* used by nextopt */

/*
 * XXX - should get rid of. Have all builtins use getopt(3).
 * The library getopt must have the BSD extension static variable
 * "optreset", otherwise it can't be used within the shell safely.
 *
 * Standard option processing (a la getopt) for builtin routines.
 * The only argument that is passed to nextopt is the option string;
 * the other arguments are unnecessary. It returns the character,
 * or '\0' on end of input.
 */
static int
nextopt(const char *optstring)
{
	char *p;
	const char *q;
	char c;

	p = optptr;
	if (p == NULL || *p == '\0') {
		/* We ate entire "-param", take next one */
		p = *argptr;
		if (p == NULL)
			return '\0';
		if (*p != '-')
			return '\0';
		if (*++p == '\0') /* just "-" ? */
			return '\0';
		argptr++;
		if (LONE_DASH(p)) /* "--" ? */
			return '\0';
		/* p => next "-param" */
	}
	/* p => some option char in the middle of a "-param" */
	c = *p++;
	for (q = optstring; *q != c;) {
		if (*q == '\0')
			ash_msg_and_raise_error("illegal option -%c", c);
		if (*++q == ':')
			q++;
	}
	if (*++q == ':') {
		if (*p == '\0') {
			p = *argptr++;
			if (p == NULL)
				ash_msg_and_raise_error("no arg for -%c option", c);
		}
		optionarg = p;
		p = NULL;
	}
	optptr = p;
	return c;
}


/* ============ Shell variables */

/*
 * The parsefile structure pointed to by the global variable parsefile
 * contains information about the current file being read.
 */
struct shparam {
	int nparam;             /* # of positional parameters (without $0) */
#if ENABLE_ASH_GETOPTS
	int optind;             /* next parameter to be processed by getopts */
	int optoff;             /* used by getopts */
#endif
# 1850 "shell/ash.c"
	unsigned char malloced; /* if parameter list dynamically allocated */
	char **p;               /* parameter list */
};

/*
 * Free the list of positional parameters.
 */
static void
freeparam(volatile struct shparam *param)
{
	if (param->malloced) {
		char **ap, **ap1;
		ap = ap1 = param->p;
		while (*ap)
			free(*ap++);
		free(ap1);
	}
}

#if ENABLE_ASH_GETOPTS
static void FAST_FUNC getoptsreset(const char *value);
#endif
# 1872 "shell/ash.c"

struct var {
	struct var *next;               /* next entry in hash list */
	int flags;                      /* flags are defined above */
	const char *var_text;           /* name=value */
	void (*var_func)(const char *) FAST_FUNC; /* function to be called when  */
					/* the variable gets set/unset */
};

struct localvar {
	struct localvar *next;          /* next local variable in list */
	struct var *vp;                 /* the variable that was made local */
	int flags;                      /* saved flags */
	const char *text;               /* saved text */
};

/* flags */
#define VEXPORT         0x01    /* variable is exported */
#define VREADONLY       0x02    /* variable cannot be modified */
#define VSTRFIXED       0x04    /* variable struct is statically allocated */
#define VTEXTFIXED      0x08    /* text is statically allocated */
#define VSTACK          0x10    /* text is allocated on the stack */
#define VUNSET          0x20    /* the variable is not set */
#define VNOFUNC         0x40    /* don't call the callback function */
#define VNOSET          0x80    /* do not set variable - just readonly test */
#define VNOSAVE         0x100   /* when text is on the heap before setvareq */
#if ENABLE_ASH_RANDOM_SUPPORT
# define VDYNAMIC       0x200   /* dynamic variable */
#else
# 1901 "shell/ash.c"
# define VDYNAMIC       0
#endif
# 1903 "shell/ash.c"


/* Need to be before varinit_data[] */
#if ENABLE_LOCALE_SUPPORT
static void FAST_FUNC
change_lc_all(const char *value)
{
	if (value && *value != '\0')
		setlocale(LC_ALL, value);
}
static void FAST_FUNC
change_lc_ctype(const char *value)
{
	if (value && *value != '\0')
		setlocale(LC_CTYPE, value);
}
#endif
# 1920 "shell/ash.c"
#if ENABLE_ASH_MAIL
static void chkmail(void);
static void changemail(const char *var_value) FAST_FUNC;
#else
# 1924 "shell/ash.c"
# define chkmail()  ((void)0)
#endif
# 1926 "shell/ash.c"
static void changepath(const char *) FAST_FUNC;
#if ENABLE_ASH_RANDOM_SUPPORT
static void change_random(const char *) FAST_FUNC;
#endif
# 1930 "shell/ash.c"

static const struct {
	int flags;
	const char *var_text;
	void (*var_func)(const char *) FAST_FUNC;
} varinit_data[] = {
	/*
	 * Note: VEXPORT would not work correctly here for NOFORK applets:
	 * some environment strings may be constant.
	 */
	{ VSTRFIXED|VTEXTFIXED       , defifsvar   , NULL            },
#if ENABLE_ASH_MAIL
	{ VSTRFIXED|VTEXTFIXED|VUNSET, "MAIL"      , changemail      },
	{ VSTRFIXED|VTEXTFIXED|VUNSET, "MAILPATH"  , changemail      },
#endif
# 1945 "shell/ash.c"
	{ VSTRFIXED|VTEXTFIXED       , bb_PATH_root_path, changepath },
	{ VSTRFIXED|VTEXTFIXED       , "PS1=$ "    , NULL            },
	{ VSTRFIXED|VTEXTFIXED       , "PS2=> "    , NULL            },
	{ VSTRFIXED|VTEXTFIXED       , "PS4=+ "    , NULL            },
#if ENABLE_ASH_GETOPTS
	{ VSTRFIXED|VTEXTFIXED       , defoptindvar, getoptsreset    },
#endif
# 1952 "shell/ash.c"
#if ENABLE_ASH_RANDOM_SUPPORT
	{ VSTRFIXED|VTEXTFIXED|VUNSET|VDYNAMIC, "RANDOM", change_random },
#endif
# 1955 "shell/ash.c"
#if ENABLE_LOCALE_SUPPORT
	{ VSTRFIXED|VTEXTFIXED|VUNSET, "LC_ALL"    , change_lc_all   },
	{ VSTRFIXED|VTEXTFIXED|VUNSET, "LC_CTYPE"  , change_lc_ctype },
#endif
# 1959 "shell/ash.c"
#if ENABLE_FEATURE_EDITING_SAVEHISTORY
	{ VSTRFIXED|VTEXTFIXED|VUNSET, "HISTFILE"  , NULL            },
#endif
# 1962 "shell/ash.c"
};

struct redirtab;

struct globals_var {
	struct shparam shellparam;      /* $@ current positional parameters */
	struct redirtab *redirlist;
	int preverrout_fd;   /* save fd2 before print debug if xflag is set. */
	struct var *vartab[VTABSIZE];
	struct var varinit[ARRAY_SIZE(varinit_data)];
};
extern struct globals_var *const ash_ptr_to_globals_var;
#define G_var (*ash_ptr_to_globals_var)
#define shellparam    (G_var.shellparam   )
//#define redirlist     (G_var.redirlist    )
#define preverrout_fd (G_var.preverrout_fd)
#define vartab        (G_var.vartab       )
#define varinit       (G_var.varinit      )
#define INIT_G_var() do { \
	unsigned i; \
	(*(struct globals_var**)&ash_ptr_to_globals_var) = xzalloc(sizeof(G_var)); \
	barrier(); \
	for (i = 0; i < ARRAY_SIZE(varinit_data); i++) { \
		varinit[i].flags    = varinit_data[i].flags; \
		varinit[i].var_text = varinit_data[i].var_text; \
		varinit[i].var_func = varinit_data[i].var_func; \
	} \
} while (0)

#define vifs      varinit[0]
#if ENABLE_ASH_MAIL
# define vmail    (&vifs)[1]
# define vmpath   (&vmail)[1]
# define vpath    (&vmpath)[1]
#else
# 1997 "shell/ash.c"
# define vpath    (&vifs)[1]
#endif
# 1999 "shell/ash.c"
#define vps1      (&vpath)[1]
#define vps2      (&vps1)[1]
#define vps4      (&vps2)[1]
#if ENABLE_ASH_GETOPTS
# define voptind  (&vps4)[1]
# if ENABLE_ASH_RANDOM_SUPPORT
#  define vrandom (&voptind)[1]
# endif
# 2007 "shell/ash.c"
#else
# 2008 "shell/ash.c"
# if ENABLE_ASH_RANDOM_SUPPORT
#  define vrandom (&vps4)[1]
# endif
# 2011 "shell/ash.c"
#endif
# 2012 "shell/ash.c"

/*
 * The following macros access the values of the above variables.
 * They have to skip over the name.  They return the null string
 * for unset variables.
 */
#define ifsval()        (vifs.var_text + 4)
#define ifsset()        ((vifs.flags & VUNSET) == 0)
#if ENABLE_ASH_MAIL
# define mailval()      (vmail.var_text + 5)
# define mpathval()     (vmpath.var_text + 9)
# define mpathset()     ((vmpath.flags & VUNSET) == 0)
#endif
# 2025 "shell/ash.c"
#define pathval()       (vpath.var_text + 5)
#define ps1val()        (vps1.var_text + 4)
#define ps2val()        (vps2.var_text + 4)
#define ps4val()        (vps4.var_text + 4)
#if ENABLE_ASH_GETOPTS
# define optindval()    (voptind.var_text + 7)
#endif
# 2032 "shell/ash.c"

#if ENABLE_ASH_GETOPTS
static void FAST_FUNC
getoptsreset(const char *value)
{
	shellparam.optind = number(value) ?: 1;
	shellparam.optoff = -1;
}
#endif
# 2041 "shell/ash.c"

/*
 * Compares two strings up to the first = or '\0'.  The first
 * string must be terminated by '='; the second may be terminated by
 * either '=' or '\0'.
 */
static int
varcmp(const char *p, const char *q)
{
	int c, d;

	while ((c = *p) == (d = *q)) {
		if (c == '\0' || c == '=')
			goto out;
		p++;
		q++;
	}
	if (c == '=')
		c = '\0';
	if (d == '=')
		d = '\0';
 out:
	return c - d;
}

/*
 * Find the appropriate entry in the hash table from the name.
 */
static struct var **
hashvar(const char *p)
{
	unsigned hashval;

	hashval = ((unsigned char) *p) << 4;
	while (*p && *p != '=')
		hashval += (unsigned char) *p++;
	return &vartab[hashval % VTABSIZE];
}

static int
vpcmp(const void *a, const void *b)
{
	return varcmp(*(const char **)a, *(const char **)b);
}

/*
 * This routine initializes the builtin variables.
 */
static void
initvar(void)
{
	struct var *vp;
	struct var *end;
	struct var **vpp;

	/*
	 * PS1 depends on uid
	 */
#if ENABLE_FEATURE_EDITING && ENABLE_FEATURE_EDITING_FANCY_PROMPT
	vps1.var_text = "PS1=\\w \\$ ";
#else
# 2102 "shell/ash.c"
	if (!geteuid())
		vps1.var_text = "PS1=# ";
#endif
# 2105 "shell/ash.c"
	vp = varinit;
	end = vp + ARRAY_SIZE(varinit);
	do {
		vpp = hashvar(vp->var_text);
		vp->next = *vpp;
		*vpp = vp;
	} while (++vp < end);
}

static struct var **
findvar(struct var **vpp, const char *name)
{
	for (; *vpp; vpp = &(*vpp)->next) {
		if (varcmp((*vpp)->var_text, name) == 0) {
			break;
		}
	}
	return vpp;
}

/*
 * Find the value of a variable.  Returns NULL if not set.
 */
static const char* FAST_FUNC
lookupvar(const char *name)
{
	struct var *v;

	v = *findvar(hashvar(name), name);
	if (v) {
#if ENABLE_ASH_RANDOM_SUPPORT
	/*
	 * Dynamic variables are implemented roughly the same way they are
	 * in bash. Namely, they're "special" so long as they aren't unset.
	 * As soon as they're unset, they're no longer dynamic, and dynamic
	 * lookup will no longer happen at that point. -- PFM.
	 */
		if (v->flags & VDYNAMIC)
			v->var_func(NULL);
#endif
# 2145 "shell/ash.c"
		if (!(v->flags & VUNSET))
			return var_end(v->var_text);
	}
	return NULL;
}

#if ENABLE_UNICODE_SUPPORT
static void
reinit_unicode_for_ash(void)
{
	/* Unicode support should be activated even if LANG is set
	 * _during_ shell execution, not only if it was set when
	 * shell was started. Therefore, re-check LANG every time:
	 */
	if (ENABLE_FEATURE_CHECK_UNICODE_IN_ENV
	 || ENABLE_UNICODE_USING_LOCALE
	) {
		const char *s = lookupvar("LC_ALL");
		if (!s) s = lookupvar("LC_CTYPE");
		if (!s) s = lookupvar("LANG");
		reinit_unicode(s);
	}
}
#else
# 2169 "shell/ash.c"
# define reinit_unicode_for_ash() ((void)0)
#endif
# 2171 "shell/ash.c"

/*
 * Search the environment of a builtin command.
 */
static const char *
bltinlookup(const char *name)
{
	struct strlist *sp;

	for (sp = cmdenviron; sp; sp = sp->next) {
		if (varcmp(sp->text, name) == 0)
			return var_end(sp->text);
	}
	return lookupvar(name);
}

/*
 * Same as setvar except that the variable and value are passed in
 * the first argument as name=value.  Since the first argument will
 * be actually stored in the table, it should not be a string that
 * will go away.
 * Called with interrupts off.
 */
static void
setvareq(char *s, int flags)
{
	struct var *vp, **vpp;

	vpp = hashvar(s);
	flags |= (VEXPORT & (((unsigned) (1 - aflag)) - 1));
	vp = *findvar(vpp, s);
	if (vp) {
		if ((vp->flags & (VREADONLY|VDYNAMIC)) == VREADONLY) {
			const char *n;

			if (flags & VNOSAVE)
				free(s);
			n = vp->var_text;
			exitstatus = 1;
			ash_msg_and_raise_error("%.*s: is read only", strchrnul(n, '=') - n, n);
		}

		if (flags & VNOSET)
			return;

		if (vp->var_func && !(flags & VNOFUNC))
			vp->var_func(var_end(s));

		if (!(vp->flags & (VTEXTFIXED|VSTACK)))
			free((char*)vp->var_text);

		flags |= vp->flags & ~(VTEXTFIXED|VSTACK|VNOSAVE|VUNSET);
	} else {
		/* variable s is not found */
		if (flags & VNOSET)
			return;
		vp = ckzalloc(sizeof(*vp));
		vp->next = *vpp;
		/*vp->func = NULL; - ckzalloc did it */
		*vpp = vp;
	}
	if (!(flags & (VTEXTFIXED|VSTACK|VNOSAVE)))
		s = ckstrdup(s);
	vp->var_text = s;
	vp->flags = flags;
}

/*
 * Set the value of a variable.  The flags argument is ored with the
 * flags of the variable.  If val is NULL, the variable is unset.
 */
static void
setvar(const char *name, const char *val, int flags)
{
	const char *q;
	char *p;
	char *nameeq;
	size_t namelen;
	size_t vallen;

	q = endofname(name);
	p = strchrnul(q, '=');
	namelen = p - name;
	if (!namelen || p != q)
		ash_msg_and_raise_error("%.*s: bad variable name", namelen, name);
	vallen = 0;
	if (val == NULL) {
		flags |= VUNSET;
	} else {
		vallen = strlen(val);
	}

	INT_OFF;
	nameeq = ckmalloc(namelen + vallen + 2);
	p = memcpy(nameeq, name, namelen) + namelen;
	if (val) {
		*p++ = '=';
		p = memcpy(p, val, vallen) + vallen;
	}
	*p = '\0';
	setvareq(nameeq, flags | VNOSAVE);
	INT_ON;
}

static void FAST_FUNC
setvar0(const char *name, const char *val)
{
	setvar(name, val, 0);
}

/*
 * Unset the specified variable.
 */
static int
unsetvar(const char *s)
{
	struct var **vpp;
	struct var *vp;
	int retval;

	vpp = findvar(hashvar(s), s);
	vp = *vpp;
	retval = 2;
	if (vp) {
		int flags = vp->flags;

		retval = 1;
		if (flags & VREADONLY)
			goto out;
#if ENABLE_ASH_RANDOM_SUPPORT
		vp->flags &= ~VDYNAMIC;
#endif
# 2303 "shell/ash.c"
		if (flags & VUNSET)
			goto ok;
		if ((flags & VSTRFIXED) == 0) {
			INT_OFF;
			if ((flags & (VTEXTFIXED|VSTACK)) == 0)
				free((char*)vp->var_text);
			*vpp = vp->next;
			free(vp);
			INT_ON;
		} else {
			setvar0(s, NULL);
			vp->flags &= ~VEXPORT;
		}
 ok:
		retval = 0;
	}
 out:
	return retval;
}

/*
 * Process a linked list of variable assignments.
 */
static void
listsetvar(struct strlist *list_set_var, int flags)
{
	struct strlist *lp = list_set_var;

	if (!lp)
		return;
	INT_OFF;
	do {
		setvareq(lp->text, flags);
		lp = lp->next;
	} while (lp);
	INT_ON;
}

/*
 * Generate a list of variables satisfying the given conditions.
 */
static char **
listvars(int on, int off, char ***end)
{
	struct var **vpp;
	struct var *vp;
	char **ep;
	int mask;

	STARTSTACKSTR(ep);
	vpp = vartab;
	mask = on | off;
	do {
		for (vp = *vpp; vp; vp = vp->next) {
			if ((vp->flags & mask) == on) {
				if (ep == stackstrend())
					ep = growstackstr();
				*ep++ = (char*)vp->var_text;
			}
		}
	} while (++vpp < vartab + VTABSIZE);
	if (ep == stackstrend())
		ep = growstackstr();
	if (end)
		*end = ep;
	*ep++ = NULL;
	return grabstackstr(ep);
}


/* ============ Path search helper
 *
 * The variable path (passed by reference) should be set to the start
 * of the path before the first call; path_advance will update
 * this value as it proceeds.  Successive calls to path_advance will return
 * the possible path expansions in sequence.  If an option (indicated by
 * a percent sign) appears in the path entry then the global variable
 * pathopt will be set to point to it; otherwise pathopt will be set to
 * NULL.
 */
static const char *pathopt;     /* set by path_advance */

static char *
path_advance(const char **path, const char *name)
{
	const char *p;
	char *q;
	const char *start;
	size_t len;

	if (*path == NULL)
		return NULL;
	start = *path;
	for (p = start; *p && *p != ':' && *p != '%'; p++)
		continue;
	len = p - start + strlen(name) + 2;     /* "2" is for '/' and '\0' */
	while (stackblocksize() < len)
		growstackblock();
	q = stackblock();
	if (p != start) {
		memcpy(q, start, p - start);
		q += p - start;
		*q++ = '/';
	}
	strcpy(q, name);
	pathopt = NULL;
	if (*p == '%') {
		pathopt = ++p;
		while (*p && *p != ':')
			p++;
	}
	if (*p == ':')
		*path = p + 1;
	else
		*path = NULL;
	return stalloc(len);
}


/* ============ Prompt */

static smallint doprompt;                   /* if set, prompt the user */
static smallint needprompt;                 /* true if interactive and at start of line */

#if ENABLE_FEATURE_EDITING
static line_input_t *line_input_state;
static const char *cmdedit_prompt;
static void
putprompt(const char *s)
{
	if (ENABLE_ASH_EXPAND_PRMT) {
		free((char*)cmdedit_prompt);
		cmdedit_prompt = ckstrdup(s);
		return;
	}
	cmdedit_prompt = s;
}
#else
# 2441 "shell/ash.c"
static void
putprompt(const char *s)
{
	out2str(s);
}
#endif
# 2447 "shell/ash.c"

#if ENABLE_ASH_EXPAND_PRMT
/* expandstr() needs parsing machinery, so it is far away ahead... */
static const char *expandstr(const char *ps);
#else
# 2452 "shell/ash.c"
#define expandstr(s) s
#endif
# 2454 "shell/ash.c"

static void
setprompt_if(smallint do_set, int whichprompt)
{
	const char *prompt;
	IF_ASH_EXPAND_PRMT(struct stackmark smark;)

	if (!do_set)
		return;

	needprompt = 0;

	switch (whichprompt) {
	case 1:
		prompt = ps1val();
		break;
	case 2:
		prompt = ps2val();
		break;
	default:                        /* 0 */
		prompt = nullstr;
	}
#if ENABLE_ASH_EXPAND_PRMT
	pushstackmark(&smark, stackblocksize());
#endif
# 2479 "shell/ash.c"
	putprompt(expandstr(prompt));
#if ENABLE_ASH_EXPAND_PRMT
	popstackmark(&smark);
#endif
# 2483 "shell/ash.c"
}


/* ============ The cd and pwd commands */

#define CD_PHYSICAL 1
#define CD_PRINT 2

static int
cdopt(void)
{
	int flags = 0;
	int i, j;

	j = 'L';
	while ((i = nextopt("LP")) != '\0') {
		if (i != j) {
			flags ^= CD_PHYSICAL;
			j = i;
		}
	}

	return flags;
}

/*
 * Update curdir (the name of the current directory) in response to a
 * cd command.
 */
static const char *
updatepwd(const char *dir)
{
	char *new;
	char *p;
	char *cdcomppath;
	const char *lim;

	cdcomppath = sstrdup(dir);
	STARTSTACKSTR(new);
	if (*dir != '/') {
		if (curdir == nullstr)
			return 0;
		new = stack_putstr(curdir, new);
	}
	new = makestrspace(strlen(dir) + 2, new);
	lim = (char *)stackblock() + 1;
	if (*dir != '/') {
		if (new[-1] != '/')
			USTPUTC('/', new);
		if (new > lim && *lim == '/')
			lim++;
	} else {
		USTPUTC('/', new);
		cdcomppath++;
		if (dir[1] == '/' && dir[2] != '/') {
			USTPUTC('/', new);
			cdcomppath++;
			lim++;
		}
	}
	p = strtok(cdcomppath, "/");
	while (p) {
		switch (*p) {
		case '.':
			if (p[1] == '.' && p[2] == '\0') {
				while (new > lim) {
					STUNPUTC(new);
					if (new[-1] == '/')
						break;
				}
				break;
			}
			if (p[1] == '\0')
				break;
			/* fall through */
		default:
			new = stack_putstr(p, new);
			USTPUTC('/', new);
		}
		p = strtok(NULL, "/");
	}
	if (new > lim)
		STUNPUTC(new);
	*new = 0;
	return stackblock();
}

/*
 * Find out what the current directory is. If we already know the current
 * directory, this routine returns immediately.
 */
static char *
getpwd(void)
{
	char *dir = getcwd(NULL, 0); /* huh, using glibc extension? */
	return dir ? dir : nullstr;
}

static void
setpwd(const char *val, int setold)
{
	char *oldcur, *dir;

	oldcur = dir = curdir;

	if (setold) {
		setvar("OLDPWD", oldcur, VEXPORT);
	}
	INT_OFF;
	if (physdir != nullstr) {
		if (physdir != oldcur)
			free(physdir);
		physdir = nullstr;
	}
	if (oldcur == val || !val) {
		char *s = getpwd();
		physdir = s;
		if (!val)
			dir = s;
	} else
		dir = ckstrdup(val);
	if (oldcur != dir && oldcur != nullstr) {
		free(oldcur);
	}
	curdir = dir;
	INT_ON;
	setvar("PWD", dir, VEXPORT);
}

static void hashcd(void);

/*
 * Actually do the chdir.  We also call hashcd to let other routines
 * know that the current directory has changed.
 */
static int
docd(const char *dest, int flags)
{
	const char *dir = NULL;
	int err;

	TRACE(("docd(\"%s\", %d) called\n", dest, flags));

	INT_OFF;
	if (!(flags & CD_PHYSICAL)) {
		dir = updatepwd(dest);
		if (dir)
			dest = dir;
	}
	err = chdir(dest);
	if (err)
		goto out;
	setpwd(dir, 1);
	hashcd();
 out:
	INT_ON;
	return err;
}

static int FAST_FUNC
cdcmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
{
	const char *dest;
	const char *path;
	const char *p;
	char c;
	struct stat statb;
	int flags;

	flags = cdopt();
	dest = *argptr;
	if (!dest)
		dest = bltinlookup("HOME");
	else if (LONE_DASH(dest)) {
		dest = bltinlookup("OLDPWD");
		flags |= CD_PRINT;
	}
	if (!dest)
		dest = nullstr;
	if (*dest == '/')
		goto step6;
	if (*dest == '.') {
		c = dest[1];
 dotdot:
		switch (c) {
		case '\0':
		case '/':
			goto step6;
		case '.':
			c = dest[2];
			if (c != '.')
				goto dotdot;
		}
	}
	if (!*dest)
		dest = ".";
	path = bltinlookup("CDPATH");
	while (path) {
		c = *path;
		p = path_advance(&path, dest);
		if (stat(p, &statb) >= 0 && S_ISDIR(statb.st_mode)) {
			if (c && c != ':')
				flags |= CD_PRINT;
 docd:
			if (!docd(p, flags))
				goto out;
			goto err;
		}
	}

 step6:
	p = dest;
	goto docd;

 err:
	ash_msg_and_raise_error("can't cd to %s", dest);
	/* NOTREACHED */
 out:
	if (flags & CD_PRINT)
		out1fmt("%s\n", curdir);
	return 0;
}

static int FAST_FUNC
pwdcmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
{
	int flags;
	const char *dir = curdir;

	flags = cdopt();
	if (flags) {
		if (physdir == nullstr)
			setpwd(dir, 0);
		dir = physdir;
	}
	out1fmt("%s\n", dir);
	return 0;
}


/* ============ ... */


#define IBUFSIZ (ENABLE_FEATURE_EDITING ? CONFIG_FEATURE_EDITING_MAX_LEN : 1024)

/* Syntax classes */
#define CWORD     0             /* character is nothing special */
#define CNL       1             /* newline character */
#define CBACK     2             /* a backslash character */
#define CSQUOTE   3             /* single quote */
#define CDQUOTE   4             /* double quote */
#define CENDQUOTE 5             /* a terminating quote */
#define CBQUOTE   6             /* backwards single quote */
#define CVAR      7             /* a dollar sign */
#define CENDVAR   8             /* a '}' character */
#define CLP       9             /* a left paren in arithmetic */
#define CRP      10             /* a right paren in arithmetic */
#define CENDFILE 11             /* end of file */
#define CCTL     12             /* like CWORD, except it must be escaped */
#define CSPCL    13             /* these terminate a word */
#define CIGN     14             /* character should be ignored */

#define PEOF     256
#if ENABLE_ASH_ALIAS
# define PEOA    257
#endif
# 2749 "shell/ash.c"

#define USE_SIT_FUNCTION ENABLE_ASH_OPTIMIZE_FOR_SIZE

#if ENABLE_FEATURE_SH_MATH
# define SIT_ITEM(a,b,c,d) (a | (b << 4) | (c << 8) | (d << 12))
#else
# 2755 "shell/ash.c"
# define SIT_ITEM(a,b,c,d) (a | (b << 4) | (c << 8))
#endif
# 2757 "shell/ash.c"
static const uint16_t S_I_T[] ALIGN2 = {
#if ENABLE_ASH_ALIAS
	SIT_ITEM(CSPCL   , CIGN     , CIGN , CIGN   ),    /* 0, PEOA */
#endif
# 2761 "shell/ash.c"
	SIT_ITEM(CSPCL   , CWORD    , CWORD, CWORD  ),    /* 1, ' ' */
	SIT_ITEM(CNL     , CNL      , CNL  , CNL    ),    /* 2, \n */
	SIT_ITEM(CWORD   , CCTL     , CCTL , CWORD  ),    /* 3, !*-/:=?[]~ */
	SIT_ITEM(CDQUOTE , CENDQUOTE, CWORD, CWORD  ),    /* 4, '"' */
	SIT_ITEM(CVAR    , CVAR     , CWORD, CVAR   ),    /* 5, $ */
	SIT_ITEM(CSQUOTE , CWORD    , CENDQUOTE, CWORD),  /* 6, "'" */
	SIT_ITEM(CSPCL   , CWORD    , CWORD, CLP    ),    /* 7, ( */
	SIT_ITEM(CSPCL   , CWORD    , CWORD, CRP    ),    /* 8, ) */
	SIT_ITEM(CBACK   , CBACK    , CCTL , CBACK  ),    /* 9, \ */
	SIT_ITEM(CBQUOTE , CBQUOTE  , CWORD, CBQUOTE),    /* 10, ` */
	SIT_ITEM(CENDVAR , CENDVAR  , CWORD, CENDVAR),    /* 11, } */
#if !USE_SIT_FUNCTION
	SIT_ITEM(CENDFILE, CENDFILE , CENDFILE, CENDFILE),/* 12, PEOF */
	SIT_ITEM(CWORD   , CWORD    , CWORD, CWORD  ),    /* 13, 0-9A-Za-z */
	SIT_ITEM(CCTL    , CCTL     , CCTL , CCTL   )     /* 14, CTLESC ... */
#endif
# 2777 "shell/ash.c"
#undef SIT_ITEM
};
/* Constants below must match table above */
enum {
#if ENABLE_ASH_ALIAS
	CSPCL_CIGN_CIGN_CIGN               , /*  0 */
#endif
# 2784 "shell/ash.c"
	CSPCL_CWORD_CWORD_CWORD            , /*  1 */
	CNL_CNL_CNL_CNL                    , /*  2 */
	CWORD_CCTL_CCTL_CWORD              , /*  3 */
	CDQUOTE_CENDQUOTE_CWORD_CWORD      , /*  4 */
	CVAR_CVAR_CWORD_CVAR               , /*  5 */
	CSQUOTE_CWORD_CENDQUOTE_CWORD      , /*  6 */
	CSPCL_CWORD_CWORD_CLP              , /*  7 */
	CSPCL_CWORD_CWORD_CRP              , /*  8 */
	CBACK_CBACK_CCTL_CBACK             , /*  9 */
	CBQUOTE_CBQUOTE_CWORD_CBQUOTE      , /* 10 */
	CENDVAR_CENDVAR_CWORD_CENDVAR      , /* 11 */
	CENDFILE_CENDFILE_CENDFILE_CENDFILE, /* 12 */
	CWORD_CWORD_CWORD_CWORD            , /* 13 */
	CCTL_CCTL_CCTL_CCTL                , /* 14 */
};

/* c in SIT(c, syntax) must be an *unsigned char* or PEOA or PEOF,
 * caller must ensure proper cast on it if c is *char_ptr!
 */
/* Values for syntax param */
#define BASESYNTAX 0    /* not in quotes */
#define DQSYNTAX   1    /* in double quotes */
#define SQSYNTAX   2    /* in single quotes */
#define ARISYNTAX  3    /* in arithmetic */
#define PSSYNTAX   4    /* prompt. never passed to SIT() */

#if USE_SIT_FUNCTION

static int
SIT(int c, int syntax)
{
	/* Used to also have '/' in this string: "\t\n !\"$&'()*-/:;<=>?[\\]`|}~" */
	static const char spec_symbls[] ALIGN1 = "\t\n !\"$&'()*-:;<=>?[\\]`|}~";
	/*
	 * This causes '/' to be prepended with CTLESC in dquoted string,
	 * making "./file"* treated incorrectly because we feed
	 * ".\/file*" string to glob(), confusing it (see expandmeta func).
	 * The "homegrown" glob implementation is okay with that,
	 * but glibc one isn't. With '/' always treated as CWORD,
	 * both work fine.
	 */
# if ENABLE_ASH_ALIAS
	static const uint8_t syntax_index_table[] ALIGN1 = {
		1, 2, 1, 3, 4, 5, 1, 6,         /* "\t\n !\"$&'" */
		7, 8, 3, 3,/*3,*/3, 1, 1,       /* "()*-/:;<" */
		3, 1, 3, 3, 9, 3, 10, 1,        /* "=>?[\\]`|" */
		11, 3                           /* "}~" */
	};
# else
# 2833 "shell/ash.c"
	static const uint8_t syntax_index_table[] ALIGN1 = {
		0, 1, 0, 2, 3, 4, 0, 5,         /* "\t\n !\"$&'" */
		6, 7, 2, 2,/*2,*/2, 0, 0,       /* "()*-/:;<" */
		2, 0, 2, 2, 8, 2, 9, 0,         /* "=>?[\\]`|" */
		10, 2                           /* "}~" */
	};
# endif
# 2840 "shell/ash.c"
	const char *s;
	int indx;

	if (c == PEOF)
		return CENDFILE;
# if ENABLE_ASH_ALIAS
	if (c == PEOA)
		indx = 0;
	else
# endif
# 2850 "shell/ash.c"
	{
		/* Cast is purely for paranoia here,
		 * just in case someone passed signed char to us */
		if ((unsigned char)c >= CTL_FIRST
		 && (unsigned char)c <= CTL_LAST
		) {
			return CCTL;
		}
		s = strchrnul(spec_symbls, c);
		if (*s == '\0')
			return CWORD;
		indx = syntax_index_table[s - spec_symbls];
	}
	return (S_I_T[indx] >> (syntax*4)) & 0xf;
}

#else   /* !USE_SIT_FUNCTION */
# 2867 "shell/ash.c"

static const uint8_t syntax_index_table[] ALIGN1 = {
	/* BASESYNTAX_DQSYNTAX_SQSYNTAX_ARISYNTAX */
	/*   0      */ CWORD_CWORD_CWORD_CWORD,
	/*   1      */ CWORD_CWORD_CWORD_CWORD,
	/*   2      */ CWORD_CWORD_CWORD_CWORD,
	/*   3      */ CWORD_CWORD_CWORD_CWORD,
	/*   4      */ CWORD_CWORD_CWORD_CWORD,
	/*   5      */ CWORD_CWORD_CWORD_CWORD,
	/*   6      */ CWORD_CWORD_CWORD_CWORD,
	/*   7      */ CWORD_CWORD_CWORD_CWORD,
	/*   8      */ CWORD_CWORD_CWORD_CWORD,
	/*   9 "\t" */ CSPCL_CWORD_CWORD_CWORD,
	/*  10 "\n" */ CNL_CNL_CNL_CNL,
	/*  11      */ CWORD_CWORD_CWORD_CWORD,
	/*  12      */ CWORD_CWORD_CWORD_CWORD,
	/*  13      */ CWORD_CWORD_CWORD_CWORD,
	/*  14      */ CWORD_CWORD_CWORD_CWORD,
	/*  15      */ CWORD_CWORD_CWORD_CWORD,
	/*  16      */ CWORD_CWORD_CWORD_CWORD,
	/*  17      */ CWORD_CWORD_CWORD_CWORD,
	/*  18      */ CWORD_CWORD_CWORD_CWORD,
	/*  19      */ CWORD_CWORD_CWORD_CWORD,
	/*  20      */ CWORD_CWORD_CWORD_CWORD,
	/*  21      */ CWORD_CWORD_CWORD_CWORD,
	/*  22      */ CWORD_CWORD_CWORD_CWORD,
	/*  23      */ CWORD_CWORD_CWORD_CWORD,
	/*  24      */ CWORD_CWORD_CWORD_CWORD,
	/*  25      */ CWORD_CWORD_CWORD_CWORD,
	/*  26      */ CWORD_CWORD_CWORD_CWORD,
	/*  27      */ CWORD_CWORD_CWORD_CWORD,
	/*  28      */ CWORD_CWORD_CWORD_CWORD,
	/*  29      */ CWORD_CWORD_CWORD_CWORD,
	/*  30      */ CWORD_CWORD_CWORD_CWORD,
	/*  31      */ CWORD_CWORD_CWORD_CWORD,
	/*  32  " " */ CSPCL_CWORD_CWORD_CWORD,
	/*  33  "!" */ CWORD_CCTL_CCTL_CWORD,
	/*  34  """ */ CDQUOTE_CENDQUOTE_CWORD_CWORD,
	/*  35  "#" */ CWORD_CWORD_CWORD_CWORD,
	/*  36  "$" */ CVAR_CVAR_CWORD_CVAR,
	/*  37  "%" */ CWORD_CWORD_CWORD_CWORD,
	/*  38  "&" */ CSPCL_CWORD_CWORD_CWORD,
	/*  39  "'" */ CSQUOTE_CWORD_CENDQUOTE_CWORD,
	/*  40  "(" */ CSPCL_CWORD_CWORD_CLP,
	/*  41  ")" */ CSPCL_CWORD_CWORD_CRP,
	/*  42  "*" */ CWORD_CCTL_CCTL_CWORD,
	/*  43  "+" */ CWORD_CWORD_CWORD_CWORD,
	/*  44  "," */ CWORD_CWORD_CWORD_CWORD,
	/*  45  "-" */ CWORD_CCTL_CCTL_CWORD,
	/*  46  "." */ CWORD_CWORD_CWORD_CWORD,
/* "/" was CWORD_CCTL_CCTL_CWORD, see comment in SIT() function why this is changed: */
	/*  47  "/" */ CWORD_CWORD_CWORD_CWORD,
	/*  48  "0" */ CWORD_CWORD_CWORD_CWORD,
	/*  49  "1" */ CWORD_CWORD_CWORD_CWORD,
	/*  50  "2" */ CWORD_CWORD_CWORD_CWORD,
	/*  51  "3" */ CWORD_CWORD_CWORD_CWORD,
	/*  52  "4" */ CWORD_CWORD_CWORD_CWORD,
	/*  53  "5" */ CWORD_CWORD_CWORD_CWORD,
	/*  54  "6" */ CWORD_CWORD_CWORD_CWORD,
	/*  55  "7" */ CWORD_CWORD_CWORD_CWORD,
	/*  56  "8" */ CWORD_CWORD_CWORD_CWORD,
	/*  57  "9" */ CWORD_CWORD_CWORD_CWORD,
	/*  58  ":" */ CWORD_CCTL_CCTL_CWORD,
	/*  59  ";" */ CSPCL_CWORD_CWORD_CWORD,
	/*  60  "<" */ CSPCL_CWORD_CWORD_CWORD,
	/*  61  "=" */ CWORD_CCTL_CCTL_CWORD,
	/*  62  ">" */ CSPCL_CWORD_CWORD_CWORD,
	/*  63  "?" */ CWORD_CCTL_CCTL_CWORD,
	/*  64  "@" */ CWORD_CWORD_CWORD_CWORD,
	/*  65  "A" */ CWORD_CWORD_CWORD_CWORD,
	/*  66  "B" */ CWORD_CWORD_CWORD_CWORD,
	/*  67  "C" */ CWORD_CWORD_CWORD_CWORD,
	/*  68  "D" */ CWORD_CWORD_CWORD_CWORD,
	/*  69  "E" */ CWORD_CWORD_CWORD_CWORD,
	/*  70  "F" */ CWORD_CWORD_CWORD_CWORD,
	/*  71  "G" */ CWORD_CWORD_CWORD_CWORD,
	/*  72  "H" */ CWORD_CWORD_CWORD_CWORD,
	/*  73  "I" */ CWORD_CWORD_CWORD_CWORD,
	/*  74  "J" */ CWORD_CWORD_CWORD_CWORD,
	/*  75  "K" */ CWORD_CWORD_CWORD_CWORD,
	/*  76  "L" */ CWORD_CWORD_CWORD_CWORD,
	/*  77  "M" */ CWORD_CWORD_CWORD_CWORD,
	/*  78  "N" */ CWORD_CWORD_CWORD_CWORD,
	/*  79  "O" */ CWORD_CWORD_CWORD_CWORD,
	/*  80  "P" */ CWORD_CWORD_CWORD_CWORD,
	/*  81  "Q" */ CWORD_CWORD_CWORD_CWORD,
	/*  82  "R" */ CWORD_CWORD_CWORD_CWORD,
	/*  83  "S" */ CWORD_CWORD_CWORD_CWORD,
	/*  84  "T" */ CWORD_CWORD_CWORD_CWORD,
	/*  85  "U" */ CWORD_CWORD_CWORD_CWORD,
	/*  86  "V" */ CWORD_CWORD_CWORD_CWORD,
	/*  87  "W" */ CWORD_CWORD_CWORD_CWORD,
	/*  88  "X" */ CWORD_CWORD_CWORD_CWORD,
	/*  89  "Y" */ CWORD_CWORD_CWORD_CWORD,
	/*  90  "Z" */ CWORD_CWORD_CWORD_CWORD,
	/*  91  "[" */ CWORD_CCTL_CCTL_CWORD,
	/*  92  "\" */ CBACK_CBACK_CCTL_CBACK,
	/*  93  "]" */ CWORD_CCTL_CCTL_CWORD,
	/*  94  "^" */ CWORD_CWORD_CWORD_CWORD,
	/*  95  "_" */ CWORD_CWORD_CWORD_CWORD,
	/*  96  "`" */ CBQUOTE_CBQUOTE_CWORD_CBQUOTE,
	/*  97  "a" */ CWORD_CWORD_CWORD_CWORD,
	/*  98  "b" */ CWORD_CWORD_CWORD_CWORD,
	/*  99  "c" */ CWORD_CWORD_CWORD_CWORD,
	/* 100  "d" */ CWORD_CWORD_CWORD_CWORD,
	/* 101  "e" */ CWORD_CWORD_CWORD_CWORD,
	/* 102  "f" */ CWORD_CWORD_CWORD_CWORD,
	/* 103  "g" */ CWORD_CWORD_CWORD_CWORD,
	/* 104  "h" */ CWORD_CWORD_CWORD_CWORD,
	/* 105  "i" */ CWORD_CWORD_CWORD_CWORD,
	/* 106  "j" */ CWORD_CWORD_CWORD_CWORD,
	/* 107  "k" */ CWORD_CWORD_CWORD_CWORD,
	/* 108  "l" */ CWORD_CWORD_CWORD_CWORD,
	/* 109  "m" */ CWORD_CWORD_CWORD_CWORD,
	/* 110  "n" */ CWORD_CWORD_CWORD_CWORD,
	/* 111  "o" */ CWORD_CWORD_CWORD_CWORD,
	/* 112  "p" */ CWORD_CWORD_CWORD_CWORD,
	/* 113  "q" */ CWORD_CWORD_CWORD_CWORD,
	/* 114  "r" */ CWORD_CWORD_CWORD_CWORD,
	/* 115  "s" */ CWORD_CWORD_CWORD_CWORD,
	/* 116  "t" */ CWORD_CWORD_CWORD_CWORD,
	/* 117  "u" */ CWORD_CWORD_CWORD_CWORD,
	/* 118  "v" */ CWORD_CWORD_CWORD_CWORD,
	/* 119  "w" */ CWORD_CWORD_CWORD_CWORD,
	/* 120  "x" */ CWORD_CWORD_CWORD_CWORD,
	/* 121  "y" */ CWORD_CWORD_CWORD_CWORD,
	/* 122  "z" */ CWORD_CWORD_CWORD_CWORD,
	/* 123  "{" */ CWORD_CWORD_CWORD_CWORD,
	/* 124  "|" */ CSPCL_CWORD_CWORD_CWORD,
	/* 125  "}" */ CENDVAR_CENDVAR_CWORD_CENDVAR,
	/* 126  "~" */ CWORD_CCTL_CCTL_CWORD,
	/* 127  del */ CWORD_CWORD_CWORD_CWORD,
	/* 128 0x80 */ CWORD_CWORD_CWORD_CWORD,
	/* 129 CTLESC       */ CCTL_CCTL_CCTL_CCTL,
	/* 130 CTLVAR       */ CCTL_CCTL_CCTL_CCTL,
	/* 131 CTLENDVAR    */ CCTL_CCTL_CCTL_CCTL,
	/* 132 CTLBACKQ     */ CCTL_CCTL_CCTL_CCTL,
	/* 133 CTLQUOTE     */ CCTL_CCTL_CCTL_CCTL,
	/* 134 CTLARI       */ CCTL_CCTL_CCTL_CCTL,
	/* 135 CTLENDARI    */ CCTL_CCTL_CCTL_CCTL,
	/* 136 CTLQUOTEMARK */ CCTL_CCTL_CCTL_CCTL,
	/* 137      */ CWORD_CWORD_CWORD_CWORD,
	/* 138      */ CWORD_CWORD_CWORD_CWORD,
	/* 139      */ CWORD_CWORD_CWORD_CWORD,
	/* 140      */ CWORD_CWORD_CWORD_CWORD,
	/* 141      */ CWORD_CWORD_CWORD_CWORD,
	/* 142      */ CWORD_CWORD_CWORD_CWORD,
	/* 143      */ CWORD_CWORD_CWORD_CWORD,
	/* 144      */ CWORD_CWORD_CWORD_CWORD,
	/* 145      */ CWORD_CWORD_CWORD_CWORD,
	/* 146      */ CWORD_CWORD_CWORD_CWORD,
	/* 147      */ CWORD_CWORD_CWORD_CWORD,
	/* 148      */ CWORD_CWORD_CWORD_CWORD,
	/* 149      */ CWORD_CWORD_CWORD_CWORD,
	/* 150      */ CWORD_CWORD_CWORD_CWORD,
	/* 151      */ CWORD_CWORD_CWORD_CWORD,
	/* 152      */ CWORD_CWORD_CWORD_CWORD,
	/* 153      */ CWORD_CWORD_CWORD_CWORD,
	/* 154      */ CWORD_CWORD_CWORD_CWORD,
	/* 155      */ CWORD_CWORD_CWORD_CWORD,
	/* 156      */ CWORD_CWORD_CWORD_CWORD,
	/* 157      */ CWORD_CWORD_CWORD_CWORD,
	/* 158      */ CWORD_CWORD_CWORD_CWORD,
	/* 159      */ CWORD_CWORD_CWORD_CWORD,
	/* 160      */ CWORD_CWORD_CWORD_CWORD,
	/* 161      */ CWORD_CWORD_CWORD_CWORD,
	/* 162      */ CWORD_CWORD_CWORD_CWORD,
	/* 163      */ CWORD_CWORD_CWORD_CWORD,
	/* 164      */ CWORD_CWORD_CWORD_CWORD,
	/* 165      */ CWORD_CWORD_CWORD_CWORD,
	/* 166      */ CWORD_CWORD_CWORD_CWORD,
	/* 167      */ CWORD_CWORD_CWORD_CWORD,
	/* 168      */ CWORD_CWORD_CWORD_CWORD,
	/* 169      */ CWORD_CWORD_CWORD_CWORD,
	/* 170      */ CWORD_CWORD_CWORD_CWORD,
	/* 171      */ CWORD_CWORD_CWORD_CWORD,
	/* 172      */ CWORD_CWORD_CWORD_CWORD,
	/* 173      */ CWORD_CWORD_CWORD_CWORD,
	/* 174      */ CWORD_CWORD_CWORD_CWORD,
	/* 175      */ CWORD_CWORD_CWORD_CWORD,
	/* 176      */ CWORD_CWORD_CWORD_CWORD,
	/* 177      */ CWORD_CWORD_CWORD_CWORD,
	/* 178      */ CWORD_CWORD_CWORD_CWORD,
	/* 179      */ CWORD_CWORD_CWORD_CWORD,
	/* 180      */ CWORD_CWORD_CWORD_CWORD,
	/* 181      */ CWORD_CWORD_CWORD_CWORD,
	/* 182      */ CWORD_CWORD_CWORD_CWORD,
	/* 183      */ CWORD_CWORD_CWORD_CWORD,
	/* 184      */ CWORD_CWORD_CWORD_CWORD,
	/* 185      */ CWORD_CWORD_CWORD_CWORD,
	/* 186      */ CWORD_CWORD_CWORD_CWORD,
	/* 187      */ CWORD_CWORD_CWORD_CWORD,
	/* 188      */ CWORD_CWORD_CWORD_CWORD,
	/* 189      */ CWORD_CWORD_CWORD_CWORD,
	/* 190      */ CWORD_CWORD_CWORD_CWORD,
	/* 191      */ CWORD_CWORD_CWORD_CWORD,
	/* 192      */ CWORD_CWORD_CWORD_CWORD,
	/* 193      */ CWORD_CWORD_CWORD_CWORD,
	/* 194      */ CWORD_CWORD_CWORD_CWORD,
	/* 195      */ CWORD_CWORD_CWORD_CWORD,
	/* 196      */ CWORD_CWORD_CWORD_CWORD,
	/* 197      */ CWORD_CWORD_CWORD_CWORD,
	/* 198      */ CWORD_CWORD_CWORD_CWORD,
	/* 199      */ CWORD_CWORD_CWORD_CWORD,
	/* 200      */ CWORD_CWORD_CWORD_CWORD,
	/* 201      */ CWORD_CWORD_CWORD_CWORD,
	/* 202      */ CWORD_CWORD_CWORD_CWORD,
	/* 203      */ CWORD_CWORD_CWORD_CWORD,
	/* 204      */ CWORD_CWORD_CWORD_CWORD,
	/* 205      */ CWORD_CWORD_CWORD_CWORD,
	/* 206      */ CWORD_CWORD_CWORD_CWORD,
	/* 207      */ CWORD_CWORD_CWORD_CWORD,
	/* 208      */ CWORD_CWORD_CWORD_CWORD,
	/* 209      */ CWORD_CWORD_CWORD_CWORD,
	/* 210      */ CWORD_CWORD_CWORD_CWORD,
	/* 211      */ CWORD_CWORD_CWORD_CWORD,
	/* 212      */ CWORD_CWORD_CWORD_CWORD,
	/* 213      */ CWORD_CWORD_CWORD_CWORD,
	/* 214      */ CWORD_CWORD_CWORD_CWORD,
	/* 215      */ CWORD_CWORD_CWORD_CWORD,
	/* 216      */ CWORD_CWORD_CWORD_CWORD,
	/* 217      */ CWORD_CWORD_CWORD_CWORD,
	/* 218      */ CWORD_CWORD_CWORD_CWORD,
	/* 219      */ CWORD_CWORD_CWORD_CWORD,
	/* 220      */ CWORD_CWORD_CWORD_CWORD,
	/* 221      */ CWORD_CWORD_CWORD_CWORD,
	/* 222      */ CWORD_CWORD_CWORD_CWORD,
	/* 223      */ CWORD_CWORD_CWORD_CWORD,
	/* 224      */ CWORD_CWORD_CWORD_CWORD,
	/* 225      */ CWORD_CWORD_CWORD_CWORD,
	/* 226      */ CWORD_CWORD_CWORD_CWORD,
	/* 227      */ CWORD_CWORD_CWORD_CWORD,
	/* 228      */ CWORD_CWORD_CWORD_CWORD,
	/* 229      */ CWORD_CWORD_CWORD_CWORD,
	/* 230      */ CWORD_CWORD_CWORD_CWORD,
	/* 231      */ CWORD_CWORD_CWORD_CWORD,
	/* 232      */ CWORD_CWORD_CWORD_CWORD,
	/* 233      */ CWORD_CWORD_CWORD_CWORD,
	/* 234      */ CWORD_CWORD_CWORD_CWORD,
	/* 235      */ CWORD_CWORD_CWORD_CWORD,
	/* 236      */ CWORD_CWORD_CWORD_CWORD,
	/* 237      */ CWORD_CWORD_CWORD_CWORD,
	/* 238      */ CWORD_CWORD_CWORD_CWORD,
	/* 239      */ CWORD_CWORD_CWORD_CWORD,
	/* 230      */ CWORD_CWORD_CWORD_CWORD,
	/* 241      */ CWORD_CWORD_CWORD_CWORD,
	/* 242      */ CWORD_CWORD_CWORD_CWORD,
	/* 243      */ CWORD_CWORD_CWORD_CWORD,
	/* 244      */ CWORD_CWORD_CWORD_CWORD,
	/* 245      */ CWORD_CWORD_CWORD_CWORD,
	/* 246      */ CWORD_CWORD_CWORD_CWORD,
	/* 247      */ CWORD_CWORD_CWORD_CWORD,
	/* 248      */ CWORD_CWORD_CWORD_CWORD,
	/* 249      */ CWORD_CWORD_CWORD_CWORD,
	/* 250      */ CWORD_CWORD_CWORD_CWORD,
	/* 251      */ CWORD_CWORD_CWORD_CWORD,
	/* 252      */ CWORD_CWORD_CWORD_CWORD,
	/* 253      */ CWORD_CWORD_CWORD_CWORD,
	/* 254      */ CWORD_CWORD_CWORD_CWORD,
	/* 255      */ CWORD_CWORD_CWORD_CWORD,
	/* PEOF */     CENDFILE_CENDFILE_CENDFILE_CENDFILE,
# if ENABLE_ASH_ALIAS
	/* PEOA */     CSPCL_CIGN_CIGN_CIGN,
# endif
# 3131 "shell/ash.c"
};

#if 1
# define SIT(c, syntax) ((S_I_T[syntax_index_table[c]] >> ((syntax)*4)) & 0xf)
#else /* debug version, caught one signed char bug */
# 3136 "shell/ash.c"
# define SIT(c, syntax) \
	({ \
		if ((c) < 0 || (c) > (PEOF + ENABLE_ASH_ALIAS)) \
			bb_error_msg_and_die("line:%d c:%d", __LINE__, (c)); \
		if ((syntax) < 0 || (syntax) > (2 + ENABLE_FEATURE_SH_MATH)) \
			bb_error_msg_and_die("line:%d c:%d", __LINE__, (c)); \
		((S_I_T[syntax_index_table[c]] >> ((syntax)*4)) & 0xf); \
	})
#endif
# 3145 "shell/ash.c"

#endif  /* !USE_SIT_FUNCTION */
# 3147 "shell/ash.c"


/* ============ Alias handling */

#if ENABLE_ASH_ALIAS

#define ALIASINUSE 1
#define ALIASDEAD  2

struct alias {
	struct alias *next;
	char *name;
	char *val;
	int flag;
};


static struct alias **atab; // [ATABSIZE];
#define INIT_G_alias() do { \
	atab = xzalloc(ATABSIZE * sizeof(atab[0])); \
} while (0)


static struct alias **
__lookupalias(const char *name)
{
	unsigned int hashval;
	struct alias **app;
	const char *p;
	unsigned int ch;

	p = name;

	ch = (unsigned char)*p;
	hashval = ch << 4;
	while (ch) {
		hashval += ch;
		ch = (unsigned char)*++p;
	}
	app = &atab[hashval % ATABSIZE];

	for (; *app; app = &(*app)->next) {
		if (strcmp(name, (*app)->name) == 0) {
			break;
		}
	}

	return app;
}

static struct alias *
lookupalias(const char *name, int check)
{
	struct alias *ap = *__lookupalias(name);

	if (check && ap && (ap->flag & ALIASINUSE))
		return NULL;
	return ap;
}

static struct alias *
freealias(struct alias *ap)
{
	struct alias *next;

	if (ap->flag & ALIASINUSE) {
		ap->flag |= ALIASDEAD;
		return ap;
	}

	next = ap->next;
	free(ap->name);
	free(ap->val);
	free(ap);
	return next;
}

static void
setalias(const char *name, const char *val)
{
	struct alias *ap, **app;

	app = __lookupalias(name);
	ap = *app;
	INT_OFF;
	if (ap) {
		if (!(ap->flag & ALIASINUSE)) {
			free(ap->val);
		}
		ap->val = ckstrdup(val);
		ap->flag &= ~ALIASDEAD;
	} else {
		/* not found */
		ap = ckzalloc(sizeof(struct alias));
		ap->name = ckstrdup(name);
		ap->val = ckstrdup(val);
		/*ap->flag = 0; - ckzalloc did it */
		/*ap->next = NULL;*/
		*app = ap;
	}
	INT_ON;
}

static int
unalias(const char *name)
{
	struct alias **app;

	app = __lookupalias(name);

	if (*app) {
		INT_OFF;
		*app = freealias(*app);
		INT_ON;
		return 0;
	}

	return 1;
}

static void
rmaliases(void)
{
	struct alias *ap, **app;
	int i;

	INT_OFF;
	for (i = 0; i < ATABSIZE; i++) {
		app = &atab[i];
		for (ap = *app; ap; ap = *app) {
			*app = freealias(*app);
			if (ap == *app) {
				app = &ap->next;
			}
		}
	}
	INT_ON;
}

static void
printalias(const struct alias *ap)
{
	out1fmt("%s=%s\n", ap->name, single_quote(ap->val));
}

/*
 * TODO - sort output
 */
static int FAST_FUNC
aliascmd(int argc UNUSED_PARAM, char **argv)
{
	char *n, *v;
	int ret = 0;
	struct alias *ap;

	if (!argv[1]) {
		int i;

		for (i = 0; i < ATABSIZE; i++) {
			for (ap = atab[i]; ap; ap = ap->next) {
				printalias(ap);
			}
		}
		return 0;
	}
	while ((n = *++argv) != NULL) {
		v = strchr(n+1, '=');
		if (v == NULL) { /* n+1: funny ksh stuff */
			ap = *__lookupalias(n);
			if (ap == NULL) {
				fprintf(stderr, "%s: %s not found\n", "alias", n);
				ret = 1;
			} else
				printalias(ap);
		} else {
			*v++ = '\0';
			setalias(n, v);
		}
	}

	return ret;
}

static int FAST_FUNC
unaliascmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
{
	int i;

	while ((i = nextopt("a")) != '\0') {
		if (i == 'a') {
			rmaliases();
			return 0;
		}
	}
	for (i = 0; *argptr; argptr++) {
		if (unalias(*argptr)) {
			fprintf(stderr, "%s: %s not found\n", "unalias", *argptr);
			i = 1;
		}
	}

	return i;
}

#endif /* ASH_ALIAS */
# 3352 "shell/ash.c"


/* Mode argument to forkshell.  Don't change FORK_FG or FORK_BG. */
#define FORK_FG    0
#define FORK_BG    1
#define FORK_NOJOB 2

/* mode flags for showjob(s) */
#define SHOW_ONLY_PGID  0x01    /* show only pgid (jobs -p) */
#define SHOW_PIDS       0x02    /* show individual pids, not just one line per job */
#define SHOW_CHANGED    0x04    /* only jobs whose state has changed */
#define SHOW_STDERR     0x08    /* print to stderr (else stdout) */

/*
 * A job structure contains information about a job.  A job is either a
 * single process or a set of processes contained in a pipeline.  In the
 * latter case, pidlist will be non-NULL, and will point to a -1 terminated
 * array of pids.
 */
struct procstat {
	pid_t   ps_pid;         /* process id */
	int     ps_status;      /* last process status from wait() */
	char    *ps_cmd;        /* text of command being run */
};

struct job {
	struct procstat ps0;    /* status of process */
	struct procstat *ps;    /* status or processes when more than one */
#if JOBS
	int stopstatus;         /* status of a stopped job */
#endif
# 3383 "shell/ash.c"
	uint32_t
		nprocs: 16,     /* number of processes */
		state: 8,
#define JOBRUNNING      0       /* at least one proc running */
#define JOBSTOPPED      1       /* all procs are stopped */
#define JOBDONE         2       /* all procs are completed */
#if JOBS
		sigint: 1,      /* job was killed by SIGINT */
		jobctl: 1,      /* job running under job control */
#endif
# 3393 "shell/ash.c"
		waited: 1,      /* true if this entry has been waited for */
		used: 1,        /* true if this entry is in used */
		changed: 1;     /* true if status has changed */
	struct job *prev_job;   /* previous job */
};

static struct job *makejob(/*union node *,*/ int);
static int forkshell(struct job *, union node *, int);
static int waitforjob(struct job *);

#if !JOBS
enum { doing_jobctl = 0 };
#define setjobctl(on) do {} while (0)
#else
# 3407 "shell/ash.c"
static smallint doing_jobctl; //references:8
static void setjobctl(int);
#endif
# 3410 "shell/ash.c"

/*
 * Ignore a signal.
 */
static void
ignoresig(int signo)
{
	/* Avoid unnecessary system calls. Is it already SIG_IGNed? */
	if (sigmode[signo - 1] != S_IGN && sigmode[signo - 1] != S_HARD_IGN) {
		/* No, need to do it */
		signal(signo, SIG_IGN);
	}
	sigmode[signo - 1] = S_HARD_IGN;
}

/*
 * Only one usage site - in setsignal()
 */
static void
signal_handler(int signo)
{
	if (signo == SIGCHLD) {
		got_sigchld = 1;
		if (!trap[SIGCHLD])
			return;
	}

	gotsig[signo - 1] = 1;
	pending_sig = signo;

	if (signo == SIGINT && !trap[SIGINT]) {
		if (!suppress_int) {
			pending_sig = 0;
			raise_interrupt(); /* does not return */
		}
		pending_int = 1;
	}
}

/*
 * Set the signal handler for the specified signal.  The routine figures
 * out what it should be set to.
 */
static void
setsignal(int signo)
{
	char *t;
	char cur_act, new_act;
	struct sigaction act;

	t = trap[signo];
	new_act = S_DFL;
	if (t != NULL) { /* trap for this sig is set */
		new_act = S_CATCH;
		if (t[0] == '\0') /* trap is "": ignore this sig */
			new_act = S_IGN;
	}

	if (rootshell && new_act == S_DFL) {
		switch (signo) {
		case SIGINT:
			if (iflag || minusc || sflag == 0)
				new_act = S_CATCH;
			break;
		case SIGQUIT:
#if DEBUG
			if (debug)
				break;
#endif
# 3479 "shell/ash.c"
			/* man bash:
			 * "In all cases, bash ignores SIGQUIT. Non-builtin
			 * commands run by bash have signal handlers
			 * set to the values inherited by the shell
			 * from its parent". */
			new_act = S_IGN;
			break;
		case SIGTERM:
			if (iflag)
				new_act = S_IGN;
			break;
#if JOBS
		case SIGTSTP:
		case SIGTTOU:
			if (mflag)
				new_act = S_IGN;
			break;
#endif
# 3497 "shell/ash.c"
		}
	}
//TODO: if !rootshell, we reset SIGQUIT to DFL,
//whereas we have to restore it to what shell got on entry
//from the parent. See comment above

	if (signo == SIGCHLD)
		new_act = S_CATCH;

	t = &sigmode[signo - 1];
	cur_act = *t;
	if (cur_act == 0) {
		/* current setting is not yet known */
		if (sigaction(signo, NULL, &act)) {
			/* pretend it worked; maybe we should give a warning,
			 * but other shells don't. We don't alter sigmode,
			 * so we retry every time.
			 * btw, in Linux it never fails. --vda */
			return;
		}
		if (act.sa_handler == SIG_IGN) {
			cur_act = S_HARD_IGN;
			if (mflag
			 && (signo == SIGTSTP || signo == SIGTTIN || signo == SIGTTOU)
			) {
				cur_act = S_IGN;   /* don't hard ignore these */
			}
		}
	}
	if (cur_act == S_HARD_IGN || cur_act == new_act)
		return;

	act.sa_handler = SIG_DFL;
	switch (new_act) {
	case S_CATCH:
		act.sa_handler = signal_handler;
		break;
	case S_IGN:
		act.sa_handler = SIG_IGN;
		break;
	}

	/* flags and mask matter only if !DFL and !IGN, but we do it
	 * for all cases for more deterministic behavior:
	 */
	act.sa_flags = 0;
	sigfillset(&act.sa_mask);

	sigaction_set(signo, &act);

	*t = new_act;
}

/* mode flags for set_curjob */
#define CUR_DELETE 2
#define CUR_RUNNING 1
#define CUR_STOPPED 0

#if JOBS
/* pgrp of shell on invocation */
static int initialpgrp; //references:2
static int ttyfd = -1; //5
#endif
# 3560 "shell/ash.c"
/* array of jobs */
static struct job *jobtab; //5
/* size of array */
static unsigned njobs; //4
/* current job */
static struct job *curjob; //lots
/* number of presumed living untracked jobs */
static int jobless; //4

static void
set_curjob(struct job *jp, unsigned mode)
{
	struct job *jp1;
	struct job **jpp, **curp;

	/* first remove from list */
	jpp = curp = &curjob;
	while (1) {
		jp1 = *jpp;
		if (jp1 == jp)
			break;
		jpp = &jp1->prev_job;
	}
	*jpp = jp1->prev_job;

	/* Then re-insert in correct position */
	jpp = curp;
	switch (mode) {
	default:
#if DEBUG
		abort();
#endif
# 3592 "shell/ash.c"
	case CUR_DELETE:
		/* job being deleted */
		break;
	case CUR_RUNNING:
		/* newly created job or backgrounded job,
		 * put after all stopped jobs.
		 */
		while (1) {
			jp1 = *jpp;
#if JOBS
			if (!jp1 || jp1->state != JOBSTOPPED)
#endif
# 3604 "shell/ash.c"
				break;
			jpp = &jp1->prev_job;
		}
		/* FALLTHROUGH */
#if JOBS
	case CUR_STOPPED:
#endif
# 3611 "shell/ash.c"
		/* newly stopped job - becomes curjob */
		jp->prev_job = *jpp;
		*jpp = jp;
		break;
	}
}

#if JOBS || DEBUG
static int
jobno(const struct job *jp)
{
	return jp - jobtab + 1;
}
#endif
# 3625 "shell/ash.c"

/*
 * Convert a job name to a job structure.
 */
#if !JOBS
#define getjob(name, getctl) getjob(name)
#endif
# 3632 "shell/ash.c"
static struct job *
getjob(const char *name, int getctl)
{
	struct job *jp;
	struct job *found;
	const char *err_msg = "%s: no such job";
	unsigned num;
	int c;
	const char *p;
	char *(*match)(const char *, const char *);

	jp = curjob;
	p = name;
	if (!p)
		goto currentjob;

	if (*p != '%')
		goto err;

	c = *++p;
	if (!c)
		goto currentjob;

	if (!p[1]) {
		if (c == '+' || c == '%') {
 currentjob:
			err_msg = "No current job";
			goto check;
		}
		if (c == '-') {
			if (jp)
				jp = jp->prev_job;
			err_msg = "No previous job";
 check:
			if (!jp)
				goto err;
			goto gotit;
		}
	}

	if (is_number(p)) {
		num = atoi(p);
		if (num > 0 && num <= njobs) {
			jp = jobtab + num - 1;
			if (jp->used)
				goto gotit;
			goto err;
		}
	}

	match = prefix;
	if (*p == '?') {
		match = strstr;
		p++;
	}

	found = NULL;
	while (jp) {
		if (match(jp->ps[0].ps_cmd, p)) {
			if (found)
				goto err;
			found = jp;
			err_msg = "%s: ambiguous";
		}
		jp = jp->prev_job;
	}
	if (!found)
		goto err;
	jp = found;

 gotit:
#if JOBS
	err_msg = "job %s not created under job control";
	if (getctl && jp->jobctl == 0)
		goto err;
#endif
# 3708 "shell/ash.c"
	return jp;
 err:
	ash_msg_and_raise_error(err_msg, name);
}

/*
 * Mark a job structure as unused.
 */
static void
freejob(struct job *jp)
{
	struct procstat *ps;
	int i;

	INT_OFF;
	for (i = jp->nprocs, ps = jp->ps; --i >= 0; ps++) {
		if (ps->ps_cmd != nullstr)
			free(ps->ps_cmd);
	}
	if (jp->ps != &jp->ps0)
		free(jp->ps);
	jp->used = 0;
	set_curjob(jp, CUR_DELETE);
	INT_ON;
}

#if JOBS
static void
xtcsetpgrp(int fd, pid_t pgrp)
{
	if (tcsetpgrp(fd, pgrp))
		ash_msg_and_raise_error("can't set tty process group (%m)");
}

/*
 * Turn job control on and off.
 *
 * Note:  This code assumes that the third arg to ioctl is a character
 * pointer, which is true on Berkeley systems but not System V.  Since
 * System V doesn't have job control yet, this isn't a problem now.
 *
 * Called with interrupts off.
 */
static void
setjobctl(int on)
{
	int fd;
	int pgrp;

	if (on == doing_jobctl || rootshell == 0)
		return;
	if (on) {
		int ofd;
		ofd = fd = open(_PATH_TTY, O_RDWR);
		if (fd < 0) {
	/* BTW, bash will try to open(ttyname(0)) if open("/dev/tty") fails.
	 * That sometimes helps to acquire controlling tty.
	 * Obviously, a workaround for bugs when someone
	 * failed to provide a controlling tty to bash! :) */
			fd = 2;
			while (!isatty(fd))
				if (--fd < 0)
					goto out;
		}
		/* fd is a tty at this point */
		fd = fcntl(fd, F_DUPFD, 10);
		if (ofd >= 0) /* if it is "/dev/tty", close. If 0/1/2, dont */
			close(ofd);
		if (fd < 0)
			goto out; /* F_DUPFD failed */
		close_on_exec_on(fd);
		while (1) { /* while we are in the background */
			pgrp = tcgetpgrp(fd);
			if (pgrp < 0) {
 out:
				ash_msg("can't access tty; job control turned off");
				mflag = on = 0;
				goto close;
			}
			if (pgrp == getpgrp())
				break;
			killpg(0, SIGTTIN);
		}
		initialpgrp = pgrp;

		setsignal(SIGTSTP);
		setsignal(SIGTTOU);
		setsignal(SIGTTIN);
		pgrp = rootpid;
		setpgid(0, pgrp);
		xtcsetpgrp(fd, pgrp);
	} else {
		/* turning job control off */
		fd = ttyfd;
		pgrp = initialpgrp;
		/* was xtcsetpgrp, but this can make exiting ash
		 * loop forever if pty is already deleted */
		tcsetpgrp(fd, pgrp);
		setpgid(0, pgrp);
		setsignal(SIGTSTP);
		setsignal(SIGTTOU);
		setsignal(SIGTTIN);
 close:
		if (fd >= 0)
			close(fd);
		fd = -1;
	}
	ttyfd = fd;
	doing_jobctl = on;
}

static int FAST_FUNC
killcmd(int argc, char **argv)
{
	if (argv[1] && strcmp(argv[1], "-l") != 0) {
		int i = 1;
		do {
			if (argv[i][0] == '%') {
				/*
				 * "kill %N" - job kill
				 * Converting to pgrp / pid kill
				 */
				struct job *jp;
				char *dst;
				int j, n;

				jp = getjob(argv[i], 0);
				/*
				 * In jobs started under job control, we signal
				 * entire process group by kill -PGRP_ID.
				 * This happens, f.e., in interactive shell.
				 *
				 * Otherwise, we signal each child via
				 * kill PID1 PID2 PID3.
				 * Testcases:
				 * sh -c 'sleep 1|sleep 1 & kill %1'
				 * sh -c 'true|sleep 2 & sleep 1; kill %1'
				 * sh -c 'true|sleep 1 & sleep 2; kill %1'
				 */
				n = jp->nprocs; /* can't be 0 (I hope) */
				if (jp->jobctl)
					n = 1;
				dst = alloca(n * sizeof(int)*4);
				argv[i] = dst;
				for (j = 0; j < n; j++) {
					struct procstat *ps = &jp->ps[j];
					/* Skip non-running and not-stopped members
					 * (i.e. dead members) of the job
					 */
					if (ps->ps_status != -1 && !WIFSTOPPED(ps->ps_status))
						continue;
					/*
					 * kill_main has matching code to expect
					 * leading space. Needed to not confuse
					 * negative pids with "kill -SIGNAL_NO" syntax
					 */
					dst += sprintf(dst, jp->jobctl ? " -%u" : " %u", (int)ps->ps_pid);
				}
				*dst = '\0';
			}
		} while (argv[++i]);
	}
	return kill_main(argc, argv);
}

static void
showpipe(struct job *jp /*, FILE *out*/)
{
	struct procstat *ps;
	struct procstat *psend;

	psend = jp->ps + jp->nprocs;
	for (ps = jp->ps + 1; ps < psend; ps++)
		printf(" | %s", ps->ps_cmd);
	newline_and_flush(stdout);
	flush_stdout_stderr();
}


static int
restartjob(struct job *jp, int mode)
{
	struct procstat *ps;
	int i;
	int status;
	pid_t pgid;

	INT_OFF;
	if (jp->state == JOBDONE)
		goto out;
	jp->state = JOBRUNNING;
	pgid = jp->ps[0].ps_pid;
	if (mode == FORK_FG)
		xtcsetpgrp(ttyfd, pgid);
	killpg(pgid, SIGCONT);
	ps = jp->ps;
	i = jp->nprocs;
	do {
		if (WIFSTOPPED(ps->ps_status)) {
			ps->ps_status = -1;
		}
		ps++;
	} while (--i);
 out:
	status = (mode == FORK_FG) ? waitforjob(jp) : 0;
	INT_ON;
	return status;
}

static int FAST_FUNC
fg_bgcmd(int argc UNUSED_PARAM, char **argv)
{
	struct job *jp;
	int mode;
	int retval;

	mode = (**argv == 'f') ? FORK_FG : FORK_BG;
	nextopt(nullstr);
	argv = argptr;
	do {
		jp = getjob(*argv, 1);
		if (mode == FORK_BG) {
			set_curjob(jp, CUR_RUNNING);
			printf("[%d] ", jobno(jp));
		}
		out1str(jp->ps[0].ps_cmd);
		showpipe(jp /*, stdout*/);
		retval = restartjob(jp, mode);
	} while (*argv && *++argv);
	return retval;
}
#endif
# 3940 "shell/ash.c"

static int
sprint_status48(char *s, int status, int sigonly)
{
	int col;
	int st;

	col = 0;
	if (!WIFEXITED(status)) {
		if (JOBS && WIFSTOPPED(status))
			st = WSTOPSIG(status);
		else
			st = WTERMSIG(status);
		if (sigonly) {
			if (st == SIGINT || st == SIGPIPE)
				goto out;
			if (JOBS && WIFSTOPPED(status))
				goto out;
		}
		st &= 0x7f;
//TODO: use bbox's get_signame? strsignal adds ~600 bytes to text+rodata
		col = fmtstr(s, 32, strsignal(st));
		if (WCOREDUMP(status)) {
			strcpy(s + col, " (core dumped)");
			col += sizeof(" (core dumped)")-1;
		}
	} else if (!sigonly) {
		st = WEXITSTATUS(status);
		col = fmtstr(s, 16, (st ? "Done(%d)" : "Done"), st);
	}
 out:
	return col;
}

static int
wait_block_or_sig(int *status)
{
	int pid;

	do {
		sigset_t mask;

		/* Poll all children for changes in their state */
		got_sigchld = 0;
		/* if job control is active, accept stopped processes too */
		pid = waitpid(-1, status, doing_jobctl ? (WNOHANG|WUNTRACED) : WNOHANG);
		if (pid != 0)
			break; /* Error (e.g. EINTR, ECHILD) or pid */

		/* Children exist, but none are ready. Sleep until interesting signal */
#if 1
		sigfillset(&mask);
		sigprocmask(SIG_SETMASK, &mask, &mask);
		while (!got_sigchld && !pending_sig)
			sigsuspend(&mask);
		sigprocmask(SIG_SETMASK, &mask, NULL);
#else /* unsafe: a signal can set pending_sig after check, but before pause() */
# 3997 "shell/ash.c"
		while (!got_sigchld && !pending_sig)
			pause();
#endif
# 4000 "shell/ash.c"

		/* If it was SIGCHLD, poll children again */
	} while (got_sigchld);

	return pid;
}

#define DOWAIT_NONBLOCK 0
#define DOWAIT_BLOCK    1
#define DOWAIT_BLOCK_OR_SIG 2

static int
dowait(int block, struct job *job)
{
	int pid;
	int status;
	struct job *jp;
	struct job *thisjob = NULL;

	TRACE(("dowait(0x%x) called\n", block));

	/* It's wrong to call waitpid() outside of INT_OFF region:
	 * signal can arrive just after syscall return and handler can
	 * longjmp away, losing stop/exit notification processing.
	 * Thus, for "jobs" builtin, and for waiting for a fg job,
	 * we call waitpid() (blocking or non-blocking) inside INT_OFF.
	 *
	 * However, for "wait" builtin it is wrong to simply call waitpid()
	 * in INT_OFF region: "wait" needs to wait for any running job
	 * to change state, but should exit on any trap too.
	 * In INT_OFF region, a signal just before syscall entry can set
	 * pending_sig variables, but we can't check them, and we would
	 * either enter a sleeping waitpid() (BUG), or need to busy-loop.
	 *
	 * Because of this, we run inside INT_OFF, but use a special routine
	 * which combines waitpid() and sigsuspend().
	 * This is the reason why we need to have a handler for SIGCHLD:
	 * SIG_DFL handler does not wake sigsuspend().
	 */
	INT_OFF;
	if (block == DOWAIT_BLOCK_OR_SIG) {
		pid = wait_block_or_sig(&status);
	} else {
		int wait_flags = 0;
		if (block == DOWAIT_NONBLOCK)
			wait_flags = WNOHANG;
		/* if job control is active, accept stopped processes too */
		if (doing_jobctl)
			wait_flags |= WUNTRACED;
		/* NB: _not_ safe_waitpid, we need to detect EINTR */
		pid = waitpid(-1, &status, wait_flags);
	}
	TRACE(("wait returns pid=%d, status=0x%x, errno=%d(%s)\n",
				pid, status, errno, strerror(errno)));
	if (pid <= 0)
		goto out;

	thisjob = NULL;
	for (jp = curjob; jp; jp = jp->prev_job) {
		int jobstate;
		struct procstat *ps;
		struct procstat *psend;
		if (jp->state == JOBDONE)
			continue;
		jobstate = JOBDONE;
		ps = jp->ps;
		psend = ps + jp->nprocs;
		do {
			if (ps->ps_pid == pid) {
				TRACE(("Job %d: changing status of proc %d "
					"from 0x%x to 0x%x\n",
					jobno(jp), pid, ps->ps_status, status));
				ps->ps_status = status;
				thisjob = jp;
			}
			if (ps->ps_status == -1)
				jobstate = JOBRUNNING;
#if JOBS
			if (jobstate == JOBRUNNING)
				continue;
			if (WIFSTOPPED(ps->ps_status)) {
				jp->stopstatus = ps->ps_status;
				jobstate = JOBSTOPPED;
			}
#endif
# 4085 "shell/ash.c"
		} while (++ps < psend);
		if (!thisjob)
			continue;

		/* Found the job where one of its processes changed its state.
		 * Is there at least one live and running process in this job? */
		if (jobstate != JOBRUNNING) {
			/* No. All live processes in the job are stopped
			 * (JOBSTOPPED) or there are no live processes (JOBDONE)
			 */
			thisjob->changed = 1;
			if (thisjob->state != jobstate) {
				TRACE(("Job %d: changing state from %d to %d\n",
					jobno(thisjob), thisjob->state, jobstate));
				thisjob->state = jobstate;
#if JOBS
				if (jobstate == JOBSTOPPED)
					set_curjob(thisjob, CUR_STOPPED);
#endif
# 4104 "shell/ash.c"
			}
		}
		goto out;
	}
	/* The process wasn't found in job list */
	if (JOBS && !WIFSTOPPED(status))
		jobless--;
 out:
	INT_ON;

	if (thisjob && thisjob == job) {
		char s[48 + 1];
		int len;

		len = sprint_status48(s, status, 1);
		if (len) {
			s[len] = '\n';
			s[len + 1] = '\0';
			out2str(s);
		}
	}
	return pid;
}

#if JOBS
static void
showjob(struct job *jp, int mode)
{
	struct procstat *ps;
	struct procstat *psend;
	int col;
	int indent_col;
	char s[16 + 16 + 48];
	FILE *out = (mode & SHOW_STDERR ? stderr : stdout);

	ps = jp->ps;

	if (mode & SHOW_ONLY_PGID) { /* jobs -p */
		/* just output process (group) id of pipeline */
		fprintf(out, "%d\n", ps->ps_pid);
		return;
	}

	col = fmtstr(s, 16, "[%d]   ", jobno(jp));
	indent_col = col;

	if (jp == curjob)
		s[col - 3] = '+';
	else if (curjob && jp == curjob->prev_job)
		s[col - 3] = '-';

	if (mode & SHOW_PIDS)
		col += fmtstr(s + col, 16, "%d ", ps->ps_pid);

	psend = ps + jp->nprocs;

	if (jp->state == JOBRUNNING) {
		strcpy(s + col, "Running");
		col += sizeof("Running") - 1;
	} else {
		int status = psend[-1].ps_status;
		if (jp->state == JOBSTOPPED)
			status = jp->stopstatus;
		col += sprint_status48(s + col, status, 0);
	}
	/* By now, "[JOBID]*  [maybe PID] STATUS" is printed */

	/* This loop either prints "<cmd1> | <cmd2> | <cmd3>" line
	 * or prints several "PID             | <cmdN>" lines,
	 * depending on SHOW_PIDS bit.
	 * We do not print status of individual processes
	 * between PID and <cmdN>. bash does it, but not very well:
	 * first line shows overall job status, not process status,
	 * making it impossible to know 1st process status.
	 */
	goto start;
	do {
		/* for each process */
		s[0] = '\0';
		col = 33;
		if (mode & SHOW_PIDS)
			col = fmtstr(s, 48, "\n%*c%d ", indent_col, ' ', ps->ps_pid) - 1;
 start:
		fprintf(out, "%s%*c%s%s",
				s,
				33 - col >= 0 ? 33 - col : 0, ' ',
				ps == jp->ps ? "" : "| ",
				ps->ps_cmd
		);
	} while (++ps != psend);
	newline_and_flush(out);

	jp->changed = 0;

	if (jp->state == JOBDONE) {
		TRACE(("showjob: freeing job %d\n", jobno(jp)));
		freejob(jp);
	}
}

/*
 * Print a list of jobs.  If "change" is nonzero, only print jobs whose
 * statuses have changed since the last call to showjobs.
 */
static void
showjobs(int mode)
{
	struct job *jp;

	TRACE(("showjobs(0x%x) called\n", mode));

	/* Handle all finished jobs */
	while (dowait(DOWAIT_NONBLOCK, NULL) > 0)
		continue;

	for (jp = curjob; jp; jp = jp->prev_job) {
		if (!(mode & SHOW_CHANGED) || jp->changed) {
			showjob(jp, mode);
		}
	}
}

static int FAST_FUNC
jobscmd(int argc UNUSED_PARAM, char **argv)
{
	int mode, m;

	mode = 0;
	while ((m = nextopt("lp")) != '\0') {
		if (m == 'l')
			mode |= SHOW_PIDS;
		else
			mode |= SHOW_ONLY_PGID;
	}

	argv = argptr;
	if (*argv) {
		do
			showjob(getjob(*argv, 0), mode);
		while (*++argv);
	} else {
		showjobs(mode);
	}

	return 0;
}
#endif /* JOBS */
# 4251 "shell/ash.c"

/* Called only on finished or stopped jobs (no members are running) */
static int
getstatus(struct job *job)
{
	int status;
	int retval;
	struct procstat *ps;

	/* Fetch last member's status */
	ps = job->ps + job->nprocs - 1;
	status = ps->ps_status;
	if (pipefail) {
		/* "set -o pipefail" mode: use last _nonzero_ status */
		while (status == 0 && --ps >= job->ps)
			status = ps->ps_status;
	}

	retval = WEXITSTATUS(status);
	if (!WIFEXITED(status)) {
#if JOBS
		retval = WSTOPSIG(status);
		if (!WIFSTOPPED(status))
#endif
# 4275 "shell/ash.c"
		{
			/* XXX: limits number of signals */
			retval = WTERMSIG(status);
#if JOBS
			if (retval == SIGINT)
				job->sigint = 1;
#endif
# 4282 "shell/ash.c"
		}
		retval += 128;
	}
	TRACE(("getstatus: job %d, nproc %d, status 0x%x, retval 0x%x\n",
		jobno(job), job->nprocs, status, retval));
	return retval;
}

static int FAST_FUNC
waitcmd(int argc UNUSED_PARAM, char **argv)
{
	struct job *job;
	int retval;
	struct job *jp;

	nextopt(nullstr);
	retval = 0;

	argv = argptr;
	if (!*argv) {
		/* wait for all jobs */
		for (;;) {
			jp = curjob;
			while (1) {
				if (!jp) /* no running procs */
					goto ret;
				if (jp->state == JOBRUNNING)
					break;
				jp->waited = 1;
				jp = jp->prev_job;
			}
	/* man bash:
	 * "When bash is waiting for an asynchronous command via
	 * the wait builtin, the reception of a signal for which a trap
	 * has been set will cause the wait builtin to return immediately
	 * with an exit status greater than 128, immediately after which
	 * the trap is executed."
	 */
			dowait(DOWAIT_BLOCK_OR_SIG, NULL);
	/* if child sends us a signal *and immediately exits*,
	 * dowait() returns pid > 0. Check this case,
	 * not "if (dowait() < 0)"!
	 */
			if (pending_sig)
				goto sigout;
		}
	}

	retval = 127;
	do {
		if (**argv != '%') {
			pid_t pid = number(*argv);
			job = curjob;
			while (1) {
				if (!job)
					goto repeat;
				if (job->ps[job->nprocs - 1].ps_pid == pid)
					break;
				job = job->prev_job;
			}
		} else {
			job = getjob(*argv, 0);
		}
		/* loop until process terminated or stopped */
		while (job->state == JOBRUNNING) {
			dowait(DOWAIT_BLOCK_OR_SIG, NULL);
			if (pending_sig)
				goto sigout;
		}
		job->waited = 1;
		retval = getstatus(job);
 repeat: ;
	} while (*++argv);

 ret:
	return retval;
 sigout:
	retval = 128 + pending_sig;
	return retval;
}

static struct job *
growjobtab(void)
{
	size_t len;
	ptrdiff_t offset;
	struct job *jp, *jq;

	len = njobs * sizeof(*jp);
	jq = jobtab;
	jp = ckrealloc(jq, len + 4 * sizeof(*jp));

	offset = (char *)jp - (char *)jq;
	if (offset) {
		/* Relocate pointers */
		size_t l = len;

		jq = (struct job *)((char *)jq + l);
		while (l) {
			l -= sizeof(*jp);
			jq--;
#define joff(p) ((struct job *)((char *)(p) + l))
#define jmove(p) (p) = (void *)((char *)(p) + offset)
			if (joff(jp)->ps == &jq->ps0)
				jmove(joff(jp)->ps);
			if (joff(jp)->prev_job)
				jmove(joff(jp)->prev_job);
		}
		if (curjob)
			jmove(curjob);
#undef joff
#undef jmove
	}

	njobs += 4;
	jobtab = jp;
	jp = (struct job *)((char *)jp + len);
	jq = jp + 3;
	do {
		jq->used = 0;
	} while (--jq >= jp);
	return jp;
}

/*
 * Return a new job structure.
 * Called with interrupts off.
 */
static struct job *
makejob(/*union node *node,*/ int nprocs)
{
	int i;
	struct job *jp;

	for (i = njobs, jp = jobtab; ; jp++) {
		if (--i < 0) {
			jp = growjobtab();
			break;
		}
		if (jp->used == 0)
			break;
		if (jp->state != JOBDONE || !jp->waited)
			continue;
#if JOBS
		if (doing_jobctl)
			continue;
#endif
# 4429 "shell/ash.c"
		freejob(jp);
		break;
	}
	memset(jp, 0, sizeof(*jp));
#if JOBS
	/* jp->jobctl is a bitfield.
	 * "jp->jobctl |= jobctl" likely to give awful code */
	if (doing_jobctl)
		jp->jobctl = 1;
#endif
# 4439 "shell/ash.c"
	jp->prev_job = curjob;
	curjob = jp;
	jp->used = 1;
	jp->ps = &jp->ps0;
	if (nprocs > 1) {
		jp->ps = ckmalloc(nprocs * sizeof(struct procstat));
	}
	TRACE(("makejob(%d) returns %%%d\n", nprocs,
				jobno(jp)));
	return jp;
}

#if JOBS
/*
 * Return a string identifying a command (to be printed by the
 * jobs command).
 */
static char *cmdnextc;

static void
cmdputs(const char *s)
{
	static const char vstype[VSTYPE + 1][3] = {
		"", "}", "-", "+", "?", "=",
		"%", "%%", "#", "##"
		IF_ASH_BASH_COMPAT(, ":", "/", "//")
	};

	const char *p, *str;
	char cc[2];
	char *nextc;
	unsigned char c;
	unsigned char subtype = 0;
	int quoted = 0;

	cc[1] = '\0';
	nextc = makestrspace((strlen(s) + 1) * 8, cmdnextc);
	p = s;
	while ((c = *p++) != '\0') {
		str = NULL;
		switch (c) {
		case CTLESC:
			c = *p++;
			break;
		case CTLVAR:
			subtype = *p++;
			if ((subtype & VSTYPE) == VSLENGTH)
				str = "${#";
			else
				str = "${";
			goto dostr;
		case CTLENDVAR:
			str = "\"}" + !(quoted & 1);
			quoted >>= 1;
			subtype = 0;
			goto dostr;
		case CTLBACKQ:
			str = "$(...)";
			goto dostr;
#if ENABLE_FEATURE_SH_MATH
		case CTLARI:
			str = "$((";
			goto dostr;
		case CTLENDARI:
			str = "))";
			goto dostr;
#endif
# 4506 "shell/ash.c"
		case CTLQUOTEMARK:
			quoted ^= 1;
			c = '"';
			break;
		case '=':
			if (subtype == 0)
				break;
			if ((subtype & VSTYPE) != VSNORMAL)
				quoted <<= 1;
			str = vstype[subtype & VSTYPE];
			if (subtype & VSNUL)
				c = ':';
			else
				goto checkstr;
			break;
		case '\'':
		case '\\':
		case '"':
		case '$':
			/* These can only happen inside quotes */
			cc[0] = c;
			str = cc;
			c = '\\';
			break;
		default:
			break;
		}
		USTPUTC(c, nextc);
 checkstr:
		if (!str)
			continue;
 dostr:
		while ((c = *str++) != '\0') {
			USTPUTC(c, nextc);
		}
	} /* while *p++ not NUL */

	if (quoted & 1) {
		USTPUTC('"', nextc);
	}
	*nextc = 0;
	cmdnextc = nextc;
}

/* cmdtxt() and cmdlist() call each other */
static void cmdtxt(union node *n);

static void
cmdlist(union node *np, int sep)
{
	for (; np; np = np->narg.next) {
		if (!sep)
			cmdputs(" ");
		cmdtxt(np);
		if (sep && np->narg.next)
			cmdputs(" ");
	}
}

static void
cmdtxt(union node *n)
{
	union node *np;
	struct nodelist *lp;
	const char *p;

	if (!n)
		return;
	switch (n->type) {
	default:
#if DEBUG
		abort();
#endif
# 4579 "shell/ash.c"
	case NPIPE:
		lp = n->npipe.cmdlist;
		for (;;) {
			cmdtxt(lp->n);
			lp = lp->next;
			if (!lp)
				break;
			cmdputs(" | ");
		}
		break;
	case NSEMI:
		p = "; ";
		goto binop;
	case NAND:
		p = " && ";
		goto binop;
	case NOR:
		p = " || ";
 binop:
		cmdtxt(n->nbinary.ch1);
		cmdputs(p);
		n = n->nbinary.ch2;
		goto donode;
	case NREDIR:
	case NBACKGND:
		n = n->nredir.n;
		goto donode;
	case NNOT:
		cmdputs("!");
		n = n->nnot.com;
 donode:
		cmdtxt(n);
		break;
	case NIF:
		cmdputs("if ");
		cmdtxt(n->nif.test);
		cmdputs("; then ");
		if (n->nif.elsepart) {
			cmdtxt(n->nif.ifpart);
			cmdputs("; else ");
			n = n->nif.elsepart;
		} else {
			n = n->nif.ifpart;
		}
		p = "; fi";
		goto dotail;
	case NSUBSHELL:
		cmdputs("(");
		n = n->nredir.n;
		p = ")";
		goto dotail;
	case NWHILE:
		p = "while ";
		goto until;
	case NUNTIL:
		p = "until ";
 until:
		cmdputs(p);
		cmdtxt(n->nbinary.ch1);
		n = n->nbinary.ch2;
		p = "; done";
 dodo:
		cmdputs("; do ");
 dotail:
		cmdtxt(n);
		goto dotail2;
	case NFOR:
		cmdputs("for ");
		cmdputs(n->nfor.var);
		cmdputs(" in ");
		cmdlist(n->nfor.args, 1);
		n = n->nfor.body;
		p = "; done";
		goto dodo;
	case NDEFUN:
		cmdputs(n->narg.text);
		p = "() { ... }";
		goto dotail2;
	case NCMD:
		cmdlist(n->ncmd.args, 1);
		cmdlist(n->ncmd.redirect, 0);
		break;
	case NARG:
		p = n->narg.text;
 dotail2:
		cmdputs(p);
		break;
	case NHERE:
	case NXHERE:
		p = "<<...";
		goto dotail2;
	case NCASE:
		cmdputs("case ");
		cmdputs(n->ncase.expr->narg.text);
		cmdputs(" in ");
		for (np = n->ncase.cases; np; np = np->nclist.next) {
			cmdtxt(np->nclist.pattern);
			cmdputs(") ");
			cmdtxt(np->nclist.body);
			cmdputs(";; ");
		}
		p = "esac";
		goto dotail2;
	case NTO:
		p = ">";
		goto redir;
	case NCLOBBER:
		p = ">|";
		goto redir;
	case NAPPEND:
		p = ">>";
		goto redir;
#if ENABLE_ASH_BASH_COMPAT
	case NTO2:
#endif
# 4694 "shell/ash.c"
	case NTOFD:
		p = ">&";
		goto redir;
	case NFROM:
		p = "<";
		goto redir;
	case NFROMFD:
		p = "<&";
		goto redir;
	case NFROMTO:
		p = "<>";
 redir:
		cmdputs(utoa(n->nfile.fd));
		cmdputs(p);
		if (n->type == NTOFD || n->type == NFROMFD) {
			cmdputs(utoa(n->ndup.dupfd));
			break;
		}
		n = n->nfile.fname;
		goto donode;
	}
}

static char *
commandtext(union node *n)
{
	char *name;

	STARTSTACKSTR(cmdnextc);
	cmdtxt(n);
	name = stackblock();
	TRACE(("commandtext: name %p, end %p\n", name, cmdnextc));
	return ckstrdup(name);
}
#endif /* JOBS */
# 4729 "shell/ash.c"

/*
 * Fork off a subshell.  If we are doing job control, give the subshell its
 * own process group.  Jp is a job structure that the job is to be added to.
 * N is the command that will be evaluated by the child.  Both jp and n may
 * be NULL.  The mode parameter can be one of the following:
 *      FORK_FG - Fork off a foreground process.
 *      FORK_BG - Fork off a background process.
 *      FORK_NOJOB - Like FORK_FG, but don't give the process its own
 *                   process group even if job control is on.
 *
 * When job control is turned off, background processes have their standard
 * input redirected to /dev/null (except for the second and later processes
 * in a pipeline).
 *
 * Called with interrupts off.
 */
/*
 * Clear traps on a fork.
 */
static void
clear_traps(void)
{
	char **tp;

	INT_OFF;
	for (tp = trap; tp < &trap[NSIG]; tp++) {
		if (*tp && **tp) {      /* trap not NULL or "" (SIG_IGN) */
			if (trap_ptr == trap)
				free(*tp);
			/* else: it "belongs" to trap_ptr vector, don't free */
			*tp = NULL;
			if ((tp - trap) != 0)
				setsignal(tp - trap);
		}
	}
	may_have_traps = 0;
	INT_ON;
}

/* Lives far away from here, needed for forkchild */
static void closescript(void);

/* Called after fork(), in child */
/* jp and n are NULL when called by openhere() for heredoc support */
static NOINLINE void
forkchild(struct job *jp, union node *n, int mode)
{
	int oldlvl;

	TRACE(("Child shell %d\n", getpid()));
	oldlvl = shlvl;
	shlvl++;

	/* man bash: "Non-builtin commands run by bash have signal handlers
	 * set to the values inherited by the shell from its parent".
	 * Do we do it correctly? */

	closescript();

	if (mode == FORK_NOJOB          /* is it `xxx` ? */
	 && n && n->type == NCMD        /* is it single cmd? */
	/* && n->ncmd.args->type == NARG - always true? */
	 && n->ncmd.args && strcmp(n->ncmd.args->narg.text, "trap") == 0
	 && n->ncmd.args->narg.next == NULL /* "trap" with no arguments */
	/* && n->ncmd.args->narg.backquote == NULL - do we need to check this? */
	) {
		TRACE(("Trap hack\n"));
		/* Awful hack for `trap` or $(trap).
		 *
		 * http://www.opengroup.org/onlinepubs/009695399/utilities/trap.html
		 * contains an example where "trap" is executed in a subshell:
		 *
		 * save_traps=$(trap)
		 * ...
		 * eval "$save_traps"
		 *
		 * Standard does not say that "trap" in subshell shall print
		 * parent shell's traps. It only says that its output
		 * must have suitable form, but then, in the above example
		 * (which is not supposed to be normative), it implies that.
		 *
		 * bash (and probably other shell) does implement it
		 * (traps are reset to defaults, but "trap" still shows them),
		 * but as a result, "trap" logic is hopelessly messed up:
		 *
		 * # trap
		 * trap -- 'echo Ho' SIGWINCH  <--- we have a handler
		 * # (trap)        <--- trap is in subshell - no output (correct, traps are reset)
		 * # true | trap   <--- trap is in subshell - no output (ditto)
		 * # echo `true | trap`    <--- in subshell - output (but traps are reset!)
		 * trap -- 'echo Ho' SIGWINCH
		 * # echo `(trap)`         <--- in subshell in subshell - output
		 * trap -- 'echo Ho' SIGWINCH
		 * # echo `true | (trap)`  <--- in subshell in subshell in subshell - output!
		 * trap -- 'echo Ho' SIGWINCH
		 *
		 * The rules when to forget and when to not forget traps
		 * get really complex and nonsensical.
		 *
		 * Our solution: ONLY bare $(trap) or `trap` is special.
		 */
		/* Save trap handler strings for trap builtin to print */
		trap_ptr = xmemdup(trap, sizeof(trap));
		/* Fall through into clearing traps */
	}
	clear_traps();
#if JOBS
	/* do job control only in root shell */
	doing_jobctl = 0;
	if (mode != FORK_NOJOB && jp->jobctl && oldlvl == 0) {
		pid_t pgrp;

		if (jp->nprocs == 0)
			pgrp = getpid();
		else
			pgrp = jp->ps[0].ps_pid;
		/* this can fail because we are doing it in the parent also */
		setpgid(0, pgrp);
		if (mode == FORK_FG)
			xtcsetpgrp(ttyfd, pgrp);
		setsignal(SIGTSTP);
		setsignal(SIGTTOU);
	} else
#endif
# 4854 "shell/ash.c"
	if (mode == FORK_BG) {
		/* man bash: "When job control is not in effect,
		 * asynchronous commands ignore SIGINT and SIGQUIT" */
		ignoresig(SIGINT);
		ignoresig(SIGQUIT);
		if (jp->nprocs == 0) {
			close(0);
			if (open(bb_dev_null, O_RDONLY) != 0)
				ash_msg_and_raise_error("can't open '%s'", bb_dev_null);
		}
	}
	if (oldlvl == 0) {
		if (iflag) { /* why if iflag only? */
			setsignal(SIGINT);
			setsignal(SIGTERM);
		}
		/* man bash:
		 * "In all cases, bash ignores SIGQUIT. Non-builtin
		 * commands run by bash have signal handlers
		 * set to the values inherited by the shell
		 * from its parent".
		 * Take care of the second rule: */
		setsignal(SIGQUIT);
	}
#if JOBS
	if (n && n->type == NCMD
	 && n->ncmd.args && strcmp(n->ncmd.args->narg.text, "jobs") == 0
	) {
		TRACE(("Job hack\n"));
		/* "jobs": we do not want to clear job list for it,
		 * instead we remove only _its_ own_ job from job list.
		 * This makes "jobs .... | cat" more useful.
		 */
		freejob(curjob);
		return;
	}
#endif
# 4891 "shell/ash.c"
	for (jp = curjob; jp; jp = jp->prev_job)
		freejob(jp);
	jobless = 0;
}

/* Called after fork(), in parent */
#if !JOBS
#define forkparent(jp, n, mode, pid) forkparent(jp, mode, pid)
#endif
# 4900 "shell/ash.c"
static void
forkparent(struct job *jp, union node *n, int mode, pid_t pid)
{
	TRACE(("In parent shell: child = %d\n", pid));
	if (!jp) {
		/* jp is NULL when called by openhere() for heredoc support */
		while (jobless && dowait(DOWAIT_NONBLOCK, NULL) > 0)
			continue;
		jobless++;
		return;
	}
#if JOBS
	if (mode != FORK_NOJOB && jp->jobctl) {
		int pgrp;

		if (jp->nprocs == 0)
			pgrp = pid;
		else
			pgrp = jp->ps[0].ps_pid;
		/* This can fail because we are doing it in the child also */
		setpgid(pid, pgrp);
	}
#endif
# 4923 "shell/ash.c"
	if (mode == FORK_BG) {
		backgndpid = pid;               /* set $! */
		set_curjob(jp, CUR_RUNNING);
	}
	if (jp) {
		struct procstat *ps = &jp->ps[jp->nprocs++];
		ps->ps_pid = pid;
		ps->ps_status = -1;
		ps->ps_cmd = nullstr;
#if JOBS
		if (doing_jobctl && n)
			ps->ps_cmd = commandtext(n);
#endif
# 4936 "shell/ash.c"
	}
}

/* jp and n are NULL when called by openhere() for heredoc support */
static int
forkshell(struct job *jp, union node *n, int mode)
{
	int pid;

	TRACE(("forkshell(%%%d, %p, %d) called\n", jobno(jp), n, mode));
	pid = fork();
	if (pid < 0) {
		TRACE(("Fork failed, errno=%d", errno));
		if (jp)
			freejob(jp);
		ash_msg_and_raise_error("can't fork");
	}
	if (pid == 0) {
		CLEAR_RANDOM_T(&random_gen); /* or else $RANDOM repeats in child */
		forkchild(jp, n, mode);
	} else {
		forkparent(jp, n, mode, pid);
	}
	return pid;
}

/*
 * Wait for job to finish.
 *
 * Under job control we have the problem that while a child process
 * is running interrupts generated by the user are sent to the child
 * but not to the shell.  This means that an infinite loop started by
 * an interactive user may be hard to kill.  With job control turned off,
 * an interactive user may place an interactive program inside a loop.
 * If the interactive program catches interrupts, the user doesn't want
 * these interrupts to also abort the loop.  The approach we take here
 * is to have the shell ignore interrupt signals while waiting for a
 * foreground process to terminate, and then send itself an interrupt
 * signal if the child process was terminated by an interrupt signal.
 * Unfortunately, some programs want to do a bit of cleanup and then
 * exit on interrupt; unless these processes terminate themselves by
 * sending a signal to themselves (instead of calling exit) they will
 * confuse this approach.
 *
 * Called with interrupts off.
 */
static int
waitforjob(struct job *jp)
{
	int st;

	TRACE(("waitforjob(%%%d) called\n", jobno(jp)));

	INT_OFF;
	while (jp->state == JOBRUNNING) {
		/* In non-interactive shells, we _can_ get
		 * a keyboard signal here and be EINTRed,
		 * but we just loop back, waiting for command to complete.
		 *
		 * man bash:
		 * "If bash is waiting for a command to complete and receives
		 * a signal for which a trap has been set, the trap
		 * will not be executed until the command completes."
		 *
		 * Reality is that even if trap is not set, bash
		 * will not act on the signal until command completes.
		 * Try this. sleep5intoff.c:
		 * #include <signal.h>
		 * #include <unistd.h>
		 * int main() {
		 *         sigset_t set;
		 *         sigemptyset(&set);
		 *         sigaddset(&set, SIGINT);
		 *         sigaddset(&set, SIGQUIT);
		 *         sigprocmask(SIG_BLOCK, &set, NULL);
		 *         sleep(5);
		 *         return 0;
		 * }
		 * $ bash -c './sleep5intoff; echo hi'
		 * ^C^C^C^C <--- pressing ^C once a second
		 * $ _
		 * $ bash -c './sleep5intoff; echo hi'
		 * ^\^\^\^\hi <--- pressing ^\ (SIGQUIT)
		 * $ _
		 */
		dowait(DOWAIT_BLOCK, jp);
	}
	INT_ON;

	st = getstatus(jp);
#if JOBS
	if (jp->jobctl) {
		xtcsetpgrp(ttyfd, rootpid);
		/*
		 * This is truly gross.
		 * If we're doing job control, then we did a TIOCSPGRP which
		 * caused us (the shell) to no longer be in the controlling
		 * session -- so we wouldn't have seen any ^C/SIGINT.  So, we
		 * intuit from the subprocess exit status whether a SIGINT
		 * occurred, and if so interrupt ourselves.  Yuck.  - mycroft
		 */
		if (jp->sigint) /* TODO: do the same with all signals */
			raise(SIGINT); /* ... by raise(jp->sig) instead? */
	}
	if (jp->state == JOBDONE)
#endif
# 5042 "shell/ash.c"
		freejob(jp);
	return st;
}

/*
 * return 1 if there are stopped jobs, otherwise 0
 */
static int
stoppedjobs(void)
{
	struct job *jp;
	int retval;

	retval = 0;
	if (job_warning)
		goto out;
	jp = curjob;
	if (jp && jp->state == JOBSTOPPED) {
		out2str("You have stopped jobs.\n");
		job_warning = 2;
		retval++;
	}
 out:
	return retval;
}


/*
 * Code for dealing with input/output redirection.
 */

#undef EMPTY
#undef CLOSED
#define EMPTY -2                /* marks an unused slot in redirtab */
#define CLOSED -3               /* marks a slot of previously-closed fd */

/*
 * Open a file in noclobber mode.
 * The code was copied from bash.
 */
static int
noclobberopen(const char *fname)
{
	int r, fd;
	struct stat finfo, finfo2;

	/*
	 * If the file exists and is a regular file, return an error
	 * immediately.
	 */
	r = stat(fname, &finfo);
	if (r == 0 && S_ISREG(finfo.st_mode)) {
		errno = EEXIST;
		return -1;
	}

	/*
	 * If the file was not present (r != 0), make sure we open it
	 * exclusively so that if it is created before we open it, our open
	 * will fail.  Make sure that we do not truncate an existing file.
	 * Note that we don't turn on O_EXCL unless the stat failed -- if the
	 * file was not a regular file, we leave O_EXCL off.
	 */
	if (r != 0)
		return open(fname, O_WRONLY|O_CREAT|O_EXCL, 0666);
	fd = open(fname, O_WRONLY|O_CREAT, 0666);

	/* If the open failed, return the file descriptor right away. */
	if (fd < 0)
		return fd;

	/*
	 * OK, the open succeeded, but the file may have been changed from a
	 * non-regular file to a regular file between the stat and the open.
	 * We are assuming that the O_EXCL open handles the case where FILENAME
	 * did not exist and is symlinked to an existing file between the stat
	 * and open.
	 */

	/*
	 * If we can open it and fstat the file descriptor, and neither check
	 * revealed that it was a regular file, and the file has not been
	 * replaced, return the file descriptor.
	 */
	if (fstat(fd, &finfo2) == 0
	 && !S_ISREG(finfo2.st_mode)
	 && finfo.st_dev == finfo2.st_dev
	 && finfo.st_ino == finfo2.st_ino
	) {
		return fd;
	}

	/* The file has been replaced.  badness. */
	close(fd);
	errno = EEXIST;
	return -1;
}

/*
 * Handle here documents.  Normally we fork off a process to write the
 * data to a pipe.  If the document is short, we can stuff the data in
 * the pipe without forking.
 */
/* openhere needs this forward reference */
static void expandhere(union node *arg, int fd);
static int
openhere(union node *redir)
{
	int pip[2];
	size_t len = 0;

	if (pipe(pip) < 0)
		ash_msg_and_raise_error("pipe call failed");
	if (redir->type == NHERE) {
		len = strlen(redir->nhere.doc->narg.text);
		if (len <= PIPE_BUF) {
			full_write(pip[1], redir->nhere.doc->narg.text, len);
			goto out;
		}
	}
	if (forkshell((struct job *)NULL, (union node *)NULL, FORK_NOJOB) == 0) {
		/* child */
		close(pip[0]);
		ignoresig(SIGINT);  //signal(SIGINT, SIG_IGN);
		ignoresig(SIGQUIT); //signal(SIGQUIT, SIG_IGN);
		ignoresig(SIGHUP);  //signal(SIGHUP, SIG_IGN);
		ignoresig(SIGTSTP); //signal(SIGTSTP, SIG_IGN);
		signal(SIGPIPE, SIG_DFL);
		if (redir->type == NHERE)
			full_write(pip[1], redir->nhere.doc->narg.text, len);
		else /* NXHERE */
			expandhere(redir->nhere.doc, pip[1]);
		_exit(EXIT_SUCCESS);
	}
 out:
	close(pip[1]);
	return pip[0];
}

static int
openredirect(union node *redir)
{
	char *fname;
	int f;

	switch (redir->nfile.type) {
/* Can't happen, our single caller does this itself */
//	case NTOFD:
//	case NFROMFD:
//		return -1;
	case NHERE:
	case NXHERE:
		return openhere(redir);
	}

	/* For N[X]HERE, reading redir->nfile.expfname would touch beyond
	 * allocated space. Do it only when we know it is safe.
	 */
	fname = redir->nfile.expfname;

	switch (redir->nfile.type) {
	default:
#if DEBUG
		abort();
#endif
# 5207 "shell/ash.c"
	case NFROM:
		f = open(fname, O_RDONLY);
		if (f < 0)
			goto eopen;
		break;
	case NFROMTO:
		f = open(fname, O_RDWR|O_CREAT, 0666);
		if (f < 0)
			goto ecreate;
		break;
	case NTO:
#if ENABLE_ASH_BASH_COMPAT
	case NTO2:
#endif
# 5221 "shell/ash.c"
		/* Take care of noclobber mode. */
		if (Cflag) {
			f = noclobberopen(fname);
			if (f < 0)
				goto ecreate;
			break;
		}
		/* FALLTHROUGH */
	case NCLOBBER:
		f = open(fname, O_WRONLY|O_CREAT|O_TRUNC, 0666);
		if (f < 0)
			goto ecreate;
		break;
	case NAPPEND:
		f = open(fname, O_WRONLY|O_CREAT|O_APPEND, 0666);
		if (f < 0)
			goto ecreate;
		break;
	}

	return f;
 ecreate:
	ash_msg_and_raise_error("can't create %s: %s", fname, errmsg(errno, "nonexistent directory"));
 eopen:
	ash_msg_and_raise_error("can't open %s: %s", fname, errmsg(errno, "no such file"));
}

/*
 * Copy a file descriptor to be >= 10. Throws exception on error.
 */
static int
savefd(int from)
{
	int newfd;
	int err;

	newfd = fcntl(from, F_DUPFD, 10);
	err = newfd < 0 ? errno : 0;
	if (err != EBADF) {
		if (err)
			ash_msg_and_raise_error("%d: %m", from);
		close(from);
		fcntl(newfd, F_SETFD, FD_CLOEXEC);
	}

	return newfd;
}
static int
dup2_or_raise(int from, int to)
{
	int newfd;

	newfd = (from != to) ? dup2(from, to) : to;
	if (newfd < 0) {
		/* Happens when source fd is not open: try "echo >&99" */
		ash_msg_and_raise_error("%d: %m", from);
	}
	return newfd;
}

/* Struct def and variable are moved down to the first usage site */
struct two_fd_t {
	int orig, copy;
};
struct redirtab {
	struct redirtab *next;
	int pair_count;
	struct two_fd_t two_fd[];
};
#define redirlist (G_var.redirlist)
enum {
	COPYFD_RESTORE = (int)~(INT_MAX),
};

static int
need_to_remember(struct redirtab *rp, int fd)
{
	int i;

	if (!rp) /* remembering was not requested */
		return 0;

	for (i = 0; i < rp->pair_count; i++) {
		if (rp->two_fd[i].orig == fd) {
			/* already remembered */
			return 0;
		}
	}
	return 1;
}

/* "hidden" fd is a fd used to read scripts, or a copy of such */
static int
is_hidden_fd(struct redirtab *rp, int fd)
{
	int i;
	struct parsefile *pf;

	if (fd == -1)
		return 0;
	/* Check open scripts' fds */
	pf = g_parsefile;
	while (pf) {
		/* We skip pf_fd == 0 case because of the following case:
		 * $ ash  # running ash interactively
		 * $ . ./script.sh
		 * and in script.sh: "exec 9>&0".
		 * Even though top-level pf_fd _is_ 0,
		 * it's still ok to use it: "read" builtin uses it,
		 * why should we cripple "exec" builtin?
		 */
		if (pf->pf_fd > 0 && fd == pf->pf_fd) {
			return 1;
		}
		pf = pf->prev;
	}

	if (!rp)
		return 0;
	/* Check saved fds of redirects */
	fd |= COPYFD_RESTORE;
	for (i = 0; i < rp->pair_count; i++) {
		if (rp->two_fd[i].copy == fd) {
			return 1;
		}
	}
	return 0;
}

/*
 * Process a list of redirection commands.  If the REDIR_PUSH flag is set,
 * old file descriptors are stashed away so that the redirection can be
 * undone by calling popredir.
 */
/* flags passed to redirect */
#define REDIR_PUSH    01        /* save previous values of file descriptors */
#define REDIR_SAVEFD2 03        /* set preverrout */
static void
redirect(union node *redir, int flags)
{
	struct redirtab *sv;
	int sv_pos;
	int i;
	int fd;
	int newfd;
	int copied_fd2 = -1;

	if (!redir) {
		return;
	}

	sv = NULL;
	sv_pos = 0;
	INT_OFF;
	if (flags & REDIR_PUSH) {
		union node *tmp = redir;
		do {
			sv_pos++;
#if ENABLE_ASH_BASH_COMPAT
			if (tmp->nfile.type == NTO2)
				sv_pos++;
#endif
# 5383 "shell/ash.c"
			tmp = tmp->nfile.next;
		} while (tmp);
		sv = ckmalloc(sizeof(*sv) + sv_pos * sizeof(sv->two_fd[0]));
		sv->next = redirlist;
		sv->pair_count = sv_pos;
		redirlist = sv;
		while (sv_pos > 0) {
			sv_pos--;
			sv->two_fd[sv_pos].orig = sv->two_fd[sv_pos].copy = EMPTY;
		}
	}

	do {
		int right_fd = -1;
		fd = redir->nfile.fd;
		if (redir->nfile.type == NTOFD || redir->nfile.type == NFROMFD) {
			right_fd = redir->ndup.dupfd;
			//bb_error_msg("doing %d > %d", fd, right_fd);
			/* redirect from/to same file descriptor? */
			if (right_fd == fd)
				continue;
			/* "echo >&10" and 10 is a fd opened to a sh script? */
			if (is_hidden_fd(sv, right_fd)) {
				errno = EBADF; /* as if it is closed */
				ash_msg_and_raise_error("%d: %m", right_fd);
			}
			newfd = -1;
		} else {
			newfd = openredirect(redir); /* always >= 0 */
			if (fd == newfd) {
				/* Descriptor wasn't open before redirect.
				 * Mark it for close in the future */
				if (need_to_remember(sv, fd)) {
					goto remember_to_close;
				}
				continue;
			}
		}
#if ENABLE_ASH_BASH_COMPAT
 redirect_more:
#endif
# 5424 "shell/ash.c"
		if (need_to_remember(sv, fd)) {
			/* Copy old descriptor */
			/* Careful to not accidentally "save"
			 * to the same fd as right side fd in N>&M */
			int minfd = right_fd < 10 ? 10 : right_fd + 1;
#if defined(F_DUPFD_CLOEXEC)
			i = fcntl(fd, F_DUPFD_CLOEXEC, minfd);
#else
# 5432 "shell/ash.c"
			i = fcntl(fd, F_DUPFD, minfd);
#endif
# 5434 "shell/ash.c"
			if (i == -1) {
				i = errno;
				if (i != EBADF) {
					/* Strange error (e.g. "too many files" EMFILE?) */
					if (newfd >= 0)
						close(newfd);
					errno = i;
					ash_msg_and_raise_error("%d: %m", fd);
					/* NOTREACHED */
				}
				/* EBADF: it is not open - good, remember to close it */
 remember_to_close:
				i = CLOSED;
			} else { /* fd is open, save its copy */
#if !defined(F_DUPFD_CLOEXEC)
				fcntl(i, F_SETFD, FD_CLOEXEC);
#endif
# 5451 "shell/ash.c"
				/* "exec fd>&-" should not close fds
				 * which point to script file(s).
				 * Force them to be restored afterwards */
				if (is_hidden_fd(sv, fd))
					i |= COPYFD_RESTORE;
			}
			if (fd == 2)
				copied_fd2 = i;
			sv->two_fd[sv_pos].orig = fd;
			sv->two_fd[sv_pos].copy = i;
			sv_pos++;
		}
		if (newfd < 0) {
			/* NTOFD/NFROMFD: copy redir->ndup.dupfd to fd */
			if (redir->ndup.dupfd < 0) { /* "fd>&-" */
				/* Don't want to trigger debugging */
				if (fd != -1)
					close(fd);
			} else {
				dup2_or_raise(redir->ndup.dupfd, fd);
			}
		} else if (fd != newfd) { /* move newfd to fd */
			dup2_or_raise(newfd, fd);
#if ENABLE_ASH_BASH_COMPAT
			if (!(redir->nfile.type == NTO2 && fd == 2))
#endif
# 5477 "shell/ash.c"
				close(newfd);
		}
#if ENABLE_ASH_BASH_COMPAT
		if (redir->nfile.type == NTO2 && fd == 1) {
			/* We already redirected it to fd 1, now copy it to 2 */
			newfd = 1;
			fd = 2;
			goto redirect_more;
		}
#endif
# 5487 "shell/ash.c"
	} while ((redir = redir->nfile.next) != NULL);

	INT_ON;
	if ((flags & REDIR_SAVEFD2) && copied_fd2 >= 0)
		preverrout_fd = copied_fd2;
}

/*
 * Undo the effects of the last redirection.
 */
static void
popredir(int drop, int restore)
{
	struct redirtab *rp;
	int i;

	if (redirlist == NULL)
		return;
	INT_OFF;
	rp = redirlist;
	for (i = 0; i < rp->pair_count; i++) {
		int fd = rp->two_fd[i].orig;
		int copy = rp->two_fd[i].copy;
		if (copy == CLOSED) {
			if (!drop)
				close(fd);
			continue;
		}
		if (copy != EMPTY) {
			if (!drop || (restore && (copy & COPYFD_RESTORE))) {
				copy &= ~COPYFD_RESTORE;
				/*close(fd);*/
				dup2_or_raise(copy, fd);
			}
			close(copy & ~COPYFD_RESTORE);
		}
	}
	redirlist = rp->next;
	free(rp);
	INT_ON;
}

/*
 * Undo all redirections.  Called on error or interrupt.
 */

static int
redirectsafe(union node *redir, int flags)
{
	int err;
	volatile int saveint;
	struct jmploc *volatile savehandler = exception_handler;
	struct jmploc jmploc;

	SAVE_INT(saveint);
	/* "echo 9>/dev/null; echo >&9; echo result: $?" - result should be 1, not 2! */
	err = setjmp(jmploc.loc); // huh?? was = setjmp(jmploc.loc) * 2;
	if (!err) {
		exception_handler = &jmploc;
		redirect(redir, flags);
	}
	exception_handler = savehandler;
	if (err && exception_type != EXERROR)
		longjmp(exception_handler->loc, 1);
	RESTORE_INT(saveint);
	return err;
}


/* ============ Routines to expand arguments to commands
 *
 * We have to deal with backquotes, shell variables, and file metacharacters.
 */

#if ENABLE_FEATURE_SH_MATH
static arith_t
ash_arith(const char *s)
{
	arith_state_t math_state;
	arith_t result;

	math_state.lookupvar = lookupvar;
	math_state.setvar    = setvar0;
	//math_state.endofname = endofname;

	INT_OFF;
	result = arith(&math_state, s);
	if (math_state.errmsg)
		ash_msg_and_raise_error(math_state.errmsg);
	INT_ON;

	return result;
}
#endif
# 5581 "shell/ash.c"

/*
 * expandarg flags
 */
#define EXP_FULL        0x1     /* perform word splitting & file globbing */
#define EXP_TILDE       0x2     /* do normal tilde expansion */
#define EXP_VARTILDE    0x4     /* expand tildes in an assignment */
#define EXP_REDIR       0x8     /* file glob for a redirection (1 match only) */
/* ^^^^^^^^^^^^^^ this is meant to support constructs such as "cmd >file*.txt"
 * POSIX says for this case:
 *  Pathname expansion shall not be performed on the word by a
 *  non-interactive shell; an interactive shell may perform it, but shall
 *  do so only when the expansion would result in one word.
 * Currently, our code complies to the above rule by never globbing
 * redirection filenames.
 * Bash performs globbing, unless it is non-interactive and in POSIX mode.
 * (this means that on a typical Linux distro, bash almost always
 * performs globbing, and thus diverges from what we do).
 */
#define EXP_CASE        0x10    /* keeps quotes around for CASE pattern */
#define EXP_QPAT        0x20    /* pattern in quoted parameter expansion */
#define EXP_VARTILDE2   0x40    /* expand tildes after colons only */
#define EXP_WORD        0x80    /* expand word in parameter expansion */
#define EXP_QUOTED      0x100   /* expand word in double quotes */
/*
 * rmescape() flags
 */
#define RMESCAPE_ALLOC  0x1     /* Allocate a new string */
#define RMESCAPE_GLOB   0x2     /* Add backslashes for glob */
#define RMESCAPE_GROW   0x8     /* Grow strings instead of stalloc */
#define RMESCAPE_HEAP   0x10    /* Malloc strings instead of stalloc */
#define RMESCAPE_SLASH  0x20    /* Stop globbing after slash */

/* Add CTLESC when necessary. */
#define QUOTES_ESC     (EXP_FULL | EXP_CASE | EXP_QPAT | EXP_REDIR)
/* Do not skip NUL characters. */
#define QUOTES_KEEPNUL EXP_TILDE

/*
 * Structure specifying which parts of the string should be searched
 * for IFS characters.
 */
struct ifsregion {
	struct ifsregion *next; /* next region in list */
	int begoff;             /* offset of start of region */
	int endoff;             /* offset of end of region */
	int nulonly;            /* search for nul bytes only */
};

struct arglist {
	struct strlist *list;
	struct strlist **lastp;
};

/* output of current string */
static char *expdest;
/* list of back quote expressions */
static struct nodelist *argbackq;
/* first struct in list of ifs regions */
static struct ifsregion ifsfirst;
/* last struct in list */
static struct ifsregion *ifslastp;
/* holds expanded arg list */
static struct arglist exparg;

/*
 * Our own itoa().
 */
#if !ENABLE_FEATURE_SH_MATH
/* cvtnum() is used even if math support is off (to prepare $? values and such) */
typedef long arith_t;
# define ARITH_FMT "%ld"
#endif
# 5654 "shell/ash.c"
static int
cvtnum(arith_t num)
{
	int len;

	expdest = makestrspace(sizeof(arith_t)*3 + 2, expdest);
	len = fmtstr(expdest, sizeof(arith_t)*3 + 2, ARITH_FMT, num);
	STADJUST(len, expdest);
	return len;
}

/*
 * Break the argument string into pieces based upon IFS and add the
 * strings to the argument list.  The regions of the string to be
 * searched for IFS characters have been stored by recordregion.
 */
static void
ifsbreakup(char *string, struct arglist *arglist)
{
	struct ifsregion *ifsp;
	struct strlist *sp;
	char *start;
	char *p;
	char *q;
	const char *ifs, *realifs;
	int ifsspc;
	int nulonly;

	start = string;
	if (ifslastp != NULL) {
		ifsspc = 0;
		nulonly = 0;
		realifs = ifsset() ? ifsval() : defifs;
		ifsp = &ifsfirst;
		do {
			p = string + ifsp->begoff;
			nulonly = ifsp->nulonly;
			ifs = nulonly ? nullstr : realifs;
			ifsspc = 0;
			while (p < string + ifsp->endoff) {
				q = p;
				if ((unsigned char)*p == CTLESC)
					p++;
				if (!strchr(ifs, *p)) {
					p++;
					continue;
				}
				if (!nulonly)
					ifsspc = (strchr(defifs, *p) != NULL);
				/* Ignore IFS whitespace at start */
				if (q == start && ifsspc) {
					p++;
					start = p;
					continue;
				}
				*q = '\0';
				sp = stzalloc(sizeof(*sp));
				sp->text = start;
				*arglist->lastp = sp;
				arglist->lastp = &sp->next;
				p++;
				if (!nulonly) {
					for (;;) {
						if (p >= string + ifsp->endoff) {
							break;
						}
						q = p;
						if ((unsigned char)*p == CTLESC)
							p++;
						if (strchr(ifs, *p) == NULL) {
							p = q;
							break;
						}
						if (strchr(defifs, *p) == NULL) {
							if (ifsspc) {
								p++;
								ifsspc = 0;
							} else {
								p = q;
								break;
							}
						} else
							p++;
					}
				}
				start = p;
			} /* while */
			ifsp = ifsp->next;
		} while (ifsp != NULL);
		if (nulonly)
			goto add;
	}

	if (!*start)
		return;

 add:
	sp = stzalloc(sizeof(*sp));
	sp->text = start;
	*arglist->lastp = sp;
	arglist->lastp = &sp->next;
}

static void
ifsfree(void)
{
	struct ifsregion *p = ifsfirst.next;

	if (!p)
		goto out;

	INT_OFF;
	do {
		struct ifsregion *ifsp;
		ifsp = p->next;
		free(p);
		p = ifsp;
	} while (p);
	ifsfirst.next = NULL;
	INT_ON;
 out:
	ifslastp = NULL;
}

static size_t
esclen(const char *start, const char *p)
{
	size_t esc = 0;

	while (p > start && (unsigned char)*--p == CTLESC) {
		esc++;
	}
	return esc;
}

/*
 * Remove any CTLESC characters from a string.
 */
static char *
rmescapes(char *str, int flag)
{
	static const char qchars[] ALIGN1 = {
		IF_ASH_BASH_COMPAT('/',) CTLESC, CTLQUOTEMARK, '\0' };

	char *p, *q, *r;
	unsigned inquotes;
	unsigned protect_against_glob;
	unsigned globbing;
	IF_ASH_BASH_COMPAT(unsigned slash = flag & RMESCAPE_SLASH;)

	p = strpbrk(str, qchars IF_ASH_BASH_COMPAT(+ !slash));
	if (!p)
		return str;

	q = p;
	r = str;
	if (flag & RMESCAPE_ALLOC) {
		size_t len = p - str;
		size_t fulllen = len + strlen(p) + 1;

		if (flag & RMESCAPE_GROW) {
			int strloc = str - (char *)stackblock();
			r = makestrspace(fulllen, expdest);
			/* p and str may be invalidated by makestrspace */
			str = (char *)stackblock() + strloc;
			p = str + len;
		} else if (flag & RMESCAPE_HEAP) {
			r = ckmalloc(fulllen);
		} else {
			r = stalloc(fulllen);
		}
		q = r;
		if (len > 0) {
			q = (char *)memcpy(q, str, len) + len;
		}
	}

	inquotes = 0;
	globbing = flag & RMESCAPE_GLOB;
	protect_against_glob = globbing;
	while (*p) {
		if ((unsigned char)*p == CTLQUOTEMARK) {
// Note: both inquotes and protect_against_glob only affect whether
			inquotes = ~inquotes;
			p++;
			protect_against_glob = globbing;
			continue;
		}
		if ((unsigned char)*p == CTLESC) {
			p++;
#if DEBUG
			if (*p == '\0')
				ash_msg_and_raise_error("CTLESC at EOL (shouldn't happen)");
#endif
# 5848 "shell/ash.c"
			if (protect_against_glob) {
				*q++ = '\\';
			}
		} else if (*p == '\\' && !inquotes) {
			/* naked back slash */
			protect_against_glob = 0;
			goto copy;
		}
#if ENABLE_ASH_BASH_COMPAT
		else if (*p == '/' && slash) {
			/* stop handling globbing and mark location of slash */
			globbing = slash = 0;
			*p = CTLESC;
		}
#endif
# 5863 "shell/ash.c"
		protect_against_glob = globbing;
 copy:
		*q++ = *p++;
	}
	*q = '\0';
	if (flag & RMESCAPE_GROW) {
		expdest = r;
		STADJUST(q - r + 1, expdest);
	}
	return r;
}
#define pmatch(a, b) !fnmatch((a), (b), 0)

/*
 * Prepare a pattern for a expmeta (internal glob(3)) call.
 *
 * Returns an stalloced string.
 */
static char *
preglob(const char *pattern, int flag)
{
	return rmescapes((char *)pattern, flag | RMESCAPE_GLOB);
}

/*
 * Put a string on the stack.
 */
static void
memtodest(const char *p, size_t len, int syntax, int quotes)
{
	char *q;

	if (!len)
		return;

	q = makestrspace((quotes & QUOTES_ESC) ? len * 2 : len, expdest);

	do {
		unsigned char c = *p++;
		if (c) {
			if (quotes & QUOTES_ESC) {
				int n = SIT(c, syntax);
				if (n == CCTL
				 || (((quotes & EXP_FULL) || syntax != BASESYNTAX)
				     && n == CBACK
				    )
				) {
					USTPUTC(CTLESC, q);
				}
			}
		} else if (!(quotes & QUOTES_KEEPNUL))
			continue;
		USTPUTC(c, q);
	} while (--len);

	expdest = q;
}

static size_t
strtodest(const char *p, int syntax, int quotes)
{
	size_t len = strlen(p);
	memtodest(p, len, syntax, quotes);
	return len;
}

/*
 * Record the fact that we have to scan this region of the
 * string for IFS characters.
 */
static void
recordregion(int start, int end, int nulonly)
{
	struct ifsregion *ifsp;

	if (ifslastp == NULL) {
		ifsp = &ifsfirst;
	} else {
		INT_OFF;
		ifsp = ckzalloc(sizeof(*ifsp));
		/*ifsp->next = NULL; - ckzalloc did it */
		ifslastp->next = ifsp;
		INT_ON;
	}
	ifslastp = ifsp;
	ifslastp->begoff = start;
	ifslastp->endoff = end;
	ifslastp->nulonly = nulonly;
}

static void
removerecordregions(int endoff)
{
	if (ifslastp == NULL)
		return;

	if (ifsfirst.endoff > endoff) {
		while (ifsfirst.next) {
			struct ifsregion *ifsp;
			INT_OFF;
			ifsp = ifsfirst.next->next;
			free(ifsfirst.next);
			ifsfirst.next = ifsp;
			INT_ON;
		}
		if (ifsfirst.begoff > endoff) {
			ifslastp = NULL;
		} else {
			ifslastp = &ifsfirst;
			ifsfirst.endoff = endoff;
		}
		return;
	}

	ifslastp = &ifsfirst;
	while (ifslastp->next && ifslastp->next->begoff < endoff)
		ifslastp = ifslastp->next;
	while (ifslastp->next) {
		struct ifsregion *ifsp;
		INT_OFF;
		ifsp = ifslastp->next->next;
		free(ifslastp->next);
		ifslastp->next = ifsp;
		INT_ON;
	}
	if (ifslastp->endoff > endoff)
		ifslastp->endoff = endoff;
}

static char *
exptilde(char *startp, char *p, int flags)
{
	unsigned char c;
	char *name;
	struct passwd *pw;
	const char *home;
	int quotes = flags & QUOTES_ESC;

	name = p + 1;

	while ((c = *++p) != '\0') {
		switch (c) {
		case CTLESC:
			return startp;
		case CTLQUOTEMARK:
			return startp;
		case ':':
			if (flags & EXP_VARTILDE)
				goto done;
			break;
		case '/':
		case CTLENDVAR:
			goto done;
		}
	}
 done:
	*p = '\0';
	if (*name == '\0') {
		home = lookupvar("HOME");
	} else {
		pw = getpwnam(name);
		if (pw == NULL)
			goto lose;
		home = pw->pw_dir;
	}
	if (!home || !*home)
		goto lose;
	*p = c;
	strtodest(home, SQSYNTAX, quotes);
	return p;
 lose:
	*p = c;
	return startp;
}

/*
 * Execute a command inside back quotes.  If it's a builtin command, we
 * want to save its output in a block obtained from malloc.  Otherwise
 * we fork off a subprocess and get the output of the command via a pipe.
 * Should be called with interrupts off.
 */
struct backcmd {                /* result of evalbackcmd */
	int fd;                 /* file descriptor to read from */
	int nleft;              /* number of chars in buffer */
	char *buf;              /* buffer */
	struct job *jp;         /* job structure for command */
};

/* These forward decls are needed to use "eval" code for backticks handling: */
#define EV_EXIT 01              /* exit after evaluating tree */
static int evaltree(union node *, int);

static void FAST_FUNC
evalbackcmd(union node *n, struct backcmd *result)
{
	int pip[2];
	struct job *jp;

	result->fd = -1;
	result->buf = NULL;
	result->nleft = 0;
	result->jp = NULL;
	if (n == NULL) {
		goto out;
	}

	if (pipe(pip) < 0)
		ash_msg_and_raise_error("pipe call failed");
	jp = makejob(/*n,*/ 1);
	if (forkshell(jp, n, FORK_NOJOB) == 0) {
		/* child */
		FORCE_INT_ON;
		close(pip[0]);
		if (pip[1] != 1) {
			/*close(1);*/
			dup2_or_raise(pip[1], 1);
			close(pip[1]);
		}
/* TODO: eflag clearing makes the following not abort:
 *  ash -c 'set -e; z=$(false;echo foo); echo $z'
 * which is what bash does (unless it is in POSIX mode).
 * dash deleted "eflag = 0" line in the commit
 *  Date: Mon, 28 Jun 2010 17:11:58 +1000
 *  [EVAL] Don't clear eflag in evalbackcmd
 * For now, preserve bash-like behavior, it seems to be somewhat more useful:
 */
		eflag = 0;
		ifsfree();
		evaltree(n, EV_EXIT); /* actually evaltreenr... */
		/* NOTREACHED */
	}
	/* parent */
	close(pip[1]);
	result->fd = pip[0];
	result->jp = jp;

 out:
	TRACE(("evalbackcmd done: fd=%d buf=0x%x nleft=%d jp=0x%x\n",
		result->fd, result->buf, result->nleft, result->jp));
}

/*
 * Expand stuff in backwards quotes.
 */
static void
expbackq(union node *cmd, int flag)
{
	struct backcmd in;
	int i;
	char buf[128];
	char *p;
	char *dest;
	int startloc;
	int syntax = flag & EXP_QUOTED ? DQSYNTAX : BASESYNTAX;
	struct stackmark smark;

	INT_OFF;
	startloc = expdest - (char *)stackblock();
	pushstackmark(&smark, startloc);
	evalbackcmd(cmd, &in);
	popstackmark(&smark);

	p = in.buf;
	i = in.nleft;
	if (i == 0)
		goto read;
	for (;;) {
		memtodest(p, i, syntax, flag & QUOTES_ESC);
 read:
		if (in.fd < 0)
			break;
		i = nonblock_immune_read(in.fd, buf, sizeof(buf));
		TRACE(("expbackq: read returns %d\n", i));
		if (i <= 0)
			break;
		p = buf;
	}

	free(in.buf);
	if (in.fd >= 0) {
		close(in.fd);
		back_exitstatus = waitforjob(in.jp);
	}
	INT_ON;

	/* Eat all trailing newlines */
	dest = expdest;
	for (; dest > (char *)stackblock() && dest[-1] == '\n';)
		STUNPUTC(dest);
	expdest = dest;

	if (!(flag & EXP_QUOTED))
		recordregion(startloc, dest - (char *)stackblock(), 0);
	TRACE(("evalbackq: size:%d:'%.*s'\n",
		(int)((dest - (char *)stackblock()) - startloc),
		(int)((dest - (char *)stackblock()) - startloc),
		stackblock() + startloc));
}

#if ENABLE_FEATURE_SH_MATH
/*
 * Expand arithmetic expression.  Backup to start of expression,
 * evaluate, place result in (backed up) result, adjust string position.
 */
static void
expari(int flag)
{
	char *p, *start;
	int begoff;
	int len;

	/* ifsfree(); */

	/*
	 * This routine is slightly over-complicated for
	 * efficiency.  Next we scan backwards looking for the
	 * start of arithmetic.
	 */
	start = stackblock();
	p = expdest - 1;
	*p = '\0';
	p--;
	while (1) {
		int esc;

		while ((unsigned char)*p != CTLARI) {
			p--;
#if DEBUG
			if (p < start) {
				ash_msg_and_raise_error("missing CTLARI (shouldn't happen)");
			}
#endif
# 6195 "shell/ash.c"
		}

		esc = esclen(start, p);
		if (!(esc % 2)) {
			break;
		}

		p -= esc + 1;
	}

	begoff = p - start;

	removerecordregions(begoff);

	expdest = p;

	if (flag & QUOTES_ESC)
		rmescapes(p + 1, 0);

	len = cvtnum(ash_arith(p + 1));

	if (!(flag & EXP_QUOTED))
		recordregion(begoff, begoff + len, 0);
}
#endif
# 6220 "shell/ash.c"

/* argstr needs it */
static char *evalvar(char *p, int flags, struct strlist *var_str_list);

/*
 * Perform variable and command substitution.  If EXP_FULL is set, output CTLESC
 * characters to allow for further processing.  Otherwise treat
 * $@ like $* since no splitting will be performed.
 *
 * var_str_list (can be NULL) is a list of "VAR=val" strings which take precedence
 * over shell varables. Needed for "A=a B=$A; echo $B" case - we use it
 * for correct expansion of "B=$A" word.
 */
static void
argstr(char *p, int flags, struct strlist *var_str_list)
{
	static const char spclchars[] ALIGN1 = {
		'=',
		':',
		CTLQUOTEMARK,
		CTLENDVAR,
		CTLESC,
		CTLVAR,
		CTLBACKQ,
#if ENABLE_FEATURE_SH_MATH
		CTLENDARI,
#endif
# 6247 "shell/ash.c"
		'\0'
	};
	const char *reject = spclchars;
	int breakall = (flags & (EXP_WORD | EXP_QUOTED)) == EXP_WORD;
	int inquotes;
	size_t length;
	int startloc;

	if (!(flags & EXP_VARTILDE)) {
		reject += 2;
	} else if (flags & EXP_VARTILDE2) {
		reject++;
	}
	inquotes = 0;
	length = 0;
	if (flags & EXP_TILDE) {
		char *q;

		flags &= ~EXP_TILDE;
 tilde:
		q = p;
		if (*q == '~')
			p = exptilde(p, q, flags);
	}
 start:
	startloc = expdest - (char *)stackblock();
	for (;;) {
		unsigned char c;

		length += strcspn(p + length, reject);
		c = p[length];
		if (c) {
			if (!(c & 0x80)
			IF_FEATURE_SH_MATH(|| c == CTLENDARI)
			) {
				/* c == '=' || c == ':' || c == CTLENDARI */
				length++;
			}
		}
		if (length > 0) {
			int newloc;
			expdest = stack_nputstr(p, length, expdest);
			newloc = expdest - (char *)stackblock();
			if (breakall && !inquotes && newloc > startloc) {
				recordregion(startloc, newloc, 0);
			}
			startloc = newloc;
		}
		p += length + 1;
		length = 0;

		switch (c) {
		case '\0':
			goto breakloop;
		case '=':
			if (flags & EXP_VARTILDE2) {
				p--;
				continue;
			}
			flags |= EXP_VARTILDE2;
			reject++;
			/* fall through */
		case ':':
			/*
			 * sort of a hack - expand tildes in variable
			 * assignments (after the first '=' and after ':'s).
			 */
			if (*--p == '~') {
				goto tilde;
			}
			continue;
		}

		switch (c) {
		case CTLENDVAR: /* ??? */
			goto breakloop;
		case CTLQUOTEMARK:
			inquotes ^= EXP_QUOTED;
			/* "$@" syntax adherence hack */
			if (inquotes && !memcmp(p, dolatstr + 1, DOLATSTRLEN - 1)) {
				p = evalvar(p + 1, flags | inquotes, /* var_str_list: */ NULL) + 1;
				goto start;
			}
 addquote:
			if (flags & QUOTES_ESC) {
				p--;
				length++;
				startloc++;
			}
			break;
		case CTLESC:
			startloc++;
			length++;

			/*
			 * Quoted parameter expansion pattern: remove quote
			 * unless inside inner quotes or we have a literal
			 * backslash.
			 */
			if (((flags | inquotes) & (EXP_QPAT | EXP_QUOTED)) ==
			    EXP_QPAT && *p != '\\')
				break;

			goto addquote;
		case CTLVAR:
			TRACE(("argstr: evalvar('%s')\n", p));
			p = evalvar(p, flags | inquotes, var_str_list);
			TRACE(("argstr: evalvar:'%s'\n", (char *)stackblock()));
			goto start;
		case CTLBACKQ:
			expbackq(argbackq->n, flags | inquotes);
			argbackq = argbackq->next;
			goto start;
#if ENABLE_FEATURE_SH_MATH
		case CTLENDARI:
			p--;
			expari(flags | inquotes);
			goto start;
#endif
# 6366 "shell/ash.c"
		}
	}
 breakloop: ;
}

static char *
scanleft(char *startp, char *rmesc, char *rmescend UNUSED_PARAM,
		char *pattern, int quotes, int zero)
{
	char *loc, *loc2;
	char c;

	loc = startp;
	loc2 = rmesc;
	do {
		int match;
		const char *s = loc2;

		c = *loc2;
		if (zero) {
			*loc2 = '\0';
			s = rmesc;
		}
		match = pmatch(pattern, s);

		*loc2 = c;
		if (match)
			return loc;
		if (quotes && (unsigned char)*loc == CTLESC)
			loc++;
		loc++;
		loc2++;
	} while (c);
	return NULL;
}

static char *
scanright(char *startp, char *rmesc, char *rmescend,
		char *pattern, int quotes, int match_at_start)
{
#if !ENABLE_ASH_OPTIMIZE_FOR_SIZE
	int try2optimize = match_at_start;
#endif
# 6409 "shell/ash.c"
	int esc = 0;
	char *loc;
	char *loc2;

	/* If we called by "${v/pattern/repl}" or "${v//pattern/repl}":
	 * startp="escaped_value_of_v" rmesc="raw_value_of_v"
	 * rmescend=""(ptr to NUL in rmesc) pattern="pattern" quotes=match_at_start=1
	 * Logic:
	 * loc starts at NUL at the end of startp, loc2 starts at the end of rmesc,
	 * and on each iteration they go back two/one char until they reach the beginning.
	 * We try to find a match in "raw_value_of_v", "raw_value_of_", "raw_value_of" etc.
	 */
	/* TODO: document in what other circumstances we are called. */

	for (loc = pattern - 1, loc2 = rmescend; loc >= startp; loc2--) {
		int match;
		char c = *loc2;
		const char *s = loc2;
		if (match_at_start) {
			*loc2 = '\0';
			s = rmesc;
		}
		match = pmatch(pattern, s);
		//bb_error_msg("pmatch(pattern:'%s',s:'%s'):%d", pattern, s, match);
		*loc2 = c;
		if (match)
			return loc;
#if !ENABLE_ASH_OPTIMIZE_FOR_SIZE
		if (try2optimize) {
			/* Maybe we can optimize this:
			 * if pattern ends with unescaped *, we can avoid checking
			 * shorter strings: if "foo*" doesnt match "raw_value_of_v",
			 * it wont match truncated "raw_value_of_" strings too.
			 */
			unsigned plen = strlen(pattern);
			/* Does it end with "*"? */
			if (plen != 0 && pattern[--plen] == '*') {
				/* "xxxx*" is not escaped */
				/* "xxx\*" is escaped */
				/* "xx\\*" is not escaped */
				/* "x\\\*" is escaped */
				int slashes = 0;
				while (plen != 0 && pattern[--plen] == '\\')
					slashes++;
				if (!(slashes & 1))
					break; /* ends with unescaped "*" */
			}
			try2optimize = 0;
		}
#endif
# 6459 "shell/ash.c"
		loc--;
		if (quotes) {
			if (--esc < 0) {
				esc = esclen(startp, loc);
			}
			if (esc % 2) {
				esc--;
				loc--;
			}
		}
	}
	return NULL;
}

static void varunset(const char *, const char *, const char *, int) NORETURN;
static void
varunset(const char *end, const char *var, const char *umsg, int varflags)
{
	const char *msg;
	const char *tail;

	tail = nullstr;
	msg = "parameter not set";
	if (umsg) {
		if ((unsigned char)*end == CTLENDVAR) {
			if (varflags & VSNUL)
				tail = " or null";
		} else {
			msg = umsg;
		}
	}
	ash_msg_and_raise_error("%.*s: %s%s", (int)(end - var - 1), var, msg, tail);
}

static const char *
subevalvar(char *p, char *varname, int strloc, int subtype,
		int startloc, int varflags, int flag, struct strlist *var_str_list)
{
	struct nodelist *saveargbackq = argbackq;
	int quotes = flag & QUOTES_ESC;
	char *startp;
	char *loc;
	char *rmesc, *rmescend;
	char *str;
	IF_ASH_BASH_COMPAT(char *repl = NULL;)
	IF_ASH_BASH_COMPAT(int pos, len, orig_len;)
	int amount, resetloc;
	IF_ASH_BASH_COMPAT(int workloc;)
	int zero;
	char *(*scan)(char*, char*, char*, char*, int, int);

	//bb_error_msg("subevalvar(p:'%s',varname:'%s',strloc:%d,subtype:%d,startloc:%d,varflags:%x,quotes:%d)",
	//		p, varname, strloc, subtype, startloc, varflags, quotes);

	argstr(p, EXP_TILDE | (subtype != VSASSIGN && subtype != VSQUESTION ?
			(flag & (EXP_QUOTED | EXP_QPAT) ? EXP_QPAT : EXP_CASE) : 0),
			var_str_list);
	STPUTC('\0', expdest);
	argbackq = saveargbackq;
	startp = (char *)stackblock() + startloc;

	switch (subtype) {
	case VSASSIGN:
		setvar0(varname, startp);
		amount = startp - expdest;
		STADJUST(amount, expdest);
		return startp;

	case VSQUESTION:
		varunset(p, varname, startp, varflags);
		/* NOTREACHED */

#if ENABLE_ASH_BASH_COMPAT
	case VSSUBSTR:
//TODO: support more general format ${v:EXPR:EXPR},
// where EXPR follows $(()) rules
		loc = str = stackblock() + strloc;
		/* Read POS in ${var:POS:LEN} */
		pos = atoi(loc); /* number(loc) errors out on "1:4" */
		len = str - startp - 1;

		/* *loc != '\0', guaranteed by parser */
		if (quotes) {
			char *ptr;

			/* Adjust the length by the number of escapes */
			for (ptr = startp; ptr < (str - 1); ptr++) {
				if ((unsigned char)*ptr == CTLESC) {
					len--;
					ptr++;
				}
			}
		}
		orig_len = len;

		if (*loc++ == ':') {
			/* ${var::LEN} */
			len = number(loc);
		} else {
			/* Skip POS in ${var:POS:LEN} */
			len = orig_len;
			while (*loc && *loc != ':') {
				/* TODO?
				 * bash complains on: var=qwe; echo ${var:1a:123}
				if (!isdigit(*loc))
					ash_msg_and_raise_error(msg_illnum, str);
				 */
				loc++;
			}
			if (*loc++ == ':') {
				len = number(loc);
			}
		}
		if (pos < 0) {
			/* ${VAR:$((-n)):l} starts n chars from the end */
			pos = orig_len + pos;
		}
		if ((unsigned)pos >= orig_len) {
			/* apart from obvious ${VAR:999999:l},
			 * covers ${VAR:$((-9999999)):l} - result is ""
			 * (bash-compat)
			 */
			pos = 0;
			len = 0;
		}
		if (len > (orig_len - pos))
			len = orig_len - pos;

		for (str = startp; pos; str++, pos--) {
			if (quotes && (unsigned char)*str == CTLESC)
				str++;
		}
		for (loc = startp; len; len--) {
			if (quotes && (unsigned char)*str == CTLESC)
				*loc++ = *str++;
			*loc++ = *str++;
		}
		*loc = '\0';
		amount = loc - expdest;
		STADJUST(amount, expdest);
		return loc;
#endif
# 6601 "shell/ash.c"
	}

	resetloc = expdest - (char *)stackblock();

	/* We'll comeback here if we grow the stack while handling
	 * a VSREPLACE or VSREPLACEALL, since our pointers into the
	 * stack will need rebasing, and we'll need to remove our work
	 * areas each time
	 */
 IF_ASH_BASH_COMPAT(restart:)

	amount = expdest - ((char *)stackblock() + resetloc);
	STADJUST(-amount, expdest);
	startp = (char *)stackblock() + startloc;

	rmesc = startp;
	rmescend = (char *)stackblock() + strloc;
	if (quotes) {
		rmesc = rmescapes(startp, RMESCAPE_ALLOC | RMESCAPE_GROW);
		if (rmesc != startp) {
			rmescend = expdest;
			startp = (char *)stackblock() + startloc;
		}
	}
	rmescend--;
	str = (char *)stackblock() + strloc;
	/*
	 * Example: v='a\bc'; echo ${v/\\b/_\\_\z_}
	 * The result is a_\_z_c (not a\_\_z_c)!
	 *
	 * The search pattern and replace string treat backslashes differently!
	 * RMESCAPE_SLASH causes preglob to work differently on the pattern
	 * and string.  It's only used on the first call.
	 */
	preglob(str, IF_ASH_BASH_COMPAT(
		(subtype == VSREPLACE || subtype == VSREPLACEALL) && !repl ?
			RMESCAPE_SLASH :) 0);

#if ENABLE_ASH_BASH_COMPAT
	workloc = expdest - (char *)stackblock();
	if (subtype == VSREPLACE || subtype == VSREPLACEALL) {
		char *idx, *end;

		if (!repl) {
			repl = strchr(str, CTLESC);
			if (repl)
				*repl++ = '\0';
			else
				repl = nullstr;
		}
		//bb_error_msg("str:'%s' repl:'%s'", str, repl);

		/* If there's no pattern to match, return the expansion unmolested */
		if (str[0] == '\0')
			return NULL;

		len = 0;
		idx = startp;
		end = str - 1;
		while (idx < end) {
 try_to_match:
			loc = scanright(idx, rmesc, rmescend, str, quotes, 1);
			//bb_error_msg("scanright('%s'):'%s'", str, loc);
			if (!loc) {
				/* No match, advance */
				char *restart_detect = stackblock();
 skip_matching:
				STPUTC(*idx, expdest);
				if (quotes && (unsigned char)*idx == CTLESC) {
					idx++;
					len++;
					STPUTC(*idx, expdest);
				}
				if (stackblock() != restart_detect)
					goto restart;
				idx++;
				len++;
				rmesc++;
				/* continue; - prone to quadratic behavior, smarter code: */
				if (idx >= end)
					break;
				if (str[0] == '*') {
					/* Pattern is "*foo". If "*foo" does not match "long_string",
					 * it would never match "ong_string" etc, no point in trying.
					 */
					goto skip_matching;
				}
				goto try_to_match;
			}

			if (subtype == VSREPLACEALL) {
				while (idx < loc) {
					if (quotes && (unsigned char)*idx == CTLESC)
						idx++;
					idx++;
					rmesc++;
				}
			} else {
				idx = loc;
			}

			//bb_error_msg("repl:'%s'", repl);
			for (loc = (char*)repl; *loc; loc++) {
				char *restart_detect = stackblock();
				if (quotes && *loc == '\\') {
					STPUTC(CTLESC, expdest);
					len++;
				}
				STPUTC(*loc, expdest);
				if (stackblock() != restart_detect)
					goto restart;
				len++;
			}

			if (subtype == VSREPLACE) {
				//bb_error_msg("tail:'%s', quotes:%x", idx, quotes);
				while (*idx) {
					char *restart_detect = stackblock();
					STPUTC(*idx, expdest);
					if (stackblock() != restart_detect)
						goto restart;
					len++;
					idx++;
				}
				break;
			}
		}

		/* We've put the replaced text into a buffer at workloc, now
		 * move it to the right place and adjust the stack.
		 */
		STPUTC('\0', expdest);
		startp = (char *)stackblock() + startloc;
		memmove(startp, (char *)stackblock() + workloc, len + 1);
		//bb_error_msg("startp:'%s'", startp);
		amount = expdest - (startp + len);
		STADJUST(-amount, expdest);
		return startp;
	}
#endif /* ENABLE_ASH_BASH_COMPAT */
# 6741 "shell/ash.c"

	subtype -= VSTRIMRIGHT;
#if DEBUG
	if (subtype < 0 || subtype > 7)
		abort();
#endif
# 6747 "shell/ash.c"
	/* zero = (subtype == VSTRIMLEFT || subtype == VSTRIMLEFTMAX) */
	zero = subtype >> 1;
	/* VSTRIMLEFT/VSTRIMRIGHTMAX -> scanleft */
	scan = (subtype & 1) ^ zero ? scanleft : scanright;

	loc = scan(startp, rmesc, rmescend, str, quotes, zero);
	if (loc) {
		if (zero) {
			memmove(startp, loc, str - loc);
			loc = startp + (str - loc) - 1;
		}
		*loc = '\0';
		amount = loc - expdest;
		STADJUST(amount, expdest);
	}
	return loc;
}

/*
 * Add the value of a specialized variable to the stack string.
 * name parameter (examples):
 * ash -c 'echo $1'      name:'1='
 * ash -c 'echo $qwe'    name:'qwe='
 * ash -c 'echo $$'      name:'$='
 * ash -c 'echo ${$}'    name:'$='
 * ash -c 'echo ${$##q}' name:'$=q'
 * ash -c 'echo ${#$}'   name:'$='
 * note: examples with bad shell syntax:
 * ash -c 'echo ${#$1}'  name:'$=1'
 * ash -c 'echo ${#1#}'  name:'1=#'
 */
static NOINLINE ssize_t
varvalue(char *name, int varflags, int flags, struct strlist *var_str_list, int *quotedp)
{
	const char *p;
	int num;
	int i;
	ssize_t len = 0;
	int sep;
	int quoted = *quotedp;
	int subtype = varflags & VSTYPE;
	int discard = subtype == VSPLUS || subtype == VSLENGTH;
	int quotes = (discard ? 0 : (flags & QUOTES_ESC)) | QUOTES_KEEPNUL;
	int syntax;

	sep = (flags & EXP_FULL) << CHAR_BIT;
	syntax = quoted ? DQSYNTAX : BASESYNTAX;

	switch (*name) {
	case '$':
		num = rootpid;
		goto numvar;
	case '?':
		num = exitstatus;
		goto numvar;
	case '#':
		num = shellparam.nparam;
		goto numvar;
	case '!':
		num = backgndpid;
		if (num == 0)
			return -1;
 numvar:
		len = cvtnum(num);
		goto check_1char_name;
	case '-':
		expdest = makestrspace(NOPTS, expdest);
		for (i = NOPTS - 1; i >= 0; i--) {
			if (optlist[i]) {
				USTPUTC(optletters(i), expdest);
				len++;
			}
		}
 check_1char_name:
#if 0
		/* handles cases similar to ${#$1} */
		if (name[2] != '\0')
			raise_error_syntax("bad substitution");
#endif
# 6826 "shell/ash.c"
		break;
	case '@':
		if (quoted && sep)
			goto param;
		/* fall through */
	case '*': {
		char **ap;
		char sepc;

		if (quoted)
			sep = 0;
		sep |= ifsset() ? ifsval()[0] : ' ';
 param:
		sepc = sep;
		*quotedp = !sepc;
		ap = shellparam.p;
		if (!ap)
			return -1;
		while ((p = *ap++) != NULL) {
			len += strtodest(p, syntax, quotes);

			if (*ap && sep) {
				len++;
				memtodest(&sepc, 1, syntax, quotes);
			}
		}
		break;
	} /* case '*' */
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
		num = atoi(name); /* number(name) fails on ${N#str} etc */
		if (num < 0 || num > shellparam.nparam)
			return -1;
		p = num ? shellparam.p[num - 1] : arg0;
		goto value;
	default:
		/* NB: name has form "VAR=..." */

		/* "A=a B=$A" case: var_str_list is a list of "A=a" strings
		 * which should be considered before we check variables. */
		if (var_str_list) {
			unsigned name_len = (strchrnul(name, '=') - name) + 1;
			p = NULL;
			do {
				char *str, *eq;
				str = var_str_list->text;
				eq = strchr(str, '=');
				if (!eq) /* stop at first non-assignment */
					break;
				eq++;
				if (name_len == (unsigned)(eq - str)
				 && strncmp(str, name, name_len) == 0
				) {
					p = eq;
					/* goto value; - WRONG! */
					/* think "A=1 A=2 B=$A" */
				}
				var_str_list = var_str_list->next;
			} while (var_str_list);
			if (p)
				goto value;
		}
		p = lookupvar(name);
 value:
		if (!p)
			return -1;

		len = strtodest(p, syntax, quotes);
#if ENABLE_UNICODE_SUPPORT
		if (subtype == VSLENGTH && len > 0) {
			reinit_unicode_for_ash();
			if (unicode_status == UNICODE_ON) {
				STADJUST(-len, expdest);
				discard = 0;
				len = unicode_strlen(p);
			}
		}
#endif
# 6912 "shell/ash.c"
		break;
	}

	if (discard)
		STADJUST(-len, expdest);
	return len;
}

/*
 * Expand a variable, and return a pointer to the next character in the
 * input string.
 */
static char *
evalvar(char *p, int flag, struct strlist *var_str_list)
{
	char varflags;
	char subtype;
	int quoted;
	char easy;
	char *var;
	int patloc;
	int startloc;
	ssize_t varlen;

	varflags = (unsigned char) *p++;
	subtype = varflags & VSTYPE;

	if (!subtype)
		raise_error_syntax("bad substitution");

	quoted = flag & EXP_QUOTED;
	var = p;
	easy = (!quoted || (*var == '@' && shellparam.nparam));
	startloc = expdest - (char *)stackblock();
	p = strchr(p, '=') + 1; //TODO: use var_end(p)?

 again:
	varlen = varvalue(var, varflags, flag, var_str_list, &quoted);
	if (varflags & VSNUL)
		varlen--;

	if (subtype == VSPLUS) {
		varlen = -1 - varlen;
		goto vsplus;
	}

	if (subtype == VSMINUS) {
 vsplus:
		if (varlen < 0) {
			argstr(
				p,
				flag | EXP_TILDE | EXP_WORD,
				var_str_list
			);
			goto end;
		}
		goto record;
	}

	if (subtype == VSASSIGN || subtype == VSQUESTION) {
		if (varlen >= 0)
			goto record;

		subevalvar(p, var, 0, subtype, startloc, varflags,
			   flag & ~QUOTES_ESC, var_str_list);
		varflags &= ~VSNUL;
		/*
		 * Remove any recorded regions beyond
		 * start of variable
		 */
		removerecordregions(startloc);
		goto again;
	}

	if (varlen < 0 && uflag)
		varunset(p, var, 0, 0);

	if (subtype == VSLENGTH) {
		cvtnum(varlen > 0 ? varlen : 0);
		goto record;
	}

	if (subtype == VSNORMAL) {
 record:
		if (!easy)
			goto end;
		recordregion(startloc, expdest - (char *)stackblock(), quoted);
		goto end;
	}

#if DEBUG
	switch (subtype) {
	case VSTRIMLEFT:
	case VSTRIMLEFTMAX:
	case VSTRIMRIGHT:
	case VSTRIMRIGHTMAX:
#if ENABLE_ASH_BASH_COMPAT
	case VSSUBSTR:
	case VSREPLACE:
	case VSREPLACEALL:
#endif
# 7013 "shell/ash.c"
		break;
	default:
		abort();
	}
#endif
# 7018 "shell/ash.c"

	if (varlen >= 0) {
		/*
		 * Terminate the string and start recording the pattern
		 * right after it
		 */
		STPUTC('\0', expdest);
		patloc = expdest - (char *)stackblock();
		if (NULL == subevalvar(p, /* varname: */ NULL, patloc, subtype,
				startloc, varflags, flag, var_str_list)) {
			int amount = expdest - (
				(char *)stackblock() + patloc - 1
			);
			STADJUST(-amount, expdest);
		}
		/* Remove any recorded regions beyond start of variable */
		removerecordregions(startloc);
		goto record;
	}

 end:
	if (subtype != VSNORMAL) {      /* skip to end of alternative */
		int nesting = 1;
		for (;;) {
			unsigned char c = *p++;
			if (c == CTLESC)
				p++;
			else if (c == CTLBACKQ) {
				if (varlen >= 0)
					argbackq = argbackq->next;
			} else if (c == CTLVAR) {
				if ((*p++ & VSTYPE) != VSNORMAL)
					nesting++;
			} else if (c == CTLENDVAR) {
				if (--nesting == 0)
					break;
			}
		}
	}
	return p;
}

/*
 * Add a file name to the list.
 */
static void
addfname(const char *name)
{
	struct strlist *sp;

	sp = stzalloc(sizeof(*sp));
	sp->text = sstrdup(name);
	*exparg.lastp = sp;
	exparg.lastp = &sp->next;
}

/* If we want to use glob() from libc... */
#if !ENABLE_ASH_INTERNAL_GLOB

/* Add the result of glob() to the list */
static void
addglob(const glob_t *pglob)
{
	char **p = pglob->gl_pathv;

	do {
		addfname(*p);
	} while (*++p);
}
static void
expandmeta(struct strlist *str /*, int flag*/)
{
	/* TODO - EXP_REDIR */

	while (str) {
		char *p;
		glob_t pglob;
		int i;

		if (fflag)
			goto nometa;

		/* Avoid glob() (and thus, stat() et al) for words like "echo" */
		p = str->text;
		while (*p) {
			if (*p == '*')
				goto need_glob;
			if (*p == '?')
				goto need_glob;
			if (*p == '[')
				goto need_glob;
			p++;
		}
		goto nometa;

 need_glob:
		INT_OFF;
		p = preglob(str->text, RMESCAPE_ALLOC | RMESCAPE_HEAP);
// GLOB_NOMAGIC (GNU): if no *?[ chars in pattern, return it even if no match
// GLOB_NOCHECK: if no match, return unchanged pattern (sans \* escapes?)
//
// glibc 2.24.90 glob(GLOB_NOMAGIC) does not remove backslashes used for escaping:
// if you pass it "file\?", it returns "file\?", not "file?", if no match.
// Which means you need to unescape the string, right? Not so fast:
// if there _is_ a file named "file\?" (with backslash), it is returned
// as "file\?" too (whichever pattern you used to find it, say, "file*").
// You DONT KNOW by looking at the result whether you need to unescape it.
//
// Worse, globbing of "file\?" in a directory with two files, "file?" and "file\?",
// returns "file\?" - which is WRONG: "file\?" pattern matches "file?" file.
// Without GLOB_NOMAGIC, this works correctly ("file?" is returned as a match).
// With GLOB_NOMAGIC | GLOB_NOCHECK, this also works correctly.
//		i = glob(p, GLOB_NOMAGIC | GLOB_NOCHECK, NULL, &pglob);
//		i = glob(p, GLOB_NOMAGIC, NULL, &pglob);
		i = glob(p, 0, NULL, &pglob);
		//bb_error_msg("glob('%s'):%d '%s'...", p, i, pglob.gl_pathv ? pglob.gl_pathv[0] : "-");
		if (p != str->text)
			free(p);
		switch (i) {
		case 0:
#if 0 // glibc 2.24.90 bug? Patterns like "*/file", when match, don't set GLOB_MAGCHAR
			/* GLOB_MAGCHAR is set if *?[ chars were seen (GNU) */
			if (!(pglob.gl_flags & GLOB_MAGCHAR))
				goto nometa2;
#endif
# 7143 "shell/ash.c"
			addglob(&pglob);
			globfree(&pglob);
			INT_ON;
			break;
		case GLOB_NOMATCH:
 //nometa2:
			globfree(&pglob);
			INT_ON;
 nometa:
			*exparg.lastp = str;
			rmescapes(str->text, 0);
			exparg.lastp = &str->next;
			break;
		default:	/* GLOB_NOSPACE */
			globfree(&pglob);
			INT_ON;
			ash_msg_and_raise_error(bb_msg_memory_exhausted);
		}
		str = str->next;
	}
}

#else
# 7166 "shell/ash.c"
/* ENABLE_ASH_INTERNAL_GLOB: Homegrown globbing code. (dash also has both, uses homegrown one.) */

/*
 * Do metacharacter (i.e. *, ?, [...]) expansion.
 */
static void
expmeta(char *expdir, char *enddir, char *name)
{
	char *p;
	const char *cp;
	char *start;
	char *endname;
	int metaflag;
	struct stat statb;
	DIR *dirp;
	struct dirent *dp;
	int atend;
	int matchdot;
	int esc;

	metaflag = 0;
	start = name;
	for (p = name; esc = 0, *p; p += esc + 1) {
		if (*p == '*' || *p == '?')
			metaflag = 1;
		else if (*p == '[') {
			char *q = p + 1;
			if (*q == '!')
				q++;
			for (;;) {
				if (*q == '\\')
					q++;
				if (*q == '/' || *q == '\0')
					break;
				if (*++q == ']') {
					metaflag = 1;
					break;
				}
			}
		} else {
			if (*p == '\\')
				esc++;
			if (p[esc] == '/') {
				if (metaflag)
					break;
				start = p + esc + 1;
			}
		}
	}
	if (metaflag == 0) {    /* we've reached the end of the file name */
		if (enddir != expdir)
			metaflag++;
		p = name;
		do {
			if (*p == '\\')
				p++;
			*enddir++ = *p;
		} while (*p++);
		if (metaflag == 0 || lstat(expdir, &statb) >= 0)
			addfname(expdir);
		return;
	}
	endname = p;
	if (name < start) {
		p = name;
		do {
			if (*p == '\\')
				p++;
			*enddir++ = *p++;
		} while (p < start);
	}
	if (enddir == expdir) {
		cp = ".";
	} else if (enddir == expdir + 1 && *expdir == '/') {
		cp = "/";
	} else {
		cp = expdir;
		enddir[-1] = '\0';
	}
	dirp = opendir(cp);
	if (dirp == NULL)
		return;
	if (enddir != expdir)
		enddir[-1] = '/';
	if (*endname == 0) {
		atend = 1;
	} else {
		atend = 0;
		*endname = '\0';
		endname += esc + 1;
	}
	matchdot = 0;
	p = start;
	if (*p == '\\')
		p++;
	if (*p == '.')
		matchdot++;
	while (!pending_int && (dp = readdir(dirp)) != NULL) {
		if (dp->d_name[0] == '.' && !matchdot)
			continue;
		if (pmatch(start, dp->d_name)) {
			if (atend) {
				strcpy(enddir, dp->d_name);
				addfname(expdir);
			} else {
				for (p = enddir, cp = dp->d_name; (*p++ = *cp++) != '\0';)
					continue;
				p[-1] = '/';
				expmeta(expdir, p, endname);
			}
		}
	}
	closedir(dirp);
	if (!atend)
		endname[-esc - 1] = esc ? '\\' : '/';
}

static struct strlist *
msort(struct strlist *list, int len)
{
	struct strlist *p, *q = NULL;
	struct strlist **lpp;
	int half;
	int n;

	if (len <= 1)
		return list;
	half = len >> 1;
	p = list;
	for (n = half; --n >= 0;) {
		q = p;
		p = p->next;
	}
	q->next = NULL;                 /* terminate first half of list */
	q = msort(list, half);          /* sort first half of list */
	p = msort(p, len - half);               /* sort second half */
	lpp = &list;
	for (;;) {
#if ENABLE_LOCALE_SUPPORT
		if (strcoll(p->text, q->text) < 0)
#else
# 7307 "shell/ash.c"
		if (strcmp(p->text, q->text) < 0)
#endif
# 7309 "shell/ash.c"
						{
			*lpp = p;
			lpp = &p->next;
			p = *lpp;
			if (p == NULL) {
				*lpp = q;
				break;
			}
		} else {
			*lpp = q;
			lpp = &q->next;
			q = *lpp;
			if (q == NULL) {
				*lpp = p;
				break;
			}
		}
	}
	return list;
}

/*
 * Sort the results of file name expansion.  It calculates the number of
 * strings to sort and then calls msort (short for merge sort) to do the
 * work.
 */
static struct strlist *
expsort(struct strlist *str)
{
	int len;
	struct strlist *sp;

	len = 0;
	for (sp = str; sp; sp = sp->next)
		len++;
	return msort(str, len);
}

static void
expandmeta(struct strlist *str /*, int flag*/)
{
	static const char metachars[] ALIGN1 = {
		'*', '?', '[', 0
	};
	/* TODO - EXP_REDIR */

	while (str) {
		char *expdir;
		struct strlist **savelastp;
		struct strlist *sp;
		char *p;

		if (fflag)
			goto nometa;
		if (!strpbrk(str->text, metachars))
			goto nometa;
		savelastp = exparg.lastp;

		INT_OFF;
		p = preglob(str->text, RMESCAPE_ALLOC | RMESCAPE_HEAP);
		{
			int i = strlen(str->text);
//BUGGY estimation of how long expanded name can be
			expdir = ckmalloc(i < 2048 ? 2048 : i+1);
		}
		expmeta(expdir, expdir, p);
		free(expdir);
		if (p != str->text)
			free(p);
		INT_ON;
		if (exparg.lastp == savelastp) {
			/*
			 * no matches
			 */
 nometa:
			*exparg.lastp = str;
			rmescapes(str->text, 0);
			exparg.lastp = &str->next;
		} else {
			*exparg.lastp = NULL;
			*savelastp = sp = expsort(*savelastp);
			while (sp->next != NULL)
				sp = sp->next;
			exparg.lastp = &sp->next;
		}
		str = str->next;
	}
}
#endif /* ENABLE_ASH_INTERNAL_GLOB */
# 7398 "shell/ash.c"

/*
 * Perform variable substitution and command substitution on an argument,
 * placing the resulting list of arguments in arglist.  If EXP_FULL is true,
 * perform splitting and file name expansion.  When arglist is NULL, perform
 * here document expansion.
 */
static void
expandarg(union node *arg, struct arglist *arglist, int flag)
{
	struct strlist *sp;
	char *p;

	argbackq = arg->narg.backquote;
	STARTSTACKSTR(expdest);
	TRACE(("expandarg: argstr('%s',flags:%x)\n", arg->narg.text, flag));
	argstr(arg->narg.text, flag,
			/* var_str_list: */ arglist ? arglist->list : NULL);
	p = _STPUTC('\0', expdest);
	expdest = p - 1;
	if (arglist == NULL) {
		/* here document expanded */
		goto out;
	}
	p = grabstackstr(p);
	TRACE(("expandarg: p:'%s'\n", p));
	exparg.lastp = &exparg.list;
	/*
	 * TODO - EXP_REDIR
	 */
	if (flag & EXP_FULL) {
		ifsbreakup(p, &exparg);
		*exparg.lastp = NULL;
		exparg.lastp = &exparg.list;
		expandmeta(exparg.list /*, flag*/);
	} else {
		if (flag & EXP_REDIR) { /*XXX - for now, just remove escapes */
			rmescapes(p, 0);
			TRACE(("expandarg: rmescapes:'%s'\n", p));
		}
		sp = stzalloc(sizeof(*sp));
		sp->text = p;
		*exparg.lastp = sp;
		exparg.lastp = &sp->next;
	}
	*exparg.lastp = NULL;
	if (exparg.list) {
		*arglist->lastp = exparg.list;
		arglist->lastp = exparg.lastp;
	}

 out:
	ifsfree();
}

/*
 * Expand shell variables and backquotes inside a here document.
 */
static void
expandhere(union node *arg, int fd)
{
	expandarg(arg, (struct arglist *)NULL, EXP_QUOTED);
	full_write(fd, stackblock(), expdest - (char *)stackblock());
}

/*
 * Returns true if the pattern matches the string.
 */
static int
patmatch(char *pattern, const char *string)
{
	return pmatch(preglob(pattern, 0), string);
}

/*
 * See if a pattern matches in a case statement.
 */
static int
casematch(union node *pattern, char *val)
{
	struct stackmark smark;
	int result;

	setstackmark(&smark);
	argbackq = pattern->narg.backquote;
	STARTSTACKSTR(expdest);
	argstr(pattern->narg.text, EXP_TILDE | EXP_CASE,
			/* var_str_list: */ NULL);
	STACKSTRNUL(expdest);
	ifsfree();
	result = patmatch(stackblock(), val);
	popstackmark(&smark);
	return result;
}


/* ============ find_command */

struct builtincmd {
	const char *name;
	int (*builtin)(int, char **) FAST_FUNC;
	/* unsigned flags; */
};
#define IS_BUILTIN_SPECIAL(b) ((b)->name[0] & 1)
/* "regular" builtins always take precedence over commands,
 * regardless of PATH=....%builtin... position */
#define IS_BUILTIN_REGULAR(b) ((b)->name[0] & 2)
#define IS_BUILTIN_ASSIGN(b)  ((b)->name[0] & 4)

struct cmdentry {
	smallint cmdtype;       /* CMDxxx */
	union param {
		int index;
		/* index >= 0 for commands without path (slashes) */
		/* (TODO: what exactly does the value mean? PATH position?) */
		/* index == -1 for commands with slashes */
		/* index == (-2 - applet_no) for NOFORK applets */
		const struct builtincmd *cmd;
		struct funcnode *func;
	} u;
};
/* values of cmdtype */
#define CMDUNKNOWN      -1      /* no entry in table for command */
#define CMDNORMAL       0       /* command is an executable program */
#define CMDFUNCTION     1       /* command is a shell function */
#define CMDBUILTIN      2       /* command is a shell builtin */

/* action to find_command() */
#define DO_ERR          0x01    /* prints errors */
#define DO_ABS          0x02    /* checks absolute paths */
#define DO_NOFUNC       0x04    /* don't return shell functions, for command */
#define DO_ALTPATH      0x08    /* using alternate path */
#define DO_ALTBLTIN     0x20    /* %builtin in alt. path */

static void find_command(char *, struct cmdentry *, int, const char *);


/* ============ Hashing commands */

/*
 * When commands are first encountered, they are entered in a hash table.
 * This ensures that a full path search will not have to be done for them
 * on each invocation.
 *
 * We should investigate converting to a linear search, even though that
 * would make the command name "hash" a misnomer.
 */

struct tblentry {
	struct tblentry *next;  /* next entry in hash chain */
	union param param;      /* definition of builtin function */
	smallint cmdtype;       /* CMDxxx */
	char rehash;            /* if set, cd done since entry created */
	char cmdname[1];        /* name of command */
};

static struct tblentry **cmdtable;
#define INIT_G_cmdtable() do { \
	cmdtable = xzalloc(CMDTABLESIZE * sizeof(cmdtable[0])); \
} while (0)

static int builtinloc = -1;     /* index in path of %builtin, or -1 */


static void
tryexec(IF_FEATURE_SH_STANDALONE(int applet_no,) char *cmd, char **argv, char **envp)
{
#if ENABLE_FEATURE_SH_STANDALONE
	if (applet_no >= 0) {
		if (APPLET_IS_NOEXEC(applet_no)) {
			clearenv();
			while (*envp)
				putenv(*envp++);
			run_applet_no_and_exit(applet_no, argv);
		}
		/* re-exec ourselves with the new arguments */
		execve(bb_busybox_exec_path, argv, envp);
		/* If they called chroot or otherwise made the binary no longer
		 * executable, fall through */
	}
#endif
# 7579 "shell/ash.c"

 repeat:
#ifdef SYSV
	do {
		execve(cmd, argv, envp);
	} while (errno == EINTR);
#else
# 7586 "shell/ash.c"
	execve(cmd, argv, envp);
#endif
# 7588 "shell/ash.c"
	if (cmd != (char*) bb_busybox_exec_path && errno == ENOEXEC) {
		/* Run "cmd" as a shell script:
		 * http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html
		 * "If the execve() function fails with ENOEXEC, the shell
		 * shall execute a command equivalent to having a shell invoked
		 * with the command name as its first operand,
		 * with any remaining arguments passed to the new shell"
		 *
		 * That is, do not use $SHELL, user's shell, or /bin/sh;
		 * just call ourselves.
		 *
		 * Note that bash reads ~80 chars of the file, and if it sees
		 * a zero byte before it sees newline, it doesn't try to
		 * interpret it, but fails with "cannot execute binary file"
		 * message and exit code 126. For one, this prevents attempts
		 * to interpret foreign ELF binaries as shell scripts.
		 */
		argv[0] = cmd;
		cmd = (char*) bb_busybox_exec_path;
		/* NB: this is only possible because all callers of shellexec()
		 * ensure that the argv[-1] slot exists!
		 */
		argv--;
		argv[0] = (char*) "ash";
		goto repeat;
	}
}

/*
 * Exec a program.  Never returns.  If you change this routine, you may
 * have to change the find_command routine as well.
 * argv[-1] must exist and be writable! See tryexec() for why.
 */
static void shellexec(char **, const char *, int) NORETURN;
static void
shellexec(char **argv, const char *path, int idx)
{
	char *cmdname;
	int e;
	char **envp;
	int exerrno;
	int applet_no = -1; /* used only by FEATURE_SH_STANDALONE */

	envp = listvars(VEXPORT, VUNSET, /*end:*/ NULL);
	if (strchr(argv[0], '/') != NULL
#if ENABLE_FEATURE_SH_STANDALONE
	 || (applet_no = find_applet_by_name(argv[0])) >= 0
#endif
# 7636 "shell/ash.c"
	) {
		tryexec(IF_FEATURE_SH_STANDALONE(applet_no,) argv[0], argv, envp);
		if (applet_no >= 0) {
			/* We tried execing ourself, but it didn't work.
			 * Maybe /proc/self/exe doesn't exist?
			 * Try $PATH search.
			 */
			goto try_PATH;
		}
		e = errno;
	} else {
 try_PATH:
		e = ENOENT;
		while ((cmdname = path_advance(&path, argv[0])) != NULL) {
			if (--idx < 0 && pathopt == NULL) {
				tryexec(IF_FEATURE_SH_STANDALONE(-1,) cmdname, argv, envp);
				if (errno != ENOENT && errno != ENOTDIR)
					e = errno;
			}
			stunalloc(cmdname);
		}
	}

	/* Map to POSIX errors */
	switch (e) {
	case EACCES:
		exerrno = 126;
		break;
	case ENOENT:
		exerrno = 127;
		break;
	default:
		exerrno = 2;
		break;
	}
	exitstatus = exerrno;
	TRACE(("shellexec failed for %s, errno %d, suppress_int %d\n",
		argv[0], e, suppress_int));
	ash_msg_and_raise(EXEXIT, "%s: %s", argv[0], errmsg(e, "not found"));
	/* NOTREACHED */
}

static void
printentry(struct tblentry *cmdp)
{
	int idx;
	const char *path;
	char *name;

	idx = cmdp->param.index;
	path = pathval();
	do {
		name = path_advance(&path, cmdp->cmdname);
		stunalloc(name);
	} while (--idx >= 0);
	out1fmt("%s%s\n", name, (cmdp->rehash ? "*" : nullstr));
}

/*
 * Clear out command entries.  The argument specifies the first entry in
 * PATH which has changed.
 */
static void
clearcmdentry(int firstchange)
{
	struct tblentry **tblp;
	struct tblentry **pp;
	struct tblentry *cmdp;

	INT_OFF;
	for (tblp = cmdtable; tblp < &cmdtable[CMDTABLESIZE]; tblp++) {
		pp = tblp;
		while ((cmdp = *pp) != NULL) {
			if ((cmdp->cmdtype == CMDNORMAL &&
			     cmdp->param.index >= firstchange)
			 || (cmdp->cmdtype == CMDBUILTIN &&
			     builtinloc >= firstchange)
			) {
				*pp = cmdp->next;
				free(cmdp);
			} else {
				pp = &cmdp->next;
			}
		}
	}
	INT_ON;
}

/*
 * Locate a command in the command hash table.  If "add" is nonzero,
 * add the command to the table if it is not already present.  The
 * variable "lastcmdentry" is set to point to the address of the link
 * pointing to the entry, so that delete_cmd_entry can delete the
 * entry.
 *
 * Interrupts must be off if called with add != 0.
 */
static struct tblentry **lastcmdentry;

static struct tblentry *
cmdlookup(const char *name, int add)
{
	unsigned int hashval;
	const char *p;
	struct tblentry *cmdp;
	struct tblentry **pp;

	p = name;
	hashval = (unsigned char)*p << 4;
	while (*p)
		hashval += (unsigned char)*p++;
	hashval &= 0x7FFF;
	pp = &cmdtable[hashval % CMDTABLESIZE];
	for (cmdp = *pp; cmdp; cmdp = cmdp->next) {
		if (strcmp(cmdp->cmdname, name) == 0)
			break;
		pp = &cmdp->next;
	}
	if (add && cmdp == NULL) {
		cmdp = *pp = ckzalloc(sizeof(struct tblentry)
				+ strlen(name)
				/* + 1 - already done because
				 * tblentry::cmdname is char[1] */);
		/*cmdp->next = NULL; - ckzalloc did it */
		cmdp->cmdtype = CMDUNKNOWN;
		strcpy(cmdp->cmdname, name);
	}
	lastcmdentry = pp;
	return cmdp;
}

/*
 * Delete the command entry returned on the last lookup.
 */
static void
delete_cmd_entry(void)
{
	struct tblentry *cmdp;

	INT_OFF;
	cmdp = *lastcmdentry;
	*lastcmdentry = cmdp->next;
	if (cmdp->cmdtype == CMDFUNCTION)
		freefunc(cmdp->param.func);
	free(cmdp);
	INT_ON;
}

/*
 * Add a new command entry, replacing any existing command entry for
 * the same name - except special builtins.
 */
static void
addcmdentry(char *name, struct cmdentry *entry)
{
	struct tblentry *cmdp;

	cmdp = cmdlookup(name, 1);
	if (cmdp->cmdtype == CMDFUNCTION) {
		freefunc(cmdp->param.func);
	}
	cmdp->cmdtype = entry->cmdtype;
	cmdp->param = entry->u;
	cmdp->rehash = 0;
}

static int FAST_FUNC
hashcmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
{
	struct tblentry **pp;
	struct tblentry *cmdp;
	int c;
	struct cmdentry entry;
	char *name;

	if (nextopt("r") != '\0') {
		clearcmdentry(0);
		return 0;
	}

	if (*argptr == NULL) {
		for (pp = cmdtable; pp < &cmdtable[CMDTABLESIZE]; pp++) {
			for (cmdp = *pp; cmdp; cmdp = cmdp->next) {
				if (cmdp->cmdtype == CMDNORMAL)
					printentry(cmdp);
			}
		}
		return 0;
	}

	c = 0;
	while ((name = *argptr) != NULL) {
		cmdp = cmdlookup(name, 0);
		if (cmdp != NULL
		 && (cmdp->cmdtype == CMDNORMAL
		     || (cmdp->cmdtype == CMDBUILTIN && builtinloc >= 0))
		) {
			delete_cmd_entry();
		}
		find_command(name, &entry, DO_ERR, pathval());
		if (entry.cmdtype == CMDUNKNOWN)
			c = 1;
		argptr++;
	}
	return c;
}

/*
 * Called when a cd is done.  Marks all commands so the next time they
 * are executed they will be rehashed.
 */
static void
hashcd(void)
{
	struct tblentry **pp;
	struct tblentry *cmdp;

	for (pp = cmdtable; pp < &cmdtable[CMDTABLESIZE]; pp++) {
		for (cmdp = *pp; cmdp; cmdp = cmdp->next) {
			if (cmdp->cmdtype == CMDNORMAL
			 || (cmdp->cmdtype == CMDBUILTIN
			     && !IS_BUILTIN_REGULAR(cmdp->param.cmd)
			     && builtinloc > 0)
			) {
				cmdp->rehash = 1;
			}
		}
	}
}

/*
 * Fix command hash table when PATH changed.
 * Called before PATH is changed.  The argument is the new value of PATH;
 * pathval() still returns the old value at this point.
 * Called with interrupts off.
 */
static void FAST_FUNC
changepath(const char *new)
{
	const char *old;
	int firstchange;
	int idx;
	int idx_bltin;

	old = pathval();
	firstchange = 9999;     /* assume no change */
	idx = 0;
	idx_bltin = -1;
	for (;;) {
		if (*old != *new) {
			firstchange = idx;
			if ((*old == '\0' && *new == ':')
			 || (*old == ':' && *new == '\0')
			) {
				firstchange++;
			}
			old = new;      /* ignore subsequent differences */
		}
		if (*new == '\0')
			break;
		if (*new == '%' && idx_bltin < 0 && prefix(new + 1, "builtin"))
			idx_bltin = idx;
		if (*new == ':')
			idx++;
		new++;
		old++;
	}
	if (builtinloc < 0 && idx_bltin >= 0)
		builtinloc = idx_bltin;             /* zap builtins */
	if (builtinloc >= 0 && idx_bltin < 0)
		firstchange = 0;
	clearcmdentry(firstchange);
	builtinloc = idx_bltin;
}
enum {
	TEOF,
	TNL,
	TREDIR,
	TWORD,
	TSEMI,
	TBACKGND,
	TAND,
	TOR,
	TPIPE,
	TLP,
	TRP,
	TENDCASE,
	TENDBQUOTE,
	TNOT,
	TCASE,
	TDO,
	TDONE,
	TELIF,
	TELSE,
	TESAC,
	TFI,
	TFOR,
#if ENABLE_ASH_BASH_COMPAT
	TFUNCTION,
#endif
# 7936 "shell/ash.c"
	TIF,
	TIN,
	TTHEN,
	TUNTIL,
	TWHILE,
	TBEGIN,
	TEND
};
typedef smallint token_id_t;

/* Nth bit indicates if token marks the end of a list */
enum {
	tokendlist = 0
	/*  0 */ | (1u << TEOF)
	/*  1 */ | (0u << TNL)
	/*  2 */ | (0u << TREDIR)
	/*  3 */ | (0u << TWORD)
	/*  4 */ | (0u << TSEMI)
	/*  5 */ | (0u << TBACKGND)
	/*  6 */ | (0u << TAND)
	/*  7 */ | (0u << TOR)
	/*  8 */ | (0u << TPIPE)
	/*  9 */ | (0u << TLP)
	/* 10 */ | (1u << TRP)
	/* 11 */ | (1u << TENDCASE)
	/* 12 */ | (1u << TENDBQUOTE)
	/* 13 */ | (0u << TNOT)
	/* 14 */ | (0u << TCASE)
	/* 15 */ | (1u << TDO)
	/* 16 */ | (1u << TDONE)
	/* 17 */ | (1u << TELIF)
	/* 18 */ | (1u << TELSE)
	/* 19 */ | (1u << TESAC)
	/* 20 */ | (1u << TFI)
	/* 21 */ | (0u << TFOR)
#if ENABLE_ASH_BASH_COMPAT
	/* 22 */ | (0u << TFUNCTION)
#endif
# 7974 "shell/ash.c"
	/* 23 */ | (0u << TIF)
	/* 24 */ | (0u << TIN)
	/* 25 */ | (1u << TTHEN)
	/* 26 */ | (0u << TUNTIL)
	/* 27 */ | (0u << TWHILE)
	/* 28 */ | (0u << TBEGIN)
	/* 29 */ | (1u << TEND)
	, /* thus far 29 bits used */
};

static const char *const tokname_array[] = {
	"end of file",
	"newline",
	"redirection",
	"word",
	";",
	"&",
	"&&",
	"||",
	"|",
	"(",
	")",
	";;",
	"`",
#define KWDOFFSET 13
	/* the following are keywords */
	"!",
	"case",
	"do",
	"done",
	"elif",
	"else",
	"esac",
	"fi",
	"for",
#if ENABLE_ASH_BASH_COMPAT
	"function",
#endif
# 8012 "shell/ash.c"
	"if",
	"in",
	"then",
	"until",
	"while",
	"{",
	"}",
};

/* Wrapper around strcmp for qsort/bsearch/... */
static int
pstrcmp(const void *a, const void *b)
{
	return strcmp((char*)a, *(char**)b);
}

static const char *const *
findkwd(const char *s)
{
	return bsearch(s, tokname_array + KWDOFFSET,
			ARRAY_SIZE(tokname_array) - KWDOFFSET,
			sizeof(tokname_array[0]), pstrcmp);
}

/*
 * Locate and print what a word is...
 */
static int
describe_command(char *command, const char *path, int describe_command_verbose)
{
	struct cmdentry entry;
	struct tblentry *cmdp;
#if ENABLE_ASH_ALIAS
	const struct alias *ap;
#endif
# 8047 "shell/ash.c"

	path = path ? path : pathval();

	if (describe_command_verbose) {
		out1str(command);
	}

	/* First look at the keywords */
	if (findkwd(command)) {
		out1str(describe_command_verbose ? " is a shell keyword" : command);
		goto out;
	}

#if ENABLE_ASH_ALIAS
	/* Then look at the aliases */
	ap = lookupalias(command, 0);
	if (ap != NULL) {
		if (!describe_command_verbose) {
			out1str("alias ");
			printalias(ap);
			return 0;
		}
		out1fmt(" is an alias for %s", ap->val);
		goto out;
	}
#endif
# 8073 "shell/ash.c"
	/* Then check if it is a tracked alias */
	cmdp = cmdlookup(command, 0);
	if (cmdp != NULL) {
		entry.cmdtype = cmdp->cmdtype;
		entry.u = cmdp->param;
	} else {
		/* Finally use brute force */
		find_command(command, &entry, DO_ABS, path);
	}

	switch (entry.cmdtype) {
	case CMDNORMAL: {
		int j = entry.u.index;
		char *p;
		if (j < 0) {
			p = command;
		} else {
			do {
				p = path_advance(&path, command);
				stunalloc(p);
			} while (--j >= 0);
		}
		if (describe_command_verbose) {
			out1fmt(" is%s %s",
				(cmdp ? " a tracked alias for" : nullstr), p
			);
		} else {
			out1str(p);
		}
		break;
	}

	case CMDFUNCTION:
		if (describe_command_verbose) {
			out1str(" is a shell function");
		} else {
			out1str(command);
		}
		break;

	case CMDBUILTIN:
		if (describe_command_verbose) {
			out1fmt(" is a %sshell builtin",
				IS_BUILTIN_SPECIAL(entry.u.cmd) ?
					"special " : nullstr
			);
		} else {
			out1str(command);
		}
		break;

	default:
		if (describe_command_verbose) {
			out1str(": not found\n");
		}
		return 127;
	}
 out:
	out1str("\n");
	return 0;
}

static int FAST_FUNC
typecmd(int argc UNUSED_PARAM, char **argv)
{
	int i = 1;
	int err = 0;
	int verbose = 1;

	/* type -p ... ? (we don't bother checking for 'p') */
	if (argv[1] && argv[1][0] == '-') {
		i++;
		verbose = 0;
	}
	while (argv[i]) {
		err |= describe_command(argv[i++], NULL, verbose);
	}
	return err;
}

#if ENABLE_ASH_CMDCMD
/* Is it "command [-p] PROG ARGS" bltin, no other opts? Return ptr to "PROG" if yes */
static char **
parse_command_args(char **argv, const char **path)
{
	char *cp, c;

	for (;;) {
		cp = *++argv;
		if (!cp)
			return NULL;
		if (*cp++ != '-')
			break;
		c = *cp++;
		if (!c)
			break;
		if (c == '-' && !*cp) {
			if (!*++argv)
				return NULL;
			break;
		}
		do {
			switch (c) {
			case 'p':
				*path = bb_default_path;
				break;
			default:
				/* run 'typecmd' for other options */
				return NULL;
			}
			c = *cp++;
		} while (c);
	}
	return argv;
}

static int FAST_FUNC
commandcmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
{
	char *cmd;
	int c;
	enum {
		VERIFY_BRIEF = 1,
		VERIFY_VERBOSE = 2,
	} verify = 0;
	const char *path = NULL;

	/* "command [-p] PROG ARGS" (that is, without -V or -v)
	 * never reaches this function.
	 */

	while ((c = nextopt("pvV")) != '\0')
		if (c == 'V')
			verify |= VERIFY_VERBOSE;
		else if (c == 'v')
			/*verify |= VERIFY_BRIEF*/;
#if DEBUG
		else if (c != 'p')
			abort();
#endif
# 8213 "shell/ash.c"
		else
			path = bb_default_path;

	/* Mimic bash: just "command -v" doesn't complain, it's a nop */
	cmd = *argptr;
	if (/*verify && */ cmd)
		return describe_command(cmd, path, verify /* - VERIFY_BRIEF*/);

	return 0;
}
#endif
# 8224 "shell/ash.c"


/*static int funcblocksize;     // size of structures in function */
/*static int funcstringsize;    // size of strings in node */
static void *funcblock;         /* block to allocate function from */
static char *funcstring_end;    /* end of block to allocate strings from */

/* flags in argument to evaltree */
#define EV_EXIT    01           /* exit after evaluating tree */
#define EV_TESTED  02           /* exit status is checked; ignore -e flag */

static const uint8_t nodesize[N_NUMBER] ALIGN1 = {
	[NCMD     ] = SHELL_ALIGN(sizeof(struct ncmd)),
	[NPIPE    ] = SHELL_ALIGN(sizeof(struct npipe)),
	[NREDIR   ] = SHELL_ALIGN(sizeof(struct nredir)),
	[NBACKGND ] = SHELL_ALIGN(sizeof(struct nredir)),
	[NSUBSHELL] = SHELL_ALIGN(sizeof(struct nredir)),
	[NAND     ] = SHELL_ALIGN(sizeof(struct nbinary)),
	[NOR      ] = SHELL_ALIGN(sizeof(struct nbinary)),
	[NSEMI    ] = SHELL_ALIGN(sizeof(struct nbinary)),
	[NIF      ] = SHELL_ALIGN(sizeof(struct nif)),
	[NWHILE   ] = SHELL_ALIGN(sizeof(struct nbinary)),
	[NUNTIL   ] = SHELL_ALIGN(sizeof(struct nbinary)),
	[NFOR     ] = SHELL_ALIGN(sizeof(struct nfor)),
	[NCASE    ] = SHELL_ALIGN(sizeof(struct ncase)),
	[NCLIST   ] = SHELL_ALIGN(sizeof(struct nclist)),
	[NDEFUN   ] = SHELL_ALIGN(sizeof(struct narg)),
	[NARG     ] = SHELL_ALIGN(sizeof(struct narg)),
	[NTO      ] = SHELL_ALIGN(sizeof(struct nfile)),
#if ENABLE_ASH_BASH_COMPAT
	[NTO2     ] = SHELL_ALIGN(sizeof(struct nfile)),
#endif
# 8256 "shell/ash.c"
	[NCLOBBER ] = SHELL_ALIGN(sizeof(struct nfile)),
	[NFROM    ] = SHELL_ALIGN(sizeof(struct nfile)),
	[NFROMTO  ] = SHELL_ALIGN(sizeof(struct nfile)),
	[NAPPEND  ] = SHELL_ALIGN(sizeof(struct nfile)),
	[NTOFD    ] = SHELL_ALIGN(sizeof(struct ndup)),
	[NFROMFD  ] = SHELL_ALIGN(sizeof(struct ndup)),
	[NHERE    ] = SHELL_ALIGN(sizeof(struct nhere)),
	[NXHERE   ] = SHELL_ALIGN(sizeof(struct nhere)),
	[NNOT     ] = SHELL_ALIGN(sizeof(struct nnot)),
};

static int calcsize(int funcblocksize, union node *n);

static int
sizenodelist(int funcblocksize, struct nodelist *lp)
{
	while (lp) {
		funcblocksize += SHELL_ALIGN(sizeof(struct nodelist));
		funcblocksize = calcsize(funcblocksize, lp->n);
		lp = lp->next;
	}
	return funcblocksize;
}

static int
calcsize(int funcblocksize, union node *n)
{
	if (n == NULL)
		return funcblocksize;
	funcblocksize += nodesize[n->type];
	switch (n->type) {
	case NCMD:
		funcblocksize = calcsize(funcblocksize, n->ncmd.redirect);
		funcblocksize = calcsize(funcblocksize, n->ncmd.args);
		funcblocksize = calcsize(funcblocksize, n->ncmd.assign);
		break;
	case NPIPE:
		funcblocksize = sizenodelist(funcblocksize, n->npipe.cmdlist);
		break;
	case NREDIR:
	case NBACKGND:
	case NSUBSHELL:
		funcblocksize = calcsize(funcblocksize, n->nredir.redirect);
		funcblocksize = calcsize(funcblocksize, n->nredir.n);
		break;
	case NAND:
	case NOR:
	case NSEMI:
	case NWHILE:
	case NUNTIL:
		funcblocksize = calcsize(funcblocksize, n->nbinary.ch2);
		funcblocksize = calcsize(funcblocksize, n->nbinary.ch1);
		break;
	case NIF:
		funcblocksize = calcsize(funcblocksize, n->nif.elsepart);
		funcblocksize = calcsize(funcblocksize, n->nif.ifpart);
		funcblocksize = calcsize(funcblocksize, n->nif.test);
		break;
	case NFOR:
		funcblocksize += SHELL_ALIGN(strlen(n->nfor.var) + 1); /* was funcstringsize += ... */
		funcblocksize = calcsize(funcblocksize, n->nfor.body);
		funcblocksize = calcsize(funcblocksize, n->nfor.args);
		break;
	case NCASE:
		funcblocksize = calcsize(funcblocksize, n->ncase.cases);
		funcblocksize = calcsize(funcblocksize, n->ncase.expr);
		break;
	case NCLIST:
		funcblocksize = calcsize(funcblocksize, n->nclist.body);
		funcblocksize = calcsize(funcblocksize, n->nclist.pattern);
		funcblocksize = calcsize(funcblocksize, n->nclist.next);
		break;
	case NDEFUN:
	case NARG:
		funcblocksize = sizenodelist(funcblocksize, n->narg.backquote);
		funcblocksize += SHELL_ALIGN(strlen(n->narg.text) + 1); /* was funcstringsize += ... */
		funcblocksize = calcsize(funcblocksize, n->narg.next);
		break;
	case NTO:
#if ENABLE_ASH_BASH_COMPAT
	case NTO2:
#endif
# 8338 "shell/ash.c"
	case NCLOBBER:
	case NFROM:
	case NFROMTO:
	case NAPPEND:
		funcblocksize = calcsize(funcblocksize, n->nfile.fname);
		funcblocksize = calcsize(funcblocksize, n->nfile.next);
		break;
	case NTOFD:
	case NFROMFD:
		funcblocksize = calcsize(funcblocksize, n->ndup.vname);
		funcblocksize = calcsize(funcblocksize, n->ndup.next);
	break;
	case NHERE:
	case NXHERE:
		funcblocksize = calcsize(funcblocksize, n->nhere.doc);
		funcblocksize = calcsize(funcblocksize, n->nhere.next);
		break;
	case NNOT:
		funcblocksize = calcsize(funcblocksize, n->nnot.com);
		break;
	};
	return funcblocksize;
}

static char *
nodeckstrdup(char *s)
{
	funcstring_end -= SHELL_ALIGN(strlen(s) + 1);
	return strcpy(funcstring_end, s);
}

static union node *copynode(union node *);

static struct nodelist *
copynodelist(struct nodelist *lp)
{
	struct nodelist *start;
	struct nodelist **lpp;

	lpp = &start;
	while (lp) {
		*lpp = funcblock;
		funcblock = (char *) funcblock + SHELL_ALIGN(sizeof(struct nodelist));
		(*lpp)->n = copynode(lp->n);
		lp = lp->next;
		lpp = &(*lpp)->next;
	}
	*lpp = NULL;
	return start;
}

static union node *
copynode(union node *n)
{
	union node *new;

	if (n == NULL)
		return NULL;
	new = funcblock;
	funcblock = (char *) funcblock + nodesize[n->type];

	switch (n->type) {
	case NCMD:
		new->ncmd.redirect = copynode(n->ncmd.redirect);
		new->ncmd.args = copynode(n->ncmd.args);
		new->ncmd.assign = copynode(n->ncmd.assign);
		break;
	case NPIPE:
		new->npipe.cmdlist = copynodelist(n->npipe.cmdlist);
		new->npipe.pipe_backgnd = n->npipe.pipe_backgnd;
		break;
	case NREDIR:
	case NBACKGND:
	case NSUBSHELL:
		new->nredir.redirect = copynode(n->nredir.redirect);
		new->nredir.n = copynode(n->nredir.n);
		break;
	case NAND:
	case NOR:
	case NSEMI:
	case NWHILE:
	case NUNTIL:
		new->nbinary.ch2 = copynode(n->nbinary.ch2);
		new->nbinary.ch1 = copynode(n->nbinary.ch1);
		break;
	case NIF:
		new->nif.elsepart = copynode(n->nif.elsepart);
		new->nif.ifpart = copynode(n->nif.ifpart);
		new->nif.test = copynode(n->nif.test);
		break;
	case NFOR:
		new->nfor.var = nodeckstrdup(n->nfor.var);
		new->nfor.body = copynode(n->nfor.body);
		new->nfor.args = copynode(n->nfor.args);
		break;
	case NCASE:
		new->ncase.cases = copynode(n->ncase.cases);
		new->ncase.expr = copynode(n->ncase.expr);
		break;
	case NCLIST:
		new->nclist.body = copynode(n->nclist.body);
		new->nclist.pattern = copynode(n->nclist.pattern);
		new->nclist.next = copynode(n->nclist.next);
		break;
	case NDEFUN:
	case NARG:
		new->narg.backquote = copynodelist(n->narg.backquote);
		new->narg.text = nodeckstrdup(n->narg.text);
		new->narg.next = copynode(n->narg.next);
		break;
	case NTO:
#if ENABLE_ASH_BASH_COMPAT
	case NTO2:
#endif
# 8452 "shell/ash.c"
	case NCLOBBER:
	case NFROM:
	case NFROMTO:
	case NAPPEND:
		new->nfile.fname = copynode(n->nfile.fname);
		new->nfile.fd = n->nfile.fd;
		new->nfile.next = copynode(n->nfile.next);
		break;
	case NTOFD:
	case NFROMFD:
		new->ndup.vname = copynode(n->ndup.vname);
		new->ndup.dupfd = n->ndup.dupfd;
		new->ndup.fd = n->ndup.fd;
		new->ndup.next = copynode(n->ndup.next);
		break;
	case NHERE:
	case NXHERE:
		new->nhere.doc = copynode(n->nhere.doc);
		new->nhere.fd = n->nhere.fd;
		new->nhere.next = copynode(n->nhere.next);
		break;
	case NNOT:
		new->nnot.com = copynode(n->nnot.com);
		break;
	};
	new->type = n->type;
	return new;
}

/*
 * Make a copy of a parse tree.
 */
static struct funcnode *
copyfunc(union node *n)
{
	struct funcnode *f;
	size_t blocksize;

	/*funcstringsize = 0;*/
	blocksize = offsetof(struct funcnode, n) + calcsize(0, n);
	f = ckzalloc(blocksize /* + funcstringsize */);
	funcblock = (char *) f + offsetof(struct funcnode, n);
	funcstring_end = (char *) f + blocksize;
	copynode(n);
	/* f->count = 0; - ckzalloc did it */
	return f;
}

/*
 * Define a shell function.
 */
static void
defun(union node *func)
{
	struct cmdentry entry;

	INT_OFF;
	entry.cmdtype = CMDFUNCTION;
	entry.u.func = copyfunc(func);
	addcmdentry(func->narg.text, &entry);
	INT_ON;
}

/* Reasons for skipping commands (see comment on breakcmd routine) */
#define SKIPBREAK      (1 << 0)
#define SKIPCONT       (1 << 1)
#define SKIPFUNC       (1 << 2)
static smallint evalskip;       /* set to SKIPxxx if we are skipping commands */
static int skipcount;           /* number of levels to skip */
static int funcnest;            /* depth of function calls */
static int loopnest;            /* current loop nesting level */

/* Forward decl way out to parsing code - dotrap needs it */
static int evalstring(char *s, int flags);

/* Called to execute a trap.
 * Single callsite - at the end of evaltree().
 * If we return non-zero, evaltree raises EXEXIT exception.
 *
 * Perhaps we should avoid entering new trap handlers
 * while we are executing a trap handler. [is it a TODO?]
 */
static void
dotrap(void)
{
	uint8_t *g;
	int sig;
	uint8_t last_status;

	if (!pending_sig)
		return;

	last_status = exitstatus;
	pending_sig = 0;
	barrier();

	TRACE(("dotrap entered\n"));
	for (sig = 1, g = gotsig; sig < NSIG; sig++, g++) {
		char *p;

		if (!*g)
			continue;

		if (evalskip) {
			pending_sig = sig;
			break;
		}

		p = trap[sig];
		/* non-trapped SIGINT is handled separately by raise_interrupt,
		 * don't upset it by resetting gotsig[SIGINT-1] */
		if (sig == SIGINT && !p)
			continue;

		TRACE(("sig %d is active, will run handler '%s'\n", sig, p));
		*g = 0;
		if (!p)
			continue;
		evalstring(p, 0);
	}
	exitstatus = last_status;
	TRACE(("dotrap returns\n"));
}

/* forward declarations - evaluation is fairly recursive business... */
static int evalloop(union node *, int);
static int evalfor(union node *, int);
static int evalcase(union node *, int);
static int evalsubshell(union node *, int);
static void expredir(union node *);
static int evalpipe(union node *, int);
static int evalcommand(union node *, int);
static int evalbltin(const struct builtincmd *, int, char **, int);
static void prehash(union node *);

/*
 * Evaluate a parse tree.  The value is left in the global variable
 * exitstatus.
 */
static int
evaltree(union node *n, int flags)
{
	int checkexit = 0;
	int (*evalfn)(union node *, int);
	int status = 0;

	if (n == NULL) {
		TRACE(("evaltree(NULL) called\n"));
		goto out;
	}
	TRACE(("evaltree(%p: %d, %d) called\n", n, n->type, flags));

	dotrap();

	switch (n->type) {
	default:
#if DEBUG
		out1fmt("Node type = %d\n", n->type);
		fflush_all();
		break;
#endif
# 8613 "shell/ash.c"
	case NNOT:
		status = !evaltree(n->nnot.com, EV_TESTED);
		goto setstatus;
	case NREDIR:
		expredir(n->nredir.redirect);
		status = redirectsafe(n->nredir.redirect, REDIR_PUSH);
		if (!status) {
			status = evaltree(n->nredir.n, flags & EV_TESTED);
		}
		if (n->nredir.redirect)
			popredir(/*drop:*/ 0, /*restore:*/ 0 /* not sure */);
		goto setstatus;
	case NCMD:
		evalfn = evalcommand;
 checkexit:
		if (eflag && !(flags & EV_TESTED))
			checkexit = ~0;
		goto calleval;
	case NFOR:
		evalfn = evalfor;
		goto calleval;
	case NWHILE:
	case NUNTIL:
		evalfn = evalloop;
		goto calleval;
	case NSUBSHELL:
	case NBACKGND:
		evalfn = evalsubshell;
		goto checkexit;
	case NPIPE:
		evalfn = evalpipe;
		goto checkexit;
	case NCASE:
		evalfn = evalcase;
		goto calleval;
	case NAND:
	case NOR:
	case NSEMI: {

#if NAND + 1 != NOR
#error NAND + 1 != NOR
#endif
# 8655 "shell/ash.c"
#if NOR + 1 != NSEMI
#error NOR + 1 != NSEMI
#endif
# 8658 "shell/ash.c"
		unsigned is_or = n->type - NAND;
		status = evaltree(
			n->nbinary.ch1,
			(flags | ((is_or >> 1) - 1)) & EV_TESTED
		);
		if ((!status) == is_or || evalskip)
			break;
		n = n->nbinary.ch2;
 evaln:
		evalfn = evaltree;
 calleval:
		status = evalfn(n, flags);
		goto setstatus;
	}
	case NIF:
		status = evaltree(n->nif.test, EV_TESTED);
		if (evalskip)
			break;
		if (!status) {
			n = n->nif.ifpart;
			goto evaln;
		}
		if (n->nif.elsepart) {
			n = n->nif.elsepart;
			goto evaln;
		}
		status = 0;
		goto setstatus;
	case NDEFUN:
		defun(n);
		/* Not necessary. To test it:
		 * "false; f() { qwerty; }; echo $?" should print 0.
		 */
		/* status = 0; */
 setstatus:
		exitstatus = status;
		break;
	}
 out:
	/* Order of checks below is important:
	 * signal handlers trigger before exit caused by "set -e".
	 */
	dotrap();

	if (checkexit & status)
		raise_exception(EXEXIT);
	if (flags & EV_EXIT)
		raise_exception(EXEXIT);

	TRACE(("leaving evaltree (no interrupts)\n"));
	return exitstatus;
}

#if !defined(__alpha__) || (defined(__GNUC__) && __GNUC__ >= 3)
static
#endif
# 8714 "shell/ash.c"
int evaltreenr(union node *, int) __attribute__ ((alias("evaltree"),__noreturn__));

static int
skiploop(void)
{
	int skip = evalskip;

	switch (skip) {
	case 0:
		break;
	case SKIPBREAK:
	case SKIPCONT:
		if (--skipcount <= 0) {
			evalskip = 0;
			break;
		}
		skip = SKIPBREAK;
		break;
	}
	return skip;
}

static int
evalloop(union node *n, int flags)
{
	int skip;
	int status;

	loopnest++;
	status = 0;
	flags &= EV_TESTED;
	do {
		int i;

		i = evaltree(n->nbinary.ch1, EV_TESTED);
		skip = skiploop();
		if (skip == SKIPFUNC)
			status = i;
		if (skip)
			continue;
		if (n->type != NWHILE)
			i = !i;
		if (i != 0)
			break;
		status = evaltree(n->nbinary.ch2, flags);
		skip = skiploop();
	} while (!(skip & ~SKIPCONT));
	loopnest--;

	return status;
}

static int
evalfor(union node *n, int flags)
{
	struct arglist arglist;
	union node *argp;
	struct strlist *sp;
	struct stackmark smark;
	int status = 0;

	setstackmark(&smark);
	arglist.list = NULL;
	arglist.lastp = &arglist.list;
	for (argp = n->nfor.args; argp; argp = argp->narg.next) {
		expandarg(argp, &arglist, EXP_FULL | EXP_TILDE);
	}
	*arglist.lastp = NULL;

	loopnest++;
	flags &= EV_TESTED;
	for (sp = arglist.list; sp; sp = sp->next) {
		setvar0(n->nfor.var, sp->text);
		status = evaltree(n->nfor.body, flags);
		if (skiploop() & ~SKIPCONT)
			break;
	}
	loopnest--;
	popstackmark(&smark);

	return status;
}

static int
evalcase(union node *n, int flags)
{
	union node *cp;
	union node *patp;
	struct arglist arglist;
	struct stackmark smark;
	int status = 0;

	setstackmark(&smark);
	arglist.list = NULL;
	arglist.lastp = &arglist.list;
	expandarg(n->ncase.expr, &arglist, EXP_TILDE);
	for (cp = n->ncase.cases; cp && evalskip == 0; cp = cp->nclist.next) {
		for (patp = cp->nclist.pattern; patp; patp = patp->narg.next) {
			if (casematch(patp, arglist.list->text)) {
				/* Ensure body is non-empty as otherwise
				 * EV_EXIT may prevent us from setting the
				 * exit status.
				 */
				if (evalskip == 0 && cp->nclist.body) {
					status = evaltree(cp->nclist.body, flags);
				}
				goto out;
			}
		}
	}
 out:
	popstackmark(&smark);

	return status;
}

/*
 * Kick off a subshell to evaluate a tree.
 */
static int
evalsubshell(union node *n, int flags)
{
	struct job *jp;
	int backgnd = (n->type == NBACKGND);
	int status;

	expredir(n->nredir.redirect);
	if (!backgnd && (flags & EV_EXIT) && !may_have_traps)
		goto nofork;
	INT_OFF;
	jp = makejob(/*n,*/ 1);
	if (forkshell(jp, n, backgnd) == 0) {
		/* child */
		INT_ON;
		flags |= EV_EXIT;
		if (backgnd)
			flags &= ~EV_TESTED;
 nofork:
		redirect(n->nredir.redirect, 0);
		evaltreenr(n->nredir.n, flags);
		/* never returns */
	}
	/* parent */
	status = 0;
	if (!backgnd)
		status = waitforjob(jp);
	INT_ON;
	return status;
}

/*
 * Compute the names of the files in a redirection list.
 */
static void fixredir(union node *, const char *, int);
static void
expredir(union node *n)
{
	union node *redir;

	for (redir = n; redir; redir = redir->nfile.next) {
		struct arglist fn;

		fn.list = NULL;
		fn.lastp = &fn.list;
		switch (redir->type) {
		case NFROMTO:
		case NFROM:
		case NTO:
#if ENABLE_ASH_BASH_COMPAT
		case NTO2:
#endif
# 8885 "shell/ash.c"
		case NCLOBBER:
		case NAPPEND:
			expandarg(redir->nfile.fname, &fn, EXP_TILDE | EXP_REDIR);
			TRACE(("expredir expanded to '%s'\n", fn.list->text));
#if ENABLE_ASH_BASH_COMPAT
 store_expfname:
#endif
# 8892 "shell/ash.c"
#if 0
// By the design of stack allocator, the loop of this kind:
//	while true; do while true; do break; done </dev/null; done
// will look like a memory leak: ash plans to free expfname's
// of "/dev/null" as soon as it finishes running the loop
// (in this case, never).
// This "fix" is wrong:
			if (redir->nfile.expfname)
				stunalloc(redir->nfile.expfname);
// It results in corrupted state of stacked allocations.
#endif
# 8903 "shell/ash.c"
			redir->nfile.expfname = fn.list->text;
			break;
		case NFROMFD:
		case NTOFD: /* >& */
			if (redir->ndup.vname) {
				expandarg(redir->ndup.vname, &fn, EXP_FULL | EXP_TILDE);
				if (fn.list == NULL)
					ash_msg_and_raise_error("redir error");
#if ENABLE_ASH_BASH_COMPAT
//FIXME: we used expandarg with different args!
				if (!isdigit_str9(fn.list->text)) {
					/* >&file, not >&fd */
					if (redir->nfile.fd != 1) /* 123>&file - BAD */
						ash_msg_and_raise_error("redir error");
					redir->type = NTO2;
					goto store_expfname;
				}
#endif
# 8921 "shell/ash.c"
				fixredir(redir, fn.list->text, 1);
			}
			break;
		}
	}
}

/*
 * Evaluate a pipeline.  All the processes in the pipeline are children
 * of the process creating the pipeline.  (This differs from some versions
 * of the shell, which make the last process in a pipeline the parent
 * of all the rest.)
 */
static int
evalpipe(union node *n, int flags)
{
	struct job *jp;
	struct nodelist *lp;
	int pipelen;
	int prevfd;
	int pip[2];
	int status = 0;

	TRACE(("evalpipe(0x%lx) called\n", (long)n));
	pipelen = 0;
	for (lp = n->npipe.cmdlist; lp; lp = lp->next)
		pipelen++;
	flags |= EV_EXIT;
	INT_OFF;
	jp = makejob(/*n,*/ pipelen);
	prevfd = -1;
	for (lp = n->npipe.cmdlist; lp; lp = lp->next) {
		prehash(lp->n);
		pip[1] = -1;
		if (lp->next) {
			if (pipe(pip) < 0) {
				close(prevfd);
				ash_msg_and_raise_error("pipe call failed");
			}
		}
		if (forkshell(jp, lp->n, n->npipe.pipe_backgnd) == 0) {
			/* child */
			INT_ON;
			if (pip[1] >= 0) {
				close(pip[0]);
			}
			if (prevfd > 0) {
				dup2(prevfd, 0);
				close(prevfd);
			}
			if (pip[1] > 1) {
				dup2(pip[1], 1);
				close(pip[1]);
			}
			evaltreenr(lp->n, flags);
			/* never returns */
		}
		/* parent */
		if (prevfd >= 0)
			close(prevfd);
		prevfd = pip[0];
		/* Don't want to trigger debugging */
		if (pip[1] != -1)
			close(pip[1]);
	}
	if (n->npipe.pipe_backgnd == 0) {
		status = waitforjob(jp);
		TRACE(("evalpipe:  job done exit status %d\n", status));
	}
	INT_ON;

	return status;
}

/*
 * Controls whether the shell is interactive or not.
 */
static void
setinteractive(int on)
{
	static smallint is_interactive;

	if (++on == is_interactive)
		return;
	is_interactive = on;
	setsignal(SIGINT);
	setsignal(SIGQUIT);
	setsignal(SIGTERM);
#if !ENABLE_FEATURE_SH_EXTRA_QUIET
	if (is_interactive > 1) {
		/* Looks like they want an interactive shell */
		static smallint did_banner;

		if (!did_banner) {
			/* note: ash and hush share this string */
			out1fmt("\n\n%s %s\n"
				IF_ASH_HELP("Enter 'help' for a list of built-in commands.\n")
				"\n",
				bb_banner,
				"built-in shell (ash)"
			);
			did_banner = 1;
		}
	}
#endif
# 9026 "shell/ash.c"
}

static void
optschanged(void)
{
#if DEBUG
	opentrace();
#endif
# 9034 "shell/ash.c"
	setinteractive(iflag);
	setjobctl(mflag);
#if ENABLE_FEATURE_EDITING_VI
	if (viflag)
		line_input_state->flags |= VI_MODE;
	else
		line_input_state->flags &= ~VI_MODE;
#else
# 9042 "shell/ash.c"
	viflag = 0; /* forcibly keep the option off */
#endif
# 9044 "shell/ash.c"
}

static struct localvar *localvars;

/*
 * Called after a function returns.
 * Interrupts must be off.
 */
static void
poplocalvars(void)
{
	struct localvar *lvp;
	struct var *vp;

	while ((lvp = localvars) != NULL) {
		localvars = lvp->next;
		vp = lvp->vp;
		TRACE(("poplocalvar %s\n", vp ? vp->var_text : "-"));
		if (vp == NULL) {       /* $- saved */
			memcpy(optlist, lvp->text, sizeof(optlist));
			free((char*)lvp->text);
			optschanged();
		} else if ((lvp->flags & (VUNSET|VSTRFIXED)) == VUNSET) {
			unsetvar(vp->var_text);
		} else {
			if (vp->var_func)
				vp->var_func(var_end(lvp->text));
			if ((vp->flags & (VTEXTFIXED|VSTACK)) == 0)
				free((char*)vp->var_text);
			vp->flags = lvp->flags;
			vp->var_text = lvp->text;
		}
		free(lvp);
	}
}

static int
evalfun(struct funcnode *func, int argc, char **argv, int flags)
{
	volatile struct shparam saveparam;
	struct localvar *volatile savelocalvars;
	struct jmploc *volatile savehandler;
	struct jmploc jmploc;
	int e;

	saveparam = shellparam;
	savelocalvars = localvars;
	savehandler = exception_handler;
	e = setjmp(jmploc.loc);
	if (e) {
		goto funcdone;
	}
	INT_OFF;
	exception_handler = &jmploc;
	localvars = NULL;
	shellparam.malloced = 0;
	func->count++;
	funcnest++;
	INT_ON;
	shellparam.nparam = argc - 1;
	shellparam.p = argv + 1;
#if ENABLE_ASH_GETOPTS
	shellparam.optind = 1;
	shellparam.optoff = -1;
#endif
# 9109 "shell/ash.c"
	evaltree(func->n.narg.next, flags & EV_TESTED);
 funcdone:
	INT_OFF;
	funcnest--;
	freefunc(func);
	poplocalvars();
	localvars = savelocalvars;
	freeparam(&shellparam);
	shellparam = saveparam;
	exception_handler = savehandler;
	INT_ON;
	evalskip &= ~SKIPFUNC;
	return e;
}

/*
 * Make a variable a local variable.  When a variable is made local, it's
 * value and flags are saved in a localvar structure.  The saved values
 * will be restored when the shell function returns.  We handle the name
 * "-" as a special case: it makes changes to "set +-options" local
 * (options will be restored on return from the function).
 */
static void
mklocal(char *name)
{
	struct localvar *lvp;
	struct var **vpp;
	struct var *vp;
	char *eq = strchr(name, '=');

	INT_OFF;
	/* Cater for duplicate "local". Examples:
	 * x=0; f() { local x=1; echo $x; local x; echo $x; }; f; echo $x
	 * x=0; f() { local x=1; echo $x; local x=2; echo $x; }; f; echo $x
	 */
	lvp = localvars;
	while (lvp) {
		if (lvp->vp && varcmp(lvp->vp->var_text, name) == 0) {
			if (eq)
				setvareq(name, 0);
			/* else:
			 * it's a duplicate "local VAR" declaration, do nothing
			 */
			goto ret;
		}
		lvp = lvp->next;
	}

	lvp = ckzalloc(sizeof(*lvp));
	if (LONE_DASH(name)) {
		char *p;
		p = ckmalloc(sizeof(optlist));
		lvp->text = memcpy(p, optlist, sizeof(optlist));
		vp = NULL;
	} else {
		vpp = hashvar(name);
		vp = *findvar(vpp, name);
		if (vp == NULL) {
			/* variable did not exist yet */
			if (eq)
				setvareq(name, VSTRFIXED);
			else
				setvar(name, NULL, VSTRFIXED);
			vp = *vpp;      /* the new variable */
			lvp->flags = VUNSET;
		} else {
			lvp->text = vp->var_text;
			lvp->flags = vp->flags;
			/* make sure neither "struct var" nor string gets freed
			 * during (un)setting:
			 */
			vp->flags |= VSTRFIXED|VTEXTFIXED;
			if (eq)
				setvareq(name, 0);
			else
				/* "local VAR" unsets VAR: */
				setvar0(name, NULL);
		}
	}
	lvp->vp = vp;
	lvp->next = localvars;
	localvars = lvp;
 ret:
	INT_ON;
}

/*
 * The "local" command.
 */
static int FAST_FUNC
localcmd(int argc UNUSED_PARAM, char **argv)
{
	char *name;

	if (!funcnest)
		ash_msg_and_raise_error("not in a function");

	argv = argptr;
	while ((name = *argv++) != NULL) {
		mklocal(name);
	}
	return 0;
}

static int FAST_FUNC
falsecmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
{
	return 1;
}

static int FAST_FUNC
truecmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
{
	return 0;
}

static int FAST_FUNC
execcmd(int argc UNUSED_PARAM, char **argv)
{
	if (argv[1]) {
		iflag = 0;              /* exit on error */
		mflag = 0;
		optschanged();
		/* We should set up signals for "exec CMD"
		 * the same way as for "CMD" without "exec".
		 * But optschanged->setinteractive->setsignal
		 * still thought we are a root shell. Therefore, for example,
		 * SIGQUIT is still set to IGN. Fix it:
		 */
		shlvl++;
		setsignal(SIGQUIT);
		/*setsignal(SIGTERM); - unnecessary because of iflag=0 */
		/*setsignal(SIGTSTP); - unnecessary because of mflag=0 */
		/*setsignal(SIGTTOU); - unnecessary because of mflag=0 */

		shellexec(argv + 1, pathval(), 0);
		/* NOTREACHED */
	}
	return 0;
}

/*
 * The return command.
 */
static int FAST_FUNC
returncmd(int argc UNUSED_PARAM, char **argv)
{
	/*
	 * If called outside a function, do what ksh does;
	 * skip the rest of the file.
	 */
	evalskip = SKIPFUNC;
	return argv[1] ? number(argv[1]) : exitstatus;
}

/* Forward declarations for builtintab[] */
static int breakcmd(int, char **) FAST_FUNC;
static int dotcmd(int, char **) FAST_FUNC;
static int evalcmd(int, char **, int) FAST_FUNC;
static int exitcmd(int, char **) FAST_FUNC;
static int exportcmd(int, char **) FAST_FUNC;
#if ENABLE_ASH_GETOPTS
static int getoptscmd(int, char **) FAST_FUNC;
#endif
# 9273 "shell/ash.c"
#if ENABLE_ASH_HELP
static int helpcmd(int, char **) FAST_FUNC;
#endif
# 9276 "shell/ash.c"
#if MAX_HISTORY
static int historycmd(int, char **) FAST_FUNC;
#endif
# 9279 "shell/ash.c"
#if ENABLE_FEATURE_SH_MATH
static int letcmd(int, char **) FAST_FUNC;
#endif
# 9282 "shell/ash.c"
static int readcmd(int, char **) FAST_FUNC;
static int setcmd(int, char **) FAST_FUNC;
static int shiftcmd(int, char **) FAST_FUNC;
static int timescmd(int, char **) FAST_FUNC;
static int trapcmd(int, char **) FAST_FUNC;
static int umaskcmd(int, char **) FAST_FUNC;
static int unsetcmd(int, char **) FAST_FUNC;
static int ulimitcmd(int, char **) FAST_FUNC;

#define BUILTIN_NOSPEC          "0"
#define BUILTIN_SPECIAL         "1"
#define BUILTIN_REGULAR         "2"
#define BUILTIN_SPEC_REG        "3"
#define BUILTIN_ASSIGN          "4"
#define BUILTIN_SPEC_ASSG       "5"
#define BUILTIN_REG_ASSG        "6"
#define BUILTIN_SPEC_REG_ASSG   "7"

/* Stubs for calling non-FAST_FUNC's */
#if ENABLE_ASH_BUILTIN_ECHO
static int FAST_FUNC echocmd(int argc, char **argv)   { return echo_main(argc, argv); }
#endif
# 9304 "shell/ash.c"
#if ENABLE_ASH_BUILTIN_PRINTF
static int FAST_FUNC printfcmd(int argc, char **argv) { return printf_main(argc, argv); }
#endif
# 9307 "shell/ash.c"
#if ENABLE_ASH_BUILTIN_TEST
static int FAST_FUNC testcmd(int argc, char **argv)   { return test_main(argc, argv); }
#endif
# 9310 "shell/ash.c"

/* Keep these in proper order since it is searched via bsearch() */
static const struct builtincmd builtintab[] = {
	{ BUILTIN_SPEC_REG      "."       , dotcmd     },
	{ BUILTIN_SPEC_REG      ":"       , truecmd    },
#if ENABLE_ASH_BUILTIN_TEST
	{ BUILTIN_REGULAR       "["       , testcmd    },
# if ENABLE_ASH_BASH_COMPAT
	{ BUILTIN_REGULAR       "[["      , testcmd    },
# endif
# 9320 "shell/ash.c"
#endif
# 9321 "shell/ash.c"
#if ENABLE_ASH_ALIAS
	{ BUILTIN_REG_ASSG      "alias"   , aliascmd   },
#endif
# 9324 "shell/ash.c"
#if JOBS
	{ BUILTIN_REGULAR       "bg"      , fg_bgcmd   },
#endif
# 9327 "shell/ash.c"
	{ BUILTIN_SPEC_REG      "break"   , breakcmd   },
	{ BUILTIN_REGULAR       "cd"      , cdcmd      },
	{ BUILTIN_NOSPEC        "chdir"   , cdcmd      },
#if ENABLE_ASH_CMDCMD
	{ BUILTIN_REGULAR       "command" , commandcmd },
#endif
# 9333 "shell/ash.c"
	{ BUILTIN_SPEC_REG      "continue", breakcmd   },
#if ENABLE_ASH_BUILTIN_ECHO
	{ BUILTIN_REGULAR       "echo"    , echocmd    },
#endif
# 9337 "shell/ash.c"
	{ BUILTIN_SPEC_REG      "eval"    , NULL       }, /*evalcmd() has a differing prototype*/
	{ BUILTIN_SPEC_REG      "exec"    , execcmd    },
	{ BUILTIN_SPEC_REG      "exit"    , exitcmd    },
	{ BUILTIN_SPEC_REG_ASSG "export"  , exportcmd  },
	{ BUILTIN_REGULAR       "false"   , falsecmd   },
#if JOBS
	{ BUILTIN_REGULAR       "fg"      , fg_bgcmd   },
#endif
# 9345 "shell/ash.c"
#if ENABLE_ASH_GETOPTS
	{ BUILTIN_REGULAR       "getopts" , getoptscmd },
#endif
# 9348 "shell/ash.c"
	{ BUILTIN_NOSPEC        "hash"    , hashcmd    },
#if ENABLE_ASH_HELP
	{ BUILTIN_NOSPEC        "help"    , helpcmd    },
#endif
# 9352 "shell/ash.c"
#if MAX_HISTORY
	{ BUILTIN_NOSPEC        "history" , historycmd },
#endif
# 9355 "shell/ash.c"
#if JOBS
	{ BUILTIN_REGULAR       "jobs"    , jobscmd    },
	{ BUILTIN_REGULAR       "kill"    , killcmd    },
#endif
# 9359 "shell/ash.c"
#if ENABLE_FEATURE_SH_MATH
	{ BUILTIN_NOSPEC        "let"     , letcmd     },
#endif
# 9362 "shell/ash.c"
	{ BUILTIN_ASSIGN        "local"   , localcmd   },
#if ENABLE_ASH_BUILTIN_PRINTF
	{ BUILTIN_REGULAR       "printf"  , printfcmd  },
#endif
# 9366 "shell/ash.c"
	{ BUILTIN_NOSPEC        "pwd"     , pwdcmd     },
	{ BUILTIN_REGULAR       "read"    , readcmd    },
	{ BUILTIN_SPEC_REG_ASSG "readonly", exportcmd  },
	{ BUILTIN_SPEC_REG      "return"  , returncmd  },
	{ BUILTIN_SPEC_REG      "set"     , setcmd     },
	{ BUILTIN_SPEC_REG      "shift"   , shiftcmd   },
#if ENABLE_ASH_BASH_COMPAT
	{ BUILTIN_SPEC_REG      "source"  , dotcmd     },
#endif
# 9375 "shell/ash.c"
#if ENABLE_ASH_BUILTIN_TEST
	{ BUILTIN_REGULAR       "test"    , testcmd    },
#endif
# 9378 "shell/ash.c"
	{ BUILTIN_SPEC_REG      "times"   , timescmd   },
	{ BUILTIN_SPEC_REG      "trap"    , trapcmd    },
	{ BUILTIN_REGULAR       "true"    , truecmd    },
	{ BUILTIN_NOSPEC        "type"    , typecmd    },
	{ BUILTIN_NOSPEC        "ulimit"  , ulimitcmd  },
	{ BUILTIN_REGULAR       "umask"   , umaskcmd   },
#if ENABLE_ASH_ALIAS
	{ BUILTIN_REGULAR       "unalias" , unaliascmd },
#endif
# 9387 "shell/ash.c"
	{ BUILTIN_SPEC_REG      "unset"   , unsetcmd   },
	{ BUILTIN_REGULAR       "wait"    , waitcmd    },
};

/* Should match the above table! */
#define COMMANDCMD (builtintab + \
	/* . : */	2 + \
	/* [ */		1 * ENABLE_ASH_BUILTIN_TEST + \
	/* [[ */	1 * ENABLE_ASH_BUILTIN_TEST * ENABLE_ASH_BASH_COMPAT + \
	/* alias */	1 * ENABLE_ASH_ALIAS + \
	/* bg */	1 * ENABLE_ASH_JOB_CONTROL + \
	/* break cd cddir  */	3)
#define EVALCMD (COMMANDCMD + \
	/* command */	1 * ENABLE_ASH_CMDCMD + \
	/* continue */	1 + \
	/* echo */	1 * ENABLE_ASH_BUILTIN_ECHO + \
	0)
#define EXECCMD (EVALCMD + \
	/* eval */	1)

/*
 * Search the table of builtin commands.
 */
static int
pstrcmp1(const void *a, const void *b)
{
	return strcmp((char*)a, *(char**)b + 1);
}
static struct builtincmd *
find_builtin(const char *name)
{
	struct builtincmd *bp;

	bp = bsearch(
		name, builtintab, ARRAY_SIZE(builtintab), sizeof(builtintab[0]),
		pstrcmp1
	);
	return bp;
}

/*
 * Execute a simple command.
 */
static int
isassignment(const char *p)
{
	const char *q = endofname(p);
	if (p == q)
		return 0;
	return *q == '=';
}
static int FAST_FUNC
bltincmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
{
	/* Preserve exitstatus of a previous possible redirection
	 * as POSIX mandates */
	return back_exitstatus;
}
static int
evalcommand(union node *cmd, int flags)
{
	static const struct builtincmd null_bltin = {
		"\0\0", bltincmd /* why three NULs? */
	};
	struct stackmark smark;
	union node *argp;
	struct arglist arglist;
	struct arglist varlist;
	char **argv;
	int argc;
	const struct strlist *sp;
	struct cmdentry cmdentry;
	struct job *jp;
	char *lastarg;
	const char *path;
	int spclbltin;
	int status;
	char **nargv;
	struct builtincmd *bcmd;
	smallint cmd_is_exec;
	smallint pseudovarflag = 0;

	/* First expand the arguments. */
	TRACE(("evalcommand(0x%lx, %d) called\n", (long)cmd, flags));
	setstackmark(&smark);
	back_exitstatus = 0;

	cmdentry.cmdtype = CMDBUILTIN;
	cmdentry.u.cmd = &null_bltin;
	varlist.lastp = &varlist.list;
	*varlist.lastp = NULL;
	arglist.lastp = &arglist.list;
	*arglist.lastp = NULL;

	argc = 0;
	if (cmd->ncmd.args) {
		bcmd = find_builtin(cmd->ncmd.args->narg.text);
		pseudovarflag = bcmd && IS_BUILTIN_ASSIGN(bcmd);
	}

	for (argp = cmd->ncmd.args; argp; argp = argp->narg.next) {
		struct strlist **spp;

		spp = arglist.lastp;
		if (pseudovarflag && isassignment(argp->narg.text))
			expandarg(argp, &arglist, EXP_VARTILDE);
		else
			expandarg(argp, &arglist, EXP_FULL | EXP_TILDE);

		for (sp = *spp; sp; sp = sp->next)
			argc++;
	}

	/* Reserve one extra spot at the front for shellexec. */
	nargv = stalloc(sizeof(char *) * (argc + 2));
	argv = ++nargv;
	for (sp = arglist.list; sp; sp = sp->next) {
		TRACE(("evalcommand arg: %s\n", sp->text));
		*nargv++ = sp->text;
	}
	*nargv = NULL;

	lastarg = NULL;
	if (iflag && funcnest == 0 && argc > 0)
		lastarg = nargv[-1];

	preverrout_fd = 2;
	expredir(cmd->ncmd.redirect);
	status = redirectsafe(cmd->ncmd.redirect, REDIR_PUSH | REDIR_SAVEFD2);

	path = vpath.var_text;
	for (argp = cmd->ncmd.assign; argp; argp = argp->narg.next) {
		struct strlist **spp;
		char *p;

		spp = varlist.lastp;
		expandarg(argp, &varlist, EXP_VARTILDE);

		/*
		 * Modify the command lookup path, if a PATH= assignment
		 * is present
		 */
		p = (*spp)->text;
		if (varcmp(p, path) == 0)
			path = p;
	}

	/* Print the command if xflag is set. */
	if (xflag) {
		int n;
		const char *p = " %s" + 1;

		fdprintf(preverrout_fd, p, expandstr(ps4val()));
		sp = varlist.list;
		for (n = 0; n < 2; n++) {
			while (sp) {
				fdprintf(preverrout_fd, p, sp->text);
				sp = sp->next;
				p = " %s";
			}
			sp = arglist.list;
		}
		safe_write(preverrout_fd, "\n", 1);
	}

	cmd_is_exec = 0;
	spclbltin = -1;

	/* Now locate the command. */
	if (argc) {
		int cmd_flag = DO_ERR;
#if ENABLE_ASH_CMDCMD
		const char *oldpath = path + 5;
#endif
# 9561 "shell/ash.c"
		path += 5;
		for (;;) {
			find_command(argv[0], &cmdentry, cmd_flag, path);
			if (cmdentry.cmdtype == CMDUNKNOWN) {
				flush_stdout_stderr();
				status = 127;
				goto bail;
			}

			/* implement bltin and command here */
			if (cmdentry.cmdtype != CMDBUILTIN)
				break;
			if (spclbltin < 0)
				spclbltin = IS_BUILTIN_SPECIAL(cmdentry.u.cmd);
			if (cmdentry.u.cmd == EXECCMD)
				cmd_is_exec = 1;
#if ENABLE_ASH_CMDCMD
			if (cmdentry.u.cmd == COMMANDCMD) {
				path = oldpath;
				nargv = parse_command_args(argv, &path);
				if (!nargv)
					break;
				/* It's "command [-p] PROG ARGS" (that is, no -Vv).
				 * nargv => "PROG". path is updated if -p.
				 */
				argc -= nargv - argv;
				argv = nargv;
				cmd_flag |= DO_NOFUNC;
			} else
#endif
# 9591 "shell/ash.c"
				break;
		}
	}

	if (status) {
 bail:
		exitstatus = status;

		/* We have a redirection error. */
		if (spclbltin > 0)
			raise_exception(EXERROR);

		goto out;
	}

	/* Execute the command. */
	switch (cmdentry.cmdtype) {
	default: {

#if ENABLE_FEATURE_SH_NOFORK
/* (1) BUG: if variables are set, we need to fork, or save/restore them
 *     around run_nofork_applet() call.
 * (2) Should this check also be done in forkshell()?
 *     (perhaps it should, so that "VAR=VAL nofork" at least avoids exec...)
 */
		/* find_command() encodes applet_no as (-2 - applet_no) */
		int applet_no = (- cmdentry.u.index - 2);
		if (applet_no >= 0 && APPLET_IS_NOFORK(applet_no)) {
			listsetvar(varlist.list, VEXPORT|VSTACK);
			/* run <applet>_main() */
			status = run_nofork_applet(applet_no, argv);
			break;
		}
#endif
# 9625 "shell/ash.c"
		/* Can we avoid forking off? For example, very last command
		 * in a script or a subshell does not need forking,
		 * we can just exec it.
		 */
		if (!(flags & EV_EXIT) || may_have_traps) {
			/* No, forking off a child is necessary */
			INT_OFF;
			jp = makejob(/*cmd,*/ 1);
			if (forkshell(jp, cmd, FORK_FG) != 0) {
				/* parent */
				status = waitforjob(jp);
				INT_ON;
				TRACE(("forked child exited with %d\n", status));
				break;
			}
			/* child */
			FORCE_INT_ON;
			/* fall through to exec'ing external program */
		}
		listsetvar(varlist.list, VEXPORT|VSTACK);
		shellexec(argv, path, cmdentry.u.index);
		/* NOTREACHED */
	} /* default */
	case CMDBUILTIN:
		cmdenviron = varlist.list;
		if (cmdenviron) {
			struct strlist *list = cmdenviron;
			int i = VNOSET;
			if (spclbltin > 0 || argc == 0) {
				i = 0;
				if (cmd_is_exec && argc > 1)
					i = VEXPORT;
			}
			listsetvar(list, i);
		}
		/* Tight loop with builtins only:
		 * "while kill -0 $child; do true; done"
		 * will never exit even if $child died, unless we do this
		 * to reap the zombie and make kill detect that it's gone: */
		dowait(DOWAIT_NONBLOCK, NULL);

		if (evalbltin(cmdentry.u.cmd, argc, argv, flags)) {
			if (exception_type == EXERROR && spclbltin <= 0) {
				FORCE_INT_ON;
				goto readstatus;
			}
 raise:
			longjmp(exception_handler->loc, 1);
		}
		goto readstatus;

	case CMDFUNCTION:
		listsetvar(varlist.list, 0);
		/* See above for the rationale */
		dowait(DOWAIT_NONBLOCK, NULL);
		if (evalfun(cmdentry.u.func, argc, argv, flags))
			goto raise;
 readstatus:
		status = exitstatus;
		break;
	} /* switch */

 out:
	if (cmd->ncmd.redirect)
		popredir(/*drop:*/ cmd_is_exec, /*restore:*/ cmd_is_exec);
	if (lastarg) {
		/* dsl: I think this is intended to be used to support
		 * '_' in 'vi' command mode during line editing...
		 * However I implemented that within libedit itself.
		 */
		setvar0("_", lastarg);
	}
	popstackmark(&smark);

	return status;
}

static int
evalbltin(const struct builtincmd *cmd, int argc, char **argv, int flags)
{
	char *volatile savecmdname;
	struct jmploc *volatile savehandler;
	struct jmploc jmploc;
	int status;
	int i;

	savecmdname = commandname;
	savehandler = exception_handler;
	i = setjmp(jmploc.loc);
	if (i)
		goto cmddone;
	exception_handler = &jmploc;
	commandname = argv[0];
	argptr = argv + 1;
	optptr = NULL;                  /* initialize nextopt */
	if (cmd == EVALCMD)
		status = evalcmd(argc, argv, flags);
	else
		status = (*cmd->builtin)(argc, argv);
	flush_stdout_stderr();
	status |= ferror(stdout);
	exitstatus = status;
 cmddone:
	clearerr(stdout);
	commandname = savecmdname;
	exception_handler = savehandler;

	return i;
}

static int
goodname(const char *p)
{
	return endofname(p)[0] == '\0';
}


/*
 * Search for a command.  This is called before we fork so that the
 * location of the command will be available in the parent as well as
 * the child.  The check for "goodname" is an overly conservative
 * check that the name will not be subject to expansion.
 */
static void
prehash(union node *n)
{
	struct cmdentry entry;

	if (n->type == NCMD && n->ncmd.args && goodname(n->ncmd.args->narg.text))
		find_command(n->ncmd.args->narg.text, &entry, 0, pathval());
}


/* ============ Builtin commands
 *
 * Builtin commands whose functions are closely tied to evaluation
 * are implemented here.
 */

/*
 * Handle break and continue commands.  Break, continue, and return are
 * all handled by setting the evalskip flag.  The evaluation routines
 * above all check this flag, and if it is set they start skipping
 * commands rather than executing them.  The variable skipcount is
 * the number of loops to break/continue, or the number of function
 * levels to return.  (The latter is always 1.)  It should probably
 * be an error to break out of more loops than exist, but it isn't
 * in the standard shell so we don't make it one here.
 */
static int FAST_FUNC
breakcmd(int argc UNUSED_PARAM, char **argv)
{
	int n = argv[1] ? number(argv[1]) : 1;

	if (n <= 0)
		ash_msg_and_raise_error(msg_illnum, argv[1]);
	if (n > loopnest)
		n = loopnest;
	if (n > 0) {
		evalskip = (**argv == 'c') ? SKIPCONT : SKIPBREAK;
		skipcount = n;
	}
	return 0;
}


/*
 * This implements the input routines used by the parser.
 */

enum {
	INPUT_PUSH_FILE = 1,
	INPUT_NOFILE_OK = 2,
};

static smallint checkkwd;
/* values of checkkwd variable */
#define CHKALIAS        0x1
#define CHKKWD          0x2
#define CHKNL           0x4

/*
 * Push a string back onto the input at this current parsefile level.
 * We handle aliases this way.
 */
#if !ENABLE_ASH_ALIAS
#define pushstring(s, ap) pushstring(s)
#endif
# 9813 "shell/ash.c"
static void
pushstring(char *s, struct alias *ap)
{
	struct strpush *sp;
	int len;

	len = strlen(s);
	INT_OFF;
	if (g_parsefile->strpush) {
		sp = ckzalloc(sizeof(*sp));
		sp->prev = g_parsefile->strpush;
	} else {
		sp = &(g_parsefile->basestrpush);
	}
	g_parsefile->strpush = sp;
	sp->prev_string = g_parsefile->next_to_pgetc;
	sp->prev_left_in_line = g_parsefile->left_in_line;
	sp->unget = g_parsefile->unget;
	memcpy(sp->lastc, g_parsefile->lastc, sizeof(sp->lastc));
#if ENABLE_ASH_ALIAS
	sp->ap = ap;
	if (ap) {
		ap->flag |= ALIASINUSE;
		sp->string = s;
	}
#endif
# 9839 "shell/ash.c"
	g_parsefile->next_to_pgetc = s;
	g_parsefile->left_in_line = len;
	g_parsefile->unget = 0;
	INT_ON;
}

static void
popstring(void)
{
	struct strpush *sp = g_parsefile->strpush;

	INT_OFF;
#if ENABLE_ASH_ALIAS
	if (sp->ap) {
		if (g_parsefile->next_to_pgetc[-1] == ' '
		 || g_parsefile->next_to_pgetc[-1] == '\t'
		) {
			checkkwd |= CHKALIAS;
		}
		if (sp->string != sp->ap->val) {
			free(sp->string);
		}
		sp->ap->flag &= ~ALIASINUSE;
		if (sp->ap->flag & ALIASDEAD) {
			unalias(sp->ap->name);
		}
	}
#endif
# 9867 "shell/ash.c"
	g_parsefile->next_to_pgetc = sp->prev_string;
	g_parsefile->left_in_line = sp->prev_left_in_line;
	g_parsefile->unget = sp->unget;
	memcpy(g_parsefile->lastc, sp->lastc, sizeof(sp->lastc));
	g_parsefile->strpush = sp->prev;
	if (sp != &(g_parsefile->basestrpush))
		free(sp);
	INT_ON;
}

static int
preadfd(void)
{
	int nr;
	char *buf = g_parsefile->buf;

	g_parsefile->next_to_pgetc = buf;
#if ENABLE_FEATURE_EDITING
 retry:
	if (!iflag || g_parsefile->pf_fd != STDIN_FILENO)
		nr = nonblock_immune_read(g_parsefile->pf_fd, buf, IBUFSIZ - 1);
	else {
		int timeout = -1;
# if ENABLE_ASH_IDLE_TIMEOUT
		if (iflag) {
			const char *tmout_var = lookupvar("TMOUT");
			if (tmout_var) {
				timeout = atoi(tmout_var) * 1000;
				if (timeout <= 0)
					timeout = -1;
			}
		}
# endif
# 9900 "shell/ash.c"
# if ENABLE_FEATURE_TAB_COMPLETION
		line_input_state->path_lookup = pathval();
# endif
# 9903 "shell/ash.c"
		reinit_unicode_for_ash();
		nr = read_line_input(line_input_state, cmdedit_prompt, buf, IBUFSIZ, timeout);
		if (nr == 0) {
			/* ^C pressed, "convert" to SIGINT */
			write(STDOUT_FILENO, "^C", 2);
			if (trap[SIGINT]) {
				buf[0] = '\n';
				buf[1] = '\0';
				raise(SIGINT);
				return 1;
			}
			exitstatus = 128 + SIGINT;
			bb_putchar('\n');
			goto retry;
		}
		if (nr < 0) {
			if (errno == 0) {
				/* Ctrl+D pressed */
				nr = 0;
			}
# if ENABLE_ASH_IDLE_TIMEOUT
			else if (errno == EAGAIN && timeout > 0) {
				puts("\007timed out waiting for input: auto-logout");
				exitshell();
			}
# endif
# 9929 "shell/ash.c"
		}
	}
#else
# 9932 "shell/ash.c"
	nr = nonblock_immune_read(g_parsefile->pf_fd, buf, IBUFSIZ - 1);
#endif
# 9934 "shell/ash.c"

#if 0 /* disabled: nonblock_immune_read() handles this problem */
	if (nr < 0) {
		if (parsefile->fd == 0 && errno == EWOULDBLOCK) {
			int flags = fcntl(0, F_GETFL);
			if (flags >= 0 && (flags & O_NONBLOCK)) {
				flags &= ~O_NONBLOCK;
				if (fcntl(0, F_SETFL, flags) >= 0) {
					out2str("sh: turning off NDELAY mode\n");
					goto retry;
				}
			}
		}
	}
#endif
# 9949 "shell/ash.c"
	return nr;
}

/*
 * Refill the input buffer and return the next input character:
 *
 * 1) If a string was pushed back on the input, pop it;
 * 2) If an EOF was pushed back (g_parsefile->left_in_line < -BIGNUM)
 *    or we are reading from a string so we can't refill the buffer,
 *    return EOF.
 * 3) If there is more stuff in this buffer, use it else call read to fill it.
 * 4) Process input up to the next newline, deleting nul characters.
 */
//#define pgetc_debug(...) bb_error_msg(__VA_ARGS__)
#define pgetc_debug(...) ((void)0)
static int pgetc(void);
static int
preadbuffer(void)
{
	char *q;
	int more;

	if (g_parsefile->strpush) {
#if ENABLE_ASH_ALIAS
		if (g_parsefile->left_in_line == -1
		 && g_parsefile->strpush->ap
		 && g_parsefile->next_to_pgetc[-1] != ' '
		 && g_parsefile->next_to_pgetc[-1] != '\t'
		) {
			pgetc_debug("preadbuffer PEOA");
			return PEOA;
		}
#endif
# 9982 "shell/ash.c"
		popstring();
		return pgetc();
	}
	/* on both branches above g_parsefile->left_in_line < 0.
	 * "pgetc" needs refilling.
	 */

	/* -90 is our -BIGNUM. Below we use -99 to mark "EOF on read",
	 * pungetc() may increment it a few times.
	 * Assuming it won't increment it to less than -90.
	 */
	if (g_parsefile->left_in_line < -90 || g_parsefile->buf == NULL) {
		pgetc_debug("preadbuffer PEOF1");
		/* even in failure keep left_in_line and next_to_pgetc
		 * in lock step, for correct multi-layer pungetc.
		 * left_in_line was decremented before preadbuffer(),
		 * must inc next_to_pgetc: */
		g_parsefile->next_to_pgetc++;
		return PEOF;
	}

	more = g_parsefile->left_in_buffer;
	if (more <= 0) {
		flush_stdout_stderr();
 again:
		more = preadfd();
		if (more <= 0) {
			/* don't try reading again */
			g_parsefile->left_in_line = -99;
			pgetc_debug("preadbuffer PEOF2");
			g_parsefile->next_to_pgetc++;
			return PEOF;
		}
	}

	/* Find out where's the end of line.
	 * Set g_parsefile->left_in_line
	 * and g_parsefile->left_in_buffer acordingly.
	 * NUL chars are deleted.
	 */
	q = g_parsefile->next_to_pgetc;
	for (;;) {
		char c;

		more--;

		c = *q;
		if (c == '\0') {
			memmove(q, q + 1, more);
		} else {
			q++;
			if (c == '\n') {
				g_parsefile->left_in_line = q - g_parsefile->next_to_pgetc - 1;
				break;
			}
		}

		if (more <= 0) {
			g_parsefile->left_in_line = q - g_parsefile->next_to_pgetc - 1;
			if (g_parsefile->left_in_line < 0)
				goto again;
			break;
		}
	}
	g_parsefile->left_in_buffer = more;

	if (vflag) {
		char save = *q;
		*q = '\0';
		out2str(g_parsefile->next_to_pgetc);
		*q = save;
	}

	pgetc_debug("preadbuffer at %d:%p'%s'",
			g_parsefile->left_in_line,
			g_parsefile->next_to_pgetc,
			g_parsefile->next_to_pgetc);
	return (unsigned char)*g_parsefile->next_to_pgetc++;
}

static void
nlprompt(void)
{
	g_parsefile->linno++;
	setprompt_if(doprompt, 2);
}
static void
nlnoprompt(void)
{
	g_parsefile->linno++;
	needprompt = doprompt;
}

static int
pgetc(void)
{
	int c;

	pgetc_debug("pgetc at %d:%p'%s'",
			g_parsefile->left_in_line,
			g_parsefile->next_to_pgetc,
			g_parsefile->next_to_pgetc);
	if (g_parsefile->unget)
		return g_parsefile->lastc[--g_parsefile->unget];

	if (--g_parsefile->left_in_line >= 0)
		c = (unsigned char)*g_parsefile->next_to_pgetc++;
	else
		c = preadbuffer();

	g_parsefile->lastc[1] = g_parsefile->lastc[0];
	g_parsefile->lastc[0] = c;

	return c;
}

#if ENABLE_ASH_ALIAS
static int
pgetc_without_PEOA(void)
{
	int c;
	do {
		pgetc_debug("pgetc at %d:%p'%s'",
				g_parsefile->left_in_line,
				g_parsefile->next_to_pgetc,
				g_parsefile->next_to_pgetc);
		c = pgetc();
	} while (c == PEOA);
	return c;
}
#else
# 10113 "shell/ash.c"
# define pgetc_without_PEOA() pgetc()
#endif
# 10115 "shell/ash.c"

/*
 * Read a line from the script.
 */
static char *
pfgets(char *line, int len)
{
	char *p = line;
	int nleft = len;
	int c;

	while (--nleft > 0) {
		c = pgetc_without_PEOA();
		if (c == PEOF) {
			if (p == line)
				return NULL;
			break;
		}
		*p++ = c;
		if (c == '\n')
			break;
	}
	*p = '\0';
	return line;
}

/*
 * Undo a call to pgetc.  Only two characters may be pushed back.
 * PEOF may be pushed back.
 */
static void
pungetc(void)
{
	g_parsefile->unget++;
}

/* This one eats backslash+newline */
static int
pgetc_eatbnl(void)
{
	int c;

	while ((c = pgetc()) == '\\') {
		if (pgetc() != '\n') {
			pungetc();
			break;
		}

		nlprompt();
	}

	return c;
}

/*
 * To handle the "." command, a stack of input files is used.  Pushfile
 * adds a new entry to the stack and popfile restores the previous level.
 */
static void
pushfile(void)
{
	struct parsefile *pf;

	pf = ckzalloc(sizeof(*pf));
	pf->prev = g_parsefile;
	pf->pf_fd = -1;
	/*pf->strpush = NULL; - ckzalloc did it */
	/*pf->basestrpush.prev = NULL;*/
	/*pf->unget = 0;*/
	g_parsefile = pf;
}

static void
popfile(void)
{
	struct parsefile *pf = g_parsefile;

	if (pf == &basepf)
		return;

	INT_OFF;
	if (pf->pf_fd >= 0)
		close(pf->pf_fd);
	free(pf->buf);
	while (pf->strpush)
		popstring();
	g_parsefile = pf->prev;
	free(pf);
	INT_ON;
}

/*
 * Return to top level.
 */
static void
popallfiles(void)
{
	while (g_parsefile != &basepf)
		popfile();
}

/*
 * Close the file(s) that the shell is reading commands from.  Called
 * after a fork is done.
 */
static void
closescript(void)
{
	popallfiles();
	if (g_parsefile->pf_fd > 0) {
		close(g_parsefile->pf_fd);
		g_parsefile->pf_fd = 0;
	}
}

/*
 * Like setinputfile, but takes an open file descriptor.  Call this with
 * interrupts off.
 */
static void
setinputfd(int fd, int push)
{
	if (push) {
		pushfile();
		g_parsefile->buf = NULL;
	}
	g_parsefile->pf_fd = fd;
	if (g_parsefile->buf == NULL)
		g_parsefile->buf = ckmalloc(IBUFSIZ);
	g_parsefile->left_in_buffer = 0;
	g_parsefile->left_in_line = 0;
	g_parsefile->linno = 1;
}

/*
 * Set the input to take input from a file.  If push is set, push the
 * old input onto the stack first.
 */
static int
setinputfile(const char *fname, int flags)
{
	int fd;

	INT_OFF;
	fd = open(fname, O_RDONLY);
	if (fd < 0) {
		if (flags & INPUT_NOFILE_OK)
			goto out;
		exitstatus = 127;
		ash_msg_and_raise_error("can't open '%s'", fname);
	}
	if (fd < 10)
		fd = savefd(fd);
	else
		close_on_exec_on(fd);
	setinputfd(fd, flags & INPUT_PUSH_FILE);
 out:
	INT_ON;
	return fd;
}

/*
 * Like setinputfile, but takes input from a string.
 */
static void
setinputstring(char *string)
{
	INT_OFF;
	pushfile();
	g_parsefile->next_to_pgetc = string;
	g_parsefile->left_in_line = strlen(string);
	g_parsefile->buf = NULL;
	g_parsefile->linno = 1;
	INT_ON;
}


/*
 * Routines to check for mail.
 */

#if ENABLE_ASH_MAIL

/* Hash of mtimes of mailboxes */
static unsigned mailtime_hash;
/* Set if MAIL or MAILPATH is changed. */
static smallint mail_var_path_changed;

/*
 * Print appropriate message(s) if mail has arrived.
 * If mail_var_path_changed is set,
 * then the value of MAIL has mail_var_path_changed,
 * so we just update the values.
 */
static void
chkmail(void)
{
	const char *mpath;
	char *p;
	char *q;
	unsigned new_hash;
	struct stackmark smark;
	struct stat statb;

	setstackmark(&smark);
	mpath = mpathset() ? mpathval() : mailval();
	new_hash = 0;
	for (;;) {
		p = path_advance(&mpath, nullstr);
		if (p == NULL)
			break;
		if (*p == '\0')
			continue;
		for (q = p; *q; q++)
			continue;
#if DEBUG
		if (q[-1] != '/')
			abort();
#endif
# 10334 "shell/ash.c"
		q[-1] = '\0';                   /* delete trailing '/' */
		if (stat(p, &statb) < 0) {
			continue;
		}
		/* Very simplistic "hash": just a sum of all mtimes */
		new_hash += (unsigned)statb.st_mtime;
	}
	if (!mail_var_path_changed && mailtime_hash != new_hash) {
		if (mailtime_hash != 0)
			out2str("you have mail\n");
		mailtime_hash = new_hash;
	}
	mail_var_path_changed = 0;
	popstackmark(&smark);
}

static void FAST_FUNC
changemail(const char *val UNUSED_PARAM)
{
	mail_var_path_changed = 1;
}

#endif /* ASH_MAIL */
# 10357 "shell/ash.c"


/* ============ ??? */

/*
 * Set the shell parameters.
 */
static void
setparam(char **argv)
{
	char **newparam;
	char **ap;
	int nparam;

	for (nparam = 0; argv[nparam]; nparam++)
		continue;
	ap = newparam = ckmalloc((nparam + 1) * sizeof(*ap));
	while (*argv) {
		*ap++ = ckstrdup(*argv++);
	}
	*ap = NULL;
	freeparam(&shellparam);
	shellparam.malloced = 1;
	shellparam.nparam = nparam;
	shellparam.p = newparam;
#if ENABLE_ASH_GETOPTS
	shellparam.optind = 1;
	shellparam.optoff = -1;
#endif
# 10386 "shell/ash.c"
}

/*
 * Process shell options.  The global variable argptr contains a pointer
 * to the argument list; we advance it past the options.
 *
 * SUSv3 section 2.8.1 "Consequences of Shell Errors" says:
 * For a non-interactive shell, an error condition encountered
 * by a special built-in ... shall cause the shell to write a diagnostic message
 * to standard error and exit as shown in the following table:
 * Error                                           Special Built-In
 * ...
 * Utility syntax error (option or operand error)  Shall exit
 * ...
 * However, in bug 1142 (http://busybox.net/bugs/view.php?id=1142)
 * we see that bash does not do that (set "finishes" with error code 1 instead,
 * and shell continues), and people rely on this behavior!
 * Testcase:
 * set -o barfoo 2>/dev/null
 * echo $?
 *
 * Oh well. Let's mimic that.
 */
static int
plus_minus_o(char *name, int val)
{
	int i;

	if (name) {
		for (i = 0; i < NOPTS; i++) {
			if (strcmp(name, optnames(i)) == 0) {
				optlist[i] = val;
				return 0;
			}
		}
		ash_msg("illegal option %co %s", val ? '-' : '+', name);
		return 1;
	}
	for (i = 0; i < NOPTS; i++) {
		if (val) {
			out1fmt("%-16s%s\n", optnames(i), optlist[i] ? "on" : "off");
		} else {
			out1fmt("set %co %s\n", optlist[i] ? '-' : '+', optnames(i));
		}
	}
	return 0;
}
static void
setoption(int flag, int val)
{
	int i;

	for (i = 0; i < NOPTS; i++) {
		if (optletters(i) == flag) {
			optlist[i] = val;
			return;
		}
	}
	ash_msg_and_raise_error("illegal option %c%c", val ? '-' : '+', flag);
	/* NOTREACHED */
}
static int
options(int cmdline)
{
	char *p;
	int val;
	int c;

	if (cmdline)
		minusc = NULL;
	while ((p = *argptr) != NULL) {
		c = *p++;
		if (c != '-' && c != '+')
			break;
		argptr++;
		val = 0; /* val = 0 if c == '+' */
		if (c == '-') {
			val = 1;
			if (p[0] == '\0' || LONE_DASH(p)) {
				if (!cmdline) {
					/* "-" means turn off -x and -v */
					if (p[0] == '\0')
						xflag = vflag = 0;
					/* "--" means reset params */
					else if (*argptr == NULL)
						setparam(argptr);
				}
				break;    /* "-" or "--" terminates options */
			}
		}
		/* first char was + or - */
		while ((c = *p++) != '\0') {
			/* bash 3.2 indeed handles -c CMD and +c CMD the same */
			if (c == 'c' && cmdline) {
				minusc = p;     /* command is after shell args */
			} else if (c == 'o') {
				if (plus_minus_o(*argptr, val)) {
					/* it already printed err message */
					return 1; /* error */
				}
				if (*argptr)
					argptr++;
			} else if (cmdline && (c == 'l')) { /* -l or +l == --login */
				isloginsh = 1;
			/* bash does not accept +-login, we also won't */
			} else if (cmdline && val && (c == '-')) { /* long options */
				if (strcmp(p, "login") == 0)
					isloginsh = 1;
				break;
			} else {
				setoption(c, val);
			}
		}
	}
	return 0;
}

/*
 * The shift builtin command.
 */
static int FAST_FUNC
shiftcmd(int argc UNUSED_PARAM, char **argv)
{
	int n;
	char **ap1, **ap2;

	n = 1;
	if (argv[1])
		n = number(argv[1]);
	if (n > shellparam.nparam)
		n = 0; /* bash compat, was = shellparam.nparam; */
	INT_OFF;
	shellparam.nparam -= n;
	for (ap1 = shellparam.p; --n >= 0; ap1++) {
		if (shellparam.malloced)
			free(*ap1);
	}
	ap2 = shellparam.p;
	while ((*ap2++ = *ap1++) != NULL)
		continue;
#if ENABLE_ASH_GETOPTS
	shellparam.optind = 1;
	shellparam.optoff = -1;
#endif
# 10530 "shell/ash.c"
	INT_ON;
	return 0;
}

/*
 * POSIX requires that 'set' (but not export or readonly) output the
 * variables in lexicographic order - by the locale's collating order (sigh).
 * Maybe we could keep them in an ordered balanced binary tree
 * instead of hashed lists.
 * For now just roll 'em through qsort for printing...
 */
static int
showvars(const char *sep_prefix, int on, int off)
{
	const char *sep;
	char **ep, **epend;

	ep = listvars(on, off, &epend);
	qsort(ep, epend - ep, sizeof(char *), vpcmp);

	sep = *sep_prefix ? " " : sep_prefix;

	for (; ep < epend; ep++) {
		const char *p;
		const char *q;

		p = strchrnul(*ep, '=');
		q = nullstr;
		if (*p)
			q = single_quote(++p);
		out1fmt("%s%s%.*s%s\n", sep_prefix, sep, (int)(p - *ep), *ep, q);
	}
	return 0;
}

/*
 * The set command builtin.
 */
static int FAST_FUNC
setcmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
{
	int retval;

	if (!argv[1])
		return showvars(nullstr, 0, VUNSET);

	INT_OFF;
	retval = options(/*cmdline:*/ 0);
	if (retval == 0) { /* if no parse error... */
		optschanged();
		if (*argptr != NULL) {
			setparam(argptr);
		}
	}
	INT_ON;
	return retval;
}

#if ENABLE_ASH_RANDOM_SUPPORT
static void FAST_FUNC
change_random(const char *value)
{
	uint32_t t;

	if (value == NULL) {
		/* "get", generate */
		t = next_random(&random_gen);
		/* set without recursion */
		setvar(vrandom.var_text, utoa(t), VNOFUNC);
		vrandom.flags &= ~VNOFUNC;
	} else {
		/* set/reset */
		t = strtoul(value, NULL, 10);
		INIT_RANDOM_T(&random_gen, (t ? t : 1), t);
	}
}
#endif
# 10607 "shell/ash.c"

#if ENABLE_ASH_GETOPTS
static int
getopts(char *optstr, char *optvar, char **optfirst)
{
	char *p, *q;
	char c = '?';
	int done = 0;
	char sbuf[2];
	char **optnext;
	int ind = shellparam.optind;
	int off = shellparam.optoff;

	sbuf[1] = '\0';

	shellparam.optind = -1;
	optnext = optfirst + ind - 1;

	if (ind <= 1 || off < 0 || (int)strlen(optnext[-1]) < off)
		p = NULL;
	else
		p = optnext[-1] + off;
	if (p == NULL || *p == '\0') {
		/* Current word is done, advance */
		p = *optnext;
		if (p == NULL || *p != '-' || *++p == '\0') {
 atend:
			p = NULL;
			done = 1;
			goto out;
		}
		optnext++;
		if (LONE_DASH(p))        /* check for "--" */
			goto atend;
	}

	c = *p++;
	for (q = optstr; *q != c;) {
		if (*q == '\0') {
			if (optstr[0] == ':') {
				sbuf[0] = c;
				/*sbuf[1] = '\0'; - already is */
				setvar0("OPTARG", sbuf);
			} else {
				fprintf(stderr, "Illegal option -%c\n", c);
				unsetvar("OPTARG");
			}
			c = '?';
			goto out;
		}
		if (*++q == ':')
			q++;
	}

	if (*++q == ':') {
		if (*p == '\0' && (p = *optnext) == NULL) {
			if (optstr[0] == ':') {
				sbuf[0] = c;
				/*sbuf[1] = '\0'; - already is */
				setvar0("OPTARG", sbuf);
				c = ':';
			} else {
				fprintf(stderr, "No arg for -%c option\n", c);
				unsetvar("OPTARG");
				c = '?';
			}
			goto out;
		}

		if (p == *optnext)
			optnext++;
		setvar0("OPTARG", p);
		p = NULL;
	} else
		setvar0("OPTARG", nullstr);
 out:
	ind = optnext - optfirst + 1;
	setvar("OPTIND", itoa(ind), VNOFUNC);
	sbuf[0] = c;
	/*sbuf[1] = '\0'; - already is */
	setvar0(optvar, sbuf);

	shellparam.optoff = p ? p - *(optnext - 1) : -1;
	shellparam.optind = ind;

	return done;
}

/*
 * The getopts builtin.  Shellparam.optnext points to the next argument
 * to be processed.  Shellparam.optptr points to the next character to
 * be processed in the current argument.  If shellparam.optnext is NULL,
 * then it's the first time getopts has been called.
 */
static int FAST_FUNC
getoptscmd(int argc, char **argv)
{
	char **optbase;

	if (argc < 3)
		ash_msg_and_raise_error("usage: getopts optstring var [arg]");
	if (argc == 3) {
		optbase = shellparam.p;
		if ((unsigned)shellparam.optind > shellparam.nparam + 1) {
			shellparam.optind = 1;
			shellparam.optoff = -1;
		}
	} else {
		optbase = &argv[3];
		if ((unsigned)shellparam.optind > argc - 2) {
			shellparam.optind = 1;
			shellparam.optoff = -1;
		}
	}

	return getopts(argv[1], argv[2], optbase);
}
#endif /* ASH_GETOPTS */
# 10725 "shell/ash.c"


/* ============ Shell parser */

struct heredoc {
	struct heredoc *next;   /* next here document in list */
	union node *here;       /* redirection node */
	char *eofmark;          /* string indicating end of input */
	smallint striptabs;     /* if set, strip leading tabs */
};

static smallint tokpushback;           /* last token pushed back */
static smallint quoteflag;             /* set if (part of) last token was quoted */
static token_id_t lasttoken;           /* last token read (integer id Txxx) */
static struct heredoc *heredoclist;    /* list of here documents to read */
static char *wordtext;                 /* text of last word returned by readtoken */
static struct nodelist *backquotelist;
static union node *redirnode;
static struct heredoc *heredoc;

static const char *
tokname(char *buf, int tok)
{
	if (tok < TSEMI)
		return tokname_array[tok];
	sprintf(buf, "\"%s\"", tokname_array[tok]);
	return buf;
}

/* raise_error_unexpected_syntax:
 * Called when an unexpected token is read during the parse.  The argument
 * is the token that is expected, or -1 if more than one type of token can
 * occur at this point.
 */
static void raise_error_unexpected_syntax(int) NORETURN;
static void
raise_error_unexpected_syntax(int token)
{
	char msg[64];
	char buf[16];
	int l;

	l = sprintf(msg, "unexpected %s", tokname(buf, lasttoken));
	if (token >= 0)
		sprintf(msg + l, " (expecting %s)", tokname(buf, token));
	raise_error_syntax(msg);
	/* NOTREACHED */
}

#define EOFMARKLEN 79

/* parsing is heavily cross-recursive, need these forward decls */
static union node *andor(void);
static union node *pipeline(void);
static union node *parse_command(void);
static void parseheredoc(void);
static int peektoken(void);
static int readtoken(void);

static union node *
list(int nlflag)
{
	union node *n1, *n2, *n3;
	int tok;

	n1 = NULL;
	for (;;) {
		switch (peektoken()) {
		case TNL:
			if (!(nlflag & 1))
				break;
			parseheredoc();
			return n1;

		case TEOF:
			if (!n1 && (nlflag & 1))
				n1 = NODE_EOF;
			parseheredoc();
			return n1;
		}

		checkkwd = CHKNL | CHKKWD | CHKALIAS;
		if (nlflag == 2 && ((1 << peektoken()) & tokendlist))
			return n1;
		nlflag |= 2;

		n2 = andor();
		tok = readtoken();
		if (tok == TBACKGND) {
			if (n2->type == NPIPE) {
				n2->npipe.pipe_backgnd = 1;
			} else {
				if (n2->type != NREDIR) {
					n3 = stzalloc(sizeof(struct nredir));
					n3->nredir.n = n2;
					/*n3->nredir.redirect = NULL; - stzalloc did it */
					n2 = n3;
				}
				n2->type = NBACKGND;
			}
		}
		if (n1 == NULL) {
			n1 = n2;
		} else {
			n3 = stzalloc(sizeof(struct nbinary));
			n3->type = NSEMI;
			n3->nbinary.ch1 = n1;
			n3->nbinary.ch2 = n2;
			n1 = n3;
		}
		switch (tok) {
		case TNL:
		case TEOF:
			tokpushback = 1;
			/* fall through */
		case TBACKGND:
		case TSEMI:
			break;
		default:
			if ((nlflag & 1))
				raise_error_unexpected_syntax(-1);
			tokpushback = 1;
			return n1;
		}
	}
}

static union node *
andor(void)
{
	union node *n1, *n2, *n3;
	int t;

	n1 = pipeline();
	for (;;) {
		t = readtoken();
		if (t == TAND) {
			t = NAND;
		} else if (t == TOR) {
			t = NOR;
		} else {
			tokpushback = 1;
			return n1;
		}
		checkkwd = CHKNL | CHKKWD | CHKALIAS;
		n2 = pipeline();
		n3 = stzalloc(sizeof(struct nbinary));
		n3->type = t;
		n3->nbinary.ch1 = n1;
		n3->nbinary.ch2 = n2;
		n1 = n3;
	}
}

static union node *
pipeline(void)
{
	union node *n1, *n2, *pipenode;
	struct nodelist *lp, *prev;
	int negate;

	negate = 0;
	TRACE(("pipeline: entered\n"));
	if (readtoken() == TNOT) {
		negate = !negate;
		checkkwd = CHKKWD | CHKALIAS;
	} else
		tokpushback = 1;
	n1 = parse_command();
	if (readtoken() == TPIPE) {
		pipenode = stzalloc(sizeof(struct npipe));
		pipenode->type = NPIPE;
		/*pipenode->npipe.pipe_backgnd = 0; - stzalloc did it */
		lp = stzalloc(sizeof(struct nodelist));
		pipenode->npipe.cmdlist = lp;
		lp->n = n1;
		do {
			prev = lp;
			lp = stzalloc(sizeof(struct nodelist));
			checkkwd = CHKNL | CHKKWD | CHKALIAS;
			lp->n = parse_command();
			prev->next = lp;
		} while (readtoken() == TPIPE);
		lp->next = NULL;
		n1 = pipenode;
	}
	tokpushback = 1;
	if (negate) {
		n2 = stzalloc(sizeof(struct nnot));
		n2->type = NNOT;
		n2->nnot.com = n1;
		return n2;
	}
	return n1;
}

static union node *
makename(void)
{
	union node *n;

	n = stzalloc(sizeof(struct narg));
	n->type = NARG;
	/*n->narg.next = NULL; - stzalloc did it */
	n->narg.text = wordtext;
	n->narg.backquote = backquotelist;
	return n;
}

static void
fixredir(union node *n, const char *text, int err)
{
	int fd;

	TRACE(("Fix redir %s %d\n", text, err));
	if (!err)
		n->ndup.vname = NULL;

	fd = bb_strtou(text, NULL, 10);
	if (!errno && fd >= 0)
		n->ndup.dupfd = fd;
	else if (LONE_DASH(text))
		n->ndup.dupfd = -1;
	else {
		if (err)
			raise_error_syntax("bad fd number");
		n->ndup.vname = makename();
	}
}

/*
 * Returns true if the text contains nothing to expand (no dollar signs
 * or backquotes).
 */
static int
noexpand(const char *text)
{
	unsigned char c;

	while ((c = *text++) != '\0') {
		if (c == CTLQUOTEMARK)
			continue;
		if (c == CTLESC)
			text++;
		else if (SIT(c, BASESYNTAX) == CCTL)
			return 0;
	}
	return 1;
}

static void
parsefname(void)
{
	union node *n = redirnode;

	if (readtoken() != TWORD)
		raise_error_unexpected_syntax(-1);
	if (n->type == NHERE) {
		struct heredoc *here = heredoc;
		struct heredoc *p;
		int i;

		if (quoteflag == 0)
			n->type = NXHERE;
		TRACE(("Here document %d\n", n->type));
		if (!noexpand(wordtext) || (i = strlen(wordtext)) == 0 || i > EOFMARKLEN)
			raise_error_syntax("illegal eof marker for << redirection");
		rmescapes(wordtext, 0);
		here->eofmark = wordtext;
		here->next = NULL;
		if (heredoclist == NULL)
			heredoclist = here;
		else {
			for (p = heredoclist; p->next; p = p->next)
				continue;
			p->next = here;
		}
	} else if (n->type == NTOFD || n->type == NFROMFD) {
		fixredir(n, wordtext, 0);
	} else {
		n->nfile.fname = makename();
	}
}

static union node *
simplecmd(void)
{
	union node *args, **app;
	union node *n = NULL;
	union node *vars, **vpp;
	union node **rpp, *redir;
	int savecheckkwd;
#if ENABLE_ASH_BASH_COMPAT
	smallint double_brackets_flag = 0;
	smallint function_flag = 0;
#endif
# 11021 "shell/ash.c"

	args = NULL;
	app = &args;
	vars = NULL;
	vpp = &vars;
	redir = NULL;
	rpp = &redir;

	savecheckkwd = CHKALIAS;
	for (;;) {
		int t;
		checkkwd = savecheckkwd;
		t = readtoken();
		switch (t) {
#if ENABLE_ASH_BASH_COMPAT
		case TFUNCTION:
			if (peektoken() != TWORD)
				raise_error_unexpected_syntax(TWORD);
			function_flag = 1;
			break;
		case TAND: /* "&&" */
		case TOR: /* "||" */
			if (!double_brackets_flag) {
				tokpushback = 1;
				goto out;
			}
			wordtext = (char *) (t == TAND ? "-a" : "-o");
#endif
# 11049 "shell/ash.c"
		case TWORD:
			n = stzalloc(sizeof(struct narg));
			n->type = NARG;
			/*n->narg.next = NULL; - stzalloc did it */
			n->narg.text = wordtext;
#if ENABLE_ASH_BASH_COMPAT
			if (strcmp("[[", wordtext) == 0)
				double_brackets_flag = 1;
			else if (strcmp("]]", wordtext) == 0)
				double_brackets_flag = 0;
#endif
# 11060 "shell/ash.c"
			n->narg.backquote = backquotelist;
			if (savecheckkwd && isassignment(wordtext)) {
				*vpp = n;
				vpp = &n->narg.next;
			} else {
				*app = n;
				app = &n->narg.next;
				savecheckkwd = 0;
			}
#if ENABLE_ASH_BASH_COMPAT
			if (function_flag) {
				checkkwd = CHKNL | CHKKWD;
				switch (peektoken()) {
				case TBEGIN:
				case TIF:
				case TCASE:
				case TUNTIL:
				case TWHILE:
				case TFOR:
					goto do_func;
				case TLP:
					function_flag = 0;
					break;
				case TWORD:
					if (strcmp("[[", wordtext) == 0)
						goto do_func;
					/* fall through */
				default:
					raise_error_unexpected_syntax(-1);
				}
			}
#endif
# 11092 "shell/ash.c"
			break;
		case TREDIR:
			*rpp = n = redirnode;
			rpp = &n->nfile.next;
			parsefname();   /* read name of redirection file */
			break;
		case TLP:
 IF_ASH_BASH_COMPAT(do_func:)
			if (args && app == &args->narg.next
			 && !vars && !redir
			) {
				struct builtincmd *bcmd;
				const char *name;

				/* We have a function */
				if (IF_ASH_BASH_COMPAT(!function_flag &&) readtoken() != TRP)
					raise_error_unexpected_syntax(TRP);
				name = n->narg.text;
				if (!goodname(name)
				 || ((bcmd = find_builtin(name)) && IS_BUILTIN_SPECIAL(bcmd))
				) {
					raise_error_syntax("bad function name");
				}
				n->type = NDEFUN;
				checkkwd = CHKNL | CHKKWD | CHKALIAS;
				n->narg.next = parse_command();
				return n;
			}
			IF_ASH_BASH_COMPAT(function_flag = 0;)
			/* fall through */
		default:
			tokpushback = 1;
			goto out;
		}
	}
 out:
	*app = NULL;
	*vpp = NULL;
	*rpp = NULL;
	n = stzalloc(sizeof(struct ncmd));
	n->type = NCMD;
	n->ncmd.args = args;
	n->ncmd.assign = vars;
	n->ncmd.redirect = redir;
	return n;
}

static union node *
parse_command(void)
{
	union node *n1, *n2;
	union node *ap, **app;
	union node *cp, **cpp;
	union node *redir, **rpp;
	union node **rpp2;
	int t;

	redir = NULL;
	rpp2 = &redir;

	switch (readtoken()) {
	default:
		raise_error_unexpected_syntax(-1);
		/* NOTREACHED */
	case TIF:
		n1 = stzalloc(sizeof(struct nif));
		n1->type = NIF;
		n1->nif.test = list(0);
		if (readtoken() != TTHEN)
			raise_error_unexpected_syntax(TTHEN);
		n1->nif.ifpart = list(0);
		n2 = n1;
		while (readtoken() == TELIF) {
			n2->nif.elsepart = stzalloc(sizeof(struct nif));
			n2 = n2->nif.elsepart;
			n2->type = NIF;
			n2->nif.test = list(0);
			if (readtoken() != TTHEN)
				raise_error_unexpected_syntax(TTHEN);
			n2->nif.ifpart = list(0);
		}
		if (lasttoken == TELSE)
			n2->nif.elsepart = list(0);
		else {
			n2->nif.elsepart = NULL;
			tokpushback = 1;
		}
		t = TFI;
		break;
	case TWHILE:
	case TUNTIL: {
		int got;
		n1 = stzalloc(sizeof(struct nbinary));
		n1->type = (lasttoken == TWHILE) ? NWHILE : NUNTIL;
		n1->nbinary.ch1 = list(0);
		got = readtoken();
		if (got != TDO) {
			TRACE(("expecting DO got '%s' %s\n", tokname_array[got],
					got == TWORD ? wordtext : ""));
			raise_error_unexpected_syntax(TDO);
		}
		n1->nbinary.ch2 = list(0);
		t = TDONE;
		break;
	}
	case TFOR:
		if (readtoken() != TWORD || quoteflag || !goodname(wordtext))
			raise_error_syntax("bad for loop variable");
		n1 = stzalloc(sizeof(struct nfor));
		n1->type = NFOR;
		n1->nfor.var = wordtext;
		checkkwd = CHKNL | CHKKWD | CHKALIAS;
		if (readtoken() == TIN) {
			app = &ap;
			while (readtoken() == TWORD) {
				n2 = stzalloc(sizeof(struct narg));
				n2->type = NARG;
				/*n2->narg.next = NULL; - stzalloc did it */
				n2->narg.text = wordtext;
				n2->narg.backquote = backquotelist;
				*app = n2;
				app = &n2->narg.next;
			}
			*app = NULL;
			n1->nfor.args = ap;
			if (lasttoken != TNL && lasttoken != TSEMI)
				raise_error_unexpected_syntax(-1);
		} else {
			n2 = stzalloc(sizeof(struct narg));
			n2->type = NARG;
			/*n2->narg.next = NULL; - stzalloc did it */
			n2->narg.text = (char *)dolatstr;
			/*n2->narg.backquote = NULL;*/
			n1->nfor.args = n2;
			/*
			 * Newline or semicolon here is optional (but note
			 * that the original Bourne shell only allowed NL).
			 */
			if (lasttoken != TSEMI)
				tokpushback = 1;
		}
		checkkwd = CHKNL | CHKKWD | CHKALIAS;
		if (readtoken() != TDO)
			raise_error_unexpected_syntax(TDO);
		n1->nfor.body = list(0);
		t = TDONE;
		break;
	case TCASE:
		n1 = stzalloc(sizeof(struct ncase));
		n1->type = NCASE;
		if (readtoken() != TWORD)
			raise_error_unexpected_syntax(TWORD);
		n1->ncase.expr = n2 = stzalloc(sizeof(struct narg));
		n2->type = NARG;
		/*n2->narg.next = NULL; - stzalloc did it */
		n2->narg.text = wordtext;
		n2->narg.backquote = backquotelist;
		checkkwd = CHKNL | CHKKWD | CHKALIAS;
		if (readtoken() != TIN)
			raise_error_unexpected_syntax(TIN);
		cpp = &n1->ncase.cases;
 next_case:
		checkkwd = CHKNL | CHKKWD;
		t = readtoken();
		while (t != TESAC) {
			if (lasttoken == TLP)
				readtoken();
			*cpp = cp = stzalloc(sizeof(struct nclist));
			cp->type = NCLIST;
			app = &cp->nclist.pattern;
			for (;;) {
				*app = ap = stzalloc(sizeof(struct narg));
				ap->type = NARG;
				/*ap->narg.next = NULL; - stzalloc did it */
				ap->narg.text = wordtext;
				ap->narg.backquote = backquotelist;
				if (readtoken() != TPIPE)
					break;
				app = &ap->narg.next;
				readtoken();
			}
			//ap->narg.next = NULL;
			if (lasttoken != TRP)
				raise_error_unexpected_syntax(TRP);
			cp->nclist.body = list(2);

			cpp = &cp->nclist.next;

			checkkwd = CHKNL | CHKKWD;
			t = readtoken();
			if (t != TESAC) {
				if (t != TENDCASE)
					raise_error_unexpected_syntax(TENDCASE);
				goto next_case;
			}
		}
		*cpp = NULL;
		goto redir;
	case TLP:
		n1 = stzalloc(sizeof(struct nredir));
		n1->type = NSUBSHELL;
		n1->nredir.n = list(0);
		/*n1->nredir.redirect = NULL; - stzalloc did it */
		t = TRP;
		break;
	case TBEGIN:
		n1 = list(0);
		t = TEND;
		break;
	IF_ASH_BASH_COMPAT(case TFUNCTION:)
	case TWORD:
	case TREDIR:
		tokpushback = 1;
		return simplecmd();
	}

	if (readtoken() != t)
		raise_error_unexpected_syntax(t);

 redir:
	/* Now check for redirection which may follow command */
	checkkwd = CHKKWD | CHKALIAS;
	rpp = rpp2;
	while (readtoken() == TREDIR) {
		*rpp = n2 = redirnode;
		rpp = &n2->nfile.next;
		parsefname();
	}
	tokpushback = 1;
	*rpp = NULL;
	if (redir) {
		if (n1->type != NSUBSHELL) {
			n2 = stzalloc(sizeof(struct nredir));
			n2->type = NREDIR;
			n2->nredir.n = n1;
			n1 = n2;
		}
		n1->nredir.redirect = redir;
	}
	return n1;
}

#if ENABLE_ASH_BASH_COMPAT
static int
decode_dollar_squote(void)
{
	static const char C_escapes[] ALIGN1 = "nrbtfav""x\\01234567";
	int c, cnt;
	char *p;
	char buf[4];

	c = pgetc();
	p = strchr(C_escapes, c);
	if (p) {
		buf[0] = c;
		p = buf;
		cnt = 3;
		if ((unsigned char)(c - '0') <= 7) { /* \ooo */
			do {
				c = pgetc();
				*++p = c;
			} while ((unsigned char)(c - '0') <= 7 && --cnt);
			pungetc();
		} else if (c == 'x') { /* \xHH */
			do {
				c = pgetc();
				*++p = c;
			} while (isxdigit(c) && --cnt);
			pungetc();
			if (cnt == 3) { /* \x but next char is "bad" */
				c = 'x';
				goto unrecognized;
			}
		} else { /* simple seq like \\ or \t */
			p++;
		}
		*p = '\0';
		p = buf;
		c = bb_process_escape_sequence((void*)&p);
	} else { /* unrecognized "\z": print both chars unless ' or " */
		if (c != '\'' && c != '"') {
 unrecognized:
			c |= 0x100; /* "please encode \, then me" */
		}
	}
	return c;
}
#endif
# 11380 "shell/ash.c"

/*
 * If eofmark is NULL, read a word or a redirection symbol.  If eofmark
 * is not NULL, read a here document.  In the latter case, eofmark is the
 * word which marks the end of the document and striptabs is true if
 * leading tabs should be stripped from the document.  The argument c
 * is the first character of the input token or document.
 *
 * Because C does not have internal subroutines, I have simulated them
 * using goto's to implement the subroutine linkage.  The following macros
 * will run code that appears at the end of readtoken1.
 */
#define CHECKEND()      {goto checkend; checkend_return:;}
#define PARSEREDIR()    {goto parseredir; parseredir_return:;}
#define PARSESUB()      {goto parsesub; parsesub_return:;}
#define PARSEBACKQOLD() {oldstyle = 1; goto parsebackq; parsebackq_oldreturn:;}
#define PARSEBACKQNEW() {oldstyle = 0; goto parsebackq; parsebackq_newreturn:;}
#define PARSEARITH()    {goto parsearith; parsearith_return:;}
static int
readtoken1(int c, int syntax, char *eofmark, int striptabs)
{
	/* NB: syntax parameter fits into smallint */
	/* c parameter is an unsigned char or PEOF or PEOA */
	char *out;
	size_t len;
	char line[EOFMARKLEN + 1];
	struct nodelist *bqlist;
	smallint quotef;
	smallint dblquote;
	smallint oldstyle;
	IF_FEATURE_SH_MATH(smallint prevsyntax;) /* syntax before arithmetic */
#if ENABLE_ASH_EXPAND_PRMT
	smallint pssyntax;   /* we are expanding a prompt string */
#endif
# 11414 "shell/ash.c"
	int varnest;         /* levels of variables expansion */
	IF_FEATURE_SH_MATH(int arinest;)    /* levels of arithmetic expansion */
	IF_FEATURE_SH_MATH(int parenlevel;) /* levels of parens in arithmetic */
	int dqvarnest;       /* levels of variables expansion within double quotes */

	IF_ASH_BASH_COMPAT(smallint bash_dollar_squote = 0;)

	startlinno = g_parsefile->linno;
	bqlist = NULL;
	quotef = 0;
	IF_FEATURE_SH_MATH(prevsyntax = 0;)
#if ENABLE_ASH_EXPAND_PRMT
	pssyntax = (syntax == PSSYNTAX);
	if (pssyntax)
		syntax = DQSYNTAX;
#endif
# 11430 "shell/ash.c"
	dblquote = (syntax == DQSYNTAX);
	varnest = 0;
	IF_FEATURE_SH_MATH(arinest = 0;)
	IF_FEATURE_SH_MATH(parenlevel = 0;)
	dqvarnest = 0;

	STARTSTACKSTR(out);
 loop:
	/* For each line, until end of word */
	CHECKEND();     /* set c to PEOF if at end of here document */
	for (;;) {      /* until end of line or end of word */
		CHECKSTRSPACE(4, out);  /* permit 4 calls to USTPUTC */
		switch (SIT(c, syntax)) {
		case CNL:       /* '\n' */
			if (syntax == BASESYNTAX)
				goto endword;   /* exit outer loop */
			USTPUTC(c, out);
			nlprompt();
			c = pgetc();
			goto loop;              /* continue outer loop */
		case CWORD:
			USTPUTC(c, out);
			break;
		case CCTL:
#if ENABLE_ASH_BASH_COMPAT
			if (c == '\\' && bash_dollar_squote) {
				c = decode_dollar_squote();
				if (c == '\0') {
					/* skip $'\000', $'\x00' (like bash) */
					break;
				}
				if (c & 0x100) {
					/* Unknown escape. Encode as '\z' */
					c = (unsigned char)c;
					if (eofmark == NULL || dblquote)
						USTPUTC(CTLESC, out);
					USTPUTC('\\', out);
				}
			}
#endif
# 11470 "shell/ash.c"
			if (eofmark == NULL || dblquote)
				USTPUTC(CTLESC, out);
			USTPUTC(c, out);
			break;
		case CBACK:     /* backslash */
			c = pgetc_without_PEOA();
			if (c == PEOF) {
				USTPUTC(CTLESC, out);
				USTPUTC('\\', out);
				pungetc();
			} else if (c == '\n') {
				nlprompt();
			} else {
#if ENABLE_ASH_EXPAND_PRMT
				if (c == '$' && pssyntax) {
					USTPUTC(CTLESC, out);
					USTPUTC('\\', out);
				}
#endif
# 11489 "shell/ash.c"
				/* Backslash is retained if we are in "str" and next char isn't special */
				if (dblquote
				 && c != '\\'
				 && c != '`'
				 && c != '$'
				 && (c != '"' || eofmark != NULL)
				) {
					USTPUTC('\\', out);
				}
				USTPUTC(CTLESC, out);
				USTPUTC(c, out);
				quotef = 1;
			}
			break;
		case CSQUOTE:
			syntax = SQSYNTAX;
 quotemark:
			if (eofmark == NULL) {
				USTPUTC(CTLQUOTEMARK, out);
			}
			break;
		case CDQUOTE:
			syntax = DQSYNTAX;
			dblquote = 1;
			goto quotemark;
		case CENDQUOTE:
			IF_ASH_BASH_COMPAT(bash_dollar_squote = 0;)
			if (eofmark != NULL && varnest == 0) {
				USTPUTC(c, out);
			} else {
				if (dqvarnest == 0) {
					syntax = BASESYNTAX;
					dblquote = 0;
				}
				quotef = 1;
				goto quotemark;
			}
			break;
		case CVAR:      /* '$' */
			PARSESUB();             /* parse substitution */
			break;
		case CENDVAR:   /* '}' */
			if (varnest > 0) {
				varnest--;
				if (dqvarnest > 0) {
					dqvarnest--;
				}
				c = CTLENDVAR;
			}
			USTPUTC(c, out);
			break;
#if ENABLE_FEATURE_SH_MATH
		case CLP:       /* '(' in arithmetic */
			parenlevel++;
			USTPUTC(c, out);
			break;
		case CRP:       /* ')' in arithmetic */
			if (parenlevel > 0) {
				parenlevel--;
			} else {
				if (pgetc_eatbnl() == ')') {
					c = CTLENDARI;
					if (--arinest == 0) {
						syntax = prevsyntax;
					}
				} else {
					/*
					 * unbalanced parens
					 * (don't 2nd guess - no error)
					 */
					pungetc();
				}
			}
			USTPUTC(c, out);
			break;
#endif
# 11565 "shell/ash.c"
		case CBQUOTE:   /* '`' */
			PARSEBACKQOLD();
			break;
		case CENDFILE:
			goto endword;           /* exit outer loop */
		case CIGN:
			break;
		default:
			if (varnest == 0) {
#if ENABLE_ASH_BASH_COMPAT
				if (c == '&') {
//Can't call pgetc_eatbnl() here, this requires three-deep pungetc()
					if (pgetc() == '>')
						c = 0x100 + '>'; /* flag &> */
					pungetc();
				}
#endif
# 11582 "shell/ash.c"
				goto endword;   /* exit outer loop */
			}
			IF_ASH_ALIAS(if (c != PEOA))
				USTPUTC(c, out);
		}
		c = pgetc();
	} /* for (;;) */
 endword:

#if ENABLE_FEATURE_SH_MATH
	if (syntax == ARISYNTAX)
		raise_error_syntax("missing '))'");
#endif
# 11595 "shell/ash.c"
	if (syntax != BASESYNTAX && eofmark == NULL)
		raise_error_syntax("unterminated quoted string");
	if (varnest != 0) {
		startlinno = g_parsefile->linno;
		/* { */
		raise_error_syntax("missing '}'");
	}
	USTPUTC('\0', out);
	len = out - (char *)stackblock();
	out = stackblock();
	if (eofmark == NULL) {
		if ((c == '>' || c == '<' IF_ASH_BASH_COMPAT( || c == 0x100 + '>'))
		 && quotef == 0
		) {
			if (isdigit_str9(out)) {
				PARSEREDIR(); /* passed as params: out, c */
				lasttoken = TREDIR;
				return lasttoken;
			}
			/* else: non-number X seen, interpret it
			 * as "NNNX>file" = "NNNX >file" */
		}
		pungetc();
	}
	quoteflag = quotef;
	backquotelist = bqlist;
	grabstackblock(len);
	wordtext = out;
	lasttoken = TWORD;
	return lasttoken;
/* end of readtoken routine */

/*
 * Check to see whether we are at the end of the here document.  When this
 * is called, c is set to the first character of the next input line.  If
 * we are at the end of the here document, this routine sets the c to PEOF.
 */
checkend: {
	if (eofmark) {
#if ENABLE_ASH_ALIAS
		if (c == PEOA)
			c = pgetc_without_PEOA();
#endif
# 11638 "shell/ash.c"
		if (striptabs) {
			while (c == '\t') {
				c = pgetc_without_PEOA();
			}
		}
		if (c == *eofmark) {
			if (pfgets(line, sizeof(line)) != NULL) {
				char *p, *q;
				int cc;

				p = line;
				for (q = eofmark + 1;; p++, q++) {
					cc = *p;
					if (cc == '\n')
						cc = 0;
					if (!*q || cc != *q)
						break;
				}
				if (cc == *q) {
					c = PEOF;
					nlnoprompt();
				} else {
					pushstring(line, NULL);
				}
			}
		}
	}
	goto checkend_return;
}

/*
 * Parse a redirection operator.  The variable "out" points to a string
 * specifying the fd to be redirected.  The variable "c" contains the
 * first character of the redirection operator.
 */
parseredir: {
	/* out is already checked to be a valid number or "" */
	int fd = (*out == '\0' ? -1 : atoi(out));
	union node *np;

	np = stzalloc(sizeof(struct nfile));
	if (c == '>') {
		np->nfile.fd = 1;
		c = pgetc();
		if (c == '>')
			np->type = NAPPEND;
		else if (c == '|')
			np->type = NCLOBBER;
		else if (c == '&')
			np->type = NTOFD;
			/* it also can be NTO2 (>&file), but we can't figure it out yet */
		else {
			np->type = NTO;
			pungetc();
		}
	}
#if ENABLE_ASH_BASH_COMPAT
	else if (c == 0x100 + '>') { /* this flags &> redirection */
		np->nfile.fd = 1;
		pgetc(); /* this is '>', no need to check */
		np->type = NTO2;
	}
#endif
# 11701 "shell/ash.c"
	else { /* c == '<' */
		/*np->nfile.fd = 0; - stzalloc did it */
		c = pgetc();
		switch (c) {
		case '<':
			if (sizeof(struct nfile) != sizeof(struct nhere)) {
				np = stzalloc(sizeof(struct nhere));
				/*np->nfile.fd = 0; - stzalloc did it */
			}
			np->type = NHERE;
			heredoc = stzalloc(sizeof(struct heredoc));
			heredoc->here = np;
			c = pgetc();
			if (c == '-') {
				heredoc->striptabs = 1;
			} else {
				/*heredoc->striptabs = 0; - stzalloc did it */
				pungetc();
			}
			break;

		case '&':
			np->type = NFROMFD;
			break;

		case '>':
			np->type = NFROMTO;
			break;

		default:
			np->type = NFROM;
			pungetc();
			break;
		}
	}
	if (fd >= 0)
		np->nfile.fd = fd;
	redirnode = np;
	goto parseredir_return;
}

/*
 * Parse a substitution.  At this point, we have read the dollar sign
 * and nothing else.
 */

/* is_special(c) evaluates to 1 for c in "!#$*-0123456789?@"; 0 otherwise
 * (assuming ascii char codes, as the original implementation did) */
#define is_special(c) \
	(((unsigned)(c) - 33 < 32) \
			&& ((0xc1ff920dU >> ((unsigned)(c) - 33)) & 1))
parsesub: {
	unsigned char subtype;
	int typeloc;

	c = pgetc_eatbnl();
	if (c > 255 /* PEOA or PEOF */
	 || (c != '(' && c != '{' && !is_name(c) && !is_special(c))
	) {
#if ENABLE_ASH_BASH_COMPAT
		if (syntax != DQSYNTAX && c == '\'')
			bash_dollar_squote = 1;
		else
#endif
# 11765 "shell/ash.c"
			USTPUTC('$', out);
		pungetc();
	} else if (c == '(') {
		/* $(command) or $((arith)) */
		if (pgetc_eatbnl() == '(') {
#if ENABLE_FEATURE_SH_MATH
			PARSEARITH();
#else
# 11773 "shell/ash.c"
			raise_error_syntax("you disabled math support for $((arith)) syntax");
#endif
# 11775 "shell/ash.c"
		} else {
			pungetc();
			PARSEBACKQNEW();
		}
	} else {
		/* $VAR, $<specialchar>, ${...}, or PEOA/PEOF */
		USTPUTC(CTLVAR, out);
		typeloc = out - (char *)stackblock();
		STADJUST(1, out);
		subtype = VSNORMAL;
		if (c == '{') {
			c = pgetc_eatbnl();
			subtype = 0;
		}
 varname:
		if (is_name(c)) {
			/* $[{[#]]NAME[}] */
			do {
				STPUTC(c, out);
				c = pgetc_eatbnl();
			} while (is_in_name(c));
		} else if (isdigit(c)) {
			/* $[{[#]]NUM[}] */
			do {
				STPUTC(c, out);
				c = pgetc_eatbnl();
			} while (isdigit(c));
		} else if (is_special(c)) {
			/* $[{[#]]<specialchar>[}] */
			int cc = c;

			c = pgetc_eatbnl();
			if (!subtype && cc == '#') {
				subtype = VSLENGTH;
				if (c == '_' || isalnum(c))
					goto varname;
				cc = c;
				c = pgetc_eatbnl();
				if (cc == '}' || c != '}') {
					pungetc();
					subtype = 0;
					c = cc;
					cc = '#';
				}
			}
			USTPUTC(cc, out);
		} else {
			goto badsub;
		}
		if (c != '}' && subtype == VSLENGTH) {
			/* ${#VAR didn't end with } */
			goto badsub;
		}

		if (subtype == 0) {
			static const char types[] ALIGN1 = "}-+?=";
			/* ${VAR...} but not $VAR or ${#VAR} */
			/* c == first char after VAR */
			switch (c) {
			case ':':
				c = pgetc_eatbnl();
#if ENABLE_ASH_BASH_COMPAT
				/* This check is only needed to not misinterpret
				 * ${VAR:-WORD}, ${VAR:+WORD}, ${VAR:=WORD}, ${VAR:?WORD}
				 * constructs.
				 */
				if (!strchr(types, c)) {
					subtype = VSSUBSTR;
					pungetc();
					break; /* "goto badsub" is bigger (!) */
				}
#endif
# 11847 "shell/ash.c"
				subtype = VSNUL;
				/*FALLTHROUGH*/
			default: {
				const char *p = strchr(types, c);
				if (p == NULL)
					break;
				subtype |= p - types + VSNORMAL;
				break;
			}
			case '%':
			case '#': {
				int cc = c;
				subtype = (c == '#' ? VSTRIMLEFT : VSTRIMRIGHT);
				c = pgetc_eatbnl();
				if (c != cc)
					goto badsub;
				subtype++;
				break;
			}
#if ENABLE_ASH_BASH_COMPAT
			case '/':
				/* ${v/[/]pattern/repl} */
//TODO: encode pattern and repl separately.
// Currently ${v/$var_with_slash/repl} is horribly broken
				subtype = VSREPLACE;
				c = pgetc_eatbnl();
				if (c != '/')
					goto badsub;
				subtype++; /* VSREPLACEALL */
				break;
#endif
# 11878 "shell/ash.c"
			}
		} else {
 badsub:
			pungetc();
		}
		((unsigned char *)stackblock())[typeloc] = subtype;
		if (subtype != VSNORMAL) {
			varnest++;
			if (dblquote)
				dqvarnest++;
		}
		STPUTC('=', out);
	}
	goto parsesub_return;
}

/*
 * Called to parse command substitutions.  Newstyle is set if the command
 * is enclosed inside $(...); nlpp is a pointer to the head of the linked
 * list of commands (passed by reference), and savelen is the number of
 * characters on the top of the stack which must be preserved.
 */
parsebackq: {
	struct nodelist **nlpp;
	union node *n;
	char *str;
	size_t savelen;
	smallint saveprompt = 0;

	str = NULL;
	savelen = out - (char *)stackblock();
	if (savelen > 0) {
		/*
		 * FIXME: this can allocate very large block on stack and SEGV.
		 * Example:
		 * echo "..<100kbytes>..`true` $(true) `true` ..."
		 * allocates 100kb for every command subst. With about
		 * a hundred command substitutions stack overflows.
		 * With larger prepended string, SEGV happens sooner.
		 */
		str = alloca(savelen);
		memcpy(str, stackblock(), savelen);
	}

	if (oldstyle) {
		/* We must read until the closing backquote, giving special
		 * treatment to some slashes, and then push the string and
		 * reread it as input, interpreting it normally.
		 */
		char *pout;
		size_t psavelen;
		char *pstr;

		STARTSTACKSTR(pout);
		for (;;) {
			int pc;

			setprompt_if(needprompt, 2);
			pc = pgetc();
			switch (pc) {
			case '`':
				goto done;

			case '\\':
				pc = pgetc();
				if (pc == '\n') {
					nlprompt();
					/*
					 * If eating a newline, avoid putting
					 * the newline into the new character
					 * stream (via the STPUTC after the
					 * switch).
					 */
					continue;
				}
				if (pc != '\\' && pc != '`' && pc != '$'
				 && (!dblquote || pc != '"')
				) {
					STPUTC('\\', pout);
				}
				if (pc <= 255 /* not PEOA or PEOF */) {
					break;
				}
				/* fall through */

			case PEOF:
			IF_ASH_ALIAS(case PEOA:)
				startlinno = g_parsefile->linno;
				raise_error_syntax("EOF in backquote substitution");

			case '\n':
				nlnoprompt();
				break;

			default:
				break;
			}
			STPUTC(pc, pout);
		}
 done:
		STPUTC('\0', pout);
		psavelen = pout - (char *)stackblock();
		if (psavelen > 0) {
			pstr = grabstackstr(pout);
			setinputstring(pstr);
		}
	}
	nlpp = &bqlist;
	while (*nlpp)
		nlpp = &(*nlpp)->next;
	*nlpp = stzalloc(sizeof(**nlpp));
	/* (*nlpp)->next = NULL; - stzalloc did it */

	if (oldstyle) {
		saveprompt = doprompt;
		doprompt = 0;
	}

	n = list(2);

	if (oldstyle)
		doprompt = saveprompt;
	else if (readtoken() != TRP)
		raise_error_unexpected_syntax(TRP);

	(*nlpp)->n = n;
	if (oldstyle) {
		/*
		 * Start reading from old file again, ignoring any pushed back
		 * tokens left from the backquote parsing
		 */
		popfile();
		tokpushback = 0;
	}
	while (stackblocksize() <= savelen)
		growstackblock();
	STARTSTACKSTR(out);
	if (str) {
		memcpy(out, str, savelen);
		STADJUST(savelen, out);
	}
	USTPUTC(CTLBACKQ, out);
	if (oldstyle)
		goto parsebackq_oldreturn;
	goto parsebackq_newreturn;
}

#if ENABLE_FEATURE_SH_MATH
/*
 * Parse an arithmetic expansion (indicate start of one and set state)
 */
parsearith: {
	if (++arinest == 1) {
		prevsyntax = syntax;
		syntax = ARISYNTAX;
	}
	USTPUTC(CTLARI, out);
	goto parsearith_return;
}
#endif
# 12038 "shell/ash.c"
} /* end of readtoken */

/*
 * Read the next input token.
 * If the token is a word, we set backquotelist to the list of cmds in
 *      backquotes.  We set quoteflag to true if any part of the word was
 *      quoted.
 * If the token is TREDIR, then we set redirnode to a structure containing
 *      the redirection.
 * In all cases, the variable startlinno is set to the number of the line
 *      on which the token starts.
 *
 * [Change comment:  here documents and internal procedures]
 * [Readtoken shouldn't have any arguments.  Perhaps we should make the
 *  word parsing code into a separate routine.  In this case, readtoken
 *  doesn't need to have any internal procedures, but parseword does.
 *  We could also make parseoperator in essence the main routine, and
 *  have parseword (readtoken1?) handle both words and redirection.]
 */
#define NEW_xxreadtoken
#ifdef NEW_xxreadtoken
/* singles must be first! */
static const char xxreadtoken_chars[7] ALIGN1 = {
	'\n', '(', ')', /* singles */
	'&', '|', ';',  /* doubles */
	0
};

#define xxreadtoken_singles 3
#define xxreadtoken_doubles 3

static const char xxreadtoken_tokens[] ALIGN1 = {
	TNL, TLP, TRP,          /* only single occurrence allowed */
	TBACKGND, TPIPE, TSEMI, /* if single occurrence */
	TEOF,                   /* corresponds to trailing nul */
	TAND, TOR, TENDCASE     /* if double occurrence */
};

static int
xxreadtoken(void)
{
	int c;

	if (tokpushback) {
		tokpushback = 0;
		return lasttoken;
	}
	setprompt_if(needprompt, 2);
	startlinno = g_parsefile->linno;
	for (;;) {                      /* until token or start of word found */
		c = pgetc();
		if (c == ' ' || c == '\t' IF_ASH_ALIAS( || c == PEOA))
			continue;

		if (c == '#') {
			while ((c = pgetc()) != '\n' && c != PEOF)
				continue;
			pungetc();
		} else if (c == '\\') {
			if (pgetc() != '\n') {
				pungetc();
				break; /* return readtoken1(...) */
			}
			nlprompt();
		} else {
			const char *p;

			p = xxreadtoken_chars + sizeof(xxreadtoken_chars) - 1;
			if (c != PEOF) {
				if (c == '\n') {
					nlnoprompt();
				}

				p = strchr(xxreadtoken_chars, c);
				if (p == NULL)
					break; /* return readtoken1(...) */

				if ((int)(p - xxreadtoken_chars) >= xxreadtoken_singles) {
					int cc = pgetc();
					if (cc == c) {    /* double occurrence? */
						p += xxreadtoken_doubles + 1;
					} else {
						pungetc();
#if ENABLE_ASH_BASH_COMPAT
						if (c == '&' && cc == '>') /* &> */
							break; /* return readtoken1(...) */
#endif
# 12125 "shell/ash.c"
					}
				}
			}
			lasttoken = xxreadtoken_tokens[p - xxreadtoken_chars];
			return lasttoken;
		}
	} /* for (;;) */

	return readtoken1(c, BASESYNTAX, (char *) NULL, 0);
}
#else /* old xxreadtoken */
# 12136 "shell/ash.c"
#define RETURN(token)   return lasttoken = token
static int
xxreadtoken(void)
{
	int c;

	if (tokpushback) {
		tokpushback = 0;
		return lasttoken;
	}
	setprompt_if(needprompt, 2);
	startlinno = g_parsefile->linno;
	for (;;) {      /* until token or start of word found */
		c = pgetc();
		switch (c) {
		case ' ': case '\t':
		IF_ASH_ALIAS(case PEOA:)
			continue;
		case '#':
			while ((c = pgetc()) != '\n' && c != PEOF)
				continue;
			pungetc();
			continue;
		case '\\':
			if (pgetc() == '\n') {
				nlprompt();
				continue;
			}
			pungetc();
			goto breakloop;
		case '\n':
			nlnoprompt();
			RETURN(TNL);
		case PEOF:
			RETURN(TEOF);
		case '&':
			if (pgetc() == '&')
				RETURN(TAND);
			pungetc();
			RETURN(TBACKGND);
		case '|':
			if (pgetc() == '|')
				RETURN(TOR);
			pungetc();
			RETURN(TPIPE);
		case ';':
			if (pgetc() == ';')
				RETURN(TENDCASE);
			pungetc();
			RETURN(TSEMI);
		case '(':
			RETURN(TLP);
		case ')':
			RETURN(TRP);
		default:
			goto breakloop;
		}
	}
 breakloop:
	return readtoken1(c, BASESYNTAX, (char *)NULL, 0);
#undef RETURN
}
#endif /* old xxreadtoken */
# 12199 "shell/ash.c"

static int
readtoken(void)
{
	int t;
	int kwd = checkkwd;
#if DEBUG
	smallint alreadyseen = tokpushback;
#endif
# 12208 "shell/ash.c"

#if ENABLE_ASH_ALIAS
 top:
#endif
# 12212 "shell/ash.c"

	t = xxreadtoken();

	/*
	 * eat newlines
	 */
	if (kwd & CHKNL) {
		while (t == TNL) {
			parseheredoc();
			t = xxreadtoken();
		}
	}

	if (t != TWORD || quoteflag) {
		goto out;
	}

	/*
	 * check for keywords
	 */
	if (kwd & CHKKWD) {
		const char *const *pp;

		pp = findkwd(wordtext);
		if (pp) {
			lasttoken = t = pp - tokname_array;
			TRACE(("keyword '%s' recognized\n", tokname_array[t]));
			goto out;
		}
	}

	if (checkkwd & CHKALIAS) {
#if ENABLE_ASH_ALIAS
		struct alias *ap;
		ap = lookupalias(wordtext, 1);
		if (ap != NULL) {
			if (*ap->val) {
				pushstring(ap->val, ap);
			}
			goto top;
		}
#endif
# 12254 "shell/ash.c"
	}
 out:
	checkkwd = 0;
#if DEBUG
	if (!alreadyseen)
		TRACE(("token '%s' %s\n", tokname_array[t], t == TWORD ? wordtext : ""));
	else
		TRACE(("reread token '%s' %s\n", tokname_array[t], t == TWORD ? wordtext : ""));
#endif
# 12263 "shell/ash.c"
	return t;
}

static int
peektoken(void)
{
	int t;

	t = readtoken();
	tokpushback = 1;
	return t;
}

/*
 * Read and parse a command.  Returns NODE_EOF on end of file.
 * (NULL is a valid parse tree indicating a blank line.)
 */
static union node *
parsecmd(int interact)
{
	tokpushback = 0;
	checkkwd = 0;
	heredoclist = 0;
	doprompt = interact;
	setprompt_if(doprompt, doprompt);
	needprompt = 0;
	return list(1);
}

/*
 * Input any here documents.
 */
static void
parseheredoc(void)
{
	struct heredoc *here;
	union node *n;

	here = heredoclist;
	heredoclist = NULL;

	while (here) {
		setprompt_if(needprompt, 2);
		readtoken1(pgetc(), here->here->type == NHERE ? SQSYNTAX : DQSYNTAX,
				here->eofmark, here->striptabs);
		n = stzalloc(sizeof(struct narg));
		n->narg.type = NARG;
		/*n->narg.next = NULL; - stzalloc did it */
		n->narg.text = wordtext;
		n->narg.backquote = backquotelist;
		here->here->nhere.doc = n;
		here = here->next;
	}
}


/*
 * called by editline -- any expansions to the prompt should be added here.
 */
#if ENABLE_ASH_EXPAND_PRMT
static const char *
expandstr(const char *ps)
{
	union node n;
	int saveprompt;

	/* XXX Fix (char *) cast. It _is_ a bug. ps is variable's value,
	 * and token processing _can_ alter it (delete NULs etc). */
	setinputstring((char *)ps);

	saveprompt = doprompt;
	doprompt = 0;
	readtoken1(pgetc(), PSSYNTAX, nullstr, 0);
	doprompt = saveprompt;

	popfile();

	n.narg.type = NARG;
	n.narg.next = NULL;
	n.narg.text = wordtext;
	n.narg.backquote = backquotelist;

	expandarg(&n, NULL, EXP_QUOTED);
	return stackblock();
}
#endif
# 12349 "shell/ash.c"

/*
 * Execute a command or commands contained in a string.
 */
static int
evalstring(char *s, int flags)
{
	struct jmploc *volatile savehandler;
	struct jmploc jmploc;
	int ex;

	union node *n;
	struct stackmark smark;
	int status;

	s = sstrdup(s);
	setinputstring(s);
	setstackmark(&smark);

	status = 0;
	/* On exception inside execution loop, we must popfile().
	 * Try interactively:
	 *	readonly a=a
	 *	command eval "a=b"  # throws "is read only" error
	 * "command BLTIN" is not supposed to abort (even in non-interactive use).
	 * But if we skip popfile(), we hit EOF in eval's string, and exit.
	 */
	savehandler = exception_handler;
	ex = setjmp(jmploc.loc);
	if (ex)
		goto out;
	exception_handler = &jmploc;

	while ((n = parsecmd(0)) != NODE_EOF) {
		int i;

		i = evaltree(n, flags);
		if (n)
			status = i;
		popstackmark(&smark);
		if (evalskip)
			break;
	}
 out:
	popstackmark(&smark);
	popfile();
	stunalloc(s);

	exception_handler = savehandler;
	if (ex)
                longjmp(exception_handler->loc, ex);

	return status;
}

/*
 * The eval command.
 */
static int FAST_FUNC
evalcmd(int argc UNUSED_PARAM, char **argv, int flags)
{
	char *p;
	char *concat;

	if (argv[1]) {
		p = argv[1];
		argv += 2;
		if (argv[0]) {
			STARTSTACKSTR(concat);
			for (;;) {
				concat = stack_putstr(p, concat);
				p = *argv++;
				if (p == NULL)
					break;
				STPUTC(' ', concat);
			}
			STPUTC('\0', concat);
			p = grabstackstr(concat);
		}
		return evalstring(p, flags & EV_TESTED);
	}
	return 0;
}

/*
 * Read and execute commands.
 * "Top" is nonzero for the top level command loop;
 * it turns on prompting if the shell is interactive.
 */
static int
cmdloop(int top)
{
	union node *n;
	struct stackmark smark;
	int inter;
	int status = 0;
	int numeof = 0;

	TRACE(("cmdloop(%d) called\n", top));
	for (;;) {
		int skip;

		setstackmark(&smark);
#if JOBS
		if (doing_jobctl)
			showjobs(SHOW_CHANGED|SHOW_STDERR);
#endif
# 12456 "shell/ash.c"
		inter = 0;
		if (iflag && top) {
			inter++;
			chkmail();
		}
		n = parsecmd(inter);
#if DEBUG
		if (DEBUG > 2 && debug && (n != NODE_EOF))
			showtree(n);
#endif
# 12466 "shell/ash.c"
		if (n == NODE_EOF) {
			if (!top || numeof >= 50)
				break;
			if (!stoppedjobs()) {
				if (!Iflag)
					break;
				out2str("\nUse \"exit\" to leave shell.\n");
			}
			numeof++;
		} else if (nflag == 0) {
			int i;

			/* job_warning can only be 2,1,0. Here 2->1, 1/0->0 */
			job_warning >>= 1;
			numeof = 0;
			i = evaltree(n, 0);
			if (n)
				status = i;
		}
		popstackmark(&smark);
		skip = evalskip;

		if (skip) {
			evalskip &= ~SKIPFUNC;
			break;
		}
	}
	return status;
}

/*
 * Take commands from a file.  To be compatible we should do a path
 * search for the file, which is necessary to find sub-commands.
 */
static char *
find_dot_file(char *name)
{
	char *fullname;
	const char *path = pathval();
	struct stat statb;

	/* don't try this for absolute or relative paths */
	if (strchr(name, '/'))
		return name;

	/* IIRC standards do not say whether . is to be searched.
	 * And it is even smaller this way, making it unconditional for now:
	 */
	if (1) { /* ENABLE_ASH_BASH_COMPAT */
		fullname = name;
		goto try_cur_dir;
	}

	while ((fullname = path_advance(&path, name)) != NULL) {
 try_cur_dir:
		if ((stat(fullname, &statb) == 0) && S_ISREG(statb.st_mode)) {
			/*
			 * Don't bother freeing here, since it will
			 * be freed by the caller.
			 */
			return fullname;
		}
		if (fullname != name)
			stunalloc(fullname);
	}

	/* not found in the PATH */
	ash_msg_and_raise_error("%s: not found", name);
	/* NOTREACHED */
}

static int FAST_FUNC
dotcmd(int argc_ UNUSED_PARAM, char **argv_ UNUSED_PARAM)
{
	/* "false; . empty_file; echo $?" should print 0, not 1: */
	int status = 0;
	char *fullname;
	char **argv;
	struct strlist *sp;
	volatile struct shparam saveparam;

	for (sp = cmdenviron; sp; sp = sp->next)
		setvareq(ckstrdup(sp->text), VSTRFIXED | VTEXTFIXED);

	nextopt(nullstr); /* handle possible "--" */
	argv = argptr;

	if (!argv[0]) {
		/* bash says: "bash: .: filename argument required" */
		return 2; /* bash compat */
	}

	/* This aborts if file isn't found, which is POSIXly correct.
	 * bash returns exitcode 1 instead.
	 */
	fullname = find_dot_file(argv[0]);
	argv++;
	if (argv[0]) { /* . FILE ARGS, ARGS exist */
		int argc;
		saveparam = shellparam;
		shellparam.malloced = 0;
		argc = 1;
		while (argv[argc])
			argc++;
		shellparam.nparam = argc;
		shellparam.p = argv;
	};

	/* This aborts if file can't be opened, which is POSIXly correct.
	 * bash returns exitcode 1 instead.
	 */
	setinputfile(fullname, INPUT_PUSH_FILE);
	commandname = fullname;
	status = cmdloop(0);
	popfile();

	if (argv[0]) {
		freeparam(&shellparam);
		shellparam = saveparam;
	};

	return status;
}

static int FAST_FUNC
exitcmd(int argc UNUSED_PARAM, char **argv)
{
	if (stoppedjobs())
		return 0;
	if (argv[1])
		exitstatus = number(argv[1]);
	raise_exception(EXEXIT);
	/* NOTREACHED */
}

/*
 * Read a file containing shell functions.
 */
static void
readcmdfile(char *name)
{
	setinputfile(name, INPUT_PUSH_FILE);
	cmdloop(0);
	popfile();
}


/* ============ find_command inplementation */

/*
 * Resolve a command name.  If you change this routine, you may have to
 * change the shellexec routine as well.
 */
static void
find_command(char *name, struct cmdentry *entry, int act, const char *path)
{
	struct tblentry *cmdp;
	int idx;
	int prev;
	char *fullname;
	struct stat statb;
	int e;
	int updatetbl;
	struct builtincmd *bcmd;

	/* If name contains a slash, don't use PATH or hash table */
	if (strchr(name, '/') != NULL) {
		entry->u.index = -1;
		if (act & DO_ABS) {
			while (stat(name, &statb) < 0) {
#ifdef SYSV
				if (errno == EINTR)
					continue;
#endif
# 12640 "shell/ash.c"
				entry->cmdtype = CMDUNKNOWN;
				return;
			}
		}
		entry->cmdtype = CMDNORMAL;
		return;
	}

/* #if ENABLE_FEATURE_SH_STANDALONE... moved after builtin check */

	updatetbl = (path == pathval());
	if (!updatetbl) {
		act |= DO_ALTPATH;
		if (strstr(path, "%builtin") != NULL)
			act |= DO_ALTBLTIN;
	}

	/* If name is in the table, check answer will be ok */
	cmdp = cmdlookup(name, 0);
	if (cmdp != NULL) {
		int bit;

		switch (cmdp->cmdtype) {
		default:
#if DEBUG
			abort();
#endif
# 12667 "shell/ash.c"
		case CMDNORMAL:
			bit = DO_ALTPATH;
			break;
		case CMDFUNCTION:
			bit = DO_NOFUNC;
			break;
		case CMDBUILTIN:
			bit = DO_ALTBLTIN;
			break;
		}
		if (act & bit) {
			updatetbl = 0;
			cmdp = NULL;
		} else if (cmdp->rehash == 0)
			/* if not invalidated by cd, we're done */
			goto success;
	}

	/* If %builtin not in path, check for builtin next */
	bcmd = find_builtin(name);
	if (bcmd) {
		if (IS_BUILTIN_REGULAR(bcmd))
			goto builtin_success;
		if (act & DO_ALTPATH) {
			if (!(act & DO_ALTBLTIN))
				goto builtin_success;
		} else if (builtinloc <= 0) {
			goto builtin_success;
		}
	}

#if ENABLE_FEATURE_SH_STANDALONE
	{
		int applet_no = find_applet_by_name(name);
		if (applet_no >= 0) {
			entry->cmdtype = CMDNORMAL;
			entry->u.index = -2 - applet_no;
			return;
		}
	}
#endif
# 12708 "shell/ash.c"

	/* We have to search path. */
	prev = -1;              /* where to start */
	if (cmdp && cmdp->rehash) {     /* doing a rehash */
		if (cmdp->cmdtype == CMDBUILTIN)
			prev = builtinloc;
		else
			prev = cmdp->param.index;
	}

	e = ENOENT;
	idx = -1;
 loop:
	while ((fullname = path_advance(&path, name)) != NULL) {
		stunalloc(fullname);
		/* NB: code below will still use fullname
		 * despite it being "unallocated" */
		idx++;
		if (pathopt) {
			if (prefix(pathopt, "builtin")) {
				if (bcmd)
					goto builtin_success;
				continue;
			}
			if ((act & DO_NOFUNC)
			 || !prefix(pathopt, "func")
			) {     /* ignore unimplemented options */
				continue;
			}
		}
		/* if rehash, don't redo absolute path names */
		if (fullname[0] == '/' && idx <= prev) {
			if (idx < prev)
				continue;
			TRACE(("searchexec \"%s\": no change\n", name));
			goto success;
		}
		while (stat(fullname, &statb) < 0) {
#ifdef SYSV
			if (errno == EINTR)
				continue;
#endif
# 12750 "shell/ash.c"
			if (errno != ENOENT && errno != ENOTDIR)
				e = errno;
			goto loop;
		}
		e = EACCES;     /* if we fail, this will be the error */
		if (!S_ISREG(statb.st_mode))
			continue;
		if (pathopt) {          /* this is a %func directory */
			stalloc(strlen(fullname) + 1);
			/* NB: stalloc will return space pointed by fullname
			 * (because we don't have any intervening allocations
			 * between stunalloc above and this stalloc) */
			readcmdfile(fullname);
			cmdp = cmdlookup(name, 0);
			if (cmdp == NULL || cmdp->cmdtype != CMDFUNCTION)
				ash_msg_and_raise_error("%s not defined in %s", name, fullname);
			stunalloc(fullname);
			goto success;
		}
		TRACE(("searchexec \"%s\" returns \"%s\"\n", name, fullname));
		if (!updatetbl) {
			entry->cmdtype = CMDNORMAL;
			entry->u.index = idx;
			return;
		}
		INT_OFF;
		cmdp = cmdlookup(name, 1);
		cmdp->cmdtype = CMDNORMAL;
		cmdp->param.index = idx;
		INT_ON;
		goto success;
	}

	/* We failed.  If there was an entry for this command, delete it */
	if (cmdp && updatetbl)
		delete_cmd_entry();
	if (act & DO_ERR)
		ash_msg("%s: %s", name, errmsg(e, "not found"));
	entry->cmdtype = CMDUNKNOWN;
	return;

 builtin_success:
	if (!updatetbl) {
		entry->cmdtype = CMDBUILTIN;
		entry->u.cmd = bcmd;
		return;
	}
	INT_OFF;
	cmdp = cmdlookup(name, 1);
	cmdp->cmdtype = CMDBUILTIN;
	cmdp->param.cmd = bcmd;
	INT_ON;
 success:
	cmdp->rehash = 0;
	entry->cmdtype = cmdp->cmdtype;
	entry->u = cmdp->param;
}


/*
 * The trap builtin.
 */
static int FAST_FUNC
trapcmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
{
	char *action;
	char **ap;
	int signo, exitcode;

	nextopt(nullstr);
	ap = argptr;
	if (!*ap) {
		for (signo = 0; signo < NSIG; signo++) {
			char *tr = trap_ptr[signo];
			if (tr) {
				/* note: bash adds "SIG", but only if invoked
				 * as "bash". If called as "sh", or if set -o posix,
				 * then it prints short signal names.
				 * We are printing short names: */
				out1fmt("trap -- %s %s\n",
						single_quote(tr),
						get_signame(signo));
		/* trap_ptr != trap only if we are in special-cased `trap` code.
		 * In this case, we will exit very soon, no need to free(). */
				/* if (trap_ptr != trap && tp[0]) */
				/*	free(tr); */
			}
		}
		/*
		if (trap_ptr != trap) {
			free(trap_ptr);
			trap_ptr = trap;
		}
		*/
		return 0;
	}

	action = NULL;
	if (ap[1])
		action = *ap++;
	exitcode = 0;
	while (*ap) {
		signo = get_signum(*ap);
		if (signo < 0) {
			/* Mimic bash message exactly */
			ash_msg("%s: invalid signal specification", *ap);
			exitcode = 1;
			goto next;
		}
		INT_OFF;
		if (action) {
			if (LONE_DASH(action))
				action = NULL;
			else {
				if (action[0]) /* not NULL and not "" and not "-" */
					may_have_traps = 1;
				action = ckstrdup(action);
			}
		}
		free(trap[signo]);
		trap[signo] = action;
		if (signo != 0)
			setsignal(signo);
		INT_ON;
 next:
		ap++;
	}
	return exitcode;
}


/* ============ Builtins */

#if ENABLE_ASH_HELP
static int FAST_FUNC
helpcmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
{
	unsigned col;
	unsigned i;

	out1fmt(
		"Built-in commands:\n"
		"------------------\n");
	for (col = 0, i = 0; i < ARRAY_SIZE(builtintab); i++) {
		col += out1fmt("%c%s", ((col == 0) ? '\t' : ' '),
					builtintab[i].name + 1);
		if (col > 60) {
			out1fmt("\n");
			col = 0;
		}
	}
# if ENABLE_FEATURE_SH_STANDALONE
	{
		const char *a = applet_names;
		while (*a) {
			col += out1fmt("%c%s", ((col == 0) ? '\t' : ' '), a);
			if (col > 60) {
				out1fmt("\n");
				col = 0;
			}
			while (*a++ != '\0')
				continue;
		}
	}
# endif
# 12915 "shell/ash.c"
	newline_and_flush(stdout);
	return EXIT_SUCCESS;
}
#endif
# 12919 "shell/ash.c"

#if MAX_HISTORY
static int FAST_FUNC
historycmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
{
	show_history(line_input_state);
	return EXIT_SUCCESS;
}
#endif
# 12928 "shell/ash.c"

/*
 * The export and readonly commands.
 */
static int FAST_FUNC
exportcmd(int argc UNUSED_PARAM, char **argv)
{
	struct var *vp;
	char *name;
	const char *p;
	char **aptr;
	char opt;
	int flag;
	int flag_off;

	/* "readonly" in bash accepts, but ignores -n.
	 * We do the same: it saves a conditional in nextopt's param.
	 */
	flag_off = 0;
	while ((opt = nextopt("np")) != '\0') {
		if (opt == 'n')
			flag_off = VEXPORT;
	}
	flag = VEXPORT;
	if (argv[0][0] == 'r') {
		flag = VREADONLY;
		flag_off = 0; /* readonly ignores -n */
	}
	flag_off = ~flag_off;

	/*if (opt_p_not_specified) - bash doesnt check this. Try "export -p NAME" */
	{
		aptr = argptr;
		name = *aptr;
		if (name) {
			do {
				p = strchr(name, '=');
				if (p != NULL) {
					p++;
				} else {
					vp = *findvar(hashvar(name), name);
					if (vp) {
						vp->flags = ((vp->flags | flag) & flag_off);
						continue;
					}
				}
				setvar(name, p, (flag & flag_off));
			} while ((name = *++aptr) != NULL);
			return 0;
		}
	}

	/* No arguments. Show the list of exported or readonly vars.
	 * -n is ignored.
	 */
	showvars(argv[0], flag, 0);
	return 0;
}

/*
 * Delete a function if it exists.
 */
static void
unsetfunc(const char *name)
{
	struct tblentry *cmdp;

	cmdp = cmdlookup(name, 0);
	if (cmdp != NULL && cmdp->cmdtype == CMDFUNCTION)
		delete_cmd_entry();
}

/*
 * The unset builtin command.  We unset the function before we unset the
 * variable to allow a function to be unset when there is a readonly variable
 * with the same name.
 */
static int FAST_FUNC
unsetcmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
{
	char **ap;
	int i;
	int flag = 0;
	int ret = 0;

	while ((i = nextopt("vf")) != 0) {
		flag = i;
	}

	for (ap = argptr; *ap; ap++) {
		if (flag != 'f') {
			i = unsetvar(*ap);
			ret |= i;
			if (!(i & 2))
				continue;
		}
		if (flag != 'v')
			unsetfunc(*ap);
	}
	return ret & 1;
}

static const unsigned char timescmd_str[] ALIGN1 = {
	' ',  offsetof(struct tms, tms_utime),
	'\n', offsetof(struct tms, tms_stime),
	' ',  offsetof(struct tms, tms_cutime),
	'\n', offsetof(struct tms, tms_cstime),
	0
};
static int FAST_FUNC
timescmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
{
	unsigned long clk_tck, s, t;
	const unsigned char *p;
	struct tms buf;

	clk_tck = bb_clk_tck();
	times(&buf);

	p = timescmd_str;
	do {
		t = *(clock_t *)(((char *) &buf) + p[1]);
		s = t / clk_tck;
		t = t % clk_tck;
		out1fmt("%lum%lu.%03lus%c",
			s / 60, s % 60,
			(t * 1000) / clk_tck,
			p[0]);
		p += 2;
	} while (*p);

	return 0;
}

#if ENABLE_FEATURE_SH_MATH
/*
 * The let builtin. Partially stolen from GNU Bash, the Bourne Again SHell.
 * Copyright (C) 1987, 1989, 1991 Free Software Foundation, Inc.
 *
 * Copyright (C) 2003 Vladimir Oleynik <dzo@simtreas.ru>
 */
static int FAST_FUNC
letcmd(int argc UNUSED_PARAM, char **argv)
{
	arith_t i;

	argv++;
	if (!*argv)
		ash_msg_and_raise_error("expression expected");
	do {
		i = ash_arith(*argv);
	} while (*++argv);

	return !i;
}
#endif
# 13084 "shell/ash.c"

/*
 * The read builtin. Options:
 *      -r              Do not interpret '\' specially
 *      -s              Turn off echo (tty only)
 *      -n NCHARS       Read NCHARS max
 *      -p PROMPT       Display PROMPT on stderr (if input is from tty)
 *      -t SECONDS      Timeout after SECONDS (tty or pipe only)
 *      -u FD           Read from given FD instead of fd 0
 * This uses unbuffered input, which may be avoidable in some cases.
 * TODO: bash also has:
 *      -a ARRAY        Read into array[0],[1],etc
 *      -d DELIM        End on DELIM char, not newline
 *      -e              Use line editing (tty only)
 */
static int FAST_FUNC
readcmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
{
	char *opt_n = NULL;
	char *opt_p = NULL;
	char *opt_t = NULL;
	char *opt_u = NULL;
	int read_flags = 0;
	const char *r;
	int i;

	while ((i = nextopt("p:u:rt:n:s")) != '\0') {
		switch (i) {
		case 'p':
			opt_p = optionarg;
			break;
		case 'n':
			opt_n = optionarg;
			break;
		case 's':
			read_flags |= BUILTIN_READ_SILENT;
			break;
		case 't':
			opt_t = optionarg;
			break;
		case 'r':
			read_flags |= BUILTIN_READ_RAW;
			break;
		case 'u':
			opt_u = optionarg;
			break;
		default:
			break;
		}
	}

	/* "read -s" needs to save/restore termios, can't allow ^C
	 * to jump out of it.
	 */
	INT_OFF;
	r = shell_builtin_read(setvar0,
		argptr,
		bltinlookup("IFS"), /* can be NULL */
		read_flags,
		opt_n,
		opt_p,
		opt_t,
		opt_u
	);
	INT_ON;

	if ((uintptr_t)r > 1)
		ash_msg_and_raise_error(r);

	return (uintptr_t)r;
}

static int FAST_FUNC
umaskcmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
{
	static const char permuser[3] ALIGN1 = "ogu";

	mode_t mask;
	int symbolic_mode = 0;

	while (nextopt("S") != '\0') {
		symbolic_mode = 1;
	}

	INT_OFF;
	mask = umask(0);
	umask(mask);
	INT_ON;

	if (*argptr == NULL) {
		if (symbolic_mode) {
			char buf[sizeof(",u=rwx,g=rwx,o=rwx")];
			char *p = buf;
			int i;

			i = 2;
			for (;;) {
				*p++ = ',';
				*p++ = permuser[i];
				*p++ = '=';
				/* mask is 0..0uuugggooo. i=2 selects uuu bits */
				if (!(mask & 0400)) *p++ = 'r';
				if (!(mask & 0200)) *p++ = 'w';
				if (!(mask & 0100)) *p++ = 'x';
				mask <<= 3;
				if (--i < 0)
					break;
			}
			*p = '\0';
			puts(buf + 1);
		} else {
			out1fmt("%04o\n", mask);
		}
	} else {
		char *modestr = *argptr;
                /* numeric umasks are taken as-is */
                /* symbolic umasks are inverted: "umask a=rx" calls umask(222) */
		if (!isdigit(modestr[0]))
			mask ^= 0777;
		mask = bb_parse_mode(modestr, mask);
		if ((unsigned)mask > 0777) {
			ash_msg_and_raise_error("illegal mode: %s", modestr);
		}
		if (!isdigit(modestr[0]))
			mask ^= 0777;
		umask(mask);
	}
	return 0;
}

static int FAST_FUNC
ulimitcmd(int argc UNUSED_PARAM, char **argv)
{
	return shell_builtin_ulimit(argv);
}

/* ============ main() and helpers */

/*
 * Called to exit the shell.
 */
static void
exitshell(void)
{
	struct jmploc loc;
	char *p;
	int status;

#if ENABLE_FEATURE_EDITING_SAVE_ON_EXIT
	save_history(line_input_state);
#endif
# 13235 "shell/ash.c"
	status = exitstatus;
	TRACE(("pid %d, exitshell(%d)\n", getpid(), status));
	if (setjmp(loc.loc)) {
		if (exception_type == EXEXIT)
			status = exitstatus;
		goto out;
	}
	exception_handler = &loc;
	p = trap[0];
	if (p) {
		trap[0] = NULL;
		evalskip = 0;
		evalstring(p, 0);
		/*free(p); - we'll exit soon */
	}
 out:
	/* dash wraps setjobctl(0) in "if (setjmp(loc.loc) == 0) {...}".
	 * our setjobctl(0) does not panic if tcsetpgrp fails inside it.
	 */
	setjobctl(0);
	flush_stdout_stderr();
	_exit(status);
	/* NOTREACHED */
}

static void
init(void)
{
	/* we will never free this */
	basepf.next_to_pgetc = basepf.buf = ckmalloc(IBUFSIZ);

	sigmode[SIGCHLD - 1] = S_DFL;
	setsignal(SIGCHLD);

	/* bash re-enables SIGHUP which is SIG_IGNed on entry.
	 * Try: "trap '' HUP; bash; echo RET" and type "kill -HUP $$"
	 */
	signal(SIGHUP, SIG_DFL);

	{
		char **envp;
		const char *p;
		struct stat st1, st2;

		initvar();
		for (envp = environ; envp && *envp; envp++) {
			p = endofname(*envp);
			if (p != *envp && *p == '=') {
				setvareq(*envp, VEXPORT|VTEXTFIXED);
			}
		}

		setvareq((char*)defoptindvar, VTEXTFIXED);

		setvar0("PPID", utoa(getppid()));
#if ENABLE_ASH_BASH_COMPAT
		p = lookupvar("SHLVL");
		setvar("SHLVL", utoa((p ? atoi(p) : 0) + 1), VEXPORT);
		if (!lookupvar("HOSTNAME")) {
			struct utsname uts;
			uname(&uts);
			setvar0("HOSTNAME", uts.nodename);
		}
#endif
# 13299 "shell/ash.c"
		p = lookupvar("PWD");
		if (p) {
			if (p[0] != '/' || stat(p, &st1) || stat(".", &st2)
			 || st1.st_dev != st2.st_dev || st1.st_ino != st2.st_ino
			) {
				p = NULL;
			}
		}
		setpwd(p, 0);
	}
}


//usage:#define ash_trivial_usage
//usage:	"[-/+OPTIONS] [-/+o OPT]... [-c 'SCRIPT' [ARG0 [ARGS]] / FILE [ARGS]]"
//usage:#define ash_full_usage "\n\n"
//usage:	"Unix shell interpreter"

/*
 * Process the shell command line arguments.
 */
static void
procargs(char **argv)
{
	int i;
	const char *xminusc;
	char **xargv;

	xargv = argv;
	arg0 = xargv[0];
	/* if (xargv[0]) - mmm, this is always true! */
		xargv++;
	for (i = 0; i < NOPTS; i++)
		optlist[i] = 2;
	argptr = xargv;
	if (options(/*cmdline:*/ 1)) {
		/* it already printed err message */
		raise_exception(EXERROR);
	}
	xargv = argptr;
	xminusc = minusc;
	if (*xargv == NULL) {
		if (xminusc)
			ash_msg_and_raise_error(bb_msg_requires_arg, "-c");
		sflag = 1;
	}
	if (iflag == 2 && sflag == 1 && isatty(0) && isatty(1))
		iflag = 1;
	if (mflag == 2)
		mflag = iflag;
	for (i = 0; i < NOPTS; i++)
		if (optlist[i] == 2)
			optlist[i] = 0;
#if DEBUG == 2
	debug = 1;
#endif
# 13355 "shell/ash.c"
	/* POSIX 1003.2: first arg after -c cmd is $0, remainder $1... */
	if (xminusc) {
		minusc = *xargv++;
		if (*xargv)
			goto setarg0;
	} else if (!sflag) {
		setinputfile(*xargv, 0);
 setarg0:
		arg0 = *xargv++;
		commandname = arg0;
	}

	shellparam.p = xargv;
#if ENABLE_ASH_GETOPTS
	shellparam.optind = 1;
	shellparam.optoff = -1;
#endif
# 13372 "shell/ash.c"
	/* assert(shellparam.malloced == 0 && shellparam.nparam == 0); */
	while (*xargv) {
		shellparam.nparam++;
		xargv++;
	}
	optschanged();
}

/*
 * Read /etc/profile, ~/.profile, $ENV.
 */
static void
read_profile(const char *name)
{
	name = expandstr(name);
	if (setinputfile(name, INPUT_PUSH_FILE | INPUT_NOFILE_OK) < 0)
		return;
	cmdloop(0);
	popfile();
}

/*
 * This routine is called when an error or an interrupt occurs in an
 * interactive shell and control is returned to the main command loop.
 * (In dash, this function is auto-generated by build machinery).
 */
static void
reset(void)
{
	/* from eval.c: */
	evalskip = 0;
	loopnest = 0;

	/* from expand.c: */
	ifsfree();

	/* from input.c: */
	g_parsefile->left_in_buffer = 0;
	g_parsefile->left_in_line = 0;      /* clear input buffer */
	popallfiles();

	/* from redir.c: */
	while (redirlist)
		popredir(/*drop:*/ 0, /*restore:*/ 0);
}

#if PROFILE
static short profile_buf[16384];
extern int etext();
#endif
# 13422 "shell/ash.c"

/*
 * Main routine.  We initialize things, parse the arguments, execute
 * profiles if we're a login shell, and then call cmdloop to execute
 * commands.  The setjmp call sets up the location to jump to when an
 * exception occurs.  When an exception occurs the variable "state"
 * is used to figure out how far we had gotten.
 */
int ash_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
int ash_main(int argc UNUSED_PARAM, char **argv)
{
	volatile smallint state;
	struct jmploc jmploc;
	struct stackmark smark;

	/* Initialize global data */
	INIT_G_misc();
	INIT_G_memstack();
	INIT_G_var();
#if ENABLE_ASH_ALIAS
	INIT_G_alias();
#endif
# 13444 "shell/ash.c"
	INIT_G_cmdtable();

#if PROFILE
	monitor(4, etext, profile_buf, sizeof(profile_buf), 50);
#endif
# 13449 "shell/ash.c"

#if ENABLE_FEATURE_EDITING
	line_input_state = new_line_input_t(FOR_SHELL | WITH_PATH_LOOKUP);
#endif
# 13453 "shell/ash.c"
	state = 0;
	if (setjmp(jmploc.loc)) {
		smallint e;
		smallint s;

		reset();

		e = exception_type;
		s = state;
		if (e == EXEXIT || s == 0 || iflag == 0 || shlvl) {
			exitshell();
		}
		if (e == EXINT) {
			newline_and_flush(stderr);
		}

		popstackmark(&smark);
		FORCE_INT_ON; /* enable interrupts */
		if (s == 1)
			goto state1;
		if (s == 2)
			goto state2;
		if (s == 3)
			goto state3;
		goto state4;
	}
	exception_handler = &jmploc;
	rootpid = getpid();

	init();
	setstackmark(&smark);
	procargs(argv);
#if DEBUG
	TRACE(("Shell args: "));
	trace_puts_args(argv);
#endif
# 13489 "shell/ash.c"

	if (argv[0] && argv[0][0] == '-')
		isloginsh = 1;
	if (isloginsh) {
		const char *hp;

		state = 1;
		read_profile("/etc/profile");
 state1:
		state = 2;
		hp = lookupvar("HOME");
		if (hp)
			read_profile("$HOME/.profile");
	}
 state2:
	state = 3;
	if (
#ifndef linux
	 getuid() == geteuid() && getgid() == getegid() &&
#endif
# 13509 "shell/ash.c"
	 iflag
	) {
		const char *shinit = lookupvar("ENV");
		if (shinit != NULL && *shinit != '\0')
			read_profile(shinit);
	}
	popstackmark(&smark);
 state3:
	state = 4;
	if (minusc) {
		/* evalstring pushes parsefile stack.
		 * Ensure we don't falsely claim that 0 (stdin)
		 * is one of stacked source fds.
		 * Testcase: ash -c 'exec 1>&0' must not complain. */
		// if (!sflag) g_parsefile->pf_fd = -1;
		// ^^ not necessary since now we special-case fd 0
		// in is_hidden_fd() to not be considered "hidden fd"
		evalstring(minusc, 0);
	}

	if (sflag || minusc == NULL) {
#if MAX_HISTORY > 0 && ENABLE_FEATURE_EDITING_SAVEHISTORY
		if (iflag) {
			const char *hp = lookupvar("HISTFILE");
			if (!hp) {
				hp = lookupvar("HOME");
				if (hp) {
					hp = concat_path_file(hp, ".ash_history");
					setvar0("HISTFILE", hp);
					free((char*)hp);
					hp = lookupvar("HISTFILE");
				}
			}
			if (hp)
				line_input_state->hist_file = hp;
# if ENABLE_FEATURE_SH_HISTFILESIZE
			hp = lookupvar("HISTFILESIZE");
			line_input_state->max_history = size_from_HISTFILESIZE(hp);
# endif
# 13548 "shell/ash.c"
		}
#endif
# 13550 "shell/ash.c"
 state4: /* XXX ??? - why isn't this before the "if" statement */
		cmdloop(1);
	}
#if PROFILE
	monitor(0);
#endif
# 13556 "shell/ash.c"
#ifdef GPROF
	{
		extern void _mcleanup(void);
		_mcleanup();
	}
#endif
# 13562 "shell/ash.c"
	TRACE(("End of main reached\n"));
	exitshell();
	/* NOTREACHED */
}


/*-
 * Copyright (c) 1989, 1991, 1993, 1994
 *      The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Kenneth Almquist.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
